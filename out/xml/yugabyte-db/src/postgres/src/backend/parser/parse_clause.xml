<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/parser/parse_clause.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * parse_clause.c
 *	  handle clauses in parser
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/parser/parse_clause.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tsmapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/heap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_amproc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/var.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/analyze.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_clause.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_collate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_func.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_oper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_target.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteManip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/catcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>

<comment type="block">/*  YB includes. */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_yb_utils.h"</cpp:file></cpp:include>

<comment type="block">/* Convenience macro for the most common makeNamespaceItem() case */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>makeDefaultNSItem</name><parameter_list>(<parameter><type><name>rte</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>makeNamespaceItem(rte, true, true, false, true)</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>extractRemainingColumns</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>common_colnames</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>src_colnames</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>src_colvars</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>res_colnames</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>res_colvars</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformJoinUsingClause</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
						 <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>leftRTE</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rightRTE</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>leftVars</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rightVars</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformJoinOnClause</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>j</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>namespace</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type><name>getRTEForSpecialRelationTypes</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
							  <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>rv</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type><name>transformTableEntry</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>r</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type><name>transformRangeSubselect</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
						<parameter><decl><type><name>RangeSubselect</name> <modifier>*</modifier></type><name>r</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type><name>transformRangeFunction</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
					   <parameter><decl><type><name>RangeFunction</name> <modifier>*</modifier></type><name>r</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type><name>transformRangeTableFunc</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
						<parameter><decl><type><name>RangeTableFunc</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TableSampleClause</name> <modifier>*</modifier></type><name>transformRangeTableSample</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
						  <parameter><decl><type><name>RangeTableSample</name> <modifier>*</modifier></type><name>rts</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformFromClauseItem</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name></decl></parameter>,
						<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier><modifier>*</modifier></type><name>top_rte</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>top_rti</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>namespace</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>buildMergedJoinVar</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
				   <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>l_colvar</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>r_colvar</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>makeNamespaceItem</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>rel_visible</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>cols_visible</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>lateral_only</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>lateral_ok</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setNamespaceColumnVisibility</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>namespace</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>cols_visible</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setNamespaceLateralState</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>namespace</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>lateral_only</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>lateral_ok</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>checkExprIsVarFree</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name></decl></parameter>,
				   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>constructName</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TargetEntry</name> <modifier>*</modifier></type><name>findTargetlistEntrySQL92</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>ParseExprKind</name></type> <name>exprKind</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TargetEntry</name> <modifier>*</modifier></type><name>findTargetlistEntrySQL99</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>ParseExprKind</name></type> <name>exprKind</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>get_matching_location</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sortgroupref</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sortgrouprefs</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>resolve_unique_index_expr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>InferClause</name> <modifier>*</modifier></type><name>infer</name></decl></parameter>,
						  <parameter><decl><type><name>Relation</name></type> <name>heapRel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>addTargetToGroupList</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>grouplist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>WindowClause</name> <modifier>*</modifier></type><name>findWindowClause</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>wclist</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformFrameOffset</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>frameOptions</name></decl></parameter>,
					 <parameter><decl><type><name>Oid</name></type> <name>rangeopfamily</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>rangeopcintype</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>inRangeFunc</name></decl></parameter>,
					 <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * transformFromClause -
 *	  Process the FROM clause and add items to the query's range table,
 *	  joinlist, and namespace.
 *
 * Note: we assume that the pstate's p_rtable, p_joinlist, and p_namespace
 * lists were initialized to NIL when the pstate was created.
 * We will add onto any entries already present --- this is needed for rule
 * processing, as well as for UPDATE and DELETE.
 */</comment>
<function><type><name>void</name></type>
<name>transformFromClause</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>frmList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>fl</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The grammar will have produced a list of RangeVars, RangeSubselects,
	 * RangeFunctions, and/or JoinExprs. Transform each one (possibly adding
	 * entries to the rtable), check for duplicate refnames, and then add it
	 * to the joinlist and namespace.
	 *
	 * Note we must process the items left-to-right for proper handling of
	 * LATERAL references.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>fl</argument>, <argument>frmList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>fl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>rtindex</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>namespace</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>transformFromClauseItem</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>n</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>rte</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>rtindex</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>namespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>checkNameSpaceConflicts</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name></expr></argument>, <argument><expr><name>namespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Mark the new namespace items as visible only to LATERAL */</comment>
		<expr_stmt><expr><call><name>setNamespaceLateralState</name><argument_list>(<argument><expr><name>namespace</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name></expr></argument>, <argument><expr><name>namespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * We're done parsing the FROM list, so make all namespace items
	 * unconditionally visible.  Note that this will also reset lateral_only
	 * for any namespace items that were already present when we were called;
	 * but those should have been that way already.
	 */</comment>
	<expr_stmt><expr><call><name>setNamespaceLateralState</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * setTargetTable
 *	  Add the target relation of INSERT/UPDATE/DELETE to the range table,
 *	  and make the special links to it in the ParseState.
 *
 *	  We also open the target relation and acquire a write lock on it.
 *	  This must be done before processing the FROM list, in case the target
 *	  is also mentioned as a source relation --- we want to be sure to grab
 *	  the write lock before any read lock.
 *
 *	  If alsoSource is true, add the target to the query's joinlist and
 *	  namespace.  For INSERT, we don't want the target to be joined to;
 *	  it's a destination of tuples, not a source.   For UPDATE/DELETE,
 *	  we do need to scan or join the target.  (NOTE: we do not bother
 *	  to check for namespace conflict; we assume that the namespace was
 *	  initially empty in these cases.)
 *
 *	  Finally, we mark the relation as requiring the permissions specified
 *	  by requiredPerms.
 *
 *	  Returns the rangetable index of the target relation.
 */</comment>
<function><type><name>int</name></type>
<name>setTargetTable</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl></parameter>,
			   <parameter><decl><type><name>bool</name></type> <name>inh</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>alsoSource</name></decl></parameter>, <parameter><decl><type><name>AclMode</name></type> <name>requiredPerms</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rtindex</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * ENRs hide tables of the same name, so we need to check for them first.
	 * In contrast, CTEs don't hide tables (for this purpose).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<call><name>scanNameSpaceForENR</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" cannot be the target of a modifying statement"</literal></expr></argument>,
						<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Close old target; this could only happen for multi-action rules */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Open target rel and grab suitable lock (which we will hold till end of
	 * transaction).
	 *
	 * free_parsestate() will eventually do the corresponding heap_close(),
	 * but *not* release the lock.
	 */</comment>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name></name> <operator>=</operator> <call><name>parserOpenTable</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>,
												<argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now build an RTE.
	 */</comment>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name></name></expr></argument>,
										<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>alias</name></name></expr></argument>, <argument><expr><name>inh</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_rangetblentry</name></name> <operator>=</operator> <name>rte</name></expr>;</expr_stmt>

	<comment type="block">/* assume new rte is at end */</comment>
	<expr_stmt><expr><name>rtindex</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rte</name> <operator>==</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Override addRangeTableEntry's default ACL_SELECT permissions check, and
	 * instead mark target table as requiring exactly the specified
	 * permissions.
	 *
	 * If we find an explicit reference to the rel later during parse
	 * analysis, we will add the ACL_SELECT bit back again; see
	 * markVarForSelectPriv and its callers.
	 */</comment>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <name>requiredPerms</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If UPDATE/DELETE, add table to joinlist and namespace.
	 *
	 * Note: some callers know that they can find the new ParseNamespaceItem
	 * at the end of the pstate-&gt;p_namespace list.  This is a bit ugly but not
	 * worth complicating this function's signature for.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>alsoSource</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>addRTEtoQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>rtindex</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given a relation-options list (of DefElems), return true iff the specified
 * table/result set should be created with OIDs. This needs to be done after
 * parsing the query string because the return value can depend upon the
 * default_with_oids GUC var.
 *
 * In some situations, we want to reject an OIDS option even if it's present.
 * That's (rather messily) handled here rather than reloptions.c, because that
 * code explicitly punts checking for oids to here.
 */</comment>
<function><type><name>bool</name></type>
<name>interpretOidsOption</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>defList</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>allowOids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<comment type="block">/* Scan list to see if OIDS was included */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>defList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>def</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>defnamespace</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"oids"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allowOids</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized parameter \"%s\""</literal></expr></argument>,
								<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><call><name>defGetBoolean</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Force no-OIDS result if caller disallows OIDS. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allowOids</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* OIDS option was not specified, so use default. */</comment>
	<return>return <expr><name>default_with_oids</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Extract all not-in-common columns from column lists of a source table
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>extractRemainingColumns</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>common_colnames</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>src_colnames</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>src_colvars</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>res_colnames</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>res_colvars</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>new_colnames</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>new_colvars</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lnames</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>lvars</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>src_colnames</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>src_colvars</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>forboth</name><argument_list>(<argument>lnames</argument>, <argument>src_colnames</argument>, <argument>lvars</argument>, <argument>src_colvars</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lnames</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>match</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cnames</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>cnames</argument>, <argument>common_colnames</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ccolname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cnames</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>colname</name></expr></argument>, <argument><expr><name>ccolname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>match</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>match</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>new_colnames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_colnames</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lnames</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>new_colvars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_colvars</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lvars</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><operator>*</operator><name>res_colnames</name> <operator>=</operator> <name>new_colnames</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>res_colvars</name> <operator>=</operator> <name>new_colvars</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* transformJoinUsingClause()
 *	  Build a complete ON clause from a partially-transformed USING list.
 *	  We are given lists of nodes representing left and right match columns.
 *	  Result is a transformed qualification expression.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformJoinUsingClause</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
						 <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>leftRTE</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rightRTE</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>leftVars</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rightVars</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>andargs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lvars</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>rvars</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We cheat a little bit here by building an untransformed operator tree
	 * whose leaves are the already-transformed Vars.  This requires collusion
	 * from transformExpr(), which normally could be expected to complain
	 * about already-transformed subnodes.  However, this does mean that we
	 * have to mark the columns as requiring SELECT privilege for ourselves;
	 * transformExpr() won't do it.
	 */</comment>
	<macro><name>forboth</name><argument_list>(<argument>lvars</argument>, <argument>leftVars</argument>, <argument>rvars</argument>, <argument>rightVars</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>lvar</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lvars</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>rvar</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rvars</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>A_Expr</name>	   <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

		<comment type="block">/* Require read access to the join variables */</comment>
		<expr_stmt><expr><call><name>markVarForSelectPriv</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>lvar</name></expr></argument>, <argument><expr><name>leftRTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>markVarForSelectPriv</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rvar</name></expr></argument>, <argument><expr><name>rightRTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Now create the lvar = rvar join condition */</comment>
		<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>makeSimpleA_Expr</name><argument_list>(<argument><expr><name>AEXPR_OP</name></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>,
							 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>lvar</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>rvar</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Prepare to combine into an AND clause, if multiple join columns */</comment>
		<expr_stmt><expr><name>andargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>andargs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Only need an AND if there's more than one join column */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>andargs</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>andargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>AND_EXPR</name></expr></argument>, <argument><expr><name>andargs</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Since the references are already Vars, and are certainly from the input
	 * relations, we don't have to go through the same pushups that
	 * transformJoinOnClause() does.  Just invoke transformExpr() to fix up
	 * the operators, and we're done.
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>EXPR_KIND_JOIN_USING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>coerce_to_boolean</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"JOIN/USING"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* transformJoinOnClause()
 *	  Transform the qual conditions for JOIN/ON.
 *	  Result is a transformed qualification expression.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformJoinOnClause</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>j</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>namespace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>save_namespace</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The namespace that the join expression should see is just the two
	 * subtrees of the JOIN plus any outer references from upper pstate
	 * levels.  Temporarily set this pstate's namespace accordingly.  (We need
	 * not check for refname conflicts, because transformFromClauseItem()
	 * already did.)  All namespace items are marked visible regardless of
	 * LATERAL state.
	 */</comment>
	<expr_stmt><expr><call><name>setNamespaceLateralState</name><argument_list>(<argument><expr><name>namespace</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>save_namespace</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name> <operator>=</operator> <name>namespace</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformWhereClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>,
								  <argument><expr><name>EXPR_KIND_JOIN_ON</name></expr></argument>, <argument><expr><literal type="string">"JOIN/ON"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name> <operator>=</operator> <name>save_namespace</name></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformTableEntry --- transform a RangeVar (simple relation reference)
 */</comment>
<function><type><specifier>static</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type>
<name>transformTableEntry</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>r</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

	<comment type="block">/* We need only build a range table entry */</comment>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntry</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>alias</name></name></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>inh</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rte</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformRangeSubselect --- transform a sub-SELECT appearing in FROM
 */</comment>
<function><type><specifier>static</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type>
<name>transformRangeSubselect</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>RangeSubselect</name> <modifier>*</modifier></type><name>r</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We require user to supply an alias for a subselect, per SQL92. To relax
	 * this, we'd have to be prepared to gin up a unique alias for an
	 * unlabeled subselect.  (This is just elog, not ereport, because the
	 * grammar should have enforced it already.  It'd probably be better to
	 * report the error here, but we don't have a good error location here.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>alias</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"subquery in FROM must have an alias"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Set p_expr_kind to show this parse level is recursing to a subselect.
	 * We can't be nested within any expression, so don't need save-restore
	 * logic here.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>==</operator> <name>EXPR_KIND_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>EXPR_KIND_FROM_SUBSELECT</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the subselect is LATERAL, make lateral_only names of this level
	 * visible to it.  (LATERAL can't nest within a single pstate level, so we
	 * don't need save/restore logic here.)
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>pstate</name><operator>-&gt;</operator><name>p_lateral_active</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_lateral_active</name></name> <operator>=</operator> <name><name>r</name><operator>-&gt;</operator><name>lateral</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Analyze and transform the subquery.
	 */</comment>
	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>parse_sub_analyze</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><call><name>isLockedRefname</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>alias</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Restore state */</comment>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_lateral_active</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>EXPR_KIND_NONE</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check that we got a SELECT.  Anything else should be impossible given
	 * restrictions of the grammar, but check anyway.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected non-SELECT command in subquery in FROM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * OK, build an RTE for the subquery.
	 */</comment>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForSubquery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										<argument><expr><name>query</name></expr></argument>,
										<argument><expr><name><name>r</name><operator>-&gt;</operator><name>alias</name></name></expr></argument>,
										<argument><expr><name><name>r</name><operator>-&gt;</operator><name>lateral</name></name></expr></argument>,
										<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rte</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * transformRangeFunction --- transform a function call appearing in FROM
 */</comment>
<function><type><specifier>static</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type>
<name>transformRangeFunction</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>RangeFunction</name> <modifier>*</modifier></type><name>r</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>funcexprs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>funcnames</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>coldeflists</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_lateral</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We make lateral_only names of this level visible, whether or not the
	 * RangeFunction is explicitly marked LATERAL.  This is needed for SQL
	 * spec compliance in the case of UNNEST(), and seems useful on
	 * convenience grounds for all functions in FROM.
	 *
	 * (LATERAL can't nest within a single pstate level, so we don't need
	 * save/restore logic here.)
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>pstate</name><operator>-&gt;</operator><name>p_lateral_active</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_lateral_active</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Transform the raw expressions.
	 *
	 * While transforming, also save function names for possible use as alias
	 * and column names.  We use the same transformation rules as for a SELECT
	 * output expression.  For a FuncCall node, the result will be the
	 * function name, but it is possible for the grammar to hand back other
	 * node types.
	 *
	 * We have to get this info now, because FigureColname only works on raw
	 * parsetrees.  Actually deciding what to do with the names is left up to
	 * addRangeTableEntryForFunction.
	 *
	 * Likewise, collect column definition lists if there were any.  But
	 * complain if we find one here and the RangeFunction has one too.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>r-&gt;functions</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pair</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>fexpr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>coldeflist</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>newfexpr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>last_srf</name></decl>;</decl_stmt>

		<comment type="block">/* Disassemble the function-call/column-def-list pairs */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>pair</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>fexpr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>pair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>coldeflist</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name>pair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we find a function call unnest() with more than one argument and
		 * no special decoration, transform it into separate unnest() calls on
		 * each argument.  This is a kluge, for sure, but it's less nasty than
		 * other ways of implementing the SQL-standard UNNEST() syntax.
		 *
		 * If there is any decoration (including a coldeflist), we don't
		 * transform, which probably means a no-such-function error later.  We
		 * could alternatively throw an error right now, but that doesn't seem
		 * tremendously helpful.  If someone is using any such decoration,
		 * then they're not using the SQL-standard syntax, and they're more
		 * likely expecting an un-tweaked function call.
		 *
		 * Note: the transformation changes a non-schema-qualified unnest()
		 * function name into schema-qualified pg_catalog.unnest().  This
		 * choice is also a bit debatable, but it seems reasonable to force
		 * use of built-in unnest() when we make this transformation.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>fexpr</name></expr></argument>, <argument><expr><name>FuncCall</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FuncCall</name>   <modifier>*</modifier></type><name>fc</name> <init>= <expr><operator>(</operator><name>FuncCall</name> <operator>*</operator><operator>)</operator> <name>fexpr</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>fc</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>fc</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"unnest"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<call><name>list_length</name><argument_list>(<argument><expr><name><name>fc</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
				<name><name>fc</name><operator>-&gt;</operator><name>agg_order</name></name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
				<name><name>fc</name><operator>-&gt;</operator><name>agg_filter</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				<operator>!</operator><name><name>fc</name><operator>-&gt;</operator><name>agg_star</name></name> <operator>&amp;&amp;</operator>
				<operator>!</operator><name><name>fc</name><operator>-&gt;</operator><name>agg_distinct</name></name> <operator>&amp;&amp;</operator>
				<operator>!</operator><name><name>fc</name><operator>-&gt;</operator><name>func_variadic</name></name> <operator>&amp;&amp;</operator>
				<name><name>fc</name><operator>-&gt;</operator><name>over</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				<name>coldeflist</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>fc-&gt;args</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>FuncCall</name>   <modifier>*</modifier></type><name>newfc</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>last_srf</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr>;</expr_stmt>

					<expr_stmt><expr><name>newfc</name> <operator>=</operator> <call><name>makeFuncCall</name><argument_list>(<argument><expr><call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"unnest"</literal></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name><name>fc</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>newfexpr</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newfc</name></expr></argument>,
											 <argument><expr><name>EXPR_KIND_FROM_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* nodeFunctionscan.c requires SRFs to be at top level */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name> <operator>!=</operator> <name>last_srf</name> <operator>&amp;&amp;</operator>
						<name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name> <operator>!=</operator> <name>newfexpr</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-returning functions must appear at top level of FROM"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
													<argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>funcexprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>funcexprs</name></expr></argument>, <argument><expr><name>newfexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>funcnames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>funcnames</name></expr></argument>,
										<argument><expr><call><name>FigureColname</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newfc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* coldeflist is empty, so no error is possible */</comment>

					<expr_stmt><expr><name>coldeflists</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>coldeflists</name></expr></argument>, <argument><expr><name>coldeflist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<continue>continue;</continue>		<comment type="block">/* done with this function item */</comment>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* normal case ... */</comment>
		<expr_stmt><expr><name>last_srf</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>newfexpr</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>fexpr</name></expr></argument>,
								 <argument><expr><name>EXPR_KIND_FROM_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* nodeFunctionscan.c requires SRFs to be at top level */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name> <operator>!=</operator> <name>last_srf</name> <operator>&amp;&amp;</operator>
			<name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name> <operator>!=</operator> <name>newfexpr</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-returning functions must appear at top level of FROM"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										<argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>funcexprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>funcexprs</name></expr></argument>, <argument><expr><name>newfexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>funcnames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>funcnames</name></expr></argument>,
							<argument><expr><call><name>FigureColname</name><argument_list>(<argument><expr><name>fexpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>coldeflist</name> <operator>&amp;&amp;</operator> <name><name>r</name><operator>-&gt;</operator><name>coldeflist</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multiple column definition lists are not allowed for the same function"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										<argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>r</name><operator>-&gt;</operator><name>coldeflist</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>coldeflists</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>coldeflists</name></expr></argument>, <argument><expr><name>coldeflist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_lateral_active</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We must assign collations now so that the RTE exposes correct collation
	 * info for Vars created from it.
	 */</comment>
	<expr_stmt><expr><call><name>assign_list_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>funcexprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Install the top-level coldeflist if there was one (we already checked
	 * that there was no conflicting per-function coldeflist).
	 *
	 * We only allow this when there's a single function (even after UNNEST
	 * expansion) and no WITH ORDINALITY.  The reason for the latter
	 * restriction is that it's not real clear whether the ordinality column
	 * should be in the coldeflist, and users are too likely to make mistakes
	 * in one direction or the other.  Putting the coldeflist inside ROWS
	 * FROM() is much clearer in this case.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>coldeflist</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>funcexprs</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>is_rowsfrom</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ROWS FROM() with multiple functions cannot have a column definition list"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Put a separate column definition list for each function inside ROWS FROM()."</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
											<argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>r</name><operator>-&gt;</operator><name>coldeflist</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"UNNEST() with multiple arguments cannot have a column definition list"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use separate UNNEST() calls inside ROWS FROM(), and attach a column definition list to each one."</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
											<argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>r</name><operator>-&gt;</operator><name>coldeflist</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>ordinality</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"WITH ORDINALITY cannot be used with a column definition list"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Put the column definition list inside ROWS FROM()."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										<argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>r</name><operator>-&gt;</operator><name>coldeflist</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>coldeflists</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>coldeflist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Mark the RTE as LATERAL if the user said LATERAL explicitly, or if
	 * there are any lateral cross-references in it.
	 */</comment>
	<expr_stmt><expr><name>is_lateral</name> <operator>=</operator> <name><name>r</name><operator>-&gt;</operator><name>lateral</name></name> <operator>||</operator> <call><name>contain_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>funcexprs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * OK, build an RTE for the function.
	 */</comment>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForFunction</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										<argument><expr><name>funcnames</name></expr></argument>, <argument><expr><name>funcexprs</name></expr></argument>, <argument><expr><name>coldeflists</name></expr></argument>,
										<argument><expr><name>r</name></expr></argument>, <argument><expr><name>is_lateral</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rte</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformRangeTableFunc -
 *			Transform a raw RangeTableFunc into TableFunc.
 *
 * Transform the namespace clauses, the document-generating expression, the
 * row-generating expression, the column-generating expressions, and the
 * default value expressions.
 */</comment>
<function><type><specifier>static</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type>
<name>transformRangeTableFunc</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>RangeTableFunc</name> <modifier>*</modifier></type><name>rtf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TableFunc</name>  <modifier>*</modifier></type><name>tf</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>TableFunc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>constructName</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>docType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_lateral</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>col</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>names</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>colno</name></decl>;</decl_stmt>

	<comment type="block">/* Currently only XMLTABLE is supported */</comment>
	<expr_stmt><expr><name>constructName</name> <operator>=</operator> <literal type="string">"XMLTABLE"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>docType</name> <operator>=</operator> <name>XMLOID</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We make lateral_only names of this level visible, whether or not the
	 * RangeTableFunc is explicitly marked LATERAL.  This is needed for SQL
	 * spec compliance and seems useful on convenience grounds for all
	 * functions in FROM.
	 *
	 * (LATERAL can't nest within a single pstate level, so we don't need
	 * save/restore logic here.)
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>pstate</name><operator>-&gt;</operator><name>p_lateral_active</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_lateral_active</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* Transform and apply typecast to the row-generating expression ... */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rtf</name><operator>-&gt;</operator><name>rowexpr</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tf</name><operator>-&gt;</operator><name>rowexpr</name></name> <operator>=</operator> <call><name>coerce_to_specific_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										  <argument><expr><call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>rtf</name><operator>-&gt;</operator><name>rowexpr</name></name></expr></argument>, <argument><expr><name>EXPR_KIND_FROM_FUNCTION</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>TEXTOID</name></expr></argument>,
										  <argument><expr><name>constructName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>tf</name><operator>-&gt;</operator><name>rowexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* ... and to the document itself */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rtf</name><operator>-&gt;</operator><name>docexpr</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tf</name><operator>-&gt;</operator><name>docexpr</name></name> <operator>=</operator> <call><name>coerce_to_specific_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										  <argument><expr><call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>rtf</name><operator>-&gt;</operator><name>docexpr</name></name></expr></argument>, <argument><expr><name>EXPR_KIND_FROM_FUNCTION</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>docType</name></expr></argument>,
										  <argument><expr><name>constructName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>tf</name><operator>-&gt;</operator><name>docexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* undef ordinality column number */</comment>
	<expr_stmt><expr><name><name>tf</name><operator>-&gt;</operator><name>ordinalitycol</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* Process column specs */</comment>
	<expr_stmt><expr><name>names</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>rtf</name><operator>-&gt;</operator><name>columns</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>colno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>col</argument>, <argument>rtf-&gt;columns</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTableFuncCol</name> <modifier>*</modifier></type><name>rawc</name> <init>= <expr><operator>(</operator><name>RangeTableFuncCol</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>col</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>typid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>colexpr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>coldefexpr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>tf</name><operator>-&gt;</operator><name>colnames</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>tf</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>,
							   <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name><name>rawc</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Determine the type and typmod for the new column. FOR ORDINALITY
		 * columns are INTEGER per spec; the others are user-specified.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rawc</name><operator>-&gt;</operator><name>for_ordinality</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>tf</name><operator>-&gt;</operator><name>ordinalitycol</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only one FOR ORDINALITY column is allowed"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>rawc</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>typid</name> <operator>=</operator> <name>INT4OID</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>typmod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tf</name><operator>-&gt;</operator><name>ordinalitycol</name></name> <operator>=</operator> <name>colno</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>rawc</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>setof</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" cannot be declared SETOF"</literal></expr></argument>,
								<argument><expr><name><name>rawc</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>rawc</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>typenameTypeIdAndMod</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>rawc</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>typid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>tf</name><operator>-&gt;</operator><name>coltypes</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>tf</name><operator>-&gt;</operator><name>coltypes</name></name></expr></argument>, <argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tf</name><operator>-&gt;</operator><name>coltypmods</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>tf</name><operator>-&gt;</operator><name>coltypmods</name></name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tf</name><operator>-&gt;</operator><name>colcollations</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>tf</name><operator>-&gt;</operator><name>colcollations</name></name></expr></argument>,
										<argument><expr><ternary><condition><expr><call><name>type_is_collatable</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>DEFAULT_COLLATION_OID</name></expr> </then><else>: <expr><name>InvalidOid</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Transform the PATH and DEFAULT expressions */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rawc</name><operator>-&gt;</operator><name>colexpr</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>colexpr</name> <operator>=</operator> <call><name>coerce_to_specific_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
											  <argument><expr><call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>rawc</name><operator>-&gt;</operator><name>colexpr</name></name></expr></argument>,
															<argument><expr><name>EXPR_KIND_FROM_FUNCTION</name></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><name>TEXTOID</name></expr></argument>,
											  <argument><expr><name>constructName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>colexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>colexpr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rawc</name><operator>-&gt;</operator><name>coldefexpr</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>coldefexpr</name> <operator>=</operator> <call><name>coerce_to_specific_type_typmod</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
														<argument><expr><call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>rawc</name><operator>-&gt;</operator><name>coldefexpr</name></name></expr></argument>,
																	  <argument><expr><name>EXPR_KIND_FROM_FUNCTION</name></expr></argument>)</argument_list></call></expr></argument>,
														<argument><expr><name>typid</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>,
														<argument><expr><name>constructName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>coldefexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>coldefexpr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name><name>tf</name><operator>-&gt;</operator><name>colexprs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>tf</name><operator>-&gt;</operator><name>colexprs</name></name></expr></argument>, <argument><expr><name>colexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tf</name><operator>-&gt;</operator><name>coldefexprs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>tf</name><operator>-&gt;</operator><name>coldefexprs</name></name></expr></argument>, <argument><expr><name>coldefexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rawc</name><operator>-&gt;</operator><name>is_not_null</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tf</name><operator>-&gt;</operator><name>notnulls</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>tf</name><operator>-&gt;</operator><name>notnulls</name></name></expr></argument>, <argument><expr><name>colno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* make sure column names are unique */</comment>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>colno</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>names</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>rawc</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column name \"%s\" is not unique"</literal></expr></argument>,
								<argument><expr><name><name>rawc</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>rawc</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
		<expr_stmt><expr><name><name>names</name><index>[<expr><name>colno</name></expr>]</index></name> <operator>=</operator> <name><name>rawc</name><operator>-&gt;</operator><name>colname</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>colno</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Namespaces, if any, also need to be transformed */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rtf</name><operator>-&gt;</operator><name>namespaces</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ns</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>ns_uris</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>ns_names</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>default_ns_seen</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>ns</argument>, <argument>rtf-&gt;namespaces</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>r</name> <init>= <expr><operator>(</operator><name>ResTarget</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ns</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>ns_uri</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>ResTarget</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ns_uri</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>EXPR_KIND_FROM_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ns_uri</name> <operator>=</operator> <call><name>coerce_to_specific_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>ns_uri</name></expr></argument>,
											 <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><name>constructName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>ns_uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ns_uris</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>ns_uris</name></expr></argument>, <argument><expr><name>ns_uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Verify consistency of name list: no dupes, only one DEFAULT */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>ns_names</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Value</name>	   <modifier>*</modifier></type><name>ns_node</name> <init>= <expr><operator>(</operator><name>Value</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>ns_node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>ns_node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"namespace name \"%s\" is not unique"</literal></expr></argument>,
										<argument><expr><name><name>r</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>default_ns_seen</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only one default namespace is allowed"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>default_ns_seen</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/* We represent DEFAULT by a null pointer */</comment>
			<expr_stmt><expr><name>ns_names</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>ns_names</name></expr></argument>,
							   <argument><expr><ternary><condition><expr><name><name>r</name><operator>-&gt;</operator><name>name</name></name></expr> ?</condition><then> <expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><name><name>tf</name><operator>-&gt;</operator><name>ns_uris</name></name> <operator>=</operator> <name>ns_uris</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tf</name><operator>-&gt;</operator><name>ns_names</name></name> <operator>=</operator> <name>ns_names</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>tf</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>rtf</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_lateral_active</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Mark the RTE as LATERAL if the user said LATERAL explicitly, or if
	 * there are any lateral cross-references in it.
	 */</comment>
	<expr_stmt><expr><name>is_lateral</name> <operator>=</operator> <name><name>rtf</name><operator>-&gt;</operator><name>lateral</name></name> <operator>||</operator> <call><name>contain_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>tf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForTableFunc</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										 <argument><expr><name>tf</name></expr></argument>, <argument><expr><name><name>rtf</name><operator>-&gt;</operator><name>alias</name></name></expr></argument>, <argument><expr><name>is_lateral</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rte</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformRangeTableSample --- transform a TABLESAMPLE clause
 *
 * Caller has already transformed rts-&gt;relation, we just have to validate
 * the remaining fields and create a TableSampleClause node.
 */</comment>
<function><type><specifier>static</specifier> <name>TableSampleClause</name> <modifier>*</modifier></type>
<name>transformRangeTableSample</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>RangeTableSample</name> <modifier>*</modifier></type><name>rts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TableSampleClause</name> <modifier>*</modifier></type><name>tablesample</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>handlerOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>funcargtypes</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TsmRoutine</name> <modifier>*</modifier></type><name>tsm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>fargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>larg</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>ltyp</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * To validate the sample method name, look up the handler function, which
	 * has the same name, one dummy INTERNAL argument, and a result type of
	 * tsm_handler.  (Note: tablesample method names are not schema-qualified
	 * in the SQL standard; but since they are just functions to us, we allow
	 * schema qualification to resolve any potential ambiguity.)
	 */</comment>
	<expr_stmt><expr><name><name>funcargtypes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>INTERNALOID</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>handlerOid</name> <operator>=</operator> <call><name>LookupFuncName</name><argument_list>(<argument><expr><name><name>rts</name><operator>-&gt;</operator><name>method</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>funcargtypes</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we want error to complain about no-such-method, not no-such-function */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>handlerOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tablesample method %s does not exist"</literal></expr></argument>,
						<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name><name>rts</name><operator>-&gt;</operator><name>method</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>rts</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* check that handler has correct return type */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>get_func_rettype</name><argument_list>(<argument><expr><name>handlerOid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TSM_HANDLEROID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function %s must return type %s"</literal></expr></argument>,
						<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name><name>rts</name><operator>-&gt;</operator><name>method</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"tsm_handler"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>rts</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* OK, run the handler to get TsmRoutine, for argument type info */</comment>
	<expr_stmt><expr><name>tsm</name> <operator>=</operator> <call><name>GetTsmRoutine</name><argument_list>(<argument><expr><name>handlerOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tablesample</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>TableSampleClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tablesample</name><operator>-&gt;</operator><name>tsmhandler</name></name> <operator>=</operator> <name>handlerOid</name></expr>;</expr_stmt>

	<comment type="block">/* check user provided the expected number of arguments */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rts</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>tsm</name><operator>-&gt;</operator><name>parameterTypes</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLESAMPLE_ARGUMENT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg_plural</name><argument_list>(<argument><expr><literal type="string">"tablesample method %s requires %d argument, not %d"</literal></expr></argument>,
							   <argument><expr><literal type="string">"tablesample method %s requires %d arguments, not %d"</literal></expr></argument>,
							   <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>tsm</name><operator>-&gt;</operator><name>parameterTypes</name></name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name><name>rts</name><operator>-&gt;</operator><name>method</name></name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>tsm</name><operator>-&gt;</operator><name>parameterTypes</name></name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rts</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>rts</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Transform the arguments, typecasting them as needed.  Note we must also
	 * assign collations now, because assign_query_collations() doesn't
	 * examine any substructure of RTEs.
	 */</comment>
	<expr_stmt><expr><name>fargs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>forboth</name><argument_list>(<argument>larg</argument>, <argument>rts-&gt;args</argument>, <argument>ltyp</argument>, <argument>tsm-&gt;parameterTypes</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>larg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>argtype</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>ltyp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>EXPR_KIND_FROM_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>coerce_to_specific_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>argtype</name></expr></argument>, <argument><expr><literal type="string">"TABLESAMPLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>fargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>fargs</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name><name>tablesample</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>fargs</name></expr>;</expr_stmt>

	<comment type="block">/* Process REPEATABLE (seed) */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rts</name><operator>-&gt;</operator><name>repeatable</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tsm</name><operator>-&gt;</operator><name>repeatable_across_queries</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tablesample method %s does not support REPEATABLE"</literal></expr></argument>,
							<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name><name>rts</name><operator>-&gt;</operator><name>method</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>rts</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>rts</name><operator>-&gt;</operator><name>repeatable</name></name></expr></argument>, <argument><expr><name>EXPR_KIND_FROM_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>coerce_to_specific_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>FLOAT8OID</name></expr></argument>, <argument><expr><literal type="string">"REPEATABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tablesample</name><operator>-&gt;</operator><name>repeatable</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tablesample</name><operator>-&gt;</operator><name>repeatable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>tablesample</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getRTEForSpecialRelationTypes
 *
 * If given RangeVar refers to a CTE or an EphemeralNamedRelation,
 * build and return an appropriate RTE, otherwise return NULL
 */</comment>
<function><type><specifier>static</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type>
<name>getRTEForSpecialRelationTypes</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>rv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>levelsup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * if it is a qualified name, it can't be a CTE or tuplestore reference
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rv</name><operator>-&gt;</operator><name>schemaname</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>cte</name> <operator>=</operator> <call><name>scanNameSpaceForCTE</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>levelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>cte</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForCTE</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>cte</name></expr></argument>, <argument><expr><name>levelsup</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>scanNameSpaceForENR</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForENR</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>rte</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>rte</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformFromClauseItem -
 *	  Transform a FROM-clause item, adding any required entries to the
 *	  range table list being built in the ParseState, and return the
 *	  transformed item ready to include in the joinlist.  Also build a
 *	  ParseNamespaceItem list describing the names exposed by this item.
 *	  This routine can recurse to handle SQL92 JOIN expressions.
 *
 * The function return value is the node to add to the jointree (a
 * RangeTblRef or JoinExpr).  Additional output parameters are:
 *
 * *top_rte: receives the RTE corresponding to the jointree item.
 * (We could extract this from the function return node, but it saves cycles
 * to pass it back separately.)
 *
 * *top_rti: receives the rangetable index of top_rte.  (Ditto.)
 *
 * *namespace: receives a List of ParseNamespaceItems for the RTEs exposed
 * as table/column names by this item.  (The lateral_only flags in these items
 * are indeterminate and should be explicitly set by the caller before use.)
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformFromClauseItem</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name></decl></parameter>,
						<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier><modifier>*</modifier></type><name>top_rte</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>top_rti</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>namespace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>RangeVar</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Plain relation reference, or perhaps a CTE reference */</comment>
		<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>rv</name> <init>= <expr><operator>(</operator><name>RangeVar</name> <operator>*</operator><operator>)</operator> <name>n</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>rtindex</name></decl>;</decl_stmt>

		<comment type="block">/* Check if it's a CTE or tuplestore reference */</comment>
		<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>getRTEForSpecialRelationTypes</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* if not found above, must be a table reference */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rte</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>transformTableEntry</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* assume new rte is at end */</comment>
		<expr_stmt><expr><name>rtindex</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rte</name> <operator>==</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>top_rte</name> <operator>=</operator> <name>rte</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>top_rti</name> <operator>=</operator> <name>rtindex</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>namespace</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeDefaultNSItem</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rtr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <name>rtindex</name></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rtr</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>RangeSubselect</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* sub-SELECT is like a plain relation */</comment>
		<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>rtindex</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>transformRangeSubselect</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>RangeSubselect</name> <operator>*</operator><operator>)</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* assume new rte is at end */</comment>
		<expr_stmt><expr><name>rtindex</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rte</name> <operator>==</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>top_rte</name> <operator>=</operator> <name>rte</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>top_rti</name> <operator>=</operator> <name>rtindex</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>namespace</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeDefaultNSItem</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rtr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <name>rtindex</name></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rtr</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>RangeFunction</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* function is like a plain relation */</comment>
		<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>rtindex</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>transformRangeFunction</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>RangeFunction</name> <operator>*</operator><operator>)</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* assume new rte is at end */</comment>
		<expr_stmt><expr><name>rtindex</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rte</name> <operator>==</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>top_rte</name> <operator>=</operator> <name>rte</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>top_rti</name> <operator>=</operator> <name>rtindex</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>namespace</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeDefaultNSItem</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rtr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <name>rtindex</name></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rtr</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>RangeTableFunc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* table function is like a plain relation */</comment>
		<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>rtindex</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>transformRangeTableFunc</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>RangeTableFunc</name> <operator>*</operator><operator>)</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* assume new rte is at end */</comment>
		<expr_stmt><expr><name>rtindex</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rte</name> <operator>==</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>top_rte</name> <operator>=</operator> <name>rte</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>top_rti</name> <operator>=</operator> <name>rtindex</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>namespace</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeDefaultNSItem</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rtr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <name>rtindex</name></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rtr</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>RangeTableSample</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* TABLESAMPLE clause (wrapping some other valid FROM node) */</comment>
		<decl_stmt><decl><type><name>RangeTableSample</name> <modifier>*</modifier></type><name>rts</name> <init>= <expr><operator>(</operator><name>RangeTableSample</name> <operator>*</operator><operator>)</operator> <name>n</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>rel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

		<comment type="block">/* Recursively transform the contained relation */</comment>
		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>transformFromClauseItem</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>rts</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>,
									  <argument><expr><name>top_rte</name></expr></argument>, <argument><expr><name>top_rti</name></expr></argument>, <argument><expr><name>namespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Currently, grammar could only return a RangeVar as contained rel */</comment>
		<expr_stmt><expr><name>rtr</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* We only support this on plain relations and matviews */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
			<name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_MATVIEW</name> <operator>&amp;&amp;</operator>
			<name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"TABLESAMPLE clause can only be applied to tables and materialized views"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name><name>rts</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Transform TABLESAMPLE details and attach to the RTE */</comment>
		<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>tablesample</name></name> <operator>=</operator> <call><name>transformRangeTableSample</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rtr</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* A newfangled join expression */</comment>
		<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>j</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>n</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>l_rte</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>r_rte</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>l_rtindex</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>r_rtindex</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>l_namespace</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>r_namespace</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>my_namespace</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>l_colnames</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>r_colnames</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>res_colnames</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>l_colvars</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>r_colvars</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>res_colvars</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>lateral_ok</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>sv_namespace_length</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>k</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Recursively process the left subtree, then the right.  We must do
		 * it in this order for correct visibility of LATERAL references.
		 */</comment>
		<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name> <operator>=</operator> <call><name>transformFromClauseItem</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>l_rte</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>l_rtindex</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>l_namespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Make the left-side RTEs available for LATERAL access within the
		 * right side, by temporarily adding them to the pstate's namespace
		 * list.  Per SQL:2008, if the join type is not INNER or LEFT then the
		 * left-side names must still be exposed, but it's an error to
		 * reference them.  (Stupid design, but that's what it says.)  Hence,
		 * we always push them into the namespace, but mark them as not
		 * lateral_ok if the jointype is wrong.
		 *
		 * Notice that we don't require the merged namespace list to be
		 * conflict-free.  See the comments for scanNameSpaceForRefname().
		 *
		 * NB: this coding relies on the fact that list_concat is not
		 * destructive to its second argument.
		 */</comment>
		<expr_stmt><expr><name>lateral_ok</name> <operator>=</operator> <operator>(</operator><name><name>j</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_INNER</name> <operator>||</operator> <name><name>j</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_LEFT</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>setNamespaceLateralState</name><argument_list>(<argument><expr><name>l_namespace</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>lateral_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>sv_namespace_length</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name></expr></argument>, <argument><expr><name>l_namespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* And now we can process the RHS */</comment>
		<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <call><name>transformFromClauseItem</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>r_rte</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>r_rtindex</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>r_namespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Remove the left-side RTEs from the namespace list again */</comment>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name> <operator>=</operator> <call><name>list_truncate</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name></expr></argument>,
											<argument><expr><name>sv_namespace_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check for conflicting refnames in left and right subtrees. Must do
		 * this because higher levels will assume I hand back a self-
		 * consistent namespace list.
		 */</comment>
		<expr_stmt><expr><call><name>checkNameSpaceConflicts</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>l_namespace</name></expr></argument>, <argument><expr><name>r_namespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Generate combined namespace info for possible use below.
		 */</comment>
		<expr_stmt><expr><name>my_namespace</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>l_namespace</name></expr></argument>, <argument><expr><name>r_namespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Extract column name and var lists from both subtrees
		 *
		 * Note: expandRTE returns new lists, safe for me to modify
		 */</comment>
		<expr_stmt><expr><call><name>expandRTE</name><argument_list>(<argument><expr><name>l_rte</name></expr></argument>, <argument><expr><name>l_rtindex</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>,
				  <argument><expr><operator>&amp;</operator><name>l_colnames</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>l_colvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>expandRTE</name><argument_list>(<argument><expr><name>r_rte</name></expr></argument>, <argument><expr><name>r_rtindex</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>,
				  <argument><expr><operator>&amp;</operator><name>r_colnames</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r_colvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Natural join does not explicitly specify columns; must generate
		 * columns to join. Need to run through the list of columns from each
		 * table or join result and match up the column names. Use the first
		 * table, and check every column in the second table for a match.
		 * (We'll check that the matches were unique later on.) The result of
		 * this step is a list of column names just like an explicitly-written
		 * USING list.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>j</name><operator>-&gt;</operator><name>isNatural</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lx</name></decl>,
					   <decl><type ref="prev"><modifier>*</modifier></type><name>rx</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>usingClause</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* shouldn't have USING() too */</comment>

			<macro><name>foreach</name><argument_list>(<argument>lx</argument>, <argument>l_colnames</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>l_colname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Value</name>	   <modifier>*</modifier></type><name>m_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

				<macro><name>foreach</name><argument_list>(<argument>rx</argument>, <argument>r_colnames</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>r_colname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>rx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>l_colname</name></expr></argument>, <argument><expr><name>r_colname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>m_name</name> <operator>=</operator> <call><name>makeString</name><argument_list>(<argument><expr><name>l_colname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block>

				<comment type="block">/* matched a right column? then keep as join column... */</comment>
				<if_stmt><if>if <condition>(<expr><name>m_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>rlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rlist</name></expr></argument>, <argument><expr><name>m_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>

			<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>usingClause</name></name> <operator>=</operator> <name>rlist</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Now transform the join qualifications, if any.
		 */</comment>
		<expr_stmt><expr><name>res_colnames</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>res_colvars</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>j</name><operator>-&gt;</operator><name>usingClause</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * JOIN/USING (or NATURAL JOIN, as transformed above). Transform
			 * the list into an explicit ON-condition, and generate a list of
			 * merged result columns.
			 */</comment>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>ucols</name> <init>= <expr><name><name>j</name><operator>-&gt;</operator><name>usingClause</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>l_usingvars</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>r_usingvars</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ucol</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* shouldn't have ON() too */</comment>

			<macro><name>foreach</name><argument_list>(<argument>ucol</argument>, <argument>ucols</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>u_colname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>ucol</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>col</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>ndx</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>l_index</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>r_index</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>l_colvar</name></decl>,
						   <decl><type ref="prev"><modifier>*</modifier></type><name>r_colvar</name></decl>;</decl_stmt>

				<comment type="block">/* Check for USING(foo,foo) */</comment>
				<macro><name>foreach</name><argument_list>(<argument>col</argument>, <argument>res_colnames</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>res_colname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>col</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>res_colname</name></expr></argument>, <argument><expr><name>u_colname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column name \"%s\" appears more than once in USING clause"</literal></expr></argument>,
										<argument><expr><name>u_colname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block>

				<comment type="block">/* Find it in left input */</comment>
				<expr_stmt><expr><name>ndx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>col</argument>, <argument>l_colnames</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>l_colname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>col</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>l_colname</name></expr></argument>, <argument><expr><name>u_colname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>l_index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_AMBIGUOUS_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"common column name \"%s\" appears more than once in left table"</literal></expr></argument>,
											<argument><expr><name>u_colname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><name>l_index</name> <operator>=</operator> <name>ndx</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name>ndx</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block>
				<if_stmt><if>if <condition>(<expr><name>l_index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" specified in USING clause does not exist in left table"</literal></expr></argument>,
									<argument><expr><name>u_colname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* Find it in right input */</comment>
				<expr_stmt><expr><name>ndx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>col</argument>, <argument>r_colnames</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>r_colname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>col</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>r_colname</name></expr></argument>, <argument><expr><name>u_colname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>r_index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_AMBIGUOUS_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"common column name \"%s\" appears more than once in right table"</literal></expr></argument>,
											<argument><expr><name>u_colname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><name>r_index</name> <operator>=</operator> <name>ndx</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name>ndx</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block>
				<if_stmt><if>if <condition>(<expr><name>r_index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" specified in USING clause does not exist in right table"</literal></expr></argument>,
									<argument><expr><name>u_colname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>l_colvar</name> <operator>=</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name>l_colvars</name></expr></argument>, <argument><expr><name>l_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>l_usingvars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>l_usingvars</name></expr></argument>, <argument><expr><name>l_colvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>r_colvar</name> <operator>=</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name>r_colvars</name></expr></argument>, <argument><expr><name>r_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>r_usingvars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>r_usingvars</name></expr></argument>, <argument><expr><name>r_colvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>res_colnames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>res_colnames</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>ucol</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>res_colvars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>res_colvars</name></expr></argument>,
									  <argument><expr><call><name>buildMergedJoinVar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
														 <argument><expr><name><name>j</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>,
														 <argument><expr><name>l_colvar</name></expr></argument>,
														 <argument><expr><name>r_colvar</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>

			<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <call><name>transformJoinUsingClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
												<argument><expr><name>l_rte</name></expr></argument>,
												<argument><expr><name>r_rte</name></expr></argument>,
												<argument><expr><name>l_usingvars</name></expr></argument>,
												<argument><expr><name>r_usingvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* User-written ON-condition; transform it */</comment>
			<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <call><name>transformJoinOnClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>my_namespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* CROSS JOIN: no quals */</comment>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Add remaining columns from each side to the output columns */</comment>
		<expr_stmt><expr><call><name>extractRemainingColumns</name><argument_list>(<argument><expr><name>res_colnames</name></expr></argument>,
								<argument><expr><name>l_colnames</name></expr></argument>, <argument><expr><name>l_colvars</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>l_colnames</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>l_colvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>extractRemainingColumns</name><argument_list>(<argument><expr><name>res_colnames</name></expr></argument>,
								<argument><expr><name>r_colnames</name></expr></argument>, <argument><expr><name>r_colvars</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>r_colnames</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r_colvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res_colnames</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>res_colnames</name></expr></argument>, <argument><expr><name>l_colnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res_colvars</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>res_colvars</name></expr></argument>, <argument><expr><name>l_colvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res_colnames</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>res_colnames</name></expr></argument>, <argument><expr><name>r_colnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res_colvars</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>res_colvars</name></expr></argument>, <argument><expr><name>r_colvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check alias (AS clause), if any.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>j</name><operator>-&gt;</operator><name>alias</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>j</name><operator>-&gt;</operator><name>alias</name><operator>-&gt;</operator><name>colnames</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>alias</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>res_colnames</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column alias list for \"%s\" has too many entries"</literal></expr></argument>,
									<argument><expr><name><name>j</name><operator>-&gt;</operator><name>alias</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Now build an RTE for the result of the join
		 */</comment>
		<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForJoin</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										<argument><expr><name>res_colnames</name></expr></argument>,
										<argument><expr><name><name>j</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>,
										<argument><expr><name>res_colvars</name></expr></argument>,
										<argument><expr><name><name>j</name><operator>-&gt;</operator><name>alias</name></name></expr></argument>,
										<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* assume new rte is at end */</comment>
		<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rte</name> <operator>==</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>top_rte</name> <operator>=</operator> <name>rte</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>top_rti</name> <operator>=</operator> <name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name></expr>;</expr_stmt>

		<comment type="block">/* make a matching link to the JoinExpr for later use */</comment>
		<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinexprs</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinexprs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinexprs</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinexprs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinexprs</name></name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinexprs</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Prepare returned namespace list.  If the JOIN has an alias then it
		 * hides the contained RTEs completely; otherwise, the contained RTEs
		 * are still visible as table names, but are not visible for
		 * unqualified column-name access.
		 *
		 * Note: if there are nested alias-less JOINs, the lower-level ones
		 * will remain in the list although they have neither p_rel_visible
		 * nor p_cols_visible set.  We could delete such list items, but it's
		 * unclear that it's worth expending cycles to do so.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>j</name><operator>-&gt;</operator><name>alias</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>my_namespace</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>setNamespaceColumnVisibility</name><argument_list>(<argument><expr><name>my_namespace</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * The join RTE itself is always made visible for unqualified column
		 * names.  It's visible as a relation name only if it has an alias.
		 */</comment>
		<expr_stmt><expr><operator>*</operator><name>namespace</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>my_namespace</name></expr></argument>,
							 <argument><expr><call><name>makeNamespaceItem</name><argument_list>(<argument><expr><name>rte</name></expr></argument>,
											   <argument><expr><operator>(</operator><name><name>j</name><operator>-&gt;</operator><name>alias</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></argument>,
											   <argument><expr><name>true</name></expr></argument>,
											   <argument><expr><name>false</name></expr></argument>,
											   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>j</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>				<comment type="block">/* can't get here, keep compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * buildMergedJoinVar -
 *	  generate a suitable replacement expression for a merged join column
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>buildMergedJoinVar</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
				   <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>l_colvar</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>r_colvar</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>outcoltype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>outcoltypmod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>l_node</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>r_node</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>res_node</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Choose output type if input types are dissimilar.
	 */</comment>
	<expr_stmt><expr><name>outcoltype</name> <operator>=</operator> <name><name>l_colvar</name><operator>-&gt;</operator><name>vartype</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>outcoltypmod</name> <operator>=</operator> <name><name>l_colvar</name><operator>-&gt;</operator><name>vartypmod</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>outcoltype</name> <operator>!=</operator> <name><name>r_colvar</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>outcoltype</name> <operator>=</operator> <call><name>select_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										<argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>l_colvar</name></expr></argument>, <argument><expr><name>r_colvar</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><literal type="string">"JOIN/USING"</literal></expr></argument>,
										<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>outcoltypmod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>		<comment type="block">/* ie, unknown */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>outcoltypmod</name> <operator>!=</operator> <name><name>r_colvar</name><operator>-&gt;</operator><name>vartypmod</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* same type, but not same typmod */</comment>
		<expr_stmt><expr><name>outcoltypmod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>		<comment type="block">/* ie, unknown */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Insert coercion functions if needed.  Note that a difference in typmod
	 * can only happen if input has typmod but outcoltypmod is -1. In that
	 * case we insert a RelabelType to clearly mark that result's typmod is
	 * not same as input.  We never need coerce_type_typmod.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>l_colvar</name><operator>-&gt;</operator><name>vartype</name></name> <operator>!=</operator> <name>outcoltype</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>l_node</name> <operator>=</operator> <call><name>coerce_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>l_colvar</name></expr></argument>, <argument><expr><name><name>l_colvar</name><operator>-&gt;</operator><name>vartype</name></name></expr></argument>,
							 <argument><expr><name>outcoltype</name></expr></argument>, <argument><expr><name>outcoltypmod</name></expr></argument>,
							 <argument><expr><name>COERCION_IMPLICIT</name></expr></argument>, <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>l_colvar</name><operator>-&gt;</operator><name>vartypmod</name></name> <operator>!=</operator> <name>outcoltypmod</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>l_node</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeRelabelType</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>l_colvar</name></expr></argument>,
										  <argument><expr><name>outcoltype</name></expr></argument>, <argument><expr><name>outcoltypmod</name></expr></argument>,
										  <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* fixed below */</comment>
										  <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>l_node</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>l_colvar</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>r_colvar</name><operator>-&gt;</operator><name>vartype</name></name> <operator>!=</operator> <name>outcoltype</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>r_node</name> <operator>=</operator> <call><name>coerce_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>r_colvar</name></expr></argument>, <argument><expr><name><name>r_colvar</name><operator>-&gt;</operator><name>vartype</name></name></expr></argument>,
							 <argument><expr><name>outcoltype</name></expr></argument>, <argument><expr><name>outcoltypmod</name></expr></argument>,
							 <argument><expr><name>COERCION_IMPLICIT</name></expr></argument>, <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>r_colvar</name><operator>-&gt;</operator><name>vartypmod</name></name> <operator>!=</operator> <name>outcoltypmod</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>r_node</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeRelabelType</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>r_colvar</name></expr></argument>,
										  <argument><expr><name>outcoltype</name></expr></argument>, <argument><expr><name>outcoltypmod</name></expr></argument>,
										  <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* fixed below */</comment>
										  <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>r_node</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>r_colvar</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Choose what to emit
	 */</comment>
	<switch>switch <condition>(<expr><name>jointype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>JOIN_INNER</name></expr>:</case>

			<comment type="block">/*
			 * We can use either var; prefer non-coerced one if available.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>l_node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>res_node</name> <operator>=</operator> <name>l_node</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>r_node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>res_node</name> <operator>=</operator> <name>r_node</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>res_node</name> <operator>=</operator> <name>l_node</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>JOIN_LEFT</name></expr>:</case>
			<comment type="block">/* Always use left var */</comment>
			<expr_stmt><expr><name>res_node</name> <operator>=</operator> <name>l_node</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>JOIN_RIGHT</name></expr>:</case>
			<comment type="block">/* Always use right var */</comment>
			<expr_stmt><expr><name>res_node</name> <operator>=</operator> <name>r_node</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>JOIN_FULL</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * Here we must build a COALESCE expression to ensure that the
				 * join output is non-null if either input is.
				 */</comment>
				<decl_stmt><decl><type><name>CoalesceExpr</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CoalesceExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>coalescetype</name></name> <operator>=</operator> <name>outcoltype</name></expr>;</expr_stmt>
				<comment type="block">/* coalescecollid will get set below */</comment>
				<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>l_node</name></expr></argument>, <argument><expr><name>r_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>res_node</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>c</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized join type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>jointype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>res_node</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Apply assign_expr_collations to fix up the collation info in the
	 * coercion and CoalesceExpr nodes, if we made any.  This must be done now
	 * so that the join node's alias vars show correct collation info.
	 */</comment>
	<expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>res_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>res_node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * makeNamespaceItem -
 *	  Convenience subroutine to construct a ParseNamespaceItem.
 */</comment>
<function><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type>
<name>makeNamespaceItem</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>rel_visible</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>cols_visible</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>lateral_only</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>lateral_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <operator>(</operator><name>ParseNamespaceItem</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ParseNamespaceItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_rte</name></name> <operator>=</operator> <name>rte</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_rel_visible</name></name> <operator>=</operator> <name>rel_visible</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_cols_visible</name></name> <operator>=</operator> <name>cols_visible</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_lateral_only</name></name> <operator>=</operator> <name>lateral_only</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_lateral_ok</name></name> <operator>=</operator> <name>lateral_ok</name></expr>;</expr_stmt>
	<return>return <expr><name>nsitem</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * setNamespaceColumnVisibility -
 *	  Convenience subroutine to update cols_visible flags in a namespace list.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setNamespaceColumnVisibility</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>namespace</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>cols_visible</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>namespace</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name> <init>= <expr><operator>(</operator><name>ParseNamespaceItem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_cols_visible</name></name> <operator>=</operator> <name>cols_visible</name></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * setNamespaceLateralState -
 *	  Convenience subroutine to update LATERAL flags in a namespace list.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setNamespaceLateralState</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>namespace</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>lateral_only</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>lateral_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>namespace</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name> <init>= <expr><operator>(</operator><name>ParseNamespaceItem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_lateral_only</name></name> <operator>=</operator> <name>lateral_only</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_lateral_ok</name></name> <operator>=</operator> <name>lateral_ok</name></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * transformWhereClause -
 *	  Transform the qualification and make sure it is of type boolean.
 *	  Used for WHERE and allied clauses.
 *
 * constructName does not affect the semantics, but is used in error messages
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>transformWhereClause</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>,
					 <parameter><decl><type><name>ParseExprKind</name></type> <name>exprKind</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>constructName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>qual</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>clause</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>, <argument><expr><name>exprKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>coerce_to_boolean</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>, <argument><expr><name>constructName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>qual</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * transformLimitClause -
 *	  Transform the expression and make sure it is of type bigint.
 *	  Used for LIMIT and allied clauses.
 *
 * Note: as of Postgres 8.2, LIMIT expressions are expected to yield int8,
 * rather than int4 as before.
 *
 * constructName does not affect the semantics, but is used in error messages
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>transformLimitClause</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>,
					 <parameter><decl><type><name>ParseExprKind</name></type> <name>exprKind</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>constructName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>qual</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>clause</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>, <argument><expr><name>exprKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>coerce_to_specific_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>, <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><name>constructName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* LIMIT can't refer to any variables of the current query */</comment>
	<expr_stmt><expr><call><name>checkExprIsVarFree</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>, <argument><expr><name>constructName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>qual</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * checkExprIsVarFree
 *		Check that given expr has no Vars of the current query level
 *		(aggregates and window functions should have been rejected already).
 *
 * This is used to check expressions that have to have a consistent value
 * across all rows of the query, such as a LIMIT.  Arguably it should reject
 * volatile functions, too, but we don't do that --- whatever value the
 * function gives on first execution is what you get.
 *
 * constructName does not affect the semantics, but is used in error messages
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkExprIsVarFree</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>constructName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/* translator: %s is name of a SQL construct, eg LIMIT */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument of %s must not contain variables"</literal></expr></argument>,
						<argument><expr><name>constructName</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
									<argument><expr><call><name>locate_var_of_level</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * checkTargetlistEntrySQL92 -
 *	  Validate a targetlist entry found by findTargetlistEntrySQL92
 *
 * When we select a pre-existing tlist entry as a result of syntax such
 * as "GROUP BY 1", we have to make sure it is acceptable for use in the
 * indicated clause type; transformExpr() will have treated it as a regular
 * targetlist item.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkTargetlistEntrySQL92</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl></parameter>,
						  <parameter><decl><type><name>ParseExprKind</name></type> <name>exprKind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>exprKind</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>EXPR_KIND_GROUP_BY</name></expr>:</case>
			<comment type="block">/* reject aggregates and window functions */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_hasAggs</name></name> <operator>&amp;&amp;</operator>
				<call><name>contain_aggs_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_GROUPING_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				<comment type="block">/* translator: %s is name of a SQL construct, eg GROUP BY */</comment>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aggregate functions are not allowed in %s"</literal></expr></argument>,
								<argument><expr><call><name>ParseExprKindName</name><argument_list>(<argument><expr><name>exprKind</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
											<argument><expr><call><name>locate_agg_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_hasWindowFuncs</name></name> <operator>&amp;&amp;</operator>
				<call><name>contain_windowfuncs</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WINDOWING_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				<comment type="block">/* translator: %s is name of a SQL construct, eg GROUP BY */</comment>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"window functions are not allowed in %s"</literal></expr></argument>,
								<argument><expr><call><name>ParseExprKindName</name><argument_list>(<argument><expr><name>exprKind</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
											<argument><expr><call><name>locate_windowfunc</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_ORDER_BY</name></expr>:</case>
			<comment type="block">/* no extra checks needed */</comment>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_DISTINCT_ON</name></expr>:</case>
			<comment type="block">/* no extra checks needed */</comment>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected exprKind in checkTargetlistEntrySQL92"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 *	findTargetlistEntrySQL92 -
 *	  Returns the targetlist entry matching the given (untransformed) node.
 *	  If no matching entry exists, one is created and appended to the target
 *	  list as a "resjunk" node.
 *
 * This function supports the old SQL92 ORDER BY interpretation, where the
 * expression is an output column name or number.  If we fail to find a
 * match of that sort, we fall through to the SQL99 rules.  For historical
 * reasons, Postgres also allows this interpretation for GROUP BY, though
 * the standard never did.  However, for GROUP BY we prefer a SQL99 match.
 * This function is *not* used for WINDOW definitions.
 *
 * node		the ORDER BY, GROUP BY, or DISTINCT ON expression to be matched
 * tlist	the target list (passed by reference so we can append to it)
 * exprKind identifies clause type being processed
 */</comment>
<function><type><specifier>static</specifier> <name>TargetEntry</name> <modifier>*</modifier></type>
<name>findTargetlistEntrySQL92</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>tlist</name></decl></parameter>,
						 <parameter><decl><type><name>ParseExprKind</name></type> <name>exprKind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>tl</name></decl>;</decl_stmt>

	<comment type="block">/*----------
	 * Handle two special cases as mandated by the SQL92 spec:
	 *
	 * 1. Bare ColumnName (no qualifier or subscripts)
	 *	  For a bare identifier, we search for a matching column name
	 *	  in the existing target list.  Multiple matches are an error
	 *	  unless they refer to identical values; for example,
	 *	  we allow	SELECT a, a FROM table ORDER BY a
	 *	  but not	SELECT a AS b, b FROM table ORDER BY b
	 *	  If no match is found, we fall through and treat the identifier
	 *	  as an expression.
	 *	  For GROUP BY, it is incorrect to match the grouping item against
	 *	  targetlist entries: according to SQL92, an identifier in GROUP BY
	 *	  is a reference to a column name exposed by FROM, not to a target
	 *	  list column.  However, many implementations (including pre-7.0
	 *	  PostgreSQL) accept this anyway.  So for GROUP BY, we look first
	 *	  to see if the identifier matches any FROM column name, and only
	 *	  try for a targetlist name if it doesn't.  This ensures that we
	 *	  adhere to the spec in the case where the name could be both.
	 *	  DISTINCT ON isn't in the standard, so we can do what we like there;
	 *	  we choose to make it work like ORDER BY, on the rather flimsy
	 *	  grounds that ordinary DISTINCT works on targetlist entries.
	 *
	 * 2. IntegerConstant
	 *	  This means to use the n'th item in the existing target list.
	 *	  Note that it would make no sense to order/group/distinct by an
	 *	  actual constant, so this does not create a conflict with SQL99.
	 *	  GROUP BY column-number is not allowed by SQL92, but since
	 *	  the standard has no other behavior defined for this syntax,
	 *	  we may as well accept this common extension.
	 *
	 * Note that pre-existing resjunk targets must not be used in either case,
	 * since the user didn't write them in his SELECT list.
	 *
	 * If neither special case applies, fall through to treat the item as
	 * an expression per SQL99.
	 *----------
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>list_length</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>ColumnRef</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>fields</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
		<call><name>IsA</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>ColumnRef</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>fields</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>ColumnRef</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>fields</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>location</name> <init>= <expr><operator>(</operator><operator>(</operator><name>ColumnRef</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>exprKind</name> <operator>==</operator> <name>EXPR_KIND_GROUP_BY</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * In GROUP BY, we must prefer a match against a FROM-clause
			 * column to one against the targetlist.  Look to see if there is
			 * a matching column.  If so, fall through to use SQL99 rules.
			 * NOTE: if name could refer ambiguously to more than one column
			 * name exposed by FROM, colNameToVar will ereport(ERROR). That's
			 * just what we want here.
			 *
			 * Small tweak for 7.4.3: ignore matches in upper query levels.
			 * This effectively changes the search order for bare names to (1)
			 * local FROM variables, (2) local targetlist aliases, (3) outer
			 * FROM variables, whereas before it was (1) (3) (2). SQL92 and
			 * SQL99 do not allow GROUPing BY an outer reference, so this
			 * breaks no cases that are legal per spec, and it seems a more
			 * self-consistent behavior.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>colNameToVar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>name</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>target_result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>tl</argument>, <argument>*tlist</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>tl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name> <operator>&amp;&amp;</operator>
					<call><name>strcmp</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>target_result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name><name>target_result</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_AMBIGUOUS_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>

							<comment type="block">/*------
							  translator: first %s is name of a SQL construct, eg ORDER BY */</comment>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s \"%s\" is ambiguous"</literal></expr></argument>,
											<argument><expr><call><name>ParseExprKindName</name><argument_list>(<argument><expr><name>exprKind</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>target_result</name> <operator>=</operator> <name>tle</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<comment type="block">/* Stay in loop to check for ambiguity */</comment>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
			<if_stmt><if>if <condition>(<expr><name>target_result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* return the first match, after suitable validation */</comment>
				<expr_stmt><expr><call><name>checkTargetlistEntrySQL92</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>target_result</name></expr></argument>, <argument><expr><name>exprKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>target_result</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>A_Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Value</name>	   <modifier>*</modifier></type><name>val</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>A_Const</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>val</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>location</name> <init>= <expr><operator>(</operator><operator>(</operator><name>A_Const</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>targetlist_pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>target_pos</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>Integer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
			<comment type="block">/* translator: %s is name of a SQL construct, eg ORDER BY */</comment>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"non-integer constant in %s"</literal></expr></argument>,
							<argument><expr><call><name>ParseExprKindName</name><argument_list>(<argument><expr><name>exprKind</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>target_pos</name> <operator>=</operator> <call><name>intVal</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>tl</argument>, <argument>*tlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>tl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>++</operator><name>targetlist_pos</name> <operator>==</operator> <name>target_pos</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* return the unique match, after suitable validation */</comment>
					<expr_stmt><expr><call><name>checkTargetlistEntrySQL92</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>, <argument><expr><name>exprKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>tle</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/* translator: %s is name of a SQL construct, eg ORDER BY */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s position %d is not in select list"</literal></expr></argument>,
						<argument><expr><call><name>ParseExprKindName</name><argument_list>(<argument><expr><name>exprKind</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>target_pos</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise, we have an expression, so process it per SQL99 rules.
	 */</comment>
	<return>return <expr><call><name>findTargetlistEntrySQL99</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>exprKind</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	findTargetlistEntrySQL99 -
 *	  Returns the targetlist entry matching the given (untransformed) node.
 *	  If no matching entry exists, one is created and appended to the target
 *	  list as a "resjunk" node.
 *
 * This function supports the SQL99 interpretation, wherein the expression
 * is just an ordinary expression referencing input column names.
 *
 * node		the ORDER BY, GROUP BY, etc expression to be matched
 * tlist	the target list (passed by reference so we can append to it)
 * exprKind identifies clause type being processed
 */</comment>
<function><type><specifier>static</specifier> <name>TargetEntry</name> <modifier>*</modifier></type>
<name>findTargetlistEntrySQL99</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>tlist</name></decl></parameter>,
						 <parameter><decl><type><name>ParseExprKind</name></type> <name>exprKind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>target_result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>tl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Convert the untransformed node to a transformed expression, and search
	 * for a match in the tlist.  NOTE: it doesn't really matter whether there
	 * is more than one match.  Also, we are willing to match an existing
	 * resjunk target here, though the SQL92 cases above must ignore resjunk
	 * targets.
	 */</comment>
	<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>exprKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>tl</argument>, <argument>*tlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>tl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>texpr</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Ignore any implicit cast on the existing tlist expression.
		 *
		 * This essentially allows the ORDER/GROUP/etc item to adopt the same
		 * datatype previously selected for a textually-equivalent tlist item.
		 * There can't be any implicit cast at top level in an ordinary SELECT
		 * tlist at this stage, but the case does arise with ORDER BY in an
		 * aggregate function.
		 */</comment>
		<expr_stmt><expr><name>texpr</name> <operator>=</operator> <call><name>strip_implicit_coercions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>texpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>tle</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If no matches, construct a new target entry which is appended to the
	 * end of the target list.  This target is given resjunk = true so that it
	 * will not be projected into the final tuple.
	 */</comment>
	<expr_stmt><expr><name>target_result</name> <operator>=</operator> <call><name>transformTargetEntry</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>exprKind</name></expr></argument>,
										 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>tlist</name></expr></argument>, <argument><expr><name>target_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>target_result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*-------------------------------------------------------------------------
 * Flatten out parenthesized sublists in grouping lists, and some cases
 * of nested grouping sets.
 *
 * Inside a grouping set (ROLLUP, CUBE, or GROUPING SETS), we expect the
 * content to be nested no more than 2 deep: i.e. ROLLUP((a,b),(c,d)) is
 * ok, but ROLLUP((a,(b,c)),d) is flattened to ((a,b,c),d), which we then
 * (later) normalize to ((a,b,c),(d)).
 *
 * CUBE or ROLLUP can be nested inside GROUPING SETS (but not the reverse),
 * and we leave that alone if we find it. But if we see GROUPING SETS inside
 * GROUPING SETS, we can flatten and normalize as follows:
 *	 GROUPING SETS (a, (b,c), GROUPING SETS ((c,d),(e)), (f,g))
 * becomes
 *	 GROUPING SETS ((a), (b,c), (c,d), (e), (f,g))
 *
 * This is per the spec's syntax transformations, but these are the only such
 * transformations we do in parse analysis, so that queries retain the
 * originally specified grouping set syntax for CUBE and ROLLUP as much as
 * possible when deparsed. (Full expansion of the result into a list of
 * grouping sets is left to the planner.)
 *
 * When we're done, the resulting list should contain only these possible
 * elements:
 *	 - an expression
 *	 - a CUBE or ROLLUP with a list of expressions nested 2 deep
 *	 - a GROUPING SET containing any of:
 *		- expression lists
 *		- empty grouping sets
 *		- CUBE or ROLLUP nodes with lists nested 2 deep
 * The return is a new list, but doesn't deep-copy the old nodes except for
 * GroupingSet nodes.
 *
 * As a side effect, flag whether the list has any GroupingSet nodes.
 *-------------------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>flatten_grouping_sets</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>toplevel</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasGroupingSets</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* just in case of pathological input */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>expr</name> <operator>==</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>NIL</name></expr>;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_RowExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RowExpr</name>    <modifier>*</modifier></type><name>r</name> <init>= <expr><operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>row_format</name></name> <operator>==</operator> <name>COERCE_IMPLICIT_CAST</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><call><name>flatten_grouping_sets</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>r</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
												 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_GroupingSet</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>GroupingSet</name> <modifier>*</modifier></type><name>gset</name> <init>= <expr><operator>(</operator><name>GroupingSet</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l2</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result_set</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>hasGroupingSets</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>hasGroupingSets</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * at the top level, we skip over all empty grouping sets; the
				 * caller can supply the canonical GROUP BY () if nothing is
				 * left.
				 */</comment>

				<if_stmt><if>if <condition>(<expr><name>toplevel</name> <operator>&amp;&amp;</operator> <name><name>gset</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>GROUPING_SET_EMPTY</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>NIL</name></expr>;</return></block_content></block></if></if_stmt>

				<macro><name>foreach</name><argument_list>(<argument>l2</argument>, <argument>gset-&gt;content</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>n1</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>n2</name> <init>= <expr><call><name>flatten_grouping_sets</name><argument_list>(<argument><expr><name>n1</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>n1</name></expr></argument>, <argument><expr><name>GroupingSet</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
						<operator>(</operator><operator>(</operator><name>GroupingSet</name> <operator>*</operator><operator>)</operator> <name>n1</name><operator>)</operator><operator>-&gt;</operator><name>kind</name> <operator>==</operator> <name>GROUPING_SET_SETS</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>result_set</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result_set</name></expr></argument>, <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>n2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>result_set</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result_set</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block>

				<comment type="block">/*
				 * At top level, keep the grouping set node; but if we're in a
				 * nested grouping set, then we need to concat the flattened
				 * result into the outer list if it's simply nested.
				 */</comment>

				<if_stmt><if>if <condition>(<expr><name>toplevel</name> <operator>||</operator> <operator>(</operator><name><name>gset</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <name>GROUPING_SET_SETS</name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeGroupingSet</name><argument_list>(<argument><expr><name><name>gset</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>, <argument><expr><name>result_set</name></expr></argument>, <argument><expr><name><name>gset</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</return>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>result_set</name></expr>;</return></block_content></block></else></if_stmt>
			</block_content>}</block>
		<case>case <expr><name>T_List</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

				<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>(List *) expr</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>flatten_grouping_sets</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>toplevel</name></expr></argument>, <argument><expr><name>hasGroupingSets</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>n</name> <operator>!=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>NIL</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block>

				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>result</name></expr>;</return>
			</block_content>}</block>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>expr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Transform a single expression within a GROUP BY clause or grouping set.
 *
 * The expression is added to the targetlist if not already present, and to the
 * flatresult list (which will become the groupClause) if not already present
 * there.  The sortClause is consulted for operator and sort order hints.
 *
 * Returns the ressortgroupref of the expression.
 *
 * flatresult	reference to flat list of SortGroupClause nodes
 * seen_local	bitmapset of sortgrouprefs already seen at the local level
 * pstate		ParseState
 * gexpr		node to transform
 * targetlist	reference to TargetEntry list
 * sortClause	ORDER BY clause (SortGroupClause nodes)
 * exprKind		expression kind
 * useSQL99		SQL99 rather than SQL92 syntax
 * toplevel		false if within any grouping set
 */</comment>
<function><type><specifier>static</specifier> <name>Index</name></type>
<name>transformGroupClauseExpr</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>flatresult</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>seen_local</name></decl></parameter>,
						 <parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>gexpr</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sortClause</name></decl></parameter>,
						 <parameter><decl><type><name>ParseExprKind</name></type> <name>exprKind</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>useSQL99</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>toplevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>useSQL99</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>findTargetlistEntrySQL99</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>gexpr</name></expr></argument>,
									   <argument><expr><name>targetlist</name></expr></argument>, <argument><expr><name>exprKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>findTargetlistEntrySQL92</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>gexpr</name></expr></argument>,
									   <argument><expr><name>targetlist</name></expr></argument>, <argument><expr><name>exprKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>sl</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Eliminate duplicates (GROUP BY x, x) but only at local level.
		 * (Duplicates in grouping sets can affect the number of returned
		 * rows, so can't be dropped indiscriminately.)
		 *
		 * Since we don't care about anything except the sortgroupref, we can
		 * use a bitmapset rather than scanning lists.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name></expr></argument>, <argument><expr><name>seen_local</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If we're already in the flat clause list, we don't need to consider
		 * adding ourselves again.
		 */</comment>
		<expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>targetIsInSortList</name><argument_list>(<argument><expr><name>tle</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>*</operator><name>flatresult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If the GROUP BY tlist entry also appears in ORDER BY, copy operator
		 * info from the (first) matching ORDER BY item.  This means that if
		 * you write something like "GROUP BY foo ORDER BY foo USING &lt;&lt;&lt;", the
		 * GROUP BY operation silently takes on the equality semantics implied
		 * by the ORDER BY.  There are two reasons to do this: it improves the
		 * odds that we can implement both GROUP BY and ORDER BY with a single
		 * sort step, and it allows the user to choose the equality semantics
		 * used by GROUP BY, should she be working with a datatype that has
		 * more than one equality operator.
		 *
		 * If we're in a grouping set, though, we force our requested ordering
		 * to be NULLS LAST, because if we have any hope of using a sorted agg
		 * for the job, we're going to be tacking on generated NULL values
		 * after the corresponding groups. If the user demands nulls first,
		 * another sort step is going to be inevitable, but that's the
		 * planner's problem.
		 */</comment>

		<macro><name>foreach</name><argument_list>(<argument>sl</argument>, <argument>sortClause</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sc</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>sl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>sc</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name> <operator>==</operator> <name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>grpc</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>sc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>toplevel</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>grpc</name><operator>-&gt;</operator><name>nulls_first</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><operator>*</operator><name>flatresult</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>flatresult</name></expr></argument>, <argument><expr><name>grpc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If no match in ORDER BY, just add it to the result using default
	 * sort/group semantics.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>flatresult</name> <operator>=</operator> <call><name>addTargetToGroupList</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>,
										   <argument><expr><operator>*</operator><name>flatresult</name></expr></argument>, <argument><expr><operator>*</operator><name>targetlist</name></expr></argument>,
										   <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>gexpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * _something_ must have assigned us a sortgroupref by now...
	 */</comment>

	<return>return <expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Transform a list of expressions within a GROUP BY clause or grouping set.
 *
 * The list of expressions belongs to a single clause within which duplicates
 * can be safely eliminated.
 *
 * Returns an integer list of ressortgroupref values.
 *
 * flatresult	reference to flat list of SortGroupClause nodes
 * pstate		ParseState
 * list			nodes to transform
 * targetlist	reference to TargetEntry list
 * sortClause	ORDER BY clause (SortGroupClause nodes)
 * exprKind		expression kind
 * useSQL99		SQL99 rather than SQL92 syntax
 * toplevel		false if within any grouping set
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>transformGroupClauseList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>flatresult</name></decl></parameter>,
						 <parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sortClause</name></decl></parameter>,
						 <parameter><decl><type><name>ParseExprKind</name></type> <name>exprKind</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>useSQL99</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>toplevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>seen_local</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>gl</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>gl</argument>, <argument>list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>gexpr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>gl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Index</name></type>		<name>ref</name> <init>= <expr><call><name>transformGroupClauseExpr</name><argument_list>(<argument><expr><name>flatresult</name></expr></argument>,
												   <argument><expr><name>seen_local</name></expr></argument>,
												   <argument><expr><name>pstate</name></expr></argument>,
												   <argument><expr><name>gexpr</name></expr></argument>,
												   <argument><expr><name>targetlist</name></expr></argument>,
												   <argument><expr><name>sortClause</name></expr></argument>,
												   <argument><expr><name>exprKind</name></expr></argument>,
												   <argument><expr><name>useSQL99</name></expr></argument>,
												   <argument><expr><name>toplevel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>ref</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>seen_local</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>seen_local</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Transform a grouping set and (recursively) its content.
 *
 * The grouping set might be a GROUPING SETS node with other grouping sets
 * inside it, but SETS within SETS have already been flattened out before
 * reaching here.
 *
 * Returns the transformed node, which now contains SIMPLE nodes with lists
 * of ressortgrouprefs rather than expressions.
 *
 * flatresult	reference to flat list of SortGroupClause nodes
 * pstate		ParseState
 * gset			grouping set to transform
 * targetlist	reference to TargetEntry list
 * sortClause	ORDER BY clause (SortGroupClause nodes)
 * exprKind		expression kind
 * useSQL99		SQL99 rather than SQL92 syntax
 * toplevel		false if within any grouping set
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformGroupingSet</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>flatresult</name></decl></parameter>,
					 <parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>GroupingSet</name> <modifier>*</modifier></type><name>gset</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sortClause</name></decl></parameter>,
					 <parameter><decl><type><name>ParseExprKind</name></type> <name>exprKind</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>useSQL99</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>toplevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>gl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>content</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>toplevel</name> <operator>||</operator> <name><name>gset</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <name>GROUPING_SET_SETS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>gl</argument>, <argument>gset-&gt;content</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>gl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>l</name> <init>= <expr><call><name>transformGroupClauseList</name><argument_list>(<argument><expr><name>flatresult</name></expr></argument>,
													 <argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>n</name></expr></argument>,
													 <argument><expr><name>targetlist</name></expr></argument>, <argument><expr><name>sortClause</name></expr></argument>,
													 <argument><expr><name>exprKind</name></expr></argument>, <argument><expr><name>useSQL99</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>content</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>content</name></expr></argument>, <argument><expr><call><name>makeGroupingSet</name><argument_list>(<argument><expr><name>GROUPING_SET_SIMPLE</name></expr></argument>,
													   <argument><expr><name>l</name></expr></argument>,
													   <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>GroupingSet</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>GroupingSet</name> <modifier>*</modifier></type><name>gset2</name> <init>= <expr><operator>(</operator><name>GroupingSet</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>gl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>content</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>content</name></expr></argument>, <argument><expr><call><name>transformGroupingSet</name><argument_list>(<argument><expr><name>flatresult</name></expr></argument>,
															<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>gset2</name></expr></argument>,
															<argument><expr><name>targetlist</name></expr></argument>, <argument><expr><name>sortClause</name></expr></argument>,
															<argument><expr><name>exprKind</name></expr></argument>, <argument><expr><name>useSQL99</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Index</name></type>		<name>ref</name> <init>= <expr><call><name>transformGroupClauseExpr</name><argument_list>(<argument><expr><name>flatresult</name></expr></argument>,
													   <argument><expr><name>NULL</name></expr></argument>,
													   <argument><expr><name>pstate</name></expr></argument>,
													   <argument><expr><name>n</name></expr></argument>,
													   <argument><expr><name>targetlist</name></expr></argument>,
													   <argument><expr><name>sortClause</name></expr></argument>,
													   <argument><expr><name>exprKind</name></expr></argument>,
													   <argument><expr><name>useSQL99</name></expr></argument>,
													   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>content</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>content</name></expr></argument>, <argument><expr><call><name>makeGroupingSet</name><argument_list>(<argument><expr><name>GROUPING_SET_SIMPLE</name></expr></argument>,
													   <argument><expr><call><name>list_make1_int</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr></argument>,
													   <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Arbitrarily cap the size of CUBE, which has exponential growth */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>gset</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>GROUPING_SET_CUBE</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">12</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_COLUMNS</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"CUBE is limited to 12 elements"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>gset</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeGroupingSet</name><argument_list>(<argument><expr><name><name>gset</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>, <argument><expr><name>content</name></expr></argument>, <argument><expr><name><name>gset</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * transformGroupClause -
 *	  transform a GROUP BY clause
 *
 * GROUP BY items will be added to the targetlist (as resjunk columns)
 * if not already present, so the targetlist must be passed by reference.
 *
 * This is also used for window PARTITION BY clauses (which act almost the
 * same, but are always interpreted per SQL99 rules).
 *
 * Grouping sets make this a lot more complex than it was. Our goal here is
 * twofold: we make a flat list of SortGroupClause nodes referencing each
 * distinct expression used for grouping, with those expressions added to the
 * targetlist if needed. At the same time, we build the groupingSets tree,
 * which stores only ressortgrouprefs as integer lists inside GroupingSet nodes
 * (possibly nested, but limited in depth: a GROUPING_SET_SETS node can contain
 * nested SIMPLE, CUBE or ROLLUP nodes, but not more sets - we flatten that
 * out; while CUBE and ROLLUP can contain only SIMPLE nodes).
 *
 * We skip much of the hard work if there are no grouping sets.
 *
 * One subtlety is that the groupClause list can end up empty while the
 * groupingSets list is not; this happens if there are only empty grouping
 * sets, or an explicit GROUP BY (). This has the same effect as specifying
 * aggregates or a HAVING clause with no GROUP BY; the output is one row per
 * grouping set even if the input is empty.
 *
 * Returns the transformed (flat) groupClause.
 *
 * pstate		ParseState
 * grouplist	clause to transform
 * groupingSets reference to list to contain the grouping set tree
 * targetlist	reference to TargetEntry list
 * sortClause	ORDER BY clause (SortGroupClause nodes)
 * exprKind		expression kind
 * useSQL99		SQL99 rather than SQL92 syntax
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>transformGroupClause</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>grouplist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>groupingSets</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sortClause</name></decl></parameter>,
					 <parameter><decl><type><name>ParseExprKind</name></type> <name>exprKind</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>useSQL99</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>flat_grouplist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>gsets</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>gl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hasGroupingSets</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>seen_local</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Recursively flatten implicit RowExprs. (Technically this is only needed
	 * for GROUP BY, per the syntax rules for grouping sets, but we do it
	 * anyway.)
	 */</comment>
	<expr_stmt><expr><name>flat_grouplist</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>flatten_grouping_sets</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>grouplist</name></expr></argument>,
													<argument><expr><name>true</name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name>hasGroupingSets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the list is now empty, but hasGroupingSets is true, it's because we
	 * elided redundant empty grouping sets. Restore a single empty grouping
	 * set to leave a canonical form: GROUP BY ()
	 */</comment>

	<if_stmt><if>if <condition>(<expr><name>flat_grouplist</name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name>hasGroupingSets</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>flat_grouplist</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeGroupingSet</name><argument_list>(<argument><expr><name>GROUPING_SET_EMPTY</name></expr></argument>,
													<argument><expr><name>NIL</name></expr></argument>,
													<argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>grouplist</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>gl</argument>, <argument>flat_grouplist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>gexpr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>gl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>gexpr</name></expr></argument>, <argument><expr><name>GroupingSet</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>GroupingSet</name> <modifier>*</modifier></type><name>gset</name> <init>= <expr><operator>(</operator><name>GroupingSet</name> <operator>*</operator><operator>)</operator> <name>gexpr</name></expr></init></decl>;</decl_stmt>

			<switch>switch <condition>(<expr><name><name>gset</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>GROUPING_SET_EMPTY</name></expr>:</case>
					<expr_stmt><expr><name>gsets</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>gsets</name></expr></argument>, <argument><expr><name>gset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>GROUPING_SET_SIMPLE</name></expr>:</case>
					<comment type="block">/* can't happen */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>GROUPING_SET_SETS</name></expr>:</case>
				<case>case <expr><name>GROUPING_SET_CUBE</name></expr>:</case>
				<case>case <expr><name>GROUPING_SET_ROLLUP</name></expr>:</case>
					<expr_stmt><expr><name>gsets</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>gsets</name></expr></argument>,
									<argument><expr><call><name>transformGroupingSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
														 <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>gset</name></expr></argument>,
														 <argument><expr><name>targetlist</name></expr></argument>, <argument><expr><name>sortClause</name></expr></argument>,
														 <argument><expr><name>exprKind</name></expr></argument>, <argument><expr><name>useSQL99</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Index</name></type>		<name>ref</name> <init>= <expr><call><name>transformGroupClauseExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>seen_local</name></expr></argument>,
													   <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>gexpr</name></expr></argument>,
													   <argument><expr><name>targetlist</name></expr></argument>, <argument><expr><name>sortClause</name></expr></argument>,
													   <argument><expr><name>exprKind</name></expr></argument>, <argument><expr><name>useSQL99</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>ref</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>seen_local</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>seen_local</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>hasGroupingSets</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>gsets</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>gsets</name></expr></argument>,
									<argument><expr><call><name>makeGroupingSet</name><argument_list>(<argument><expr><name>GROUPING_SET_SIMPLE</name></expr></argument>,
													<argument><expr><call><name>list_make1_int</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr></argument>,
													<argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>gexpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/* parser should prevent this */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>gsets</name> <operator>==</operator> <name>NIL</name> <operator>||</operator> <name>groupingSets</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>groupingSets</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>groupingSets</name> <operator>=</operator> <name>gsets</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformSortClause -
 *	  transform an ORDER BY clause
 *
 * ORDER BY items will be added to the targetlist (as resjunk columns)
 * if not already present, so the targetlist must be passed by reference.
 *
 * This is also used for window and aggregate ORDER BY clauses (which act
 * almost the same, but are always interpreted per SQL99 rules).
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>transformSortClause</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
					<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>orderlist</name></decl></parameter>,
					<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetlist</name></decl></parameter>,
					<parameter><decl><type><name>ParseExprKind</name></type> <name>exprKind</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>useSQL99</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sortlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>olitem</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>olitem</argument>, <argument>orderlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortBy</name>	   <modifier>*</modifier></type><name>sortby</name> <init>= <expr><operator>(</operator><name>SortBy</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>olitem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>useSQL99</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>findTargetlistEntrySQL99</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>sortby</name><operator>-&gt;</operator><name>node</name></name></expr></argument>,
										   <argument><expr><name>targetlist</name></expr></argument>, <argument><expr><name>exprKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>findTargetlistEntrySQL92</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>sortby</name><operator>-&gt;</operator><name>node</name></name></expr></argument>,
										   <argument><expr><name>targetlist</name></expr></argument>, <argument><expr><name>exprKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>sortlist</name> <operator>=</operator> <call><name>addTargetToSortList</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>,
									   <argument><expr><name>sortlist</name></expr></argument>, <argument><expr><operator>*</operator><name>targetlist</name></expr></argument>, <argument><expr><name>sortby</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>sortlist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformWindowDefinitions -
 *		transform window definitions (WindowDef to WindowClause)
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>transformWindowDefinitions</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>windowdefs</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>winref</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>windowdefs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WindowDef</name>  <modifier>*</modifier></type><name>windef</name> <init>= <expr><operator>(</operator><name>WindowDef</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>refwc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>partitionClause</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>orderClause</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>rangeopfamily</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>rangeopcintype</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>wc</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>winref</name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check for duplicate window names.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>windef</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator>
			<call><name>findWindowClause</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>windef</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WINDOWING_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"window \"%s\" is already defined"</literal></expr></argument>, <argument><expr><name><name>windef</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>windef</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If it references a previous window, look that up.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>windef</name><operator>-&gt;</operator><name>refname</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>refwc</name> <operator>=</operator> <call><name>findWindowClause</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>windef</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>refwc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"window \"%s\" does not exist"</literal></expr></argument>,
								<argument><expr><name><name>windef</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>windef</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Transform PARTITION and ORDER specs, if any.  These are treated
		 * almost exactly like top-level GROUP BY and ORDER BY clauses,
		 * including the special handling of nondefault operator semantics.
		 */</comment>
		<expr_stmt><expr><name>orderClause</name> <operator>=</operator> <call><name>transformSortClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										  <argument><expr><name><name>windef</name><operator>-&gt;</operator><name>orderClause</name></name></expr></argument>,
										  <argument><expr><name>targetlist</name></expr></argument>,
										  <argument><expr><name>EXPR_KIND_WINDOW_ORDER</name></expr></argument>,
										  <argument><expr><name>true</name></expr></argument> <comment type="block">/* force SQL99 rules */</comment> )</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>partitionClause</name> <operator>=</operator> <call><name>transformGroupClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
											   <argument><expr><name><name>windef</name><operator>-&gt;</operator><name>partitionClause</name></name></expr></argument>,
											   <argument><expr><name>NULL</name></expr></argument>,
											   <argument><expr><name>targetlist</name></expr></argument>,
											   <argument><expr><name>orderClause</name></expr></argument>,
											   <argument><expr><name>EXPR_KIND_WINDOW_PARTITION</name></expr></argument>,
											   <argument><expr><name>true</name></expr></argument> <comment type="block">/* force SQL99 rules */</comment> )</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * And prepare the new WindowClause.
		 */</comment>
		<expr_stmt><expr><name>wc</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>WindowClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>wc</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name><name>windef</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>wc</name><operator>-&gt;</operator><name>refname</name></name> <operator>=</operator> <name><name>windef</name><operator>-&gt;</operator><name>refname</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Per spec, a windowdef that references a previous one copies the
		 * previous partition clause (and mustn't specify its own).  It can
		 * specify its own ordering clause, but only if the previous one had
		 * none.  It always specifies its own frame clause, and the previous
		 * one must not have a frame clause.  Yeah, it's bizarre that each of
		 * these cases works differently, but SQL:2008 says so; see 7.11
		 * &lt;window clause&gt; syntax rule 10 and general rule 1.  The frame
		 * clause rule is especially bizarre because it makes "OVER foo"
		 * different from "OVER (foo)", and requires the latter to throw an
		 * error if foo has a nondefault frame clause.  Well, ours not to
		 * reason why, but we do go out of our way to throw a useful error
		 * message for such cases.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>refwc</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>partitionClause</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WINDOWING_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot override PARTITION BY clause of window \"%s\""</literal></expr></argument>,
								<argument><expr><name><name>windef</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>windef</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>wc</name><operator>-&gt;</operator><name>partitionClause</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>refwc</name><operator>-&gt;</operator><name>partitionClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>wc</name><operator>-&gt;</operator><name>partitionClause</name></name> <operator>=</operator> <name>partitionClause</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>refwc</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>orderClause</name> <operator>&amp;&amp;</operator> <name><name>refwc</name><operator>-&gt;</operator><name>orderClause</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WINDOWING_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot override ORDER BY clause of window \"%s\""</literal></expr></argument>,
								<argument><expr><name><name>windef</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>windef</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>orderClause</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>wc</name><operator>-&gt;</operator><name>orderClause</name></name> <operator>=</operator> <name>orderClause</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>wc</name><operator>-&gt;</operator><name>copiedOrder</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>wc</name><operator>-&gt;</operator><name>orderClause</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>refwc</name><operator>-&gt;</operator><name>orderClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>wc</name><operator>-&gt;</operator><name>copiedOrder</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>wc</name><operator>-&gt;</operator><name>orderClause</name></name> <operator>=</operator> <name>orderClause</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>wc</name><operator>-&gt;</operator><name>copiedOrder</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>refwc</name> <operator>&amp;&amp;</operator> <name><name>refwc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>!=</operator> <name>FRAMEOPTION_DEFAULTS</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Use this message if this is a WINDOW clause, or if it's an OVER
			 * clause that includes ORDER BY or framing clauses.  (We already
			 * rejected PARTITION BY above, so no need to check that.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>windef</name><operator>-&gt;</operator><name>name</name></name> <operator>||</operator>
				<name>orderClause</name> <operator>||</operator> <name><name>windef</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>!=</operator> <name>FRAMEOPTION_DEFAULTS</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WINDOWING_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot copy window \"%s\" because it has a frame clause"</literal></expr></argument>,
								<argument><expr><name><name>windef</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>windef</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* Else this clause is just OVER (foo), so say this: */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WINDOWING_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot copy window \"%s\" because it has a frame clause"</literal></expr></argument>,
							<argument><expr><name><name>windef</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Omit the parentheses in this OVER clause."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>windef</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>=</operator> <name><name>windef</name><operator>-&gt;</operator><name>frameOptions</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * RANGE offset PRECEDING/FOLLOWING requires exactly one ORDER BY
		 * column; check that and get its sort opfamily info.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_RANGE</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <operator>(</operator><name>FRAMEOPTION_START_OFFSET</name> <operator>|</operator>
								 <name>FRAMEOPTION_END_OFFSET</name><operator>)</operator><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sortcl</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>sortkey</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int16</name></type>		<name>rangestrategy</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>orderClause</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WINDOWING_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"RANGE with offset PRECEDING/FOLLOWING requires exactly one ORDER BY column"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>windef</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>sortcl</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>SortGroupClause</name></expr></argument>, <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>orderClause</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sortkey</name> <operator>=</operator> <call><name>get_sortgroupclause_expr</name><argument_list>(<argument><expr><name>sortcl</name></expr></argument>, <argument><expr><operator>*</operator><name>targetlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Find the sort operator in pg_amop */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_ordering_op_properties</name><argument_list>(<argument><expr><name><name>sortcl</name><operator>-&gt;</operator><name>sortop</name></name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>rangeopfamily</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>rangeopcintype</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>rangestrategy</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"operator %u is not a valid ordering operator"</literal></expr></argument>,
					 <argument><expr><name><name>sortcl</name><operator>-&gt;</operator><name>sortop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* Record properties of sort ordering */</comment>
			<expr_stmt><expr><name><name>wc</name><operator>-&gt;</operator><name>inRangeColl</name></name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><name>sortkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>wc</name><operator>-&gt;</operator><name>inRangeAsc</name></name> <operator>=</operator> <operator>(</operator><name>rangestrategy</name> <operator>==</operator> <name>BTLessStrategyNumber</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>wc</name><operator>-&gt;</operator><name>inRangeNullsFirst</name></name> <operator>=</operator> <name><name>sortcl</name><operator>-&gt;</operator><name>nulls_first</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Per spec, GROUPS mode requires an ORDER BY clause */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_GROUPS</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>orderClause</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WINDOWING_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"GROUPS mode requires an ORDER BY clause"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>windef</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Process frame offset expressions */</comment>
		<expr_stmt><expr><name><name>wc</name><operator>-&gt;</operator><name>startOffset</name></name> <operator>=</operator> <call><name>transformFrameOffset</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name></expr></argument>,
											   <argument><expr><name>rangeopfamily</name></expr></argument>, <argument><expr><name>rangeopcintype</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name><name>wc</name><operator>-&gt;</operator><name>startInRangeFunc</name></name></expr></argument>,
											   <argument><expr><name><name>windef</name><operator>-&gt;</operator><name>startOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>wc</name><operator>-&gt;</operator><name>endOffset</name></name> <operator>=</operator> <call><name>transformFrameOffset</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name></expr></argument>,
											 <argument><expr><name>rangeopfamily</name></expr></argument>, <argument><expr><name>rangeopcintype</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name><name>wc</name><operator>-&gt;</operator><name>endInRangeFunc</name></name></expr></argument>,
											 <argument><expr><name><name>windef</name><operator>-&gt;</operator><name>endOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>wc</name><operator>-&gt;</operator><name>winref</name></name> <operator>=</operator> <name>winref</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>wc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformDistinctClause -
 *	  transform a DISTINCT clause
 *
 * Since we may need to add items to the query's targetlist, that list
 * is passed by reference.
 *
 * As with GROUP BY, we absorb the sorting semantics of ORDER BY as much as
 * possible into the distinctClause.  This avoids a possible need to re-sort,
 * and allows the user to choose the equality semantics used by DISTINCT,
 * should she be working with a datatype that has more than one equality
 * operator.
 *
 * is_agg is true if we are transforming an aggregate(DISTINCT ...)
 * function call.  This does not affect any behavior, only the phrasing
 * of error messages.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>transformDistinctClause</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sortClause</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_agg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>slitem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>tlitem</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The distinctClause should consist of all ORDER BY items followed by all
	 * other non-resjunk targetlist items.  There must not be any resjunk
	 * ORDER BY items --- that would imply that we are sorting by a value that
	 * isn't necessarily unique within a DISTINCT group, so the results
	 * wouldn't be well-defined.  This construction ensures we follow the rule
	 * that sortClause and distinctClause match; in fact the sortClause will
	 * always be a prefix of distinctClause.
	 *
	 * Note a corner case: the same TLE could be in the ORDER BY list multiple
	 * times with different sortops.  We have to include it in the
	 * distinctClause the same way to preserve the prefix property. The net
	 * effect will be that the TLE value will be made unique according to both
	 * sortops.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>slitem</argument>, <argument>sortClause</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>scl</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>slitem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>get_sortgroupclause_tle</name><argument_list>(<argument><expr><name>scl</name></expr></argument>, <argument><expr><operator>*</operator><name>targetlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <ternary><condition><expr><name>is_agg</name></expr> ?</condition><then>
					 <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list"</literal></expr></argument>)</argument_list></call></expr> </then><else>:
					 <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"for SELECT DISTINCT, ORDER BY expressions must appear in select list"</literal></expr></argument>)</argument_list></call></expr></else></ternary><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										<argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>scl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Now add any remaining non-resjunk tlist items, using default sort/group
	 * semantics for their data types.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>tlitem</argument>, <argument>*targetlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>tlitem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* ignore junk */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>addTargetToGroupList</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>,
									  <argument><expr><name>result</name></expr></argument>, <argument><expr><operator>*</operator><name>targetlist</name></expr></argument>,
									  <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Complain if we found nothing to make DISTINCT.  Returning an empty list
	 * would cause the parsed Query to look like it didn't have DISTINCT, with
	 * results that would probably surprise the user.  Note: this case is
	 * presently impossible for aggregates because of grammar restrictions,
	 * but we check anyway.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <ternary><condition><expr><name>is_agg</name></expr> ?</condition><then>
				 <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"an aggregate with DISTINCT must have at least one argument"</literal></expr></argument>)</argument_list></call></expr> </then><else>:
				 <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SELECT DISTINCT must have at least one column"</literal></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformDistinctOnClause -
 *	  transform a DISTINCT ON clause
 *
 * Since we may need to add items to the query's targetlist, that list
 * is passed by reference.
 *
 * As with GROUP BY, we absorb the sorting semantics of ORDER BY as much as
 * possible into the distinctClause.  This avoids a possible need to re-sort,
 * and allows the user to choose the equality semantics used by DISTINCT,
 * should she be working with a datatype that has more than one equality
 * operator.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>transformDistinctOnClause</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>distinctlist</name></decl></parameter>,
						  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sortClause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sortgrouprefs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>skipped_sortitem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Add all the DISTINCT ON expressions to the tlist (if not already
	 * present, they are added as resjunk items).  Assign sortgroupref numbers
	 * to them, and make a list of these numbers.  (NB: we rely below on the
	 * sortgrouprefs list being one-for-one with the original distinctlist.
	 * Also notice that we could have duplicate DISTINCT ON expressions and
	 * hence duplicate entries in sortgrouprefs.)
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>distinctlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>dexpr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>sortgroupref</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>findTargetlistEntrySQL92</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>dexpr</name></expr></argument>, <argument><expr><name>targetlist</name></expr></argument>,
									   <argument><expr><name>EXPR_KIND_DISTINCT_ON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sortgroupref</name> <operator>=</operator> <call><name>assignSortGroupRef</name><argument_list>(<argument><expr><name>tle</name></expr></argument>, <argument><expr><operator>*</operator><name>targetlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sortgrouprefs</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>sortgrouprefs</name></expr></argument>, <argument><expr><name>sortgroupref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If the user writes both DISTINCT ON and ORDER BY, adopt the sorting
	 * semantics from ORDER BY items that match DISTINCT ON items, and also
	 * adopt their column sort order.  We insist that the distinctClause and
	 * sortClause match, so throw error if we find the need to add any more
	 * distinctClause items after we've skipped an ORDER BY item that wasn't
	 * in DISTINCT ON.
	 */</comment>
	<expr_stmt><expr><name>skipped_sortitem</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>sortClause</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>scl</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>list_member_int</name><argument_list>(<argument><expr><name>sortgrouprefs</name></expr></argument>, <argument><expr><name><name>scl</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>skipped_sortitem</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SELECT DISTINCT ON expressions must match initial ORDER BY expressions"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
											<argument><expr><call><name>get_matching_location</name><argument_list>(<argument><expr><name><name>scl</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr></argument>,
																  <argument><expr><name>sortgrouprefs</name></expr></argument>,
																  <argument><expr><name>distinctlist</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>scl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>skipped_sortitem</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Now add any remaining DISTINCT ON items, using default sort/group
	 * semantics for their data types.  (Note: this is pretty questionable; if
	 * the ORDER BY list doesn't include all the DISTINCT ON items and more
	 * besides, you certainly aren't using DISTINCT ON in the intended way,
	 * and you probably aren't going to get consistent results.  It might be
	 * better to throw an error or warning here.  But historically we've
	 * allowed it, so keep doing so.)
	 */</comment>
	<macro><name>forboth</name><argument_list>(<argument>lc</argument>, <argument>distinctlist</argument>, <argument>lc2</argument>, <argument>sortgrouprefs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>dexpr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>sortgroupref</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>get_sortgroupref_tle</name><argument_list>(<argument><expr><name>sortgroupref</name></expr></argument>, <argument><expr><operator>*</operator><name>targetlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>targetIsInSortList</name><argument_list>(<argument><expr><name>tle</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* already in list (with some semantics) */</comment>
		<if_stmt><if>if <condition>(<expr><name>skipped_sortitem</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SELECT DISTINCT ON expressions must match initial ORDER BY expressions"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>dexpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>addTargetToGroupList</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>,
									  <argument><expr><name>result</name></expr></argument>, <argument><expr><operator>*</operator><name>targetlist</name></expr></argument>,
									  <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>dexpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * An empty result list is impossible here because of grammar
	 * restrictions.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>result</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_matching_location
 *		Get the exprLocation of the exprs member corresponding to the
 *		(first) member of sortgrouprefs that equals sortgroupref.
 *
 * This is used so that we can point at a troublesome DISTINCT ON entry.
 * (Note that we need to use the original untransformed DISTINCT ON list
 * item, as whatever TLE it corresponds to will very possibly have a
 * parse location pointing to some matching entry in the SELECT list
 * or ORDER BY list.)
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_matching_location</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sortgroupref</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sortgrouprefs</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lce</name></decl>;</decl_stmt>

	<macro><name>forboth</name><argument_list>(<argument>lcs</argument>, <argument>sortgrouprefs</argument>, <argument>lce</argument>, <argument>exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lcs</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>sortgroupref</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lce</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
	<comment type="block">/* if no match, caller blew it */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"get_matching_location: no matching sortgroupref"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>					<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * resolve_unique_index_expr
 *		Infer a unique index from a list of indexElems, for ON
 *		CONFLICT clause
 *
 * Perform parse analysis of expressions and columns appearing within ON
 * CONFLICT clause.  During planning, the returned list of expressions is used
 * to infer which unique index to use.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>resolve_unique_index_expr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>InferClause</name> <modifier>*</modifier></type><name>infer</name></decl></parameter>,
						  <parameter><decl><type><name>Relation</name></type> <name>heapRel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>infer-&gt;indexElems</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexElem</name>  <modifier>*</modifier></type><name>ielem</name> <init>= <expr><operator>(</operator><name>IndexElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>InferenceElem</name> <modifier>*</modifier></type><name>pInfer</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>InferenceElem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>parse</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Raw grammar re-uses CREATE INDEX infrastructure for unique index
		 * inference clause, and so will accept opclasses by name and so on.
		 *
		 * Make no attempt to match ASC or DESC ordering or NULLS FIRST/NULLS
		 * LAST ordering, since those are not significant for inference
		 * purposes (any unique index matching the inference specification in
		 * other regards is accepted indifferently).  Actively reject this as
		 * wrong-headed.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>ielem</name><operator>-&gt;</operator><name>ordering</name></name> <operator>!=</operator> <name>SORTBY_DEFAULT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ASC/DESC is not allowed in ON CONFLICT clause"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										<argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>infer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>ielem</name><operator>-&gt;</operator><name>nulls_ordering</name></name> <operator>!=</operator> <name>SORTBY_NULLS_DEFAULT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"NULLS FIRST/LAST is not allowed in ON CONFLICT clause"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										<argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>infer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ielem</name><operator>-&gt;</operator><name>expr</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Simple index attribute */</comment>
			<decl_stmt><decl><type><name>ColumnRef</name>  <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Grammar won't have built raw expression for us in event of
			 * plain column reference.  Create one directly, and perform
			 * expression transformation.  Planner expects this, and performs
			 * its own normalization for the purposes of matching against
			 * pg_index.
			 */</comment>
			<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>fields</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>ielem</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Location is approximately that of inference specification */</comment>
			<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>infer</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>parse</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>n</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Do parse transformation of the raw expression */</comment>
			<expr_stmt><expr><name>parse</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>ielem</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * transformExpr() will reject subqueries, aggregates, window
		 * functions, and SRFs, based on being passed
		 * EXPR_KIND_INDEX_EXPRESSION.  So we needn't worry about those
		 * further ... not that they would match any available index
		 * expression anyway.
		 */</comment>
		<expr_stmt><expr><name><name>pInfer</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>, <argument><expr><name>EXPR_KIND_INDEX_EXPRESSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Perform lookup of collation and operator class as required */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ielem</name><operator>-&gt;</operator><name>collation</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pInfer</name><operator>-&gt;</operator><name>infercollid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pInfer</name><operator>-&gt;</operator><name>infercollid</name></name> <operator>=</operator> <call><name>LookupCollation</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>ielem</name><operator>-&gt;</operator><name>collation</name></name></expr></argument>,
												  <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name><name>pInfer</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ielem</name><operator>-&gt;</operator><name>opclass</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pInfer</name><operator>-&gt;</operator><name>inferopclass</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pInfer</name><operator>-&gt;</operator><name>inferopclass</name></name> <operator>=</operator> <call><name>get_opclass_oid</name><argument_list>(<argument><expr><ternary><condition><expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>LSM_AM_OID</name></expr> </then><else>: <expr><name>BTREE_AM_OID</name></expr></else></ternary></expr></argument>,
												   <argument><expr><name><name>ielem</name><operator>-&gt;</operator><name>opclass</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>pInfer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformOnConflictArbiter -
 *		transform arbiter expressions in an ON CONFLICT clause.
 *
 * Transformed expressions used to infer one unique index relation to serve as
 * an ON CONFLICT arbiter.  Partial unique indexes may be inferred using WHERE
 * clause from inference specification clause.
 */</comment>
<function><type><name>void</name></type>
<name>transformOnConflictArbiter</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
						   <parameter><decl><type><name>OnConflictClause</name> <modifier>*</modifier></type><name>onConflictClause</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>arbiterExpr</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type><name>arbiterWhere</name></decl></parameter>,
						   <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>constraint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>InferClause</name> <modifier>*</modifier></type><name>infer</name> <init>= <expr><name><name>onConflictClause</name><operator>-&gt;</operator><name>infer</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>arbiterExpr</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>arbiterWhere</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>constraint</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>onConflictClause</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>ONCONFLICT_UPDATE</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>infer</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ON CONFLICT DO UPDATE requires inference specification or constraint name"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"For example, ON CONFLICT (column_name)."</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
									<argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>onConflictClause</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>IsYsqlUpgrade</name> <operator>&amp;&amp;</operator>
		<call><name>IsYBRelation</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name><name>onConflictClause</name><operator>-&gt;</operator><name>action</name></name> <operator>!=</operator> <name>ONCONFLICT_NOTHING</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only ON CONFLICT DO NOTHING can be used in YSQL upgrade"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
									<argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>onConflictClause</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * To simplify certain aspects of its design, speculative insertion into
	 * system catalogs is disallowed
	 *
	 * For Yugabyte, however, there's no practical difference between system
	 * catalogs and user tables.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsYBRelation</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>IsCatalogRelation</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ON CONFLICT is not supported with system catalog tables"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
									<argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>onConflictClause</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Same applies to table used by logical decoding as catalog table */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationIsUsedAsCatalogTable</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ON CONFLICT is not supported on table \"%s\" used as a catalog table"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
									<argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>onConflictClause</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* ON CONFLICT DO NOTHING does not require an inference clause */</comment>
	<if_stmt><if>if <condition>(<expr><name>infer</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>save_namespace</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * While we process the arbiter expressions, accept only non-qualified
		 * references to the target table. Hide any other relations.
		 */</comment>
		<expr_stmt><expr><name>save_namespace</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>addRTEtoQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_rangetblentry</name></name></expr></argument>,
					  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>infer</name><operator>-&gt;</operator><name>indexElems</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>arbiterExpr</name> <operator>=</operator> <call><name>resolve_unique_index_expr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>infer</name></expr></argument>,
													 <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Handling inference WHERE clause (for partial unique index
		 * inference)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>infer</name><operator>-&gt;</operator><name>whereClause</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>arbiterWhere</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>infer</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>,
										  <argument><expr><name>EXPR_KIND_INDEX_PREDICATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name> <operator>=</operator> <name>save_namespace</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the arbiter is specified by constraint name, get the constraint
		 * OID and mark the constrained columns as requiring SELECT privilege,
		 * in the same way as would have happened if the arbiter had been
		 * specified by explicit reference to the constraint's index columns.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>infer</name><operator>-&gt;</operator><name>conname</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_rangetblentry</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>conattnos</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>conattnos</name> <operator>=</operator> <call><name>get_relation_constraint_attnos</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name></name></expr></argument>, <argument><expr><name><name>infer</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>,
													   <argument><expr><name>false</name></expr></argument>, <argument><expr><name>constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Make sure the rel as a whole is marked for SELECT access */</comment>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>|=</operator> <name>ACL_SELECT</name></expr>;</expr_stmt>
			<comment type="block">/* Mark the constrained columns as requiring SELECT access */</comment>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>selectedCols</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>selectedCols</name></name></expr></argument>, <argument><expr><name>conattnos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * It's convenient to form a list of expressions based on the
	 * representation used by CREATE INDEX, since the same restrictions are
	 * appropriate (e.g. on subqueries).  However, from here on, a dedicated
	 * primnode representation is used for inference elements, and so
	 * assign_query_collations() can be trusted to do the right thing with the
	 * post parse analysis query tree inference clause representation.
	 */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * addTargetToSortList
 *		If the given targetlist entry isn't already in the SortGroupClause
 *		list, add it to the end of the list, using the given sort ordering
 *		info.
 *
 * Returns the updated SortGroupClause list.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>addTargetToSortList</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl></parameter>,
					<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sortlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>, <parameter><decl><type><name>SortBy</name> <modifier>*</modifier></type><name>sortby</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>restype</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>sortop</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>eqop</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hashable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>reverse</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>location</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseCallbackState</name></type> <name>pcbstate</name></decl>;</decl_stmt>

	<comment type="block">/* if tlist item is an UNKNOWN literal, change it to TEXT */</comment>
	<if_stmt><if>if <condition>(<expr><name>restype</name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>coerce_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
										 <argument><expr><name>restype</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
										 <argument><expr><name>COERCION_IMPLICIT</name></expr></argument>,
										 <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
										 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>restype</name> <operator>=</operator> <name>TEXTOID</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Rather than clutter the API of get_sort_group_operators and the other
	 * functions we're about to use, make use of error context callback to
	 * mark any error reports with a parse position.  We point to the operator
	 * location if present, else to the expression being sorted.  (NB: use the
	 * original untransformed expression here; the TLE entry might well point
	 * at a duplicate expression in the regular SELECT list.)
	 */</comment>
	<expr_stmt><expr><name>location</name> <operator>=</operator> <name><name>sortby</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>location</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>location</name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><name><name>sortby</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>setup_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* determine the sortop, eqop, and directionality */</comment>
	<switch>switch <condition>(<expr><name><name>sortby</name><operator>-&gt;</operator><name>sortby_dir</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>SORTBY_DEFAULT</name></expr>:</case>
		<case>case <expr><name>SORTBY_ASC</name></expr>:</case>
			<expr_stmt><expr><call><name>get_sort_group_operators</name><argument_list>(<argument><expr><name>restype</name></expr></argument>,
									 <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>sortop</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eqop</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>hashable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>reverse</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SORTBY_DESC</name></expr>:</case>
			<expr_stmt><expr><call><name>get_sort_group_operators</name><argument_list>(<argument><expr><name>restype</name></expr></argument>,
									 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eqop</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sortop</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>hashable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>reverse</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SORTBY_USING</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sortby</name><operator>-&gt;</operator><name>useOp</name></name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sortop</name> <operator>=</operator> <call><name>compatible_oper_opid</name><argument_list>(<argument><expr><name><name>sortby</name><operator>-&gt;</operator><name>useOp</name></name></expr></argument>,
										  <argument><expr><name>restype</name></expr></argument>,
										  <argument><expr><name>restype</name></expr></argument>,
										  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Verify it's a valid ordering operator, fetch the corresponding
			 * equality operator, and determine whether to consider it like
			 * ASC or DESC.
			 */</comment>
			<expr_stmt><expr><name>eqop</name> <operator>=</operator> <call><name>get_equality_op_for_ordering_op</name><argument_list>(<argument><expr><name>sortop</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reverse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>eqop</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operator %s is not a valid ordering operator"</literal></expr></argument>,
								<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>llast</name><argument_list>(<argument><expr><name><name>sortby</name><operator>-&gt;</operator><name>useOp</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Ordering operators must be \"&lt;\" or \"&gt;\" members of btree operator families."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Also see if the equality operator is hashable.
			 */</comment>
			<expr_stmt><expr><name>hashable</name> <operator>=</operator> <call><name>op_hashjoinable</name><argument_list>(<argument><expr><name>eqop</name></expr></argument>, <argument><expr><name>restype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized sortby_dir: %d"</literal></expr></argument>, <argument><expr><name><name>sortby</name><operator>-&gt;</operator><name>sortby_dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sortop</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
			<expr_stmt><expr><name>eqop</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>hashable</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>reverse</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>cancel_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* avoid making duplicate sortlist entries */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>targetIsInSortList</name><argument_list>(<argument><expr><name>tle</name></expr></argument>, <argument><expr><name>sortop</name></expr></argument>, <argument><expr><name>sortlist</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sortcl</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>SortGroupClause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>sortcl</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name> <operator>=</operator> <call><name>assignSortGroupRef</name><argument_list>(<argument><expr><name>tle</name></expr></argument>, <argument><expr><name>targetlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>sortcl</name><operator>-&gt;</operator><name>eqop</name></name> <operator>=</operator> <name>eqop</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sortcl</name><operator>-&gt;</operator><name>sortop</name></name> <operator>=</operator> <name>sortop</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sortcl</name><operator>-&gt;</operator><name>hashable</name></name> <operator>=</operator> <name>hashable</name></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name><name>sortby</name><operator>-&gt;</operator><name>sortby_nulls</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>SORTBY_NULLS_DEFAULT</name></expr>:</case>
				<comment type="block">/* NULLS FIRST is default for DESC; other way for ASC */</comment>
				<expr_stmt><expr><name><name>sortcl</name><operator>-&gt;</operator><name>nulls_first</name></name> <operator>=</operator> <name>reverse</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>SORTBY_NULLS_FIRST</name></expr>:</case>
				<expr_stmt><expr><name><name>sortcl</name><operator>-&gt;</operator><name>nulls_first</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>SORTBY_NULLS_LAST</name></expr>:</case>
				<expr_stmt><expr><name><name>sortcl</name><operator>-&gt;</operator><name>nulls_first</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized sortby_nulls: %d"</literal></expr></argument>,
					 <argument><expr><name><name>sortby</name><operator>-&gt;</operator><name>sortby_nulls</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<expr_stmt><expr><name>sortlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>sortlist</name></expr></argument>, <argument><expr><name>sortcl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>sortlist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * addTargetToGroupList
 *		If the given targetlist entry isn't already in the SortGroupClause
 *		list, add it to the end of the list, using default sort/group
 *		semantics.
 *
 * This is very similar to addTargetToSortList, except that we allow the
 * case where only a grouping (equality) operator can be found, and that
 * the TLE is considered "already in the list" if it appears there with any
 * sorting semantics.
 *
 * location is the parse location to be fingered in event of trouble.  Note
 * that we can't rely on exprLocation(tle-&gt;expr), because that might point
 * to a SELECT item that matches the GROUP BY item; it'd be pretty confusing
 * to report such a location.
 *
 * Returns the updated SortGroupClause list.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>addTargetToGroupList</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>grouplist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>restype</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* if tlist item is an UNKNOWN literal, change it to TEXT */</comment>
	<if_stmt><if>if <condition>(<expr><name>restype</name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>coerce_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
										 <argument><expr><name>restype</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
										 <argument><expr><name>COERCION_IMPLICIT</name></expr></argument>,
										 <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
										 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>restype</name> <operator>=</operator> <name>TEXTOID</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* avoid making duplicate grouplist entries */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>targetIsInSortList</name><argument_list>(<argument><expr><name>tle</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>grouplist</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>grpcl</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>SortGroupClause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>sortop</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>eqop</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>hashable</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ParseCallbackState</name></type> <name>pcbstate</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>setup_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* determine the eqop and optional sortop */</comment>
		<expr_stmt><expr><call><name>get_sort_group_operators</name><argument_list>(<argument><expr><name>restype</name></expr></argument>,
								 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>sortop</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eqop</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>hashable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>cancel_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name> <operator>=</operator> <call><name>assignSortGroupRef</name><argument_list>(<argument><expr><name>tle</name></expr></argument>, <argument><expr><name>targetlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>eqop</name></name> <operator>=</operator> <name>eqop</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>sortop</name></name> <operator>=</operator> <name>sortop</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>nulls_first</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* OK with or without sortop */</comment>
		<expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>hashable</name></name> <operator>=</operator> <name>hashable</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>grouplist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>grouplist</name></expr></argument>, <argument><expr><name>grpcl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>grouplist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * assignSortGroupRef
 *	  Assign the targetentry an unused ressortgroupref, if it doesn't
 *	  already have one.  Return the assigned or pre-existing refnumber.
 *
 * 'tlist' is the targetlist containing (or to contain) the given targetentry.
 */</comment>
<function><type><name>Index</name></type>
<name>assignSortGroupRef</name><parameter_list>(<parameter><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Index</name></type>		<name>maxRef</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* already has one? */</comment>
		<return>return <expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* easiest way to pick an unused refnumber: max used + 1 */</comment>
	<expr_stmt><expr><name>maxRef</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>tlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Index</name></type>		<name>ref</name> <init>= <expr><operator>(</operator><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>ressortgroupref</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>ref</name> <operator>&gt;</operator> <name>maxRef</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>maxRef</name> <operator>=</operator> <name>ref</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>=</operator> <name>maxRef</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<return>return <expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * targetIsInSortList
 *		Is the given target item already in the sortlist?
 *		If sortop is not InvalidOid, also test for a match to the sortop.
 *
 * It is not an oversight that this function ignores the nulls_first flag.
 * We check sortop when determining if an ORDER BY item is redundant with
 * earlier ORDER BY items, because it's conceivable that "ORDER BY
 * foo USING &lt;, foo USING &lt;&lt;&lt;" is not redundant, if &lt;&lt;&lt; distinguishes
 * values that &lt; considers equal.  We need not check nulls_first
 * however, because a lower-order column with the same sortop but
 * opposite nulls direction is redundant.  Also, we can consider
 * ORDER BY foo ASC, foo DESC redundant, so check for a commutator match.
 *
 * Works for both ordering and grouping lists (sortop would normally be
 * InvalidOid when considering grouping).  Note that the main reason we need
 * this routine (and not just a quick test for nonzeroness of ressortgroupref)
 * is that a TLE might be in only one of the lists.
 */</comment>
<function><type><name>bool</name></type>
<name>targetIsInSortList</name><parameter_list>(<parameter><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>sortop</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sortList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Index</name></type>		<name>ref</name> <init>= <expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/* no need to scan list if tle has no marker */</comment>
	<if_stmt><if>if <condition>(<expr><name>ref</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>sortList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>scl</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>scl</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name> <operator>==</operator> <name>ref</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>sortop</name> <operator>==</operator> <name>InvalidOid</name> <operator>||</operator>
			 <name>sortop</name> <operator>==</operator> <name><name>scl</name><operator>-&gt;</operator><name>sortop</name></name> <operator>||</operator>
			 <name>sortop</name> <operator>==</operator> <call><name>get_commutator</name><argument_list>(<argument><expr><name><name>scl</name><operator>-&gt;</operator><name>sortop</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * findWindowClause
 *		Find the named WindowClause in the list, or return NULL if not there
 */</comment>
<function><type><specifier>static</specifier> <name>WindowClause</name> <modifier>*</modifier></type>
<name>findWindowClause</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>wclist</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>wclist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>wc</name> <init>= <expr><operator>(</operator><name>WindowClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>wc</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformFrameOffset
 *		Process a window frame offset expression
 *
 * In RANGE mode, rangeopfamily is the sort opfamily for the input ORDER BY
 * column, and rangeopcintype is the input data type the sort operator is
 * registered with.  We expect the in_range function to be registered with
 * that same type.  (In binary-compatible cases, it might be different from
 * the input column's actual type, so we can't use that for the lookups.)
 * We'll return the OID of the in_range function to *inRangeFunc.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformFrameOffset</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>frameOptions</name></decl></parameter>,
					 <parameter><decl><type><name>Oid</name></type> <name>rangeopfamily</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>rangeopcintype</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>inRangeFunc</name></decl></parameter>,
					 <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>constructName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>inRangeFunc</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>	<comment type="block">/* default result */</comment>

	<comment type="block">/* Quick exit if no offset expression */</comment>
	<if_stmt><if>if <condition>(<expr><name>clause</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_ROWS</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Transform the raw expression tree */</comment>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>, <argument><expr><name>EXPR_KIND_WINDOW_FRAME_ROWS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Like LIMIT clause, simply coerce to int8
		 */</comment>
		<expr_stmt><expr><name>constructName</name> <operator>=</operator> <literal type="string">"ROWS"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>coerce_to_specific_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><name>constructName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_RANGE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We must look up the in_range support function that's to be used,
		 * possibly choosing one of several, and coerce the "offset" value to
		 * the appropriate input type.
		 */</comment>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>nodeType</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>preferredType</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nfuncs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nmatches</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>selectedType</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>selectedFunc</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CatCList</name>   <modifier>*</modifier></type><name>proclist</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/* Transform the raw expression tree */</comment>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>, <argument><expr><name>EXPR_KIND_WINDOW_FRAME_RANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nodeType</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If there are multiple candidates, we'll prefer the one that exactly
		 * matches nodeType; or if nodeType is as yet unknown, prefer the one
		 * that exactly matches the sort column type.  (The second rule is
		 * like what we do for "known_type operator unknown".)
		 */</comment>
		<expr_stmt><expr><name>preferredType</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>nodeType</name> <operator>!=</operator> <name>UNKNOWNOID</name><operator>)</operator></expr> ?</condition><then> <expr><name>nodeType</name></expr> </then><else>: <expr><name>rangeopcintype</name></expr></else></ternary></expr>;</expr_stmt>

		<comment type="block">/* Find the in_range support functions applicable to this case */</comment>
		<expr_stmt><expr><name>proclist</name> <operator>=</operator> <call><name>SearchSysCacheList2</name><argument_list>(<argument><expr><name>AMPROCNUM</name></expr></argument>,
									   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>rangeopfamily</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>rangeopcintype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>proclist</name><operator>-&gt;</operator><name>n_members</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>proctup</name> <init>= <expr><operator>&amp;</operator><name><name>proclist</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>tuple</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_amproc</name></type> <name>procform</name> <init>= <expr><operator>(</operator><name>Form_pg_amproc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* The search will find all support proc types; ignore others */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>procform</name><operator>-&gt;</operator><name>amprocnum</name></name> <operator>!=</operator> <name>BTINRANGE_PROC</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>nfuncs</name><operator>++</operator></expr>;</expr_stmt>

			<comment type="block">/* Ignore function if given value can't be coerced to that type */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>can_coerce_type</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>nodeType</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>procform</name><operator>-&gt;</operator><name>amprocrighttype</name></name></expr></argument>,
								 <argument><expr><name>COERCION_IMPLICIT</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>nmatches</name><operator>++</operator></expr>;</expr_stmt>

			<comment type="block">/* Remember preferred match, or any match if didn't find that */</comment>
			<if_stmt><if>if <condition>(<expr><name>selectedType</name> <operator>!=</operator> <name>preferredType</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>selectedType</name> <operator>=</operator> <name><name>procform</name><operator>-&gt;</operator><name>amprocrighttype</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>selectedFunc</name> <operator>=</operator> <name><name>procform</name><operator>-&gt;</operator><name>amproc</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>ReleaseCatCacheList</name><argument_list>(<argument><expr><name>proclist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Throw error if needed.  It seems worth taking the trouble to
		 * distinguish "no support at all" from "you didn't match any
		 * available offset type".
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>nfuncs</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"RANGE with offset PRECEDING/FOLLOWING is not supported for column type %s"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>rangeopcintype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>nmatches</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"RANGE with offset PRECEDING/FOLLOWING is not supported for column type %s and offset type %s"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>rangeopcintype</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>nodeType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Cast the offset value to an appropriate type."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>nmatches</name> <operator>!=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>selectedType</name> <operator>!=</operator> <name>preferredType</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"RANGE with offset PRECEDING/FOLLOWING has multiple interpretations for column type %s and offset type %s"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>rangeopcintype</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>nodeType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Cast the offset value to the exact intended type."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* OK, coerce the offset to the right type */</comment>
		<expr_stmt><expr><name>constructName</name> <operator>=</operator> <literal type="string">"RANGE"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>coerce_to_specific_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
									   <argument><expr><name>selectedType</name></expr></argument>, <argument><expr><name>constructName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>inRangeFunc</name> <operator>=</operator> <name>selectedFunc</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_GROUPS</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Transform the raw expression tree */</comment>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>, <argument><expr><name>EXPR_KIND_WINDOW_FRAME_GROUPS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Like LIMIT clause, simply coerce to int8
		 */</comment>
		<expr_stmt><expr><name>constructName</name> <operator>=</operator> <literal type="string">"GROUPS"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>coerce_to_specific_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><name>constructName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Disallow variables in frame offsets */</comment>
	<expr_stmt><expr><call><name>checkExprIsVarFree</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>constructName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>
</unit>
