<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/parser/parse_relation.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * parse_relation.c
 *	  parser support routines dealing with relations
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/parser/parse_relation.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/heap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_enr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/varlena.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_yb_utils.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_FUZZY_DISTANCE</name></cpp:macro>				<cpp:value>3</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type><name>scanNameSpaceForRefname</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type><name>scanNameSpaceForRelid</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>check_lateral_ref_ok</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>markRTEForSelectPriv</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>rtindex</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>col</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>expandRelation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Alias</name> <modifier>*</modifier></type><name>eref</name></decl></parameter>,
			   <parameter><decl><type><name>int</name></type> <name>rtindex</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sublevels_up</name></decl></parameter>,
			   <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>include_dropped</name></decl></parameter>,
			   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>colnames</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>colvars</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>expandTupleDesc</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>Alias</name> <modifier>*</modifier></type><name>eref</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>rtindex</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sublevels_up</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>include_dropped</name></decl></parameter>,
				<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>colnames</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>colvars</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>specialAttNum</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>isQueryUsingTempRelation_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * refnameRangeTblEntry
 *	  Given a possibly-qualified refname, look to see if it matches any RTE.
 *	  If so, return a pointer to the RangeTblEntry; else return NULL.
 *
 *	  Optionally get RTE's nesting depth (0 = current) into *sublevels_up.
 *	  If sublevels_up is NULL, only consider items at the current nesting
 *	  level.
 *
 * An unqualified refname (schemaname == NULL) can match any RTE with matching
 * alias, or matching unqualified relname in the case of alias-less relation
 * RTEs.  It is possible that such a refname matches multiple RTEs in the
 * nearest nesting level that has a match; if so, we report an error via
 * ereport().
 *
 * A qualified refname (schemaname != NULL) can only match a relation RTE
 * that (a) has no alias and (b) is for the same relation identified by
 * schemaname.refname.  In this case we convert schemaname.refname to a
 * relation OID and search by relid, rather than by alias name.  This is
 * peculiar, but it's what SQL says to do.
 */</comment>
<function><type><name>RangeTblEntry</name> <modifier>*</modifier></type>
<name>refnameRangeTblEntry</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
					 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schemaname</name></decl></parameter>,
					 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>,
					 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>sublevels_up</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>sublevels_up</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>sublevels_up</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>schemaname</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We can use LookupNamespaceNoError() here because we are only
		 * interested in finding existing RTEs.  Checking USAGE permission on
		 * the schema is unnecessary since it would have already been checked
		 * when the RTE was made.  Furthermore, we want to report "RTE not
		 * found", not "no permissions for schema", if the name happens to
		 * match a schema name the user hasn't got access to.
		 */</comment>
		<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>LookupNamespaceNoError</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>relId</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><name>refname</name></expr></argument>, <argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><name>pstate</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>scanNameSpaceForRelid</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>relId</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>scanNameSpaceForRefname</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>refname</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>sublevels_up</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>sublevels_up</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<break>break;</break></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>pstate</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>parentParseState</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Search the query's table namespace for an RTE matching the
 * given unqualified refname.  Return the RTE if a unique match, or NULL
 * if no match.  Raise error if multiple matches.
 *
 * Note: it might seem that we shouldn't have to worry about the possibility
 * of multiple matches; after all, the SQL standard disallows duplicate table
 * aliases within a given SELECT level.  Historically, however, Postgres has
 * been laxer than that.  For example, we allow
 *		SELECT ... FROM tab1 x CROSS JOIN (tab2 x CROSS JOIN tab3 y) z
 * on the grounds that the aliased join (z) hides the aliases within it,
 * therefore there is no conflict between the two RTEs named "x".  However,
 * if tab3 is a LATERAL subquery, then from within the subquery both "x"es
 * are visible.  Rather than rejecting queries that used to work, we allow
 * this situation, and complain only if there's actually an ambiguous
 * reference to "x".
 */</comment>
<function><type><specifier>static</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type>
<name>scanNameSpaceForRefname</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>pstate-&gt;p_namespace</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name> <init>= <expr><operator>(</operator><name>ParseNamespaceItem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_rte</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Ignore columns-only items */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nsitem</name><operator>-&gt;</operator><name>p_rel_visible</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<comment type="block">/* If not inside LATERAL, ignore lateral-only items */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_lateral_only</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pstate</name><operator>-&gt;</operator><name>p_lateral_active</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>, <argument><expr><name>refname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_AMBIGUOUS_ALIAS</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table reference \"%s\" is ambiguous"</literal></expr></argument>,
								<argument><expr><name>refname</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>check_lateral_ref_ok</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>rte</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Search the query's table namespace for a relation RTE matching the
 * given relation OID.  Return the RTE if a unique match, or NULL
 * if no match.  Raise error if multiple matches.
 *
 * See the comments for refnameRangeTblEntry to understand why this
 * acts the way it does.
 */</comment>
<function><type><specifier>static</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type>
<name>scanNameSpaceForRelid</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>pstate-&gt;p_namespace</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name> <init>= <expr><operator>(</operator><name>ParseNamespaceItem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_rte</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Ignore columns-only items */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nsitem</name><operator>-&gt;</operator><name>p_rel_visible</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<comment type="block">/* If not inside LATERAL, ignore lateral-only items */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_lateral_only</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pstate</name><operator>-&gt;</operator><name>p_lateral_active</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* yes, the test for alias == NULL should be there... */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name> <operator>&amp;&amp;</operator>
			<name><name>rte</name><operator>-&gt;</operator><name>relid</name></name> <operator>==</operator> <name>relid</name> <operator>&amp;&amp;</operator>
			<name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_AMBIGUOUS_ALIAS</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table reference %u is ambiguous"</literal></expr></argument>,
								<argument><expr><name>relid</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>check_lateral_ref_ok</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>rte</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Search the query's CTE namespace for a CTE matching the given unqualified
 * refname.  Return the CTE (and its levelsup count) if a match, or NULL
 * if no match.  We need not worry about multiple matches, since parse_cte.c
 * rejects WITH lists containing duplicate CTE names.
 */</comment>
<function><type><name>CommonTableExpr</name> <modifier>*</modifier></type>
<name>scanNameSpaceForCTE</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl></parameter>,
					<parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>ctelevelsup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Index</name></type>		<name>levelsup</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>levelsup</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init>
		 <condition><expr><name>pstate</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
		 <incr><expr><name>pstate</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>parentParseState</name></name></expr><operator>,</operator> <expr><name>levelsup</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>pstate-&gt;p_ctenamespace</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name> <init>= <expr><operator>(</operator><name>CommonTableExpr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>, <argument><expr><name>refname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>ctelevelsup</name> <operator>=</operator> <name>levelsup</name></expr>;</expr_stmt>
				<return>return <expr><name>cte</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></for>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Search for a possible "future CTE", that is one that is not yet in scope
 * according to the WITH scoping rules.  This has nothing to do with valid
 * SQL semantics, but it's important for error reporting purposes.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>isFutureCTE</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<for>for <control>(<init>;</init> <condition><expr><name>pstate</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>pstate</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>parentParseState</name></name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>pstate-&gt;p_future_ctes</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name> <init>= <expr><operator>(</operator><name>CommonTableExpr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>, <argument><expr><name>refname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></for>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Search the query's ephemeral named relation namespace for a relation
 * matching the given unqualified refname.
 */</comment>
<function><type><name>bool</name></type>
<name>scanNameSpaceForENR</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>name_matches_visible_ENR</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * searchRangeTableForRel
 *	  See if any RangeTblEntry could possibly match the RangeVar.
 *	  If so, return a pointer to the RangeTblEntry; else return NULL.
 *
 * This is different from refnameRangeTblEntry in that it considers every
 * entry in the ParseState's rangetable(s), not only those that are currently
 * visible in the p_namespace list(s).  This behavior is invalid per the SQL
 * spec, and it may give ambiguous results (there might be multiple equally
 * valid matches, but only one will be returned).  This must be used ONLY
 * as a heuristic in giving suitable error messages.  See errorMissingRTE.
 *
 * Notice that we consider both matches on actual relation (or CTE) name
 * and matches on alias.
 */</comment>
<function><type><specifier>static</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type>
<name>searchRangeTableForRel</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name> <init>= <expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isenr</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>ctelevelsup</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>levelsup</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If it's an unqualified name, check for possible CTE matches. A CTE
	 * hides any real relation matches.  If no CTE, look for a matching
	 * relation.
	 *
	 * NB: It's not critical that RangeVarGetRelid return the correct answer
	 * here in the face of concurrent DDL.  If it doesn't, the worst case
	 * scenario is a less-clear error message.  Also, the tables involved in
	 * the query are already locked, which reduces the number of cases in
	 * which surprising behavior can occur.  So we do the name lookup
	 * unlocked.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>cte</name> <operator>=</operator> <call><name>scanNameSpaceForCTE</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>refname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctelevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cte</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>isenr</name> <operator>=</operator> <call><name>scanNameSpaceForENR</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cte</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isenr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>relId</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Now look for RTEs matching either the relation/CTE/ENR or the alias */</comment>
	<for>for <control>(<init><expr><name>levelsup</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init>
		 <condition><expr><name>pstate</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
		 <incr><expr><name>pstate</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>parentParseState</name></name></expr><operator>,</operator> <expr><name>levelsup</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>pstate-&gt;p_rtable</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name> <operator>&amp;&amp;</operator>
				<call><name>OidIsValid</name><argument_list>(<argument><expr><name>relId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<name><name>rte</name><operator>-&gt;</operator><name>relid</name></name> <operator>==</operator> <name>relId</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>rte</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_CTE</name> <operator>&amp;&amp;</operator>
				<name>cte</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				<name><name>rte</name><operator>-&gt;</operator><name>ctelevelsup</name></name> <operator>+</operator> <name>levelsup</name> <operator>==</operator> <name>ctelevelsup</name> <operator>&amp;&amp;</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>, <argument><expr><name>refname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>rte</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_NAMEDTUPLESTORE</name> <operator>&amp;&amp;</operator>
				<name>isenr</name> <operator>&amp;&amp;</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>enrname</name></name></expr></argument>, <argument><expr><name>refname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>rte</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>, <argument><expr><name>refname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>rte</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></for>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check for relation-name conflicts between two namespace lists.
 * Raise an error if any is found.
 *
 * Note: we assume that each given argument does not contain conflicts
 * itself; we just want to know if the two can be merged together.
 *
 * Per SQL, two alias-less plain relation RTEs do not conflict even if
 * they have the same eref-&gt;aliasname (ie, same relation name), if they
 * are for different relation OIDs (implying they are in different schemas).
 *
 * We ignore the lateral-only flags in the namespace items: the lists must
 * not conflict, even when all items are considered visible.  However,
 * columns-only items should be ignored.
 */</comment>
<function><type><name>void</name></type>
<name>checkNameSpaceConflicts</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>namespace1</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>namespace2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l1</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l1</argument>, <argument>namespace1</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem1</name> <init>= <expr><operator>(</operator><name>ParseNamespaceItem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte1</name> <init>= <expr><name><name>nsitem1</name><operator>-&gt;</operator><name>p_rte</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aliasname1</name> <init>= <expr><name><name>rte1</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l2</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nsitem1</name><operator>-&gt;</operator><name>p_rel_visible</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l2</argument>, <argument>namespace2</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem2</name> <init>= <expr><operator>(</operator><name>ParseNamespaceItem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte2</name> <init>= <expr><name><name>nsitem2</name><operator>-&gt;</operator><name>p_rte</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nsitem2</name><operator>-&gt;</operator><name>p_rel_visible</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>rte2</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>, <argument><expr><name>aliasname1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* definitely no conflict */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rte1</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name> <operator>&amp;&amp;</operator> <name><name>rte1</name><operator>-&gt;</operator><name>alias</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				<name><name>rte2</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name> <operator>&amp;&amp;</operator> <name><name>rte2</name><operator>-&gt;</operator><name>alias</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				<name><name>rte1</name><operator>-&gt;</operator><name>relid</name></name> <operator>!=</operator> <name><name>rte2</name><operator>-&gt;</operator><name>relid</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* no conflict per SQL rule */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_ALIAS</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table name \"%s\" specified more than once"</literal></expr></argument>,
							<argument><expr><name>aliasname1</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Complain if a namespace item is currently disallowed as a LATERAL reference.
 * This enforces both SQL:2008's rather odd idea of what to do with a LATERAL
 * reference to the wrong side of an outer join, and our own prohibition on
 * referencing the target table of an UPDATE or DELETE as a lateral reference
 * in a FROM/USING clause.
 *
 * Convenience subroutine to avoid multiple copies of a rather ugly ereport.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_lateral_ref_ok</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_lateral_only</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>nsitem</name><operator>-&gt;</operator><name>p_lateral_ok</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* SQL:2008 demands this be an error, not an invisible item */</comment>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_rte</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>refname</name> <init>= <expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid reference to FROM-clause entry for table \"%s\""</literal></expr></argument>,
						<argument><expr><name>refname</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <ternary><condition><expr><operator>(</operator><name>rte</name> <operator>==</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_target_rangetblentry</name></name><operator>)</operator></expr> ?</condition><then>
				 <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"There is an entry for table \"%s\", but it cannot be referenced from this part of the query."</literal></expr></argument>,
						 <argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr> </then><else>:
				 <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The combining JOIN type must be INNER or LEFT for a LATERAL reference."</literal></expr></argument>)</argument_list></call></expr></else></ternary><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * given an RTE, return RT index (starting with 1) of the entry,
 * and optionally get its nesting depth (0 = current).  If sublevels_up
 * is NULL, only consider rels at the current nesting level.
 * Raises error if RTE not found.
 */</comment>
<function><type><name>int</name></type>
<name>RTERangeTablePosn</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>sublevels_up</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>sublevels_up</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>sublevels_up</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><name>pstate</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>index</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>pstate-&gt;p_rtable</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>rte</name> <operator>==</operator> <operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>index</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>index</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><name>pstate</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>parentParseState</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>sublevels_up</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>sublevels_up</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<break>break;</break></block_content></block></else></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"RTE not found (internal error)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>					<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Given an RT index and nesting depth, find the corresponding RTE.
 * This is the inverse of RTERangeTablePosn.
 */</comment>
<function><type><name>RangeTblEntry</name> <modifier>*</modifier></type>
<name>GetRTEByRangeTablePosn</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>varno</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>sublevels_up</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<while>while <condition>(<expr><name>sublevels_up</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>pstate</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>parentParseState</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pstate</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>varno</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>varno</name> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name>varno</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch the CTE for a CTE-reference RTE.
 *
 * rtelevelsup is the number of query levels above the given pstate that the
 * RTE came from.  Callers that don't have this information readily available
 * may pass -1 instead.
 */</comment>
<function><type><name>CommonTableExpr</name> <modifier>*</modifier></type>
<name>GetCTEForRTE</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rtelevelsup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Index</name></type>		<name>levelsup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Determine RTE's levelsup if caller didn't know it */</comment>
	<if_stmt><if>if <condition>(<expr><name>rtelevelsup</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>RTERangeTablePosn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rtelevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_CTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>levelsup</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>ctelevelsup</name></name> <operator>+</operator> <name>rtelevelsup</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>levelsup</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>pstate</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>parentParseState</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pstate</name></expr>)</condition><block type="pseudo"><block_content>			<comment type="block">/* shouldn't happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bad levelsup for CTE \"%s\""</literal></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>pstate-&gt;p_ctenamespace</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name> <init>= <expr><operator>(</operator><name>CommonTableExpr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>cte</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
	<comment type="block">/* shouldn't happen */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find CTE \"%s\""</literal></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>				<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * updateFuzzyAttrMatchState
 *	  Using Levenshtein distance, consider if column is best fuzzy match.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>updateFuzzyAttrMatchState</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fuzzy_rte_penalty</name></decl></parameter>,
						  <parameter><decl><type><name>FuzzyAttrMatchState</name> <modifier>*</modifier></type><name>fuzzystate</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
						  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>actual</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>match</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>columndistance</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>matchlen</name></decl>;</decl_stmt>

	<comment type="block">/* Bail before computing the Levenshtein distance if there's no hope. */</comment>
	<if_stmt><if>if <condition>(<expr><name>fuzzy_rte_penalty</name> <operator>&gt;</operator> <name><name>fuzzystate</name><operator>-&gt;</operator><name>distance</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Outright reject dropped columns, which can appear here with apparent
	 * empty actual names, per remarks within scanRTEForColumn().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>actual</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Use Levenshtein to compute match distance. */</comment>
	<expr_stmt><expr><name>matchlen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>columndistance</name> <operator>=</operator>
		<call><name>varstr_levenshtein_less_equal</name><argument_list>(<argument><expr><name>actual</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>actual</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name>matchlen</name></expr></argument>,
									  <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
									  <argument><expr><name><name>fuzzystate</name><operator>-&gt;</operator><name>distance</name></name> <operator>+</operator> <literal type="number">1</literal>
									  <operator>-</operator> <name>fuzzy_rte_penalty</name></expr></argument>,
									  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If more than half the characters are different, don't treat it as a
	 * match, to avoid making ridiculous suggestions.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>columndistance</name> <operator>&gt;</operator> <name>matchlen</name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * From this point on, we can ignore the distinction between the RTE-name
	 * distance and the column-name distance.
	 */</comment>
	<expr_stmt><expr><name>columndistance</name> <operator>+=</operator> <name>fuzzy_rte_penalty</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the new distance is less than or equal to that of the best match
	 * found so far, update fuzzystate.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>columndistance</name> <operator>&lt;</operator> <name><name>fuzzystate</name><operator>-&gt;</operator><name>distance</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Store new lowest observed distance for RTE */</comment>
		<expr_stmt><expr><name><name>fuzzystate</name><operator>-&gt;</operator><name>distance</name></name> <operator>=</operator> <name>columndistance</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fuzzystate</name><operator>-&gt;</operator><name>rfirst</name></name> <operator>=</operator> <name>rte</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fuzzystate</name><operator>-&gt;</operator><name>first</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fuzzystate</name><operator>-&gt;</operator><name>rsecond</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fuzzystate</name><operator>-&gt;</operator><name>second</name></name> <operator>=</operator> <name>InvalidAttrNumber</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>columndistance</name> <operator>==</operator> <name><name>fuzzystate</name><operator>-&gt;</operator><name>distance</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * This match distance may equal a prior match within this same range
		 * table.  When that happens, the prior match may also be given, but
		 * only if there is no more than two equally distant matches from the
		 * RTE (in turn, our caller will only accept two equally distant
		 * matches overall).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>fuzzystate</name><operator>-&gt;</operator><name>second</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Too many RTE-level matches */</comment>
			<expr_stmt><expr><name><name>fuzzystate</name><operator>-&gt;</operator><name>rfirst</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fuzzystate</name><operator>-&gt;</operator><name>first</name></name> <operator>=</operator> <name>InvalidAttrNumber</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fuzzystate</name><operator>-&gt;</operator><name>rsecond</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fuzzystate</name><operator>-&gt;</operator><name>second</name></name> <operator>=</operator> <name>InvalidAttrNumber</name></expr>;</expr_stmt>
			<comment type="block">/* Clearly, distance is too low a bar (for *any* RTE) */</comment>
			<expr_stmt><expr><name><name>fuzzystate</name><operator>-&gt;</operator><name>distance</name></name> <operator>=</operator> <name>columndistance</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>fuzzystate</name><operator>-&gt;</operator><name>first</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Record as provisional second match for RTE */</comment>
			<expr_stmt><expr><name><name>fuzzystate</name><operator>-&gt;</operator><name>rsecond</name></name> <operator>=</operator> <name>rte</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fuzzystate</name><operator>-&gt;</operator><name>second</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>fuzzystate</name><operator>-&gt;</operator><name>distance</name></name> <operator>&lt;=</operator> <name>MAX_FUZZY_DISTANCE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Record as provisional first match (this can occasionally occur
			 * because previous lowest distance was "too low a bar", rather
			 * than being associated with a real match)
			 */</comment>
			<expr_stmt><expr><name><name>fuzzystate</name><operator>-&gt;</operator><name>rfirst</name></name> <operator>=</operator> <name>rte</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fuzzystate</name><operator>-&gt;</operator><name>first</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * scanRTEForColumn
 *	  Search the column names of a single RTE for the given name.
 *	  If found, return an appropriate Var node, else return NULL.
 *	  If the name proves ambiguous within this RTE, raise error.
 *
 * Side effect: if we find a match, mark the RTE as requiring read access
 * for the column.
 *
 * Additional side effect: if fuzzystate is non-NULL, check non-system columns
 * for an approximate match and update fuzzystate accordingly.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>scanRTEForColumn</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>,
				 <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fuzzy_rte_penalty</name></decl></parameter>,
				 <parameter><decl><type><name>FuzzyAttrMatchState</name> <modifier>*</modifier></type><name>fuzzystate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Scan the user column names (or aliases) for a match. Complain if
	 * multiple matches.
	 *
	 * Note: eref-&gt;colnames may include entries for dropped columns, but those
	 * will be empty strings that cannot match any legal SQL identifier, so we
	 * don't bother to test for that case here.
	 *
	 * Should this somehow go wrong and we try to access a dropped column,
	 * we'll still catch it by virtue of the checks in
	 * get_rte_attribute_type(), which is called by make_var().  That routine
	 * has to do a cache lookup anyway, so the check there is cheap.  Callers
	 * interested in finding match with shortest distance need to defend
	 * against this directly, though.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>c</argument>, <argument>rte-&gt;eref-&gt;colnames</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attcolname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>attnum</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>attcolname</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_AMBIGUOUS_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column reference \"%s\" is ambiguous"</literal></expr></argument>,
								<argument><expr><name>colname</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>make_var</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Require read access to the column */</comment>
			<expr_stmt><expr><call><name>markVarForSelectPriv</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>var</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Updating fuzzy match state, if provided. */</comment>
		<if_stmt><if>if <condition>(<expr><name>fuzzystate</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>updateFuzzyAttrMatchState</name><argument_list>(<argument><expr><name>fuzzy_rte_penalty</name></expr></argument>, <argument><expr><name>fuzzystate</name></expr></argument>,
									  <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>attcolname</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If we have a unique match, return it.  Note that this allows a user
	 * alias to override a system column name (such as OID) without error.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the RTE represents a real relation, consider system column names.
	 * Composites are only used for pseudo-relations like ON CONFLICT's
	 * excluded.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name> <operator>&amp;&amp;</operator>
		<name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* quick check to see if name could be a system column */</comment>
		<expr_stmt><expr><name>attnum</name> <operator>=</operator> <call><name>specialAttNum</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* In constraint check, no system column is allowed except tableOid */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>==</operator> <name>EXPR_KIND_CHECK_CONSTRAINT</name> <operator>&amp;&amp;</operator>
			<name>attnum</name> <operator>&lt;</operator> <name>InvalidAttrNumber</name> <operator>&amp;&amp;</operator> <name>attnum</name> <operator>!=</operator> <name>TableOidAttributeNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"system column \"%s\" reference in check constraint is invalid"</literal></expr></argument>,
							<argument><expr><name>colname</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>!=</operator> <name>InvalidAttrNumber</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* now check to see if column actually is defined */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>SearchSysCacheExists2</name><argument_list>(<argument><expr><name>ATTNUM</name></expr></argument>,
									  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>make_var</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Require read access to the column */</comment>
				<expr_stmt><expr><call><name>markVarForSelectPriv</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>IsYBRelationById</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>YbCheckUnsupportedSystemColumns</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>var</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * colNameToVar
 *	  Search for an unqualified column name.
 *	  If found, return the appropriate Var node (or expression).
 *	  If not found, return NULL.  If the name proves ambiguous, raise error.
 *	  If localonly is true, only names in the innermost query are considered.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>colNameToVar</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>localonly</name></decl></parameter>,
			 <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>orig_pstate</name> <init>= <expr><name>pstate</name></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>pstate</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>pstate-&gt;p_namespace</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name> <init>= <expr><operator>(</operator><name>ParseNamespaceItem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_rte</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>newresult</name></decl>;</decl_stmt>

			<comment type="block">/* Ignore table-only items */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nsitem</name><operator>-&gt;</operator><name>p_cols_visible</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<comment type="block">/* If not inside LATERAL, ignore lateral-only items */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_lateral_only</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pstate</name><operator>-&gt;</operator><name>p_lateral_active</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* use orig_pstate here to get the right sublevels_up */</comment>
			<expr_stmt><expr><name>newresult</name> <operator>=</operator> <call><name>scanRTEForColumn</name><argument_list>(<argument><expr><name>orig_pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>, <argument><expr><name>location</name></expr></argument>,
										 <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>newresult</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_AMBIGUOUS_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column reference \"%s\" is ambiguous"</literal></expr></argument>,
									<argument><expr><name>colname</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>check_lateral_ref_ok</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>newresult</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name>localonly</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>				<comment type="block">/* found, or don't want to look at parent */</comment>

		<expr_stmt><expr><name>pstate</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>parentParseState</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * searchRangeTableForCol
 *	  See if any RangeTblEntry could possibly provide the given column name (or
 *	  find the best match available).  Returns state with relevant details.
 *
 * This is different from colNameToVar in that it considers every entry in
 * the ParseState's rangetable(s), not only those that are currently visible
 * in the p_namespace list(s).  This behavior is invalid per the SQL spec,
 * and it may give ambiguous results (there might be multiple equally valid
 * matches, but only one will be returned).  This must be used ONLY as a
 * heuristic in giving suitable error messages.  See errorMissingColumn.
 *
 * This function is also different in that it will consider approximate
 * matches -- if the user entered an alias/column pair that is only slightly
 * different from a valid pair, we may be able to infer what they meant to
 * type and provide a reasonable hint.
 *
 * The FuzzyAttrMatchState will have 'rfirst' pointing to the best RTE
 * containing the most promising match for the alias and column name.  If
 * the alias and column names match exactly, 'first' will be InvalidAttrNumber;
 * otherwise, it will be the attribute number for the match.  In the latter
 * case, 'rsecond' may point to a second, equally close approximate match,
 * and 'second' will contain the attribute number for the second match.
 */</comment>
<function><type><specifier>static</specifier> <name>FuzzyAttrMatchState</name> <modifier>*</modifier></type>
<name>searchRangeTableForCol</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>orig_pstate</name> <init>= <expr><name>pstate</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuzzyAttrMatchState</name> <modifier>*</modifier></type><name>fuzzystate</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FuzzyAttrMatchState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>fuzzystate</name><operator>-&gt;</operator><name>distance</name></name> <operator>=</operator> <name>MAX_FUZZY_DISTANCE</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fuzzystate</name><operator>-&gt;</operator><name>rfirst</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fuzzystate</name><operator>-&gt;</operator><name>rsecond</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fuzzystate</name><operator>-&gt;</operator><name>first</name></name> <operator>=</operator> <name>InvalidAttrNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fuzzystate</name><operator>-&gt;</operator><name>second</name></name> <operator>=</operator> <name>InvalidAttrNumber</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>pstate</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>pstate-&gt;p_rtable</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>fuzzy_rte_penalty</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Typically, it is not useful to look for matches within join
			 * RTEs; they effectively duplicate other RTEs for our purposes,
			 * and if a match is chosen from a join RTE, an unhelpful alias is
			 * displayed in the final diagnostic message.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_JOIN</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * If the user didn't specify an alias, then matches against one
			 * RTE are as good as another.  But if the user did specify an
			 * alias, then we want at least a fuzzy - and preferably an exact
			 * - match for the range table entry.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>alias</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>fuzzy_rte_penalty</name> <operator>=</operator>
					<call><name>varstr_levenshtein_less_equal</name><argument_list>(<argument><expr><name>alias</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>,
												  <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
												  <argument><expr><name>MAX_FUZZY_DISTANCE</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
												  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Scan for a matching column; if we find an exact match, we're
			 * done.  Otherwise, update fuzzystate.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>scanRTEForColumn</name><argument_list>(<argument><expr><name>orig_pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>, <argument><expr><name>location</name></expr></argument>,
								 <argument><expr><name>fuzzy_rte_penalty</name></expr></argument>, <argument><expr><name>fuzzystate</name></expr></argument>)</argument_list></call>
				<operator>&amp;&amp;</operator> <name>fuzzy_rte_penalty</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>fuzzystate</name><operator>-&gt;</operator><name>rfirst</name></name> <operator>=</operator> <name>rte</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>fuzzystate</name><operator>-&gt;</operator><name>first</name></name> <operator>=</operator> <name>InvalidAttrNumber</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>fuzzystate</name><operator>-&gt;</operator><name>rsecond</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>fuzzystate</name><operator>-&gt;</operator><name>second</name></name> <operator>=</operator> <name>InvalidAttrNumber</name></expr>;</expr_stmt>
				<return>return <expr><name>fuzzystate</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<expr_stmt><expr><name>pstate</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>parentParseState</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>fuzzystate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * markRTEForSelectPriv
 *	   Mark the specified column of an RTE as requiring SELECT privilege
 *
 * col == InvalidAttrNumber means a "whole row" reference
 *
 * The caller should pass the actual RTE if it has it handy; otherwise pass
 * NULL, and we'll look it up here.  (This uglification of the API is
 * worthwhile because nearly all external callers have the RTE at hand.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>markRTEForSelectPriv</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>rtindex</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>col</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>rte</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Make sure the rel as a whole is marked for SELECT access */</comment>
		<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>|=</operator> <name>ACL_SELECT</name></expr>;</expr_stmt>
		<comment type="block">/* Must offset the attnum to fit in a bitmapset */</comment>
		<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>selectedCols</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>selectedCols</name></name></expr></argument>,
												<argument><expr><name>col</name> <operator>-</operator> <call><name>YBGetFirstLowInvalidAttributeNumberFromOid</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_JOIN</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>col</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * A whole-row reference to a join has to be treated as whole-row
			 * references to the two inputs.
			 */</comment>
			<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>j</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>rtindex</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rtindex</name> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinexprs</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>j</name> <operator>=</operator> <call><name>list_nth_node</name><argument_list>(<argument><expr><name>JoinExpr</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinexprs</name></name></expr></argument>, <argument><expr><name>rtindex</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>j</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find JoinExpr for whole-row reference"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Note: we can't see FromExpr here */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>varno</name> <init>= <expr><operator>(</operator><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name><name>j</name><operator>-&gt;</operator><name>larg</name></name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>markRTEForSelectPriv</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>varno</name></expr></argument>, <argument><expr><name>InvalidAttrNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>varno</name> <init>= <expr><operator>(</operator><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name><name>j</name><operator>-&gt;</operator><name>larg</name></name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>markRTEForSelectPriv</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>varno</name></expr></argument>, <argument><expr><name>InvalidAttrNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>varno</name> <init>= <expr><operator>(</operator><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name><name>j</name><operator>-&gt;</operator><name>rarg</name></name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>markRTEForSelectPriv</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>varno</name></expr></argument>, <argument><expr><name>InvalidAttrNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>varno</name> <init>= <expr><operator>(</operator><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name><name>j</name><operator>-&gt;</operator><name>rarg</name></name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>markRTEForSelectPriv</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>varno</name></expr></argument>, <argument><expr><name>InvalidAttrNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Regular join attribute, look at the alias-variable list.
			 *
			 * The aliasvar could be either a Var or a COALESCE expression,
			 * but in the latter case we should already have marked the two
			 * referent variables as being selected, due to their use in the
			 * JOIN clause.  So we need only be concerned with the Var case.
			 * But we do need to drill down through implicit coercions.
			 */</comment>
			<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>aliasvar</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>col</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>col</name> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>joinaliasvars</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>aliasvar</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>joinaliasvars</name></name></expr></argument>, <argument><expr><name>col</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>aliasvar</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>strip_implicit_coercions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>aliasvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>aliasvar</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>aliasvar</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>markVarForSelectPriv</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>aliasvar</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* other RTE types don't require privilege marking */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * markVarForSelectPriv
 *	   Mark the RTE referenced by a Var as requiring SELECT privilege
 *
 * The caller should pass the Var's referenced RTE if it has it handy
 * (nearly all do); otherwise pass NULL.
 */</comment>
<function><type><name>void</name></type>
<name>markVarForSelectPriv</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Index</name></type>		<name>lv</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Find the appropriate pstate if it's an uplevel Var */</comment>
	<for>for <control>(<init><expr><name>lv</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>lv</name> <operator>&lt;</operator> <name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name></expr>;</condition> <incr><expr><name>lv</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>pstate</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>parentParseState</name></name></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>markRTEForSelectPriv</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * buildRelationAliases
 *		Construct the eref column name list for a relation RTE.
 *		This code is also used for function RTEs.
 *
 * tupdesc: the physical column information
 * alias: the user-supplied alias, or NULL if none
 * eref: the eref Alias to store column names in
 *
 * eref-&gt;colnames is filled in.  Also, alias-&gt;colnames is rebuilt to insert
 * empty strings for any dropped columns, so that it will be one-to-one with
 * physical column numbers.
 *
 * It is an error for there to be more aliases present than required.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>buildRelationAliases</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>Alias</name> <modifier>*</modifier></type><name>alias</name></decl></parameter>, <parameter><decl><type><name>Alias</name> <modifier>*</modifier></type><name>eref</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxattrs</name> <init>= <expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>aliaslc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numaliases</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>varattno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numdropped</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>eref</name><operator>-&gt;</operator><name>colnames</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>alias</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>aliaslc</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>alias</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>numaliases</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>alias</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* We'll rebuild the alias colname list */</comment>
		<expr_stmt><expr><name><name>alias</name><operator>-&gt;</operator><name>colnames</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>aliaslc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>numaliases</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<for>for <control>(<init><expr><name>varattno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>varattno</name> <operator>&lt;</operator> <name>maxattrs</name></expr>;</condition> <incr><expr><name>varattno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>varattno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Value</name>	   <modifier>*</modifier></type><name>attrname</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Always insert an empty string for a dropped column */</comment>
			<expr_stmt><expr><name>attrname</name> <operator>=</operator> <call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>aliaslc</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>alias</name><operator>-&gt;</operator><name>colnames</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>alias</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>, <argument><expr><name>attrname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>numdropped</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>aliaslc</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Use the next user-supplied alias */</comment>
			<expr_stmt><expr><name>attrname</name> <operator>=</operator> <operator>(</operator><name>Value</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>aliaslc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>aliaslc</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>aliaslc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>alias</name><operator>-&gt;</operator><name>colnames</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>alias</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>, <argument><expr><name>attrname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>attrname</name> <operator>=</operator> <call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* we're done with the alias if any */</comment>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>eref</name><operator>-&gt;</operator><name>colnames</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>, <argument><expr><name>attrname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Too many user-supplied aliases? */</comment>
	<if_stmt><if>if <condition>(<expr><name>aliaslc</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" has %d columns available but %d columns specified"</literal></expr></argument>,
						<argument><expr><name><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>, <argument><expr><name>maxattrs</name> <operator>-</operator> <name>numdropped</name></expr></argument>, <argument><expr><name>numaliases</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * chooseScalarFunctionAlias
 *		Select the column alias for a function in a function RTE,
 *		when the function returns a scalar type (not composite or RECORD).
 *
 * funcexpr: transformed expression tree for the function call
 * funcname: function name (as determined by FigureColname)
 * alias: the user-supplied alias for the RTE, or NULL if none
 * nfuncs: the number of functions appearing in the function RTE
 *
 * Note that the name we choose might be overridden later, if the user-given
 * alias includes column alias names.  That's of no concern here.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>chooseScalarFunctionAlias</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>funcexpr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>,
						  <parameter><decl><type><name>Alias</name> <modifier>*</modifier></type><name>alias</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nfuncs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pname</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the expression is a simple function call, and the function has a
	 * single OUT parameter that is named, use the parameter's name.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>funcexpr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>funcexpr</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>pname</name> <operator>=</operator> <call><name>get_func_result_name</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>funcexpr</name><operator>)</operator><operator>-&gt;</operator><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>pname</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>pname</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If there's just one function in the RTE, and the user gave an RTE alias
	 * name, use that name.  (This makes FROM func() AS foo use "foo" as the
	 * column name as well as the table alias.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nfuncs</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>alias</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>alias</name><operator>-&gt;</operator><name>aliasname</name></name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise use the function name.
	 */</comment>
	<return>return <expr><name>funcname</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Open a table during parse analysis
 *
 * This is essentially just the same as heap_openrv(), except that it caters
 * to some parser-specific error reporting needs, notably that it arranges
 * to include the RangeVar's parse location in any resulting error.
 *
 * Note: properly, lockmode should be declared LOCKMODE not int, but that
 * would require importing storage/lock.h into parse_relation.h.  Since
 * LOCKMODE is typedef'd as int anyway, that seems like overkill.
 */</comment>
<function><type><name>Relation</name></type>
<name>parserOpenTable</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseCallbackState</name></type> <name>pcbstate</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>setup_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_openrv_extended</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rel</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s.%s\" does not exist"</literal></expr></argument>,
							<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>, <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * An unqualified name might have been meant as a reference to
			 * some not-yet-in-scope CTE.  The bare "does not exist" message
			 * has proven remarkably unhelpful for figuring out such problems,
			 * so we take pains to offer a specific hint.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>isFutureCTE</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" does not exist"</literal></expr></argument>,
								<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"There is a WITH item named \"%s\", but it cannot be referenced from this part of the query."</literal></expr></argument>,
								   <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use WITH RECURSIVE, or re-order the WITH items to remove forward references."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" does not exist"</literal></expr></argument>,
								<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>cancel_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add an entry for a relation to the pstate's range table (p_rtable).
 *
 * Note: formerly this checked for refname conflicts, but that's wrong.
 * Caller is responsible for checking for conflicts in the appropriate scope.
 */</comment>
<function><type><name>RangeTblEntry</name> <modifier>*</modifier></type>
<name>addRangeTableEntry</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
				   <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl></parameter>,
				   <parameter><decl><type><name>Alias</name> <modifier>*</modifier></type><name>alias</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>inh</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>inFromCl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>refname</name> <init>= <expr><ternary><condition><expr><name>alias</name></expr> ?</condition><then> <expr><name><name>alias</name><operator>-&gt;</operator><name>aliasname</name></name></expr> </then><else>: <expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>lockmode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pstate</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_RELATION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <name>alias</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get the rel's OID.  This access also ensures that we have an up-to-date
	 * relcache entry for the rel.  Since this is typically the first access
	 * to a rel in a statement, be careful to get the right access level
	 * depending on whether we're doing SELECT FOR UPDATE/SHARE.
	 */</comment>
	<expr_stmt><expr><name>lockmode</name> <operator>=</operator> <ternary><condition><expr><call><name>isLockedRefname</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>RowShareLock</name></expr> </then><else>: <expr><name>AccessShareLock</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>parserOpenTable</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build the list of effective column names using user-supplied aliases
	 * and/or actual column names.
	 */</comment>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name></name> <operator>=</operator> <call><name>makeAlias</name><argument_list>(<argument><expr><name>refname</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>buildRelationAliases</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>alias</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Drop the rel refcount, but keep the access lock till end of transaction
	 * so that the table can't be deleted or have its schema modified
	 * underneath us.
	 */</comment>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set flags and access permissions.
	 *
	 * The initial default on access checks is always check-for-READ-access,
	 * which is the right thing for all except target tables.
	 */</comment>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>lateral</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>inh</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inFromCl</name></name> <operator>=</operator> <name>inFromCl</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <name>ACL_SELECT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>checkAsUser</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>	<comment type="block">/* not set-uid by default, either */</comment>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>selectedCols</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>insertedCols</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>updatedCols</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Add completed RTE to pstate's range table list, but not to join list
	 * nor namespace --- caller must do that if appropriate.
	 */</comment>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rte</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add an entry for a relation to the pstate's range table (p_rtable).
 *
 * This is just like addRangeTableEntry() except that it makes an RTE
 * given an already-open relation instead of a RangeVar reference.
 */</comment>
<function><type><name>RangeTblEntry</name> <modifier>*</modifier></type>
<name>addRangeTableEntryForRelation</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
							  <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
							  <parameter><decl><type><name>Alias</name> <modifier>*</modifier></type><name>alias</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name></type> <name>inh</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name></type> <name>inFromCl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>refname</name> <init>= <expr><ternary><condition><expr><name>alias</name></expr> ?</condition><then> <expr><name><name>alias</name><operator>-&gt;</operator><name>aliasname</name></name></expr> </then><else>: <expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pstate</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_RELATION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <name>alias</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build the list of effective column names using user-supplied aliases
	 * and/or actual column names.
	 */</comment>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name></name> <operator>=</operator> <call><name>makeAlias</name><argument_list>(<argument><expr><name>refname</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>buildRelationAliases</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>alias</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set flags and access permissions.
	 *
	 * The initial default on access checks is always check-for-READ-access,
	 * which is the right thing for all except target tables.
	 */</comment>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>lateral</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>inh</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inFromCl</name></name> <operator>=</operator> <name>inFromCl</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <name>ACL_SELECT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>checkAsUser</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>	<comment type="block">/* not set-uid by default, either */</comment>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>selectedCols</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>insertedCols</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>updatedCols</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Add completed RTE to pstate's range table list, but not to join list
	 * nor namespace --- caller must do that if appropriate.
	 */</comment>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rte</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add an entry for a subquery to the pstate's range table (p_rtable).
 *
 * This is just like addRangeTableEntry() except that it makes a subquery RTE.
 * Note that an alias clause *must* be supplied.
 */</comment>
<function><type><name>RangeTblEntry</name> <modifier>*</modifier></type>
<name>addRangeTableEntryForSubquery</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
							  <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name></decl></parameter>,
							  <parameter><decl><type><name>Alias</name> <modifier>*</modifier></type><name>alias</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name></type> <name>lateral</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name></type> <name>inFromCl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>refname</name> <init>= <expr><name><name>alias</name><operator>-&gt;</operator><name>aliasname</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Alias</name>	   <modifier>*</modifier></type><name>eref</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numaliases</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>varattno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>tlistitem</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pstate</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_SUBQUERY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <name>subquery</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <name>alias</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>eref</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>numaliases</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* fill in any unspecified alias columns */</comment>
	<expr_stmt><expr><name>varattno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>tlistitem</argument>, <argument>subquery-&gt;targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>tlistitem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>te</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>varattno</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>varattno</name> <operator>==</operator> <name><name>te</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>varattno</name> <operator>&gt;</operator> <name>numaliases</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attrname</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>attrname</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>eref</name><operator>-&gt;</operator><name>colnames</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>attrname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<if_stmt><if>if <condition>(<expr><name>varattno</name> <operator>&lt;</operator> <name>numaliases</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" has %d columns available but %d columns specified"</literal></expr></argument>,
						<argument><expr><name>refname</name></expr></argument>, <argument><expr><name>varattno</name></expr></argument>, <argument><expr><name>numaliases</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name></name> <operator>=</operator> <name>eref</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set flags and access permissions.
	 *
	 * Subqueries are never checked for access rights.
	 */</comment>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>lateral</name></name> <operator>=</operator> <name>lateral</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>			<comment type="block">/* never true for subqueries */</comment>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inFromCl</name></name> <operator>=</operator> <name>inFromCl</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>checkAsUser</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>selectedCols</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>insertedCols</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>updatedCols</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Add completed RTE to pstate's range table list, but not to join list
	 * nor namespace --- caller must do that if appropriate.
	 */</comment>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rte</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add an entry for a function (or functions) to the pstate's range table
 * (p_rtable).
 *
 * This is just like addRangeTableEntry() except that it makes a function RTE.
 */</comment>
<function><type><name>RangeTblEntry</name> <modifier>*</modifier></type>
<name>addRangeTableEntryForFunction</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
							  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>funcnames</name></decl></parameter>,
							  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>funcexprs</name></decl></parameter>,
							  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>coldeflists</name></decl></parameter>,
							  <parameter><decl><type><name>RangeFunction</name> <modifier>*</modifier></type><name>rangefunc</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name></type> <name>lateral</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name></type> <name>inFromCl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Alias</name>	   <modifier>*</modifier></type><name>alias</name> <init>= <expr><name><name>rangefunc</name><operator>-&gt;</operator><name>alias</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Alias</name>	   <modifier>*</modifier></type><name>eref</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>aliasname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nfuncs</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>funcexprs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name>  <modifier>*</modifier></type><name>functupdescs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>lc2</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>lc3</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>funcno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>natts</name></decl>,
				<decl><type ref="prev"/><name>totalatts</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pstate</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_FUNCTION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>functions</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>		<comment type="block">/* we'll fill this list below */</comment>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>funcordinality</name></name> <operator>=</operator> <name><name>rangefunc</name><operator>-&gt;</operator><name>ordinality</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <name>alias</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Choose the RTE alias name.  We default to using the first function's
	 * name even when there's more than one; which is maybe arguable but beats
	 * using something constant like "table".
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>alias</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>aliasname</name> <operator>=</operator> <name><name>alias</name><operator>-&gt;</operator><name>aliasname</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>aliasname</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>funcnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>eref</name> <operator>=</operator> <call><name>makeAlias</name><argument_list>(<argument><expr><name>aliasname</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name></name> <operator>=</operator> <name>eref</name></expr>;</expr_stmt>

	<comment type="block">/* Process each function ... */</comment>
	<expr_stmt><expr><name>functupdescs</name> <operator>=</operator> <operator>(</operator><name>TupleDesc</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nfuncs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TupleDesc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>totalatts</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>funcno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>forthree</name><argument_list>(<argument>lc1</argument>, <argument>funcexprs</argument>, <argument>lc2</argument>, <argument>funcnames</argument>, <argument>lc3</argument>, <argument>coldeflists</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>funcexpr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>funcname</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>coldeflist</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc3</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rtfunc</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblFunction</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TypeFuncClass</name></type> <name>functypclass</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>funcrettype</name></decl>;</decl_stmt>

		<comment type="block">/* Initialize RangeTblFunction node */</comment>
		<expr_stmt><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name> <operator>=</operator> <name>funcexpr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funccolnames</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funccoltypes</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funccoltypmods</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funccolcollations</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funcparams</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* not set until planning */</comment>

		<comment type="block">/*
		 * Now determine if the function returns a simple or composite type.
		 */</comment>
		<expr_stmt><expr><name>functypclass</name> <operator>=</operator> <call><name>get_expr_result_type</name><argument_list>(<argument><expr><name>funcexpr</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>funcrettype</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * A coldeflist is required if the function returns RECORD and hasn't
		 * got a predetermined record type, and is prohibited otherwise.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>coldeflist</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>functypclass</name> <operator>!=</operator> <name>TYPEFUNC_RECORD</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"a column definition list is only allowed for functions returning \"record\""</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
											<argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>coldeflist</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>functypclass</name> <operator>==</operator> <name>TYPEFUNC_RECORD</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"a column definition list is required for functions returning \"record\""</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>funcexpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>functypclass</name> <operator>==</operator> <name>TYPEFUNC_COMPOSITE</name> <operator>||</operator>
			<name>functypclass</name> <operator>==</operator> <name>TYPEFUNC_COMPOSITE_DOMAIN</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Composite data type, e.g. a table's row type */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>functypclass</name> <operator>==</operator> <name>TYPEFUNC_SCALAR</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Base data type, i.e. scalar */</comment>
			<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>,
							   <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>,
							   <argument><expr><call><name>chooseScalarFunctionAlias</name><argument_list>(<argument><expr><name>funcexpr</name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>,
														 <argument><expr><name>alias</name></expr></argument>, <argument><expr><name>nfuncs</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name>funcrettype</name></expr></argument>,
							   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
							   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>functypclass</name> <operator>==</operator> <name>TYPEFUNC_RECORD</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>col</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Use the column definition list to construct a tupdesc and fill
			 * in the RangeTblFunction's lists.
			 */</comment>
			<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>coldeflist</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>col</argument>, <argument>coldeflist</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>n</name> <init>= <expr><operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>col</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attrname</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>attrtype</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int32</name></type>		<name>attrtypmod</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>attrcollation</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>attrname</name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>colname</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>setof</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" cannot be declared SETOF"</literal></expr></argument>,
									<argument><expr><name>attrname</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>typenameTypeIdAndMod</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>attrtype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attrtypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>attrcollation</name> <operator>=</operator> <call><name>GetColumnDefCollation</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>attrtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name>i</name></expr></argument>,
								   <argument><expr><name>attrname</name></expr></argument>,
								   <argument><expr><name>attrtype</name></expr></argument>,
								   <argument><expr><name>attrtypmod</name></expr></argument>,
								   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>TupleDescInitEntryCollation</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>,
											<argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name>i</name></expr></argument>,
											<argument><expr><name>attrcollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funccolnames</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funccolnames</name></name></expr></argument>,
											   <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>attrname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funccoltypes</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funccoltypes</name></name></expr></argument>,
												   <argument><expr><name>attrtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funccoltypmods</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funccoltypmods</name></name></expr></argument>,
													 <argument><expr><name>attrtypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funccolcollations</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funccolcollations</name></name></expr></argument>,
														<argument><expr><name>attrcollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block>

			<comment type="block">/*
			 * Ensure that the coldeflist defines a legal set of names (no
			 * duplicates) and datatypes (no pseudo-types, for instance).
			 */</comment>
			<expr_stmt><expr><call><name>CheckAttributeNamesTypes</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>RELKIND_COMPOSITE_TYPE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function \"%s\" in FROM has unsupported return type %s"</literal></expr></argument>,
							<argument><expr><name>funcname</name></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>funcrettype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>funcexpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Finish off the RangeTblFunction and add it to the RTE's list */</comment>
		<expr_stmt><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funccolcount</name></name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>functions</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>, <argument><expr><name>rtfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Save the tupdesc for use below */</comment>
		<expr_stmt><expr><name><name>functupdescs</name><index>[<expr><name>funcno</name></expr>]</index></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>totalatts</name> <operator>+=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>funcno</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If there's more than one function, or we want an ordinality column, we
	 * have to produce a merged tupdesc.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nfuncs</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>rangefunc</name><operator>-&gt;</operator><name>ordinality</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>rangefunc</name><operator>-&gt;</operator><name>ordinality</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>totalatts</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Merge the tuple descs of each function into a composite one */</comment>
		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>totalatts</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>natts</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nfuncs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <name><name>functupdescs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>natts</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>TupleDescCopyEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>++</operator><name>natts</name></expr></argument>, <argument><expr><name><name>functupdescs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		</block_content>}</block></for>

		<comment type="block">/* Add the ordinality column if needed */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rangefunc</name><operator>-&gt;</operator><name>ordinality</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>,
							   <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <operator>++</operator><name>natts</name></expr></argument>,
							   <argument><expr><literal type="string">"ordinality"</literal></expr></argument>,
							   <argument><expr><name>INT8OID</name></expr></argument>,
							   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
							   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>natts</name> <operator>==</operator> <name>totalatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* We can just use the single function's tupdesc as-is */</comment>
		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <name><name>functupdescs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Use the tupdesc while assigning column aliases for the RTE */</comment>
	<expr_stmt><expr><call><name>buildRelationAliases</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>, <argument><expr><name>eref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set flags and access permissions.
	 *
	 * Functions are never checked for access rights (at least, not by the RTE
	 * permissions mechanism).
	 */</comment>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>lateral</name></name> <operator>=</operator> <name>lateral</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>			<comment type="block">/* never true for functions */</comment>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inFromCl</name></name> <operator>=</operator> <name>inFromCl</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>checkAsUser</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>selectedCols</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>insertedCols</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>updatedCols</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Add completed RTE to pstate's range table list, but not to join list
	 * nor namespace --- caller must do that if appropriate.
	 */</comment>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rte</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add an entry for a table function to the pstate's range table (p_rtable).
 *
 * This is much like addRangeTableEntry() except that it makes a tablefunc RTE.
 */</comment>
<function><type><name>RangeTblEntry</name> <modifier>*</modifier></type>
<name>addRangeTableEntryForTableFunc</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
							   <parameter><decl><type><name>TableFunc</name> <modifier>*</modifier></type><name>tf</name></decl></parameter>,
							   <parameter><decl><type><name>Alias</name> <modifier>*</modifier></type><name>alias</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name></type> <name>lateral</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name></type> <name>inFromCl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>refname</name> <init>= <expr><ternary><condition><expr><name>alias</name></expr> ?</condition><then> <expr><name><name>alias</name><operator>-&gt;</operator><name>aliasname</name></name></expr> </then><else>: <expr><call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"xmltable"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Alias</name>	   <modifier>*</modifier></type><name>eref</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numaliases</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pstate</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_TABLEFUNC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>tablefunc</name></name> <operator>=</operator> <name>tf</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>coltypes</name></name> <operator>=</operator> <name><name>tf</name><operator>-&gt;</operator><name>coltypes</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>coltypmods</name></name> <operator>=</operator> <name><name>tf</name><operator>-&gt;</operator><name>coltypmods</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>colcollations</name></name> <operator>=</operator> <name><name>tf</name><operator>-&gt;</operator><name>colcollations</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <name>alias</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>eref</name> <operator>=</operator> <ternary><condition><expr><name>alias</name></expr> ?</condition><then> <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>makeAlias</name><argument_list>(<argument><expr><name>refname</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>numaliases</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* fill in any unspecified alias columns */</comment>
	<if_stmt><if>if <condition>(<expr><name>numaliases</name> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>tf</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>eref</name><operator>-&gt;</operator><name>colnames</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>,
									 <argument><expr><call><name>list_copy_tail</name><argument_list>(<argument><expr><name><name>tf</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>, <argument><expr><name>numaliases</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name></name> <operator>=</operator> <name>eref</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set flags and access permissions.
	 *
	 * Tablefuncs are never checked for access rights (at least, not by the
	 * RTE permissions mechanism).
	 */</comment>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>lateral</name></name> <operator>=</operator> <name>lateral</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>			<comment type="block">/* never true for tablefunc RTEs */</comment>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inFromCl</name></name> <operator>=</operator> <name>inFromCl</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>checkAsUser</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>selectedCols</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>insertedCols</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>updatedCols</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Add completed RTE to pstate's range table list, but not to join list
	 * nor namespace --- caller must do that if appropriate.
	 */</comment>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rte</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add an entry for a VALUES list to the pstate's range table (p_rtable).
 *
 * This is much like addRangeTableEntry() except that it makes a values RTE.
 */</comment>
<function><type><name>RangeTblEntry</name> <modifier>*</modifier></type>
<name>addRangeTableEntryForValues</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
							<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprs</name></decl></parameter>,
							<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>coltypes</name></decl></parameter>,
							<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>coltypmods</name></decl></parameter>,
							<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colcollations</name></decl></parameter>,
							<parameter><decl><type><name>Alias</name> <modifier>*</modifier></type><name>alias</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>lateral</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>inFromCl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>refname</name> <init>= <expr><ternary><condition><expr><name>alias</name></expr> ?</condition><then> <expr><name><name>alias</name><operator>-&gt;</operator><name>aliasname</name></name></expr> </then><else>: <expr><call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"*VALUES*"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Alias</name>	   <modifier>*</modifier></type><name>eref</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numaliases</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numcolumns</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pstate</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_VALUES</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>values_lists</name></name> <operator>=</operator> <name>exprs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>coltypes</name></name> <operator>=</operator> <name>coltypes</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>coltypmods</name></name> <operator>=</operator> <name>coltypmods</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>colcollations</name></name> <operator>=</operator> <name>colcollations</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <name>alias</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>eref</name> <operator>=</operator> <ternary><condition><expr><name>alias</name></expr> ?</condition><then> <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>makeAlias</name><argument_list>(<argument><expr><name>refname</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* fill in any unspecified alias columns */</comment>
	<expr_stmt><expr><name>numcolumns</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>exprs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>numaliases</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>numaliases</name> <operator>&lt;</operator> <name>numcolumns</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>attrname</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><name>numaliases</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>attrname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>attrname</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"column%d"</literal></expr></argument>, <argument><expr><name>numaliases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>eref</name><operator>-&gt;</operator><name>colnames</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>,
								 <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>attrname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if <condition>(<expr><name>numcolumns</name> <operator>&lt;</operator> <name>numaliases</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"VALUES lists \"%s\" have %d columns available but %d columns specified"</literal></expr></argument>,
						<argument><expr><name>refname</name></expr></argument>, <argument><expr><name>numcolumns</name></expr></argument>, <argument><expr><name>numaliases</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name></name> <operator>=</operator> <name>eref</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set flags and access permissions.
	 *
	 * Subqueries are never checked for access rights.
	 */</comment>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>lateral</name></name> <operator>=</operator> <name>lateral</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>			<comment type="block">/* never true for values RTEs */</comment>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inFromCl</name></name> <operator>=</operator> <name>inFromCl</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>checkAsUser</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>selectedCols</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>insertedCols</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>updatedCols</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Add completed RTE to pstate's range table list, but not to join list
	 * nor namespace --- caller must do that if appropriate.
	 */</comment>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rte</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add an entry for a join to the pstate's range table (p_rtable).
 *
 * This is much like addRangeTableEntry() except that it makes a join RTE.
 */</comment>
<function><type><name>RangeTblEntry</name> <modifier>*</modifier></type>
<name>addRangeTableEntryForJoin</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
						  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colnames</name></decl></parameter>,
						  <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
						  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>aliasvars</name></decl></parameter>,
						  <parameter><decl><type><name>Alias</name> <modifier>*</modifier></type><name>alias</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name></type> <name>inFromCl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Alias</name>	   <modifier>*</modifier></type><name>eref</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numaliases</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pstate</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fail if join has too many columns --- we must be able to reference any
	 * of the columns with an AttrNumber.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>aliasvars</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>MaxAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"joins can have at most %d columns"</literal></expr></argument>,
						<argument><expr><name>MaxAttrNumber</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_JOIN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>jointype</name></name> <operator>=</operator> <name>jointype</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>joinaliasvars</name></name> <operator>=</operator> <name>aliasvars</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <name>alias</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>eref</name> <operator>=</operator> <ternary><condition><expr><name>alias</name></expr> ?</condition><then> <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"unnamed_join"</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>numaliases</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* fill in any unspecified alias columns */</comment>
	<if_stmt><if>if <condition>(<expr><name>numaliases</name> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>colnames</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>eref</name><operator>-&gt;</operator><name>colnames</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>,
									 <argument><expr><call><name>list_copy_tail</name><argument_list>(<argument><expr><name>colnames</name></expr></argument>, <argument><expr><name>numaliases</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name></name> <operator>=</operator> <name>eref</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set flags and access permissions.
	 *
	 * Joins are never checked for access rights.
	 */</comment>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>lateral</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>			<comment type="block">/* never true for joins */</comment>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inFromCl</name></name> <operator>=</operator> <name>inFromCl</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>checkAsUser</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>selectedCols</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>insertedCols</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>updatedCols</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Add completed RTE to pstate's range table list, but not to join list
	 * nor namespace --- caller must do that if appropriate.
	 */</comment>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rte</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add an entry for a CTE reference to the pstate's range table (p_rtable).
 *
 * This is much like addRangeTableEntry() except that it makes a CTE RTE.
 */</comment>
<function><type><name>RangeTblEntry</name> <modifier>*</modifier></type>
<name>addRangeTableEntryForCTE</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
						 <parameter><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name></decl></parameter>,
						 <parameter><decl><type><name>Index</name></type> <name>levelsup</name></decl></parameter>,
						 <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>rv</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>inFromCl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Alias</name>	   <modifier>*</modifier></type><name>alias</name> <init>= <expr><name><name>rv</name><operator>-&gt;</operator><name>alias</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>refname</name> <init>= <expr><ternary><condition><expr><name>alias</name></expr> ?</condition><then> <expr><name><name>alias</name><operator>-&gt;</operator><name>aliasname</name></name></expr> </then><else>: <expr><name><name>cte</name><operator>-&gt;</operator><name>ctename</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Alias</name>	   <modifier>*</modifier></type><name>eref</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numaliases</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>varattno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pstate</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_CTE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name> <operator>=</operator> <name><name>cte</name><operator>-&gt;</operator><name>ctename</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>ctelevelsup</name></name> <operator>=</operator> <name>levelsup</name></expr>;</expr_stmt>

	<comment type="block">/* Self-reference if and only if CTE's parse analysis isn't completed */</comment>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>self_reference</name></name> <operator>=</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctequery</name></name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cte</name><operator>-&gt;</operator><name>cterecursive</name></name> <operator>||</operator> <operator>!</operator><name><name>rte</name><operator>-&gt;</operator><name>self_reference</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Bump the CTE's refcount if this isn't a self-reference */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rte</name><operator>-&gt;</operator><name>self_reference</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>cte</name><operator>-&gt;</operator><name>cterefcount</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We throw error if the CTE is INSERT/UPDATE/DELETE without RETURNING.
	 * This won't get checked in case of a self-reference, but that's OK
	 * because data-modifying CTEs aren't allowed to be recursive anyhow.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctequery</name></name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>ctequery</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>cte</name><operator>-&gt;</operator><name>ctequery</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>ctequery</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name> <operator>&amp;&amp;</operator>
			<name><name>ctequery</name><operator>-&gt;</operator><name>returningList</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"WITH query \"%s\" does not have a RETURNING clause"</literal></expr></argument>,
							<argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>coltypes</name></name> <operator>=</operator> <name><name>cte</name><operator>-&gt;</operator><name>ctecoltypes</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>coltypmods</name></name> <operator>=</operator> <name><name>cte</name><operator>-&gt;</operator><name>ctecoltypmods</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>colcollations</name></name> <operator>=</operator> <name><name>cte</name><operator>-&gt;</operator><name>ctecolcollations</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <name>alias</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>alias</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>eref</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>eref</name> <operator>=</operator> <call><name>makeAlias</name><argument_list>(<argument><expr><name>refname</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>numaliases</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* fill in any unspecified alias columns */</comment>
	<expr_stmt><expr><name>varattno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>cte-&gt;ctecolnames</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>varattno</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>varattno</name> <operator>&gt;</operator> <name>numaliases</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>eref</name><operator>-&gt;</operator><name>colnames</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	<if_stmt><if>if <condition>(<expr><name>varattno</name> <operator>&lt;</operator> <name>numaliases</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" has %d columns available but %d columns specified"</literal></expr></argument>,
						<argument><expr><name>refname</name></expr></argument>, <argument><expr><name>varattno</name></expr></argument>, <argument><expr><name>numaliases</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name></name> <operator>=</operator> <name>eref</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set flags and access permissions.
	 *
	 * Subqueries are never checked for access rights.
	 */</comment>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>lateral</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>			<comment type="block">/* never true for subqueries */</comment>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inFromCl</name></name> <operator>=</operator> <name>inFromCl</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>checkAsUser</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>selectedCols</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>insertedCols</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>updatedCols</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Add completed RTE to pstate's range table list, but not to join list
	 * nor namespace --- caller must do that if appropriate.
	 */</comment>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rte</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add an entry for an ephemeral named relation reference to the pstate's
 * range table (p_rtable).
 *
 * It is expected that the RangeVar, which up until now is only known to be an
 * ephemeral named relation, will (in conjunction with the QueryEnvironment in
 * the ParseState), create a RangeTblEntry for a specific *kind* of ephemeral
 * named relation, based on enrtype.
 *
 * This is much like addRangeTableEntry() except that it makes an RTE for an
 * ephemeral named relation.
 */</comment>
<function><type><name>RangeTblEntry</name> <modifier>*</modifier></type>
<name>addRangeTableEntryForENR</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
						 <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>rv</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>inFromCl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Alias</name>	   <modifier>*</modifier></type><name>alias</name> <init>= <expr><name><name>rv</name><operator>-&gt;</operator><name>alias</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>refname</name> <init>= <expr><ternary><condition><expr><name>alias</name></expr> ?</condition><then> <expr><name><name>alias</name><operator>-&gt;</operator><name>aliasname</name></name></expr> </then><else>: <expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EphemeralNamedRelationMetadata</name></type> <name>enrmd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attno</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pstate</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>enrmd</name> <operator>=</operator> <call><name>get_visible_ENR</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>enrmd</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>enrmd</name><operator>-&gt;</operator><name>enrtype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>ENR_NAMED_TUPLESTORE</name></expr>:</case>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_NAMEDTUPLESTORE</name></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected enrtype: %d"</literal></expr></argument>, <argument><expr><name><name>enrmd</name><operator>-&gt;</operator><name>enrtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>		<comment type="block">/* for fussy compilers */</comment>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Record dependency on a relation.  This allows plans to be invalidated
	 * if they access transition tables linked to a table that is altered.
	 */</comment>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name><name>enrmd</name><operator>-&gt;</operator><name>reliddesc</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build the list of effective column names using user-supplied aliases
	 * and/or actual column names.
	 */</comment>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>ENRMetadataGetTupDesc</name><argument_list>(<argument><expr><name>enrmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name></name> <operator>=</operator> <call><name>makeAlias</name><argument_list>(<argument><expr><name>refname</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>buildRelationAliases</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Record additional data for ENR, including column type info */</comment>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>enrname</name></name> <operator>=</operator> <name><name>enrmd</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>enrtuples</name></name> <operator>=</operator> <name><name>enrmd</name><operator>-&gt;</operator><name>enrtuples</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>coltypes</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>coltypmods</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>colcollations</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>attno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>attno</name> <operator>&lt;=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>attno</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Record zeroes for a dropped column */</comment>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>coltypes</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>coltypes</name></name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>coltypmods</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>coltypmods</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>colcollations</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>colcollations</name></name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Let's just make sure we can tell this isn't dropped */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"atttypid is invalid for non-dropped column in \"%s\""</literal></expr></argument>,
					 <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>coltypes</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>coltypes</name></name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>coltypmods</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>coltypmods</name></name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>colcollations</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>colcollations</name></name></expr></argument>,
											 <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Set flags and access permissions.
	 *
	 * ENRs are never checked for access rights.
	 */</comment>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>lateral</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>			<comment type="block">/* never true for ENRs */</comment>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inFromCl</name></name> <operator>=</operator> <name>inFromCl</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>checkAsUser</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>selectedCols</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Add completed RTE to pstate's range table list, but not to join list
	 * nor namespace --- caller must do that if appropriate.
	 */</comment>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rte</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Has the specified refname been selected FOR UPDATE/FOR SHARE?
 *
 * This is used when we have not yet done transformLockingClause, but need
 * to know the correct lock to take during initial opening of relations.
 *
 * Note: we pay no attention to whether it's FOR UPDATE vs FOR SHARE,
 * since the table-level lock is the same either way.
 */</comment>
<function><type><name>bool</name></type>
<name>isLockedRefname</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If we are in a subquery specified as locked FOR UPDATE/SHARE from
	 * parent level, then act as though there's a generic FOR UPDATE here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_locked_from_parent</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>pstate-&gt;p_locking_clause</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LockingClause</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><operator>(</operator><name>LockingClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>lc</name><operator>-&gt;</operator><name>lockedRels</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* all tables used in query */</comment>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* just the named tables */</comment>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l2</name></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>l2</argument>, <argument>lc-&gt;lockedRels</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>thisrel</name> <init>= <expr><operator>(</operator><name>RangeVar</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>refname</name></expr></argument>, <argument><expr><name><name>thisrel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add the given RTE as a top-level entry in the pstate's join list
 * and/or namespace list.  (We assume caller has checked for any
 * namespace conflicts.)  The RTE is always marked as unconditionally
 * visible, that is, not LATERAL-only.
 *
 * Note: some callers know that they can find the new ParseNamespaceItem
 * at the end of the pstate-&gt;p_namespace list.  This is a bit ugly but not
 * worth complicating this function's signature for.
 */</comment>
<function><type><name>void</name></type>
<name>addRTEtoQuery</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
			  <parameter><decl><type><name>bool</name></type> <name>addToJoinList</name></decl></parameter>,
			  <parameter><decl><type><name>bool</name></type> <name>addToRelNameSpace</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>addToVarNameSpace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>addToJoinList</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>rtindex</name> <init>= <expr><call><name>RTERangeTablePosn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <name>rtindex</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>rtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>addToRelNameSpace</name> <operator>||</operator> <name>addToVarNameSpace</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <operator>(</operator><name>ParseNamespaceItem</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ParseNamespaceItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_rte</name></name> <operator>=</operator> <name>rte</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_rel_visible</name></name> <operator>=</operator> <name>addToRelNameSpace</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_cols_visible</name></name> <operator>=</operator> <name>addToVarNameSpace</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_lateral_only</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_lateral_ok</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * expandRTE -- expand the columns of a rangetable entry
 *
 * This creates lists of an RTE's column names (aliases if provided, else
 * real names) and Vars for each column.  Only user columns are considered.
 * If include_dropped is false then dropped columns are omitted from the
 * results.  If include_dropped is true then empty strings and NULL constants
 * (not Vars!) are returned for dropped columns.
 *
 * rtindex, sublevels_up, and location are the varno, varlevelsup, and location
 * values to use in the created Vars.  Ordinarily rtindex should match the
 * actual position of the RTE in its rangetable.
 *
 * The output lists go into *colnames and *colvars.
 * If only one of the two kinds of output list is needed, pass NULL for the
 * output pointer for the unwanted one.
 */</comment>
<function><type><name>void</name></type>
<name>expandRTE</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rtindex</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sublevels_up</name></decl></parameter>,
		  <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>include_dropped</name></decl></parameter>,
		  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>colnames</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>colvars</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>varattno</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>colnames</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>colnames</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>colvars</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>colvars</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RTE_RELATION</name></expr>:</case>
			<comment type="block">/* Ordinary relation RTE */</comment>
			<expr_stmt><expr><call><name>expandRelation</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name></name></expr></argument>,
						   <argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name>sublevels_up</name></expr></argument>, <argument><expr><name>location</name></expr></argument>,
						   <argument><expr><name>include_dropped</name></expr></argument>, <argument><expr><name>colnames</name></expr></argument>, <argument><expr><name>colvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RTE_SUBQUERY</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/* Subquery RTE */</comment>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>aliasp_item</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>tlistitem</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>varattno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>tlistitem</argument>, <argument>rte-&gt;subquery-&gt;targetList</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>tlistitem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>te</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>varattno</name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>varattno</name> <operator>==</operator> <name><name>te</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * In scenarios where columns have been added to a view
					 * since the outer query was originally parsed, there can
					 * be more items in the subquery tlist than the outer
					 * query expects.  We should ignore such extra column(s)
					 * --- compare the behavior for composite-returning
					 * functions, in the RTE_FUNCTION case below.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>aliasp_item</name></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name>colnames</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>label</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>aliasp_item</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><operator>*</operator><name>colnames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>colnames</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>label</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name>colvars</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>varnode</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>varnode</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name>varattno</name></expr></argument>,
										  <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>sublevels_up</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>varnode</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>

						<expr_stmt><expr><operator>*</operator><name>colvars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>colvars</name></expr></argument>, <argument><expr><name>varnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><name>aliasp_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>aliasp_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>RTE_FUNCTION</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/* Function RTE */</comment>
				<decl_stmt><decl><type><name>int</name></type>			<name>atts_done</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rte-&gt;functions</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rtfunc</name> <init>= <expr><operator>(</operator><name>RangeTblFunction</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>TypeFuncClass</name></type> <name>functypclass</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>funcrettype</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>functypclass</name> <operator>=</operator> <call><name>get_expr_result_type</name><argument_list>(<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></argument>,
														<argument><expr><operator>&amp;</operator><name>funcrettype</name></expr></argument>,
														<argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>functypclass</name> <operator>==</operator> <name>TYPEFUNC_COMPOSITE</name> <operator>||</operator>
						<name>functypclass</name> <operator>==</operator> <name>TYPEFUNC_COMPOSITE_DOMAIN</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* Composite data type, e.g. a table's row type */</comment>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>expandTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name></name></expr></argument>,
										<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funccolcount</name></name></expr></argument>, <argument><expr><name>atts_done</name></expr></argument>,
										<argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name>sublevels_up</name></expr></argument>, <argument><expr><name>location</name></expr></argument>,
										<argument><expr><name>include_dropped</name></expr></argument>, <argument><expr><name>colnames</name></expr></argument>, <argument><expr><name>colvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name>functypclass</name> <operator>==</operator> <name>TYPEFUNC_SCALAR</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* Base data type, i.e. scalar */</comment>
						<if_stmt><if>if <condition>(<expr><name>colnames</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><operator>*</operator><name>colnames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>colnames</name></expr></argument>,
												<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>,
														 <argument><expr><name>atts_done</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<if_stmt><if>if <condition>(<expr><name>colvars</name></expr>)</condition>
						<block>{<block_content>
							<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>varnode</name></decl>;</decl_stmt>

							<expr_stmt><expr><name>varnode</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name>atts_done</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
											  <argument><expr><name>funcrettype</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
											  <argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><name>sublevels_up</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>varnode</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>

							<expr_stmt><expr><operator>*</operator><name>colvars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>colvars</name></expr></argument>, <argument><expr><name>varnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name>functypclass</name> <operator>==</operator> <name>TYPEFUNC_RECORD</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>colnames</name></expr>)</condition>
						<block>{<block_content>
							<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>namelist</name></decl>;</decl_stmt>

							<comment type="block">/* extract appropriate subset of column list */</comment>
							<expr_stmt><expr><name>namelist</name> <operator>=</operator> <call><name>list_copy_tail</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>,
													  <argument><expr><name>atts_done</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>namelist</name> <operator>=</operator> <call><name>list_truncate</name><argument_list>(<argument><expr><name>namelist</name></expr></argument>,
													 <argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funccolcount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><operator>*</operator><name>colnames</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><operator>*</operator><name>colnames</name></expr></argument>, <argument><expr><name>namelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>

						<if_stmt><if>if <condition>(<expr><name>colvars</name></expr>)</condition>
						<block>{<block_content>
							<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l1</name></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l2</name></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l3</name></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><name>atts_done</name></expr></init></decl>;</decl_stmt>

							<macro><name>forthree</name><argument_list>(<argument>l1</argument>, <argument>rtfunc-&gt;funccoltypes</argument>,
									 <argument>l2</argument>, <argument>rtfunc-&gt;funccoltypmods</argument>,
									 <argument>l3</argument>, <argument>rtfunc-&gt;funccolcollations</argument>)</argument_list></macro>
							<block>{<block_content>
								<decl_stmt><decl><type><name>Oid</name></type>			<name>attrtype</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
								<decl_stmt><decl><type><name>int32</name></type>		<name>attrtypmod</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
								<decl_stmt><decl><type><name>Oid</name></type>			<name>attrcollation</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l3</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
								<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>varnode</name></decl>;</decl_stmt>

								<expr_stmt><expr><name>attnum</name><operator>++</operator></expr>;</expr_stmt>
								<expr_stmt><expr><name>varnode</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>,
												  <argument><expr><name>attnum</name></expr></argument>,
												  <argument><expr><name>attrtype</name></expr></argument>,
												  <argument><expr><name>attrtypmod</name></expr></argument>,
												  <argument><expr><name>attrcollation</name></expr></argument>,
												  <argument><expr><name>sublevels_up</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><name><name>varnode</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>
								<expr_stmt><expr><operator>*</operator><name>colvars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>colvars</name></expr></argument>, <argument><expr><name>varnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* addRangeTableEntryForFunction should've caught this */</comment>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function in FROM has unsupported return type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					<expr_stmt><expr><name>atts_done</name> <operator>+=</operator> <name><name>rtfunc</name><operator>-&gt;</operator><name>funccolcount</name></name></expr>;</expr_stmt>
				</block_content>}</block>

				<comment type="block">/* Append the ordinality column if any */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>funcordinality</name></name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>colnames</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>*</operator><name>colnames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>colnames</name></expr></argument>,
											<argument><expr><call><name>llast</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name>colvars</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>varnode</name> <init>= <expr><call><name>makeVar</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>,
													  <argument><expr><name>atts_done</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
													  <argument><expr><name>INT8OID</name></expr></argument>,
													  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
													  <argument><expr><name>InvalidOid</name></expr></argument>,
													  <argument><expr><name>sublevels_up</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><operator>*</operator><name>colvars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>colvars</name></expr></argument>, <argument><expr><name>varnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>RTE_JOIN</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/* Join RTE */</comment>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>colname</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>aliasvar</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>joinaliasvars</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>varattno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<macro><name>forboth</name><argument_list>(<argument>colname</argument>, <argument>rte-&gt;eref-&gt;colnames</argument>, <argument>aliasvar</argument>, <argument>rte-&gt;joinaliasvars</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>avar</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>aliasvar</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name>varattno</name><operator>++</operator></expr>;</expr_stmt>

					<comment type="block">/*
					 * During ordinary parsing, there will never be any
					 * deleted columns in the join; but we have to check since
					 * this routine is also used by the rewriter, and joins
					 * found in stored rules might have join columns for
					 * since-deleted columns.  This will be signaled by a null
					 * pointer in the alias-vars list.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>avar</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>include_dropped</name></expr>)</condition>
						<block>{<block_content>
							<if_stmt><if>if <condition>(<expr><name>colnames</name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><operator>*</operator><name>colnames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>colnames</name></expr></argument>,
													<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
							<if_stmt><if>if <condition>(<expr><name>colvars</name></expr>)</condition>
							<block>{<block_content>
								<comment type="block">/*
								 * Can't use join's column type here (it might
								 * be dropped!); but it doesn't really matter
								 * what type the Const claims to be.
								 */</comment>
								<expr_stmt><expr><operator>*</operator><name>colvars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>colvars</name></expr></argument>,
												   <argument><expr><call><name>makeNullConst</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
																 <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
						</block_content>}</block></if></if_stmt>
						<continue>continue;</continue>
					</block_content>}</block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name>colnames</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>label</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><operator>*</operator><name>colnames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>colnames</name></expr></argument>,
											<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>label</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name>colvars</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>varnode</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>varnode</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name>varattno</name></expr></argument>,
										  <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>avar</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>avar</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><name>avar</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>sublevels_up</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>varnode</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>

						<expr_stmt><expr><operator>*</operator><name>colvars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>colvars</name></expr></argument>, <argument><expr><name>varnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>RTE_TABLEFUNC</name></expr>:</case>
		<case>case <expr><name>RTE_VALUES</name></expr>:</case>
		<case>case <expr><name>RTE_CTE</name></expr>:</case>
		<case>case <expr><name>RTE_NAMEDTUPLESTORE</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/* Tablefunc, Values, CTE, or ENR RTE */</comment>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>aliasp_item</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lct</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcm</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcc</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>varattno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<macro><name>forthree</name><argument_list>(<argument>lct</argument>, <argument>rte-&gt;coltypes</argument>,
						 <argument>lcm</argument>, <argument>rte-&gt;coltypmods</argument>,
						 <argument>lcc</argument>, <argument>rte-&gt;colcollations</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>coltype</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lct</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int32</name></type>		<name>coltypmod</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lcm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>colcoll</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lcc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name>varattno</name><operator>++</operator></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>colnames</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* Assume there is one alias per output column */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>coltype</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>label</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>aliasp_item</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

							<expr_stmt><expr><operator>*</operator><name>colnames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>colnames</name></expr></argument>,
												<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>label</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if>
						<if type="elseif">else if <condition>(<expr><name>include_dropped</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><operator>*</operator><name>colnames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>colnames</name></expr></argument>,
												<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<expr_stmt><expr><name>aliasp_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>aliasp_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name>colvars</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>coltype</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>varnode</name></decl>;</decl_stmt>

							<expr_stmt><expr><name>varnode</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name>varattno</name></expr></argument>,
											  <argument><expr><name>coltype</name></expr></argument>, <argument><expr><name>coltypmod</name></expr></argument>, <argument><expr><name>colcoll</name></expr></argument>,
											  <argument><expr><name>sublevels_up</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>varnode</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>

							<expr_stmt><expr><operator>*</operator><name>colvars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>colvars</name></expr></argument>, <argument><expr><name>varnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if>
						<if type="elseif">else if <condition>(<expr><name>include_dropped</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/*
							 * It doesn't really matter what type the Const
							 * claims to be.
							 */</comment>
							<expr_stmt><expr><operator>*</operator><name>colvars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>colvars</name></expr></argument>,
											   <argument><expr><call><name>makeNullConst</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
															 <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block>
			</block_content>}</block>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized RTE kind: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * expandRelation -- expandRTE subroutine
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>expandRelation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Alias</name> <modifier>*</modifier></type><name>eref</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rtindex</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sublevels_up</name></decl></parameter>,
			   <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>include_dropped</name></decl></parameter>,
			   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>colnames</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>colvars</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>

	<comment type="block">/* Get the tupledesc and turn it over to expandTupleDesc */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>expandTupleDesc</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>eref</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					<argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name>sublevels_up</name></expr></argument>,
					<argument><expr><name>location</name></expr></argument>, <argument><expr><name>include_dropped</name></expr></argument>,
					<argument><expr><name>colnames</name></expr></argument>, <argument><expr><name>colvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * expandTupleDesc -- expandRTE subroutine
 *
 * Generate names and/or Vars for the first "count" attributes of the tupdesc,
 * and append them to colnames/colvars.  "offset" is added to the varattno
 * that each Var would otherwise have, and we also skip the first "offset"
 * entries in eref-&gt;colnames.  (These provisions allow use of this code for
 * an individual composite-returning function in an RTE_FUNCTION RTE.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>expandTupleDesc</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>Alias</name> <modifier>*</modifier></type><name>eref</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>rtindex</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sublevels_up</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>include_dropped</name></decl></parameter>,
				<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>colnames</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>colvars</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>aliascell</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><name><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>varattno</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>colnames</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>offset</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>aliascell</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>aliascell</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>aliascell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>count</name> <operator>&lt;=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>varattno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>varattno</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>varattno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>varattno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>include_dropped</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>colnames</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>colnames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>colnames</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>colvars</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * can't use atttypid here, but it doesn't really matter
					 * what type the Const claims to be.
					 */</comment>
					<expr_stmt><expr><operator>*</operator><name>colvars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>colvars</name></expr></argument>,
									   <argument><expr><call><name>makeNullConst</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>aliascell</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>aliascell</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>aliascell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>colnames</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>label</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>aliascell</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>label</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>aliascell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>aliascell</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>aliascell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* If we run out of aliases, use the underlying name */</comment>
				<expr_stmt><expr><name>label</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><operator>*</operator><name>colnames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>colnames</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>label</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>colvars</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>varnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>varnode</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name>varattno</name> <operator>+</operator> <name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
							  <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>,
							  <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>,
							  <argument><expr><name>sublevels_up</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>varnode</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>

			<expr_stmt><expr><operator>*</operator><name>colvars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>colvars</name></expr></argument>, <argument><expr><name>varnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * expandRelAttrs -
 *	  Workhorse for "*" expansion: produce a list of targetentries
 *	  for the attributes of the RTE
 *
 * As with expandRTE, rtindex/sublevels_up determine the varno/varlevelsup
 * fields of the Vars produced, and location sets their location.
 * pstate-&gt;p_next_resno determines the resnos assigned to the TLEs.
 * The referenced columns are marked as requiring SELECT access.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>expandRelAttrs</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
			   <parameter><decl><type><name>int</name></type> <name>rtindex</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sublevels_up</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>names</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>vars</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>name</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>te_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>expandRTE</name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name>sublevels_up</name></expr></argument>, <argument><expr><name>location</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
			  <argument><expr><operator>&amp;</operator><name>names</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Require read access to the table.  This is normally redundant with the
	 * markVarForSelectPriv calls below, but not if the table has zero
	 * columns.
	 */</comment>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>|=</operator> <name>ACL_SELECT</name></expr>;</expr_stmt>

	<macro><name>forboth</name><argument_list>(<argument>name</argument>, <argument>names</argument>, <argument>var</argument>, <argument>vars</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>label</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>varnode</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>varnode</name></expr></argument>,
							 <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>,
							 <argument><expr><name>label</name></expr></argument>,
							 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>te_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>te_list</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Require read access to each column */</comment>
		<expr_stmt><expr><call><name>markVarForSelectPriv</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>varnode</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>name</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>var</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* lists not the same length? */</comment>

	<return>return <expr><name>te_list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_rte_attribute_name
 *		Get an attribute name from a RangeTblEntry
 *
 * This is unlike get_attname() because we use aliases if available.
 * In particular, it will work on an RTE for a subselect or join, whereas
 * get_attname() only works on real relations.
 *
 * "*" is returned if the given attnum is InvalidAttrNumber --- this case
 * occurs when a Var represents a whole tuple of a relation.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>get_rte_attribute_name</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="string">"*"</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If there is a user-written column alias, use it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>&amp;&amp;</operator>
		<name>attnum</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>attnum</name> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the RTE is a relation, go to the system catalogs not the
	 * eref-&gt;colnames list.  This is a little slower but it will give the
	 * right answer if the column has been renamed since the eref list was
	 * built (which can easily happen for rules).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>get_attname</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise use the column name from eref.  There should always be one.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>attnum</name> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* else caller gave us a bogus attnum */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid attnum %d for rangetable entry %s"</literal></expr></argument>,
		 <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>				<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * get_rte_attribute_type
 *		Get attribute type/typmod/collation information from a RangeTblEntry
 */</comment>
<function><type><name>void</name></type>
<name>get_rte_attribute_type</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>,
					   <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>vartype</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>vartypmod</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>varcollid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RTE_RELATION</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/* Plain relation RTE --- get the attribute's type info */</comment>
				<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att_tup</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>ATTNUM</name></expr></argument>,
									 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* shouldn't happen */</comment>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for attribute %d of relation %u"</literal></expr></argument>,
						 <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>att_tup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If dropped column, pretend it ain't there.  See notes in
				 * scanRTEForColumn.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>att_tup</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
									<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><operator>*</operator><name>vartype</name> <operator>=</operator> <name><name>att_tup</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>vartypmod</name> <operator>=</operator> <name><name>att_tup</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>varcollid</name> <operator>=</operator> <name><name>att_tup</name><operator>-&gt;</operator><name>attcollation</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>RTE_SUBQUERY</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/* Subselect RTE --- get type info from subselect's tlist */</comment>
				<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name> <init>= <expr><call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
												   <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>te</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>te</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"subquery %s does not have attribute %d"</literal></expr></argument>,
						 <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><operator>*</operator><name>vartype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>vartypmod</name> <operator>=</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>varcollid</name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>RTE_FUNCTION</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/* Function RTE */</comment>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>atts_done</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

				<comment type="block">/* Identify which function covers the requested column */</comment>
				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rte-&gt;functions</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rtfunc</name> <init>= <expr><operator>(</operator><name>RangeTblFunction</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&gt;</operator> <name>atts_done</name> <operator>&amp;&amp;</operator>
						<name>attnum</name> <operator>&lt;=</operator> <name>atts_done</name> <operator>+</operator> <name><name>rtfunc</name><operator>-&gt;</operator><name>funccolcount</name></name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>TypeFuncClass</name></type> <name>functypclass</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>Oid</name></type>			<name>funcrettype</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>attnum</name> <operator>-=</operator> <name>atts_done</name></expr>;</expr_stmt>	<comment type="block">/* now relative to this func */</comment>
						<expr_stmt><expr><name>functypclass</name> <operator>=</operator> <call><name>get_expr_result_type</name><argument_list>(<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></argument>,
															<argument><expr><operator>&amp;</operator><name>funcrettype</name></expr></argument>,
															<argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><name>functypclass</name> <operator>==</operator> <name>TYPEFUNC_COMPOSITE</name> <operator>||</operator>
							<name>functypclass</name> <operator>==</operator> <name>TYPEFUNC_COMPOSITE_DOMAIN</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* Composite data type, e.g. a table's row type */</comment>
							<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att_tup</name></decl>;</decl_stmt>

							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attnum</name> <operator>&lt;=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>att_tup</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<comment type="block">/*
							 * If dropped column, pretend it ain't there.  See
							 * notes in scanRTEForColumn.
							 */</comment>
							<if_stmt><if>if <condition>(<expr><name><name>att_tup</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
										<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
										 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
												<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
							<expr_stmt><expr><operator>*</operator><name>vartype</name> <operator>=</operator> <name><name>att_tup</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
							<expr_stmt><expr><operator>*</operator><name>vartypmod</name> <operator>=</operator> <name><name>att_tup</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>;</expr_stmt>
							<expr_stmt><expr><operator>*</operator><name>varcollid</name> <operator>=</operator> <name><name>att_tup</name><operator>-&gt;</operator><name>attcollation</name></name></expr>;</expr_stmt>
						</block_content>}</block></if>
						<if type="elseif">else if <condition>(<expr><name>functypclass</name> <operator>==</operator> <name>TYPEFUNC_SCALAR</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* Base data type, i.e. scalar */</comment>
							<expr_stmt><expr><operator>*</operator><name>vartype</name> <operator>=</operator> <name>funcrettype</name></expr>;</expr_stmt>
							<expr_stmt><expr><operator>*</operator><name>vartypmod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
							<expr_stmt><expr><operator>*</operator><name>varcollid</name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if>
						<if type="elseif">else if <condition>(<expr><name>functypclass</name> <operator>==</operator> <name>TYPEFUNC_RECORD</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><operator>*</operator><name>vartype</name> <operator>=</operator> <call><name>list_nth_oid</name><argument_list>(<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funccoltypes</name></name></expr></argument>,
													<argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><operator>*</operator><name>vartypmod</name> <operator>=</operator> <call><name>list_nth_int</name><argument_list>(<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funccoltypmods</name></name></expr></argument>,
													  <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><operator>*</operator><name>varcollid</name> <operator>=</operator> <call><name>list_nth_oid</name><argument_list>(<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funccolcollations</name></name></expr></argument>,
													  <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if>
						<else>else
						<block>{<block_content>
							<comment type="block">/*
							 * addRangeTableEntryForFunction should've caught
							 * this
							 */</comment>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function in FROM has unsupported return type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></else></if_stmt>
						<return>return;</return>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name>atts_done</name> <operator>+=</operator> <name><name>rtfunc</name><operator>-&gt;</operator><name>funccolcount</name></name></expr>;</expr_stmt>
				</block_content>}</block>

				<comment type="block">/* If we get here, must be looking for the ordinality column */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>funcordinality</name></name> <operator>&amp;&amp;</operator> <name>attnum</name> <operator>==</operator> <name>atts_done</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><operator>*</operator><name>vartype</name> <operator>=</operator> <name>INT8OID</name></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>vartypmod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>varcollid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
					<return>return;</return>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* this probably can't happen ... */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column %d of relation \"%s\" does not exist"</literal></expr></argument>,
								<argument><expr><name>attnum</name></expr></argument>,
								<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>RTE_JOIN</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * Join RTE --- get type info from join RTE's alias variable
				 */</comment>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>aliasvar</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attnum</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>attnum</name> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>joinaliasvars</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>aliasvar</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>joinaliasvars</name></name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>aliasvar</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>vartype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>aliasvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>vartypmod</name> <operator>=</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><name>aliasvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>varcollid</name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><name>aliasvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>RTE_TABLEFUNC</name></expr>:</case>
		<case>case <expr><name>RTE_VALUES</name></expr>:</case>
		<case>case <expr><name>RTE_CTE</name></expr>:</case>
		<case>case <expr><name>RTE_NAMEDTUPLESTORE</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * tablefunc, VALUES, CTE, or ENR RTE --- get type info from
				 * lists in the RTE
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attnum</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>attnum</name> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>coltypes</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>vartype</name> <operator>=</operator> <call><name>list_nth_oid</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>coltypes</name></name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>vartypmod</name> <operator>=</operator> <call><name>list_nth_int</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>coltypmods</name></name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>varcollid</name> <operator>=</operator> <call><name>list_nth_oid</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>colcollations</name></name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* For ENR, better check for dropped column */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>vartype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column %d of relation \"%s\" does not exist"</literal></expr></argument>,
									<argument><expr><name>attnum</name></expr></argument>,
									<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized RTE kind: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * get_rte_attribute_is_dropped
 *		Check whether attempted attribute ref is to a dropped column
 */</comment>
<function><type><name>bool</name></type>
<name>get_rte_attribute_is_dropped</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RTE_RELATION</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * Plain relation RTE --- get the attribute's catalog entry
				 */</comment>
				<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att_tup</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>ATTNUM</name></expr></argument>,
									 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* shouldn't happen */</comment>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for attribute %d of relation %u"</literal></expr></argument>,
						 <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>att_tup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>att_tup</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>RTE_SUBQUERY</name></expr>:</case>
		<case>case <expr><name>RTE_TABLEFUNC</name></expr>:</case>
		<case>case <expr><name>RTE_VALUES</name></expr>:</case>
		<case>case <expr><name>RTE_CTE</name></expr>:</case>

			<comment type="block">/*
			 * Subselect, Table Functions, Values, CTE RTEs never have dropped
			 * columns
			 */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RTE_NAMEDTUPLESTORE</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/* Check dropped-ness by testing for valid coltype */</comment>
				<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator>
					<name>attnum</name> <operator>&gt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>coltypes</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid varattno %d"</literal></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><operator>(</operator><call><name>list_nth_oid</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>coltypes</name></name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>RTE_JOIN</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * A join RTE would not have dropped columns when constructed,
				 * but one in a stored rule might contain columns that were
				 * dropped from the underlying tables, if said columns are
				 * nowhere explicitly referenced in the rule.  This will be
				 * signaled to us by a null pointer in the joinaliasvars list.
				 */</comment>
				<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>aliasvar</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator>
					<name>attnum</name> <operator>&gt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>joinaliasvars</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid varattno %d"</literal></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>aliasvar</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>joinaliasvars</name></name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>aliasvar</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>RTE_FUNCTION</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/* Function RTE */</comment>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>atts_done</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * Dropped attributes are only possible with functions that
				 * return named composite types.  In such a case we have to
				 * look up the result type to see if it currently has this
				 * column dropped.  So first, loop over the funcs until we
				 * find the one that covers the requested column.
				 */</comment>
				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rte-&gt;functions</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rtfunc</name> <init>= <expr><operator>(</operator><name>RangeTblFunction</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&gt;</operator> <name>atts_done</name> <operator>&amp;&amp;</operator>
						<name>attnum</name> <operator>&lt;=</operator> <name>atts_done</name> <operator>+</operator> <name><name>rtfunc</name><operator>-&gt;</operator><name>funccolcount</name></name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>get_expr_result_tupdesc</name><argument_list>(<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></argument>,
														  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>tupdesc</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* Composite data type, e.g. a table's row type */</comment>
							<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att_tup</name></decl>;</decl_stmt>

							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attnum</name> <operator>-</operator> <name>atts_done</name> <operator>&lt;=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>att_tup</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>,
													<argument><expr><name>attnum</name> <operator>-</operator> <name>atts_done</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<return>return <expr><name><name>att_tup</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>;</return>
						</block_content>}</block></if></if_stmt>
						<comment type="block">/* Otherwise, it can't have any dropped columns */</comment>
						<return>return <expr><name>false</name></expr>;</return>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name>atts_done</name> <operator>+=</operator> <name><name>rtfunc</name><operator>-&gt;</operator><name>funccolcount</name></name></expr>;</expr_stmt>
				</block_content>}</block>

				<comment type="block">/* If we get here, must be looking for the ordinality column */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>funcordinality</name></name> <operator>&amp;&amp;</operator> <name>attnum</name> <operator>==</operator> <name>atts_done</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/* this probably can't happen ... */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column %d of relation \"%s\" does not exist"</literal></expr></argument>,
								<argument><expr><name>attnum</name></expr></argument>,
								<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* keep compiler quiet */</comment>
			</block_content>}</block>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized RTE kind: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>		<comment type="block">/* keep compiler quiet */</comment>
	</block_content>}</block></switch>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given a targetlist and a resno, return the matching TargetEntry
 *
 * Returns NULL if resno is not present in list.
 *
 * Note: we need to search, rather than just indexing with list_nth(),
 * because not all tlists are sorted by resno.
 */</comment>
<function><type><name>TargetEntry</name> <modifier>*</modifier></type>
<name>get_tle_by_resno</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>resno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>tlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>==</operator> <name>resno</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>tle</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given a Query and rangetable index, return relation's RowMarkClause if any
 *
 * Returns NULL if relation is not selected FOR UPDATE/SHARE
 */</comment>
<function><type><name>RowMarkClause</name> <modifier>*</modifier></type>
<name>get_parse_rowmark</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>qry</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rtindex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>qry-&gt;rowMarks</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RowMarkClause</name> <modifier>*</modifier></type><name>rc</name> <init>= <expr><operator>(</operator><name>RowMarkClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>rti</name></name> <operator>==</operator> <name>rtindex</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	given relation and att name, return attnum of variable
 *
 *	Returns InvalidAttrNumber if the attr doesn't exist (or is dropped).
 *
 *	This should only be used if the relation is already
 *	heap_open()'ed.  Use the cache version get_attnum()
 *	for access to non-opened relations.
 */</comment>
<function><type><name>int</name></type>
<name>attnameAttNum</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>sysColOK</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>rd</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>rd</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>namestrcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>att</name><operator>-&gt;</operator><name>attname</name></name><operator>)</operator></expr></argument>, <argument><expr><name>attname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>sysColOK</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <call><name>specialAttNum</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>InvalidAttrNumber</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <name>ObjectIdAttributeNumber</name> <operator>||</operator> <name><name>rd</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasoids</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* on failure */</comment>
	<return>return <expr><name>InvalidAttrNumber</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* specialAttNum()
 *
 * Check attribute name to see if it is "special", e.g. "oid".
 * - thomas 2000-02-07
 *
 * Note: this only discovers whether the name could be a system attribute.
 * Caller needs to verify that it really is an attribute of the rel,
 * at least in the case of "oid", which is now optional.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>specialAttNum</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>sysatt</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>sysatt</name> <operator>=</operator> <call><name>SystemAttributeByName</name><argument_list>(<argument><expr><name>attname</name></expr></argument>,
								   <argument><expr><name>true</name></expr></argument> <comment type="block">/* "oid" will be accepted */</comment> )</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>sysatt</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>sysatt</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>InvalidAttrNumber</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * given attribute id, return name of that attribute
 *
 *	This should only be used if the relation is already
 *	heap_open()'ed.  Use the cache version get_atttype()
 *	for access to non-opened relations.
 */</comment>
<function><type><name>Name</name></type>
<name>attnumAttName</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>attid</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>sysatt</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>sysatt</name> <operator>=</operator> <call><name>SystemAttributeDefinition</name><argument_list>(<argument><expr><name>attid</name></expr></argument>, <argument><expr><name><name>rd</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasoids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>&amp;</operator><name><name>sysatt</name><operator>-&gt;</operator><name>attname</name></name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>attid</name> <operator>&gt;</operator> <name><name>rd</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid attribute number %d"</literal></expr></argument>, <argument><expr><name>attid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><operator>&amp;</operator><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>rd</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>attid</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attname</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * given attribute id, return type of that attribute
 *
 *	This should only be used if the relation is already
 *	heap_open()'ed.  Use the cache version get_atttype()
 *	for access to non-opened relations.
 */</comment>
<function><type><name>Oid</name></type>
<name>attnumTypeId</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>attid</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>sysatt</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>sysatt</name> <operator>=</operator> <call><name>SystemAttributeDefinition</name><argument_list>(<argument><expr><name>attid</name></expr></argument>, <argument><expr><name><name>rd</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasoids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name><name>sysatt</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>attid</name> <operator>&gt;</operator> <name><name>rd</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid attribute number %d"</literal></expr></argument>, <argument><expr><name>attid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>rd</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>attid</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * given attribute id, return collation of that attribute
 *
 *	This should only be used if the relation is already heap_open()'ed.
 */</comment>
<function><type><name>Oid</name></type>
<name>attnumCollationId</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>attid</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* All system attributes are of noncollatable types. */</comment>
		<return>return <expr><name>InvalidOid</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>attid</name> <operator>&gt;</operator> <name><name>rd</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid attribute number %d"</literal></expr></argument>, <argument><expr><name>attid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>rd</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>attid</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attcollation</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate a suitable error about a missing RTE.
 *
 * Since this is a very common type of error, we work rather hard to
 * produce a helpful message.
 */</comment>
<function><type><name>void</name></type>
<name>errorMissingRTE</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sublevels_up</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>badAlias</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check to see if there are any potential matches in the query's
	 * rangetable.  (Note: cases involving a bad schema name in the RangeVar
	 * will throw error immediately here.  That seems OK.)
	 */</comment>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>searchRangeTableForRel</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we found a match that has an alias and the alias is visible in the
	 * namespace, then the problem is probably use of the relation's real name
	 * instead of its alias, ie "SELECT foo.* FROM foo f". This mistake is
	 * common enough to justify a specific hint.
	 *
	 * If we found a match that doesn't meet those criteria, assume the
	 * problem is illegal use of a relation outside its scope, as in the
	 * MySQL-ism "SELECT ... FROM a, b LEFT JOIN c ON (a.x = c.y)".
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>rte</name> <operator>&amp;&amp;</operator> <name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>&amp;&amp;</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>, <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<call><name>refnameRangeTblEntry</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>,
							 <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>location</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>sublevels_up</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rte</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>badAlias</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>rte</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid reference to FROM-clause entry for table \"%s\""</literal></expr></argument>,
						<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
				 <operator>(</operator><ternary><condition><expr><name>badAlias</name></expr> ?</condition><then>
				  <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Perhaps you meant to reference the table alias \"%s\"."</literal></expr></argument>,
						  <argument><expr><name>badAlias</name></expr></argument>)</argument_list></call></expr> </then><else>:
				  <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"There is an entry for table \"%s\", but it cannot be referenced from this part of the query."</literal></expr></argument>,
						  <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"missing FROM-clause entry for table \"%s\""</literal></expr></argument>,
						<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Generate a suitable error about a missing column.
 *
 * Since this is a very common type of error, we work rather hard to
 * produce a helpful message.
 */</comment>
<function><type><name>void</name></type>
<name>errorMissingColumn</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
				   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuzzyAttrMatchState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>closestfirst</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Search the entire rtable looking for possible matches.  If we find one,
	 * emit a hint about it.
	 *
	 * TODO: improve this code (and also errorMissingRTE) to mention using
	 * LATERAL if appropriate.
	 */</comment>
	<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>searchRangeTableForCol</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Extract closest col string for best match, if any.
	 *
	 * Infer an exact match referenced despite not being visible from the fact
	 * that an attribute number was not present in state passed back -- this
	 * is what is reported when !closestfirst.  There might also be an exact
	 * match that was qualified with an incorrect alias, in which case
	 * closestfirst will be set (so hint is the same as generic fuzzy case).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>rfirst</name></name> <operator>&amp;&amp;</operator> <call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>first</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>closestfirst</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rfirst</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>,
									   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>first</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>rsecond</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Handle case where there is zero or one column suggestions to hint,
		 * including exact matches referenced but not visible.
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <ternary><condition><expr><name>relname</name></expr> ?</condition><then>
				 <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column %s.%s does not exist"</literal></expr></argument>, <argument><expr><name>relname</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr> </then><else>:
				 <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>,</operator>
				 <ternary><condition><expr><name><name>state</name><operator>-&gt;</operator><name>rfirst</name></name></expr> ?</condition><then> <expr><ternary><condition><expr><name>closestfirst</name></expr> ?</condition><then>
				 <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Perhaps you meant to reference the column \"%s.%s\"."</literal></expr></argument>,
						 <argument><expr><name><name>state</name><operator>-&gt;</operator><name>rfirst</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>, <argument><expr><name>closestfirst</name></expr></argument>)</argument_list></call></expr> </then><else>:
				 <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"There is a column named \"%s\" in table \"%s\", but it cannot be referenced from this part of the query."</literal></expr></argument>,
						 <argument><expr><name>colname</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>rfirst</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Handle case where there are two equally useful column hints */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>closestsecond</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>closestsecond</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rsecond</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>,
										<argument><expr><name><name>state</name><operator>-&gt;</operator><name>second</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <ternary><condition><expr><name>relname</name></expr> ?</condition><then>
				 <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column %s.%s does not exist"</literal></expr></argument>, <argument><expr><name>relname</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr> </then><else>:
				 <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Perhaps you meant to reference the column \"%s.%s\" or the column \"%s.%s\"."</literal></expr></argument>,
						 <argument><expr><name><name>state</name><operator>-&gt;</operator><name>rfirst</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>, <argument><expr><name>closestfirst</name></expr></argument>,
						 <argument><expr><name><name>state</name><operator>-&gt;</operator><name>rsecond</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>, <argument><expr><name>closestsecond</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Examine a fully-parsed query, and return true iff any relation underlying
 * the query is a temporary relation (table, view, or materialized view).
 */</comment>
<function><type><name>bool</name></type>
<name>isQueryUsingTempRelation</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>isQueryUsingTempRelation_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>query</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>isQueryUsingTempRelation_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>rtable</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>rtable</argument>, <argument>query-&gt;rtable</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>rtable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><call><name>heap_open</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name></type>		<name>relpersistence</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>relpersistence</name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<return>return <expr><call><name>query_tree_walker</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
								 <argument><expr><name>isQueryUsingTempRelation_walker</name></expr></argument>,
								 <argument><expr><name>context</name></expr></argument>,
								 <argument><expr><name>QTW_IGNORE_JOINALIASES</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
								  <argument><expr><name>isQueryUsingTempRelation_walker</name></expr></argument>,
								  <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
