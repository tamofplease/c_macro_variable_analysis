<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/parser/parse_target.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * parse_target.c
 *	  handle target lists
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/parser/parse_target.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_func.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_target.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>

<comment type="block">/* YB includes. */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>markTargetListOrigin</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl></parameter>,
					 <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>levelsup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformAssignmentIndirection</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
							   <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>basenode</name></decl></parameter>,
							   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetName</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name></type> <name>targetIsArray</name></decl></parameter>,
							   <parameter><decl><type><name>Oid</name></type> <name>targetTypeId</name></decl></parameter>,
							   <parameter><decl><type><name>int32</name></type> <name>targetTypMod</name></decl></parameter>,
							   <parameter><decl><type><name>Oid</name></type> <name>targetCollation</name></decl></parameter>,
							   <parameter><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>indirection</name></decl></parameter>,
							   <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>rhs</name></decl></parameter>,
							   <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformAssignmentSubscripts</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
							  <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>basenode</name></decl></parameter>,
							  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetName</name></decl></parameter>,
							  <parameter><decl><type><name>Oid</name></type> <name>targetTypeId</name></decl></parameter>,
							  <parameter><decl><type><name>int32</name></type> <name>targetTypMod</name></decl></parameter>,
							  <parameter><decl><type><name>Oid</name></type> <name>targetCollation</name></decl></parameter>,
							  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>subscripts</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name></type> <name>isSlice</name></decl></parameter>,
							  <parameter><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>next_indirection</name></decl></parameter>,
							  <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>rhs</name></decl></parameter>,
							  <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>ExpandColumnRefStar</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ColumnRef</name> <modifier>*</modifier></type><name>cref</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>make_target_entry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>ExpandAllTables</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>ExpandIndirectionStar</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>A_Indirection</name> <modifier>*</modifier></type><name>ind</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>make_target_entry</name></decl></parameter>, <parameter><decl><type><name>ParseExprKind</name></type> <name>exprKind</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>ExpandSingleTable</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>make_target_entry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>ExpandRowReference</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>make_target_entry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>FigureColnameInternal</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * transformTargetEntry()
 *	Transform any ordinary "expression-type" node into a targetlist entry.
 *	This is exported so that parse_clause.c can generate targetlist entries
 *	for ORDER/GROUP BY items that are not already in the targetlist.
 *
 * node		the (untransformed) parse tree for the value expression.
 * expr		the transformed expression, or NULL if caller didn't do it yet.
 * exprKind expression kind (EXPR_KIND_SELECT_TARGET, etc)
 * colname	the column name to be assigned, or NULL if none yet set.
 * resjunk	true if the target should be marked resjunk, ie, it is not
 *			wanted in the final projected tuple.
 */</comment>
<function><type><name>TargetEntry</name> <modifier>*</modifier></type>
<name>transformTargetEntry</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
					 <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
					 <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
					 <parameter><decl><type><name>ParseExprKind</name></type> <name>exprKind</name></decl></parameter>,
					 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>resjunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Transform the node if caller didn't do it already */</comment>
	<if_stmt><if>if <condition>(<expr><name>expr</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If it's a SetToDefault node and we should allow that, pass it
		 * through unmodified.  (transformExpr will throw the appropriate
		 * error if we're disallowing it.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>exprKind</name> <operator>==</operator> <name>EXPR_KIND_UPDATE_SOURCE</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SetToDefault</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <name>node</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>exprKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>colname</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>resjunk</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Generate a suitable column name for a column without any explicit
		 * 'AS ColumnName' clause.
		 */</comment>
		<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>FigureColname</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>,
						   <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>,
						   <argument><expr><name>colname</name></expr></argument>,
						   <argument><expr><name>resjunk</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * transformTargetList()
 * Turns a list of ResTarget's into a list of TargetEntry's.
 *
 * This code acts mostly the same for SELECT, UPDATE, or RETURNING lists;
 * the main thing is to transform the given expressions (the "val" fields).
 * The exprKind parameter distinguishes these cases when necessary.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>transformTargetList</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>,
					<parameter><decl><type><name>ParseExprKind</name></type> <name>exprKind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>p_target</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>expand_star</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>o_target</name></decl>;</decl_stmt>

	<comment type="block">/* Shouldn't have any leftover multiassign items at start */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_multiassign_exprs</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Expand "something.*" in SELECT and RETURNING, but not UPDATE */</comment>
	<expr_stmt><expr><name>expand_star</name> <operator>=</operator> <operator>(</operator><name>exprKind</name> <operator>!=</operator> <name>EXPR_KIND_UPDATE_SOURCE</name><operator>)</operator></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>o_target</argument>, <argument>targetlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>res</name> <init>= <expr><operator>(</operator><name>ResTarget</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>o_target</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Check for "something.*".  Depending on the complexity of the
		 * "something", the star could appear as the last field in ColumnRef,
		 * or as the last indirection item in A_Indirection.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>expand_star</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ColumnRef</name>  <modifier>*</modifier></type><name>cref</name> <init>= <expr><operator>(</operator><name>ColumnRef</name> <operator>*</operator><operator>)</operator> <name><name>res</name><operator>-&gt;</operator><name>val</name></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><call><name>llast</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>A_Star</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* It is something.*, expand into multiple items */</comment>
					<expr_stmt><expr><name>p_target</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>p_target</name></expr></argument>,
										   <argument><expr><call><name>ExpandColumnRefStar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
															   <argument><expr><name>cref</name></expr></argument>,
															   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>A_Indirection</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>A_Indirection</name> <modifier>*</modifier></type><name>ind</name> <init>= <expr><operator>(</operator><name>A_Indirection</name> <operator>*</operator><operator>)</operator> <name><name>res</name><operator>-&gt;</operator><name>val</name></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><call><name>llast</name><argument_list>(<argument><expr><name><name>ind</name><operator>-&gt;</operator><name>indirection</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>A_Star</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* It is something.*, expand into multiple items */</comment>
					<expr_stmt><expr><name>p_target</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>p_target</name></expr></argument>,
										   <argument><expr><call><name>ExpandIndirectionStar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
																 <argument><expr><name>ind</name></expr></argument>,
																 <argument><expr><name>true</name></expr></argument>,
																 <argument><expr><name>exprKind</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Not "something.*", or we want to treat that as a plain whole-row
		 * variable, so transform as a single expression
		 */</comment>
		<expr_stmt><expr><name>p_target</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>p_target</name></expr></argument>,
						   <argument><expr><call><name>transformTargetEntry</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
												<argument><expr><name><name>res</name><operator>-&gt;</operator><name>val</name></name></expr></argument>,
												<argument><expr><name>NULL</name></expr></argument>,
												<argument><expr><name>exprKind</name></expr></argument>,
												<argument><expr><name><name>res</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
												<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If any multiassign resjunk items were created, attach them to the end
	 * of the targetlist.  This should only happen in an UPDATE tlist.  We
	 * don't need to worry about numbering of these items; transformUpdateStmt
	 * will set their resnos.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_multiassign_exprs</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>exprKind</name> <operator>==</operator> <name>EXPR_KIND_UPDATE_SOURCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>p_target</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>p_target</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_multiassign_exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_multiassign_exprs</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>p_target</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * transformExpressionList()
 *
 * This is the identical transformation to transformTargetList, except that
 * the input list elements are bare expressions without ResTarget decoration,
 * and the output elements are likewise just expressions without TargetEntry
 * decoration.  We use this for ROW() and VALUES() constructs.
 *
 * exprKind is not enough to tell us whether to allow SetToDefault, so
 * an additional flag is needed for that.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>transformExpressionList</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprlist</name></decl></parameter>,
						<parameter><decl><type><name>ParseExprKind</name></type> <name>exprKind</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>allowDefault</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>exprlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Check for "something.*".  Depending on the complexity of the
		 * "something", the star could appear as the last field in ColumnRef,
		 * or as the last indirection item in A_Indirection.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ColumnRef</name>  <modifier>*</modifier></type><name>cref</name> <init>= <expr><operator>(</operator><name>ColumnRef</name> <operator>*</operator><operator>)</operator> <name>e</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><call><name>llast</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>A_Star</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* It is something.*, expand into multiple items */</comment>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
									 <argument><expr><call><name>ExpandColumnRefStar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>cref</name></expr></argument>,
														 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>A_Indirection</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>A_Indirection</name> <modifier>*</modifier></type><name>ind</name> <init>= <expr><operator>(</operator><name>A_Indirection</name> <operator>*</operator><operator>)</operator> <name>e</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><call><name>llast</name><argument_list>(<argument><expr><name><name>ind</name><operator>-&gt;</operator><name>indirection</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>A_Star</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* It is something.*, expand into multiple items */</comment>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
									 <argument><expr><call><name>ExpandIndirectionStar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>ind</name></expr></argument>,
														   <argument><expr><name>false</name></expr></argument>, <argument><expr><name>exprKind</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Not "something.*", so transform as a single expression.  If it's a
		 * SetToDefault node and we should allow that, pass it through
		 * unmodified.  (transformExpr will throw the appropriate error if
		 * we're disallowing it.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>allowDefault</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>SetToDefault</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			 <comment type="block">/* do nothing */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>exprKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Shouldn't have any multiassign items here */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_multiassign_exprs</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * resolveTargetListUnknowns()
 *		Convert any unknown-type targetlist entries to type TEXT.
 *
 * We do this after we've exhausted all other ways of identifying the output
 * column types of a query.
 */</comment>
<function><type><name>void</name></type>
<name>resolveTargetListUnknowns</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>targetlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>restype</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>restype</name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>coerce_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
											 <argument><expr><name>restype</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
											 <argument><expr><name>COERCION_IMPLICIT</name></expr></argument>,
											 <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
											 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * markTargetListOrigins()
 *		Mark targetlist columns that are simple Vars with the source
 *		table's OID and column number.
 *
 * Currently, this is done only for SELECT targetlists and RETURNING lists,
 * since we only need the info if we are going to send it to the frontend.
 */</comment>
<function><type><name>void</name></type>
<name>markTargetListOrigins</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>targetlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>markTargetListOrigin</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>, <argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * markTargetListOrigin()
 *		If 'var' is a Var of a plain relation, mark 'tle' with its origin
 *
 * levelsup is an extra offset to interpret the Var's varlevelsup correctly.
 *
 * This is split out so it can recurse for join references.  Note that we
 * do not drill down into views, but report the view as the column owner.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>markTargetListOrigin</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl></parameter>,
					 <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>levelsup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>netlevelsup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>var</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>netlevelsup</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>+</operator> <name>levelsup</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>GetRTEByRangeTablePosn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name>netlevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RTE_RELATION</name></expr>:</case>
			<comment type="block">/* It's a table or view, report it */</comment>
			<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>resorigtbl</name></name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>resorigcol</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RTE_SUBQUERY</name></expr>:</case>
			<comment type="block">/* Subselect-in-FROM: copy up from the subselect */</comment>
			<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>!=</operator> <name>InvalidAttrNumber</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>ste</name> <init>= <expr><call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
													<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>ste</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>ste</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"subquery %s does not have attribute %d"</literal></expr></argument>,
						 <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>resorigtbl</name></name> <operator>=</operator> <name><name>ste</name><operator>-&gt;</operator><name>resorigtbl</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>resorigcol</name></name> <operator>=</operator> <name><name>ste</name><operator>-&gt;</operator><name>resorigcol</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>RTE_JOIN</name></expr>:</case>
			<comment type="block">/* Join RTE --- recursively inspect the alias variable */</comment>
			<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>!=</operator> <name>InvalidAttrNumber</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>aliasvar</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attnum</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>attnum</name> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>joinaliasvars</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>aliasvar</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>joinaliasvars</name></name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* We intentionally don't strip implicit coercions here */</comment>
				<expr_stmt><expr><call><name>markTargetListOrigin</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>, <argument><expr><name>aliasvar</name></expr></argument>, <argument><expr><name>netlevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>RTE_FUNCTION</name></expr>:</case>
		<case>case <expr><name>RTE_VALUES</name></expr>:</case>
		<case>case <expr><name>RTE_TABLEFUNC</name></expr>:</case>
		<case>case <expr><name>RTE_NAMEDTUPLESTORE</name></expr>:</case>
			<comment type="block">/* not a simple relation, leave it unmarked */</comment>
			<break>break;</break>
		<case>case <expr><name>RTE_CTE</name></expr>:</case>

			<comment type="block">/*
			 * CTE reference: copy up from the subquery, if possible. If the
			 * RTE is a recursive self-reference then we can't do anything
			 * because we haven't finished analyzing it yet. However, it's no
			 * big loss because we must be down inside the recursive term of a
			 * recursive CTE, and so any markings on the current targetlist
			 * are not going to affect the results anyway.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>!=</operator> <name>InvalidAttrNumber</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>rte</name><operator>-&gt;</operator><name>self_reference</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name> <init>= <expr><call><name>GetCTEForRTE</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>netlevelsup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>ste</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>ste</name> <operator>=</operator> <call><name>get_tle_by_resno</name><argument_list>(<argument><expr><call><name>GetCTETargetList</name><argument_list>(<argument><expr><name>cte</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>ste</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>ste</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"subquery %s does not have attribute %d"</literal></expr></argument>,
						 <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>resorigtbl</name></name> <operator>=</operator> <name><name>ste</name><operator>-&gt;</operator><name>resorigtbl</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>resorigcol</name></name> <operator>=</operator> <name><name>ste</name><operator>-&gt;</operator><name>resorigcol</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * transformAssignedExpr()
 *	This is used in INSERT and UPDATE statements only.  It prepares an
 *	expression for assignment to a column of the target table.
 *	This includes coercing the given value to the target column's type
 *	(if necessary), and dealing with any subfield names or subscripts
 *	attached to the target column itself.  The input expression has
 *	already been through transformExpr().
 *
 * pstate		parse state
 * expr			expression to be modified
 * exprKind		indicates which type of statement we're dealing with
 * colname		target column name (ie, name of attribute to be assigned to)
 * attrno		target attribute number
 * indirection	subscripts/field names for target column, if any
 * location		error cursor position for the target column, or -1
 *
 * Returns the modified expression.
 *
 * Note: location points at the target column name (SET target or INSERT
 * column name list entry), and must therefore be -1 in an INSERT that
 * omits the column name list.  So we should usually prefer to use
 * exprLocation(expr) for errors that can happen in a default INSERT.
 */</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type>
<name>transformAssignedExpr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
					  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
					  <parameter><decl><type><name>ParseExprKind</name></type> <name>exprKind</name></decl></parameter>,
					  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>attrno</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indirection</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rd</name> <init>= <expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>type_id</name></decl>;</decl_stmt>		<comment type="block">/* type of value provided */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>attrtype</name></decl>;</decl_stmt>		<comment type="block">/* type of target column */</comment>
	<decl_stmt><decl><type><name>int32</name></type>		<name>attrtypmod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>attrcollation</name></decl>;</decl_stmt>	<comment type="block">/* collation of target column */</comment>
	<decl_stmt><decl><type><name>ParseExprKind</name></type> <name>sv_expr_kind</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Save and restore identity of expression type we're parsing.  We must
	 * set p_expr_kind here because we can parse subscripts without going
	 * through transformExpr().
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>exprKind</name> <operator>!=</operator> <name>EXPR_KIND_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sv_expr_kind</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>exprKind</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rd</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsYsqlUpgrade</name> <operator>&amp;&amp;</operator> <name>attrno</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot assign to system column \"%s\""</literal></expr></argument>,
						<argument><expr><name>colname</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>attrtype</name> <operator>=</operator> <call><name>attnumTypeId</name><argument_list>(<argument><expr><name>rd</name></expr></argument>, <argument><expr><name>attrno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attrtypmod</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>rd</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>attrno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypmod</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>attrcollation</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>rd</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>attrno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attcollation</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the expression is a DEFAULT placeholder, insert the attribute's
	 * type/typmod/collation into it so that exprType etc will report the
	 * right things.  (We expect that the eventually substituted default
	 * expression will in fact have this type and typmod.  The collation
	 * likely doesn't matter, but let's set it correctly anyway.)  Also,
	 * reject trying to update a subfield or array element with DEFAULT, since
	 * there can't be any default for portions of a column.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>expr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>SetToDefault</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SetToDefault</name> <modifier>*</modifier></type><name>def</name> <init>= <expr><operator>(</operator><name>SetToDefault</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>typeId</name></name> <operator>=</operator> <name>attrtype</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>typeMod</name></name> <operator>=</operator> <name>attrtypmod</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>collation</name></name> <operator>=</operator> <name>attrcollation</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>indirection</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>indirection</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>A_Indices</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot set an array element to DEFAULT"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot set a subfield to DEFAULT"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Now we can use exprType() safely. */</comment>
	<expr_stmt><expr><name>type_id</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there is indirection on the target column, prepare an array or
	 * subfield assignment expression.  This will generate a new column value
	 * that the source value has been inserted into, which can then be placed
	 * in the new tuple constructed by INSERT or UPDATE.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>indirection</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>colVar</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_is_insert</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The command is INSERT INTO table (col.something) ... so there
			 * is not really a source value to work with. Insert a NULL
			 * constant as the source value.
			 */</comment>
			<expr_stmt><expr><name>colVar</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeNullConst</name><argument_list>(<argument><expr><name>attrtype</name></expr></argument>, <argument><expr><name>attrtypmod</name></expr></argument>,
											<argument><expr><name>attrcollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Build a Var for the column to be updated.
			 */</comment>
			<expr_stmt><expr><name>colVar</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_var</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
									   <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_rangetblentry</name></name></expr></argument>,
									   <argument><expr><name>attrno</name></expr></argument>,
									   <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator>
			<call><name>transformAssignmentIndirection</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										   <argument><expr><name>colVar</name></expr></argument>,
										   <argument><expr><name>colname</name></expr></argument>,
										   <argument><expr><name>false</name></expr></argument>,
										   <argument><expr><name>attrtype</name></expr></argument>,
										   <argument><expr><name>attrtypmod</name></expr></argument>,
										   <argument><expr><name>attrcollation</name></expr></argument>,
										   <argument><expr><call><name>list_head</name><argument_list>(<argument><expr><name>indirection</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>,
										   <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * For normal non-qualified target column, do type checking and
		 * coercion.
		 */</comment>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>orig_expr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator>
			<call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
								  <argument><expr><name>orig_expr</name></expr></argument>, <argument><expr><name>type_id</name></expr></argument>,
								  <argument><expr><name>attrtype</name></expr></argument>, <argument><expr><name>attrtypmod</name></expr></argument>,
								  <argument><expr><name>COERCION_ASSIGNMENT</name></expr></argument>,
								  <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
								  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>expr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" is of type %s"</literal>
							<literal type="string">" but expression is of type %s"</literal></expr></argument>,
							<argument><expr><name>colname</name></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>attrtype</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>type_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You will need to rewrite or cast the expression."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>orig_expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>sv_expr_kind</name></expr>;</expr_stmt>

	<return>return <expr><name>expr</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * updateTargetListEntry()
 *	This is used in UPDATE statements (and ON CONFLICT DO UPDATE)
 *	only.  It prepares an UPDATE TargetEntry for assignment to a
 *	column of the target table.  This includes coercing the given
 *	value to the target column's type (if necessary), and dealing with
 *	any subfield names or subscripts attached to the target column
 *	itself.
 *
 * pstate		parse state
 * tle			target list entry to be modified
 * colname		target column name (ie, name of attribute to be assigned to)
 * attrno		target attribute number
 * indirection	subscripts/field names for target column, if any
 * location		error cursor position (should point at column name), or -1
 */</comment>
<function><type><name>void</name></type>
<name>updateTargetListEntry</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
					  <parameter><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl></parameter>,
					  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>attrno</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indirection</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Fix up expression as needed */</comment>
	<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <call><name>transformAssignedExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
									  <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
									  <argument><expr><name>EXPR_KIND_UPDATE_TARGET</name></expr></argument>,
									  <argument><expr><name>colname</name></expr></argument>,
									  <argument><expr><name>attrno</name></expr></argument>,
									  <argument><expr><name>indirection</name></expr></argument>,
									  <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set the resno to identify the target column --- the rewriter and
	 * planner depend on this.  We also set the resname to identify the target
	 * column, but this is only for debugging purposes; it should not be
	 * relied on.  (In particular, it might be out of date in a stored rule.)
	 */</comment>
	<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name><operator>)</operator> <name>attrno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>resname</name></name> <operator>=</operator> <name>colname</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Process indirection (field selection or subscripting) of the target
 * column in INSERT/UPDATE.  This routine recurses for multiple levels
 * of indirection --- but note that several adjacent A_Indices nodes in
 * the indirection list are treated as a single multidimensional subscript
 * operation.
 *
 * In the initial call, basenode is a Var for the target column in UPDATE,
 * or a null Const of the target's type in INSERT.  In recursive calls,
 * basenode is NULL, indicating that a substitute node should be consed up if
 * needed.
 *
 * targetName is the name of the field or subfield we're assigning to, and
 * targetIsArray is true if we're subscripting it.  These are just for
 * error reporting.
 *
 * targetTypeId, targetTypMod, targetCollation indicate the datatype and
 * collation of the object to be assigned to (initially the target column,
 * later some subobject).
 *
 * indirection is the sublist remaining to process.  When it's NULL, we're
 * done recursing and can just coerce and return the RHS.
 *
 * rhs is the already-transformed value to be assigned; note it has not been
 * coerced to any particular type.
 *
 * location is the cursor error position for any errors.  (Note: this points
 * to the head of the target clause, eg "foo" in "foo.bar[baz]".  Later we
 * might want to decorate indirection cells with their own location info,
 * in which case the location argument could probably be dropped.)
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformAssignmentIndirection</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
							   <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>basenode</name></decl></parameter>,
							   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetName</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name></type> <name>targetIsArray</name></decl></parameter>,
							   <parameter><decl><type><name>Oid</name></type> <name>targetTypeId</name></decl></parameter>,
							   <parameter><decl><type><name>int32</name></type> <name>targetTypMod</name></decl></parameter>,
							   <parameter><decl><type><name>Oid</name></type> <name>targetCollation</name></decl></parameter>,
							   <parameter><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>indirection</name></decl></parameter>,
							   <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>rhs</name></decl></parameter>,
							   <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subscripts</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isSlice</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>indirection</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>basenode</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Set up a substitution.  We abuse CaseTestExpr for this.  It's safe
		 * to do so because the only nodes that will be above the CaseTestExpr
		 * in the finished expression will be FieldStore and ArrayRef nodes.
		 * (There could be other stuff in the tree, but it will be within
		 * other child fields of those node types.)
		 */</comment>
		<decl_stmt><decl><type><name>CaseTestExpr</name> <modifier>*</modifier></type><name>ctest</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CaseTestExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>ctest</name><operator>-&gt;</operator><name>typeId</name></name> <operator>=</operator> <name>targetTypeId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctest</name><operator>-&gt;</operator><name>typeMod</name></name> <operator>=</operator> <name>targetTypMod</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctest</name><operator>-&gt;</operator><name>collation</name></name> <operator>=</operator> <name>targetCollation</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>basenode</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>ctest</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We have to split any field-selection operations apart from
	 * subscripting.  Adjacent A_Indices nodes have to be treated as a single
	 * multidimensional subscript operation.
	 */</comment>
	<macro><name>for_each_cell</name><argument_list>(<argument>i</argument>, <argument>indirection</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>A_Indices</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>subscripts</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>subscripts</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>A_Indices</name> <operator>*</operator><operator>)</operator> <name>n</name><operator>)</operator><operator>-&gt;</operator><name>is_slice</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>isSlice</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>A_Star</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"row expansion via \"*\" is not supported here"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>FieldStore</name> <modifier>*</modifier></type><name>fstore</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>baseTypeId</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type>		<name>baseTypeMod</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>typrelid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>fieldTypeId</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type>		<name>fieldTypMod</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>fieldCollation</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* process subscripts before this field selection */</comment>
			<if_stmt><if>if <condition>(<expr><name>subscripts</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* recurse, and then return because we're done */</comment>
				<return>return <expr><call><name>transformAssignmentSubscripts</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
													 <argument><expr><name>basenode</name></expr></argument>,
													 <argument><expr><name>targetName</name></expr></argument>,
													 <argument><expr><name>targetTypeId</name></expr></argument>,
													 <argument><expr><name>targetTypMod</name></expr></argument>,
													 <argument><expr><name>targetCollation</name></expr></argument>,
													 <argument><expr><name>subscripts</name></expr></argument>,
													 <argument><expr><name>isSlice</name></expr></argument>,
													 <argument><expr><name>i</name></expr></argument>,
													 <argument><expr><name>rhs</name></expr></argument>,
													 <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* No subscripts, so can process field selection here */</comment>

			<comment type="block">/*
			 * Look up the composite type, accounting for possibility that
			 * what we are given is a domain over composite.
			 */</comment>
			<expr_stmt><expr><name>baseTypeMod</name> <operator>=</operator> <name>targetTypMod</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>baseTypeId</name> <operator>=</operator> <call><name>getBaseTypeAndTypmod</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>baseTypeMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>typrelid</name> <operator>=</operator> <call><name>typeidTypeRelid</name><argument_list>(<argument><expr><name>baseTypeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>typrelid</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot assign to field \"%s\" of column \"%s\" because its type %s is not a composite type"</literal></expr></argument>,
								<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>targetName</name></expr></argument>,
								<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>attnum</name> <operator>=</operator> <call><name>get_attnum</name><argument_list>(<argument><expr><name>typrelid</name></expr></argument>, <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot assign to field \"%s\" of column \"%s\" because there is no such column in data type %s"</literal></expr></argument>,
								<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>targetName</name></expr></argument>,
								<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot assign to system column \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>get_atttypetypmodcoll</name><argument_list>(<argument><expr><name>typrelid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>fieldTypeId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fieldTypMod</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fieldCollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* recurse to create appropriate RHS for field assign */</comment>
			<expr_stmt><expr><name>rhs</name> <operator>=</operator> <call><name>transformAssignmentIndirection</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
												 <argument><expr><name>NULL</name></expr></argument>,
												 <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><name>false</name></expr></argument>,
												 <argument><expr><name>fieldTypeId</name></expr></argument>,
												 <argument><expr><name>fieldTypMod</name></expr></argument>,
												 <argument><expr><name>fieldCollation</name></expr></argument>,
												 <argument><expr><call><name>lnext</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><name>rhs</name></expr></argument>,
												 <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* and build a FieldStore node */</comment>
			<expr_stmt><expr><name>fstore</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>FieldStore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fstore</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>basenode</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fstore</name><operator>-&gt;</operator><name>newvals</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fstore</name><operator>-&gt;</operator><name>fieldnums</name></name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fstore</name><operator>-&gt;</operator><name>resulttype</name></name> <operator>=</operator> <name>baseTypeId</name></expr>;</expr_stmt>

			<comment type="block">/* If target is a domain, apply constraints */</comment>
			<if_stmt><if>if <condition>(<expr><name>baseTypeId</name> <operator>!=</operator> <name>targetTypeId</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>coerce_to_domain</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>fstore</name></expr></argument>,
										<argument><expr><name>baseTypeId</name></expr></argument>, <argument><expr><name>baseTypeMod</name></expr></argument>,
										<argument><expr><name>targetTypeId</name></expr></argument>,
										<argument><expr><name>COERCION_IMPLICIT</name></expr></argument>,
										<argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
										<argument><expr><name>location</name></expr></argument>,
										<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>fstore</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/* process trailing subscripts, if any */</comment>
	<if_stmt><if>if <condition>(<expr><name>subscripts</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* recurse, and then return because we're done */</comment>
		<return>return <expr><call><name>transformAssignmentSubscripts</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
											 <argument><expr><name>basenode</name></expr></argument>,
											 <argument><expr><name>targetName</name></expr></argument>,
											 <argument><expr><name>targetTypeId</name></expr></argument>,
											 <argument><expr><name>targetTypMod</name></expr></argument>,
											 <argument><expr><name>targetCollation</name></expr></argument>,
											 <argument><expr><name>subscripts</name></expr></argument>,
											 <argument><expr><name>isSlice</name></expr></argument>,
											 <argument><expr><name>NULL</name></expr></argument>,
											 <argument><expr><name>rhs</name></expr></argument>,
											 <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* base case: just coerce RHS to match target type ID */</comment>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
								   <argument><expr><name>rhs</name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>targetTypeId</name></expr></argument>, <argument><expr><name>targetTypMod</name></expr></argument>,
								   <argument><expr><name>COERCION_ASSIGNMENT</name></expr></argument>,
								   <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
								   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>targetIsArray</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"array assignment to \"%s\" requires type %s"</literal>
							<literal type="string">" but expression is of type %s"</literal></expr></argument>,
							<argument><expr><name>targetName</name></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You will need to rewrite or cast the expression."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"subfield \"%s\" is of type %s"</literal>
							<literal type="string">" but expression is of type %s"</literal></expr></argument>,
							<argument><expr><name>targetName</name></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You will need to rewrite or cast the expression."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * helper for transformAssignmentIndirection: process array assignment
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformAssignmentSubscripts</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
							  <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>basenode</name></decl></parameter>,
							  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetName</name></decl></parameter>,
							  <parameter><decl><type><name>Oid</name></type> <name>targetTypeId</name></decl></parameter>,
							  <parameter><decl><type><name>int32</name></type> <name>targetTypMod</name></decl></parameter>,
							  <parameter><decl><type><name>Oid</name></type> <name>targetCollation</name></decl></parameter>,
							  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>subscripts</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name></type> <name>isSlice</name></decl></parameter>,
							  <parameter><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>next_indirection</name></decl></parameter>,
							  <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>rhs</name></decl></parameter>,
							  <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>arrayType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>arrayTypMod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>elementTypeId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typeNeeded</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>collationNeeded</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>subscripts</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Identify the actual array type and element type involved */</comment>
	<expr_stmt><expr><name>arrayType</name> <operator>=</operator> <name>targetTypeId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>arrayTypMod</name> <operator>=</operator> <name>targetTypMod</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>elementTypeId</name> <operator>=</operator> <call><name>transformArrayType</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arrayType</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arrayTypMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Identify type that RHS must provide */</comment>
	<expr_stmt><expr><name>typeNeeded</name> <operator>=</operator> <ternary><condition><expr><name>isSlice</name></expr> ?</condition><then> <expr><name>arrayType</name></expr> </then><else>: <expr><name>elementTypeId</name></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/*
	 * Array normally has same collation as elements, but there's an
	 * exception: we might be subscripting a domain over an array type. In
	 * that case use collation of the base type.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>arrayType</name> <operator>==</operator> <name>targetTypeId</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>collationNeeded</name> <operator>=</operator> <name>targetCollation</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>collationNeeded</name> <operator>=</operator> <call><name>get_typcollation</name><argument_list>(<argument><expr><name>arrayType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* recurse to create appropriate RHS for array assign */</comment>
	<expr_stmt><expr><name>rhs</name> <operator>=</operator> <call><name>transformAssignmentIndirection</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										 <argument><expr><name>NULL</name></expr></argument>,
										 <argument><expr><name>targetName</name></expr></argument>,
										 <argument><expr><name>true</name></expr></argument>,
										 <argument><expr><name>typeNeeded</name></expr></argument>,
										 <argument><expr><name>arrayTypMod</name></expr></argument>,
										 <argument><expr><name>collationNeeded</name></expr></argument>,
										 <argument><expr><name>next_indirection</name></expr></argument>,
										 <argument><expr><name>rhs</name></expr></argument>,
										 <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* process subscripts */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>transformArraySubscripts</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
											   <argument><expr><name>basenode</name></expr></argument>,
											   <argument><expr><name>arrayType</name></expr></argument>,
											   <argument><expr><name>elementTypeId</name></expr></argument>,
											   <argument><expr><name>arrayTypMod</name></expr></argument>,
											   <argument><expr><name>subscripts</name></expr></argument>,
											   <argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If target was a domain over array, need to coerce up to the domain */</comment>
	<if_stmt><if>if <condition>(<expr><name>arrayType</name> <operator>!=</operator> <name>targetTypeId</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>resulttype</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
									   <argument><expr><name>result</name></expr></argument>, <argument><expr><name>resulttype</name></expr></argument>,
									   <argument><expr><name>targetTypeId</name></expr></argument>, <argument><expr><name>targetTypMod</name></expr></argument>,
									   <argument><expr><name>COERCION_ASSIGNMENT</name></expr></argument>,
									   <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
									   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* can fail if we had int2vector/oidvector, but not for true domains */</comment>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CANNOT_COERCE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot cast type %s to %s"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * checkInsertTargets -
 *	  generate a list of INSERT column targets if not supplied, or
 *	  test supplied column names to make sure they are in target table.
 *	  Also return an integer list of the columns' attribute numbers.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>checkInsertTargets</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>cols</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>attrnos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>attrnos</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>cols</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Generate default column list for INSERT.
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>numcol</name> <init>= <expr><call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numcol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>col</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>col</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ResTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>col</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>col</name><operator>-&gt;</operator><name>indirection</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>col</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>col</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>cols</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>cols</name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>attrnos</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><operator>*</operator><name>attrnos</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Do initial validation of user-supplied INSERT column list.
		 */</comment>
		<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>wholecols</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>partialcols</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>tl</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>tl</argument>, <argument>cols</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>col</name> <init>= <expr><operator>(</operator><name>ResTarget</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>tl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>col</name><operator>-&gt;</operator><name>name</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>attrno</name></decl>;</decl_stmt>

			<comment type="block">/* Lookup column name, ereport on failure */</comment>
			<expr_stmt><expr><name>attrno</name> <operator>=</operator> <call><name>attnameAttNum</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>,
								   <argument><expr><name>IsYsqlUpgrade</name></expr></argument> <comment type="block">/* sysColOK */</comment>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>attrno</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
								<argument><expr><name>name</name></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>col</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Check for duplicates, but only of whole columns --- we allow
			 * INSERT INTO foo (col.subcol1, col.subcol2)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>col</name><operator>-&gt;</operator><name>indirection</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * In YSQL upgrade mode, we allow oid column for INSERT.
				 * Bitmap sets can't handle negative values, so we skip
				 * duplicate validation.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsYsqlUpgrade</name> <operator>||</operator> <name>attrno</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* whole column; must not have any other assignment */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>attrno</name></expr></argument>, <argument><expr><name>wholecols</name></expr></argument>)</argument_list></call> <operator>||</operator>
						<call><name>bms_is_member</name><argument_list>(<argument><expr><name>attrno</name></expr></argument>, <argument><expr><name>partialcols</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" specified more than once"</literal></expr></argument>,
										<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>col</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>wholecols</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>wholecols</name></expr></argument>, <argument><expr><name>attrno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* partial column; must not have any whole assignment */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>attrno</name></expr></argument>, <argument><expr><name>wholecols</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" specified more than once"</literal></expr></argument>,
									<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>col</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>partialcols</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>partialcols</name></expr></argument>, <argument><expr><name>attrno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><operator>*</operator><name>attrnos</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><operator>*</operator><name>attrnos</name></expr></argument>, <argument><expr><name>attrno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>cols</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExpandColumnRefStar()
 *		Transforms foo.* into a list of expressions or targetlist entries.
 *
 * This handles the case where '*' appears as the last or only item in a
 * ColumnRef.  The code is shared between the case of foo.* at the top level
 * in a SELECT target list (where we want TargetEntry nodes in the result)
 * and foo.* in a ROW() or VALUES() construct (where we want just bare
 * expressions).
 *
 * The referenced columns are marked as requiring SELECT access.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>ExpandColumnRefStar</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ColumnRef</name> <modifier>*</modifier></type><name>cref</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>make_target_entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>fields</name> <init>= <expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numnames</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>fields</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>numnames</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Target item is a bare '*', expand all tables
		 *
		 * (e.g., SELECT * FROM emp, dept)
		 *
		 * Since the grammar only accepts bare '*' at top level of SELECT, we
		 * need not handle the make_target_entry==false case here.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>make_target_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>ExpandAllTables</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Target item is relation.*, expand that table
		 *
		 * (e.g., SELECT emp.*, dname FROM emp, dept)
		 *
		 * Note: this code is a lot like transformColumnRef; it's tempting to
		 * call that instead and then replace the resulting whole-row Var with
		 * a list of Vars.  However, that would leave us with the RTE's
		 * selectedCols bitmap showing the whole row as needing select
		 * permission, as well as the individual columns.  That would be
		 * incorrect (since columns added later shouldn't need select
		 * permissions).  We could try to remove the whole-row permission bit
		 * after the fact, but duplicating code is less messy.
		 */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nspname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>relname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>levels_up</name></decl>;</decl_stmt>
		<enum>enum
		<block>{
			<decl><name>CRSERR_NO_RTE</name></decl>,
			<decl><name>CRSERR_WRONG_DB</name></decl>,
			<decl><name>CRSERR_TOO_MANY</name></decl>
		}</block>			<decl><name>crserr</name> <init>= <expr><name>CRSERR_NO_RTE</name></expr></init></decl>;</enum>

		<comment type="block">/*
		 * Give the PreParseColumnRefHook, if any, first shot.  If it returns
		 * non-null then we should use that expression.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_pre_columnref_hook</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name><name>pstate</name><operator>-&gt;</operator><name>p_pre_columnref_hook</name></name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>node</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>ExpandRowReference</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>make_target_entry</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<switch>switch <condition>(<expr><name>numnames</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="number">2</literal></expr>:</case>
				<expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>fields</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>refnameRangeTblEntry</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>,
										   <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>levels_up</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">3</literal></expr>:</case>
				<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>fields</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name>fields</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>refnameRangeTblEntry</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>,
										   <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>levels_up</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">4</literal></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>catname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>fields</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<comment type="block">/*
					 * We check the catalog name and then ignore it.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>catname</name></expr></argument>, <argument><expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>crserr</name> <operator>=</operator> <name>CRSERR_WRONG_DB</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name>fields</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>lthird</name><argument_list>(<argument><expr><name>fields</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>refnameRangeTblEntry</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>,
											   <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>levels_up</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>
			<default>default:</default>
				<expr_stmt><expr><name>crserr</name> <operator>=</operator> <name>CRSERR_TOO_MANY</name></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<comment type="block">/*
		 * Now give the PostParseColumnRefHook, if any, a chance. We cheat a
		 * bit by passing the RangeTblEntry, not a Var, as the planned
		 * translation.  (A single Var wouldn't be strictly correct anyway.
		 * This convention allows hooks that really care to know what is
		 * happening.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_post_columnref_hook</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name><name>pstate</name><operator>-&gt;</operator><name>p_post_columnref_hook</name></name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>cref</name></expr></argument>,
												 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>node</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>rte</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_AMBIGUOUS_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column reference \"%s\" is ambiguous"</literal></expr></argument>,
									<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<return>return <expr><call><name>ExpandRowReference</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>make_target_entry</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Throw error if no translation found.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>rte</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<switch>switch <condition>(<expr><name>crserr</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>CRSERR_NO_RTE</name></expr>:</case>
					<expr_stmt><expr><call><name>errorMissingRTE</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>makeRangeVar</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>,
														 <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>CRSERR_WRONG_DB</name></expr>:</case>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cross-database references are not implemented: %s"</literal></expr></argument>,
									<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>CRSERR_TOO_MANY</name></expr>:</case>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"improper qualified name (too many dotted names): %s"</literal></expr></argument>,
									<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * OK, expand the RTE into fields.
		 */</comment>
		<return>return <expr><call><name>ExpandSingleTable</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>, <argument><expr><name>make_target_entry</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExpandAllTables()
 *		Transforms '*' (in the target list) into a list of targetlist entries.
 *
 * tlist entries are generated for each relation visible for unqualified
 * column name access.  We do not consider qualified-name-only entries because
 * that would include input tables of aliasless JOINs, NEW/OLD pseudo-entries,
 * etc.
 *
 * The referenced relations/columns are marked as requiring SELECT access.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>ExpandAllTables</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>target</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found_table</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>pstate-&gt;p_namespace</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name> <init>= <expr><operator>(</operator><name>ParseNamespaceItem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_rte</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Ignore table-only items */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nsitem</name><operator>-&gt;</operator><name>p_cols_visible</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<comment type="block">/* Should not have any lateral-only items when parsing targetlist */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>nsitem</name><operator>-&gt;</operator><name>p_lateral_only</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Remember we found a p_cols_visible item */</comment>
		<expr_stmt><expr><name>found_table</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>target</name></expr></argument>,
							 <argument><expr><call><name>expandRelAttrs</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
											<argument><expr><name>rte</name></expr></argument>,
											<argument><expr><call><name>RTERangeTablePosn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>,
															  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><literal type="number">0</literal></expr></argument>,
											<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Check for "SELECT *;".  We do it this way, rather than checking for
	 * target == NIL, because we want to allow SELECT * FROM a zero_column
	 * table.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found_table</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SELECT * with no tables specified is not valid"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>target</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExpandIndirectionStar()
 *		Transforms foo.* into a list of expressions or targetlist entries.
 *
 * This handles the case where '*' appears as the last item in A_Indirection.
 * The code is shared between the case of foo.* at the top level in a SELECT
 * target list (where we want TargetEntry nodes in the result) and foo.* in
 * a ROW() or VALUES() construct (where we want just bare expressions).
 * For robustness, we use a separate "make_target_entry" flag to control
 * this rather than relying on exprKind.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>ExpandIndirectionStar</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>A_Indirection</name> <modifier>*</modifier></type><name>ind</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>make_target_entry</name></decl></parameter>, <parameter><decl><type><name>ParseExprKind</name></type> <name>exprKind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

	<comment type="block">/* Strip off the '*' to create a reference to the rowtype object */</comment>
	<expr_stmt><expr><name>ind</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>ind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ind</name><operator>-&gt;</operator><name>indirection</name></name> <operator>=</operator> <call><name>list_truncate</name><argument_list>(<argument><expr><name><name>ind</name><operator>-&gt;</operator><name>indirection</name></name></expr></argument>,
									 <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>ind</name><operator>-&gt;</operator><name>indirection</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* And transform that */</comment>
	<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>ind</name></expr></argument>, <argument><expr><name>exprKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Expand the rowtype expression into individual fields */</comment>
	<return>return <expr><call><name>ExpandRowReference</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>make_target_entry</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExpandSingleTable()
 *		Transforms foo.* into a list of expressions or targetlist entries.
 *
 * This handles the case where foo has been determined to be a simple
 * reference to an RTE, so we can just generate Vars for the expressions.
 *
 * The referenced columns are marked as requiring SELECT access.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>ExpandSingleTable</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>make_target_entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>sublevels_up</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rtindex</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rtindex</name> <operator>=</operator> <call><name>RTERangeTablePosn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sublevels_up</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>make_target_entry</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* expandRelAttrs handles permissions marking */</comment>
		<return>return <expr><call><name>expandRelAttrs</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name>sublevels_up</name></expr></argument>,
							  <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>vars</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>expandRTE</name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name>sublevels_up</name></expr></argument>, <argument><expr><name>location</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
				  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Require read access to the table.  This is normally redundant with
		 * the markVarForSelectPriv calls below, but not if the table has zero
		 * columns.
		 */</comment>
		<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>|=</operator> <name>ACL_SELECT</name></expr>;</expr_stmt>

		<comment type="block">/* Require read access to each column */</comment>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>vars</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>markVarForSelectPriv</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<return>return <expr><name>vars</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExpandRowReference()
 *		Transforms foo.* into a list of expressions or targetlist entries.
 *
 * This handles the case where foo is an arbitrary expression of composite
 * type.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>ExpandRowReference</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>make_target_entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupleDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numAttrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the rowtype expression is a whole-row Var, we can expand the fields
	 * as simple Vars.  Note: if the RTE is a relation, this case leaves us
	 * with the RTE's selectedCols bitmap showing the whole row as needing
	 * select permission, as well as the individual columns.  However, we can
	 * only get here for weird notations like (table.*).*, so it's not worth
	 * trying to clean up --- arguably, the permissions marking is correct
	 * anyway for such cases.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>varattno</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>GetRTEByRangeTablePosn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>ExpandSingleTable</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>location</name></name></expr></argument>, <argument><expr><name>make_target_entry</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise we have to do it the hard way.  Our current implementation is
	 * to generate multiple copies of the expression and do FieldSelects.
	 * (This can be pretty inefficient if the expression involves nontrivial
	 * computation :-(.)
	 *
	 * Verify it's a composite type, and get the tupdesc.
	 * get_expr_result_tupdesc() handles this conveniently.
	 *
	 * If it's a Var of type RECORD, we have to work even harder: we have to
	 * find what the Var refers to, and pass that to get_expr_result_tupdesc.
	 * That task is handled by expandRecordVariable().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>vartype</name> <operator>==</operator> <name>RECORDOID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tupleDesc</name> <operator>=</operator> <call><name>expandRecordVariable</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>tupleDesc</name> <operator>=</operator> <call><name>get_expr_result_tupdesc</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Generate a list of references to the individual fields */</comment>
	<expr_stmt><expr><name>numAttrs</name> <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numAttrs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FieldSelect</name> <modifier>*</modifier></type><name>fselect</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>fselect</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>FieldSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fselect</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fselect</name><operator>-&gt;</operator><name>fieldnum</name></name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fselect</name><operator>-&gt;</operator><name>resulttype</name></name> <operator>=</operator> <name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fselect</name><operator>-&gt;</operator><name>resulttypmod</name></name> <operator>=</operator> <name><name>att</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>;</expr_stmt>
		<comment type="block">/* save attribute's collation for parse_collate.c */</comment>
		<expr_stmt><expr><name><name>fselect</name><operator>-&gt;</operator><name>resultcollid</name></name> <operator>=</operator> <name><name>att</name><operator>-&gt;</operator><name>attcollation</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>make_target_entry</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* add TargetEntry decoration */</comment>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>fselect</name></expr></argument>,
								 <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>,
								 <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>fselect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * expandRecordVariable
 *		Get the tuple descriptor for a Var of type RECORD, if possible.
 *
 * Since no actual table or view column is allowed to have type RECORD, such
 * a Var must refer to a JOIN or FUNCTION RTE or to a subquery output.  We
 * drill down to find the ultimate defining expression and attempt to infer
 * the tupdesc from it.  We ereport if we can't determine the tupdesc.
 *
 * levelsup is an extra offset to interpret the Var's varlevelsup correctly.
 */</comment>
<function><type><name>TupleDesc</name></type>
<name>expandRecordVariable</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>levelsup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupleDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>netlevelsup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

	<comment type="block">/* Check my caller didn't mess up */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>vartype</name></name> <operator>==</operator> <name>RECORDOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>netlevelsup</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>+</operator> <name>levelsup</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>GetRTEByRangeTablePosn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name>netlevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Whole-row reference to an RTE, so expand the known fields */</comment>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>names</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>vars</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lname</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>lvar</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>expandRTE</name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>location</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
				  <argument><expr><operator>&amp;</operator><name>names</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tupleDesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>vars</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<macro><name>forboth</name><argument_list>(<argument>lname</argument>, <argument>names</argument>, <argument>lvar</argument>, <argument>vars</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>label</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>varnode</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lvar</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
							   <argument><expr><name>label</name></expr></argument>,
							   <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>varnode</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>varnode</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>TupleDescInitEntryCollation</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
										<argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><name>varnode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>lname</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>lvar</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* lists same length? */</comment>

		<return>return <expr><name>tupleDesc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>var</name></expr>;</expr_stmt>		<comment type="block">/* default if we can't drill down */</comment>

	<switch>switch <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RTE_RELATION</name></expr>:</case>
		<case>case <expr><name>RTE_VALUES</name></expr>:</case>
		<case>case <expr><name>RTE_NAMEDTUPLESTORE</name></expr>:</case>

			<comment type="block">/*
			 * This case should not occur: a column of a table, values list,
			 * or ENR shouldn't have type RECORD.  Fall through and fail (most
			 * likely) at the bottom.
			 */</comment>
			<break>break;</break>
		<case>case <expr><name>RTE_SUBQUERY</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/* Subselect-in-FROM: examine sub-select's output expr */</comment>
				<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>ste</name> <init>= <expr><call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
													<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>ste</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>ste</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"subquery %s does not have attribute %d"</literal></expr></argument>,
						 <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>ste</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Recurse into the sub-select to see what its Var refers
					 * to.  We have to build an additional level of ParseState
					 * to keep in step with varlevelsup in the subselect.
					 */</comment>
					<decl_stmt><decl><type><name>ParseState</name></type>	<name>mypstate</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mypstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mypstate</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>mypstate</name><operator>.</operator><name>parentParseState</name></name> <operator>=</operator> <name>pstate</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>mypstate</name><operator>.</operator><name>p_rtable</name></name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>subquery</name><operator>-&gt;</operator><name>rtable</name></name></expr>;</expr_stmt>
					<comment type="block">/* don't bother filling the rest of the fake pstate */</comment>

					<return>return <expr><call><name>expandRecordVariable</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mypstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* else fall through to inspect the expression */</comment>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>RTE_JOIN</name></expr>:</case>
			<comment type="block">/* Join RTE --- recursively inspect the alias variable */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attnum</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>attnum</name> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>joinaliasvars</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>joinaliasvars</name></name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>expr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* We intentionally don't strip implicit coercions here */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>expandRecordVariable</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>, <argument><expr><name>netlevelsup</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
			<comment type="block">/* else fall through to inspect the expression */</comment>
			<break>break;</break>
		<case>case <expr><name>RTE_FUNCTION</name></expr>:</case>

			<comment type="block">/*
			 * We couldn't get here unless a function is declared with one of
			 * its result columns as RECORD, which is not allowed.
			 */</comment>
			<break>break;</break>
		<case>case <expr><name>RTE_TABLEFUNC</name></expr>:</case>

			<comment type="block">/*
			 * Table function cannot have columns with RECORD type.
			 */</comment>
			<break>break;</break>
		<case>case <expr><name>RTE_CTE</name></expr>:</case>
			<comment type="block">/* CTE reference: examine subquery's output expr */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rte</name><operator>-&gt;</operator><name>self_reference</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name> <init>= <expr><call><name>GetCTEForRTE</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>netlevelsup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>ste</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>ste</name> <operator>=</operator> <call><name>get_tle_by_resno</name><argument_list>(<argument><expr><call><name>GetCTETargetList</name><argument_list>(<argument><expr><name>cte</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>ste</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>ste</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"subquery %s does not have attribute %d"</literal></expr></argument>,
						 <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>ste</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Recurse into the CTE to see what its Var refers to. We
					 * have to build an additional level of ParseState to keep
					 * in step with varlevelsup in the CTE; furthermore it
					 * could be an outer CTE.
					 */</comment>
					<decl_stmt><decl><type><name>ParseState</name></type>	<name>mypstate</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Index</name></type>		<name>levelsup</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mypstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mypstate</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* this loop must work, since GetCTEForRTE did */</comment>
					<for>for <control>(<init><expr><name>levelsup</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init>
						 <condition><expr><name>levelsup</name> <operator>&lt;</operator> <name><name>rte</name><operator>-&gt;</operator><name>ctelevelsup</name></name> <operator>+</operator> <name>netlevelsup</name></expr>;</condition>
						 <incr><expr><name>levelsup</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
						<expr_stmt><expr><name>pstate</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>parentParseState</name></name></expr>;</expr_stmt></block_content></block></for>
					<expr_stmt><expr><name><name>mypstate</name><operator>.</operator><name>parentParseState</name></name> <operator>=</operator> <name>pstate</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>mypstate</name><operator>.</operator><name>p_rtable</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>cte</name><operator>-&gt;</operator><name>ctequery</name></name><operator>)</operator><operator>-&gt;</operator><name>rtable</name></expr>;</expr_stmt>
					<comment type="block">/* don't bother filling the rest of the fake pstate */</comment>

					<return>return <expr><call><name>expandRecordVariable</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mypstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* else fall through to inspect the expression */</comment>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * We now have an expression we can't expand any more, so see if
	 * get_expr_result_tupdesc() can do anything with it.
	 */</comment>
	<return>return <expr><call><name>get_expr_result_tupdesc</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FigureColname -
 *	  if the name of the resulting column is not specified in the target
 *	  list, we have to guess a suitable name.  The SQL spec provides some
 *	  guidance, but not much...
 *
 * Note that the argument is the *untransformed* parse tree for the target
 * item.  This is a shade easier to work with than the transformed tree.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>FigureColname</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>FigureColnameInternal</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>name</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* default result if we can't guess anything */</comment>
	<return>return <expr><literal type="string">"?column?"</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * FigureIndexColname -
 *	  choose the name for an expression column in an index
 *
 * This is actually just like FigureColname, except we return NULL if
 * we can't pick a good name.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>FigureIndexColname</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>FigureColnameInternal</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>name</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * FigureColnameInternal -
 *	  internal workhorse for FigureColname
 *
 * Return value indicates strength of confidence in result:
 *		0 - no information
 *		1 - second-best name choice
 *		2 - good name choice
 * The return value is actually only used internally.
 * If the result isn't zero, *name is set to the chosen name.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>FigureColnameInternal</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>strength</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>strength</name></expr>;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_ColumnRef</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

				<comment type="block">/* find last field name, if any, ignoring "*" */</comment>
				<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>((ColumnRef *) node)-&gt;fields</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>i</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block>
				<if_stmt><if>if <condition>(<expr><name>fname</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <name>fname</name></expr>;</expr_stmt>
					<return>return <expr><literal type="number">2</literal></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_A_Indirection</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>A_Indirection</name> <modifier>*</modifier></type><name>ind</name> <init>= <expr><operator>(</operator><name>A_Indirection</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

				<comment type="block">/* find last field name, if any, ignoring "*" and subscripts */</comment>
				<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>ind-&gt;indirection</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>i</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block>
				<if_stmt><if>if <condition>(<expr><name>fname</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <name>fname</name></expr>;</expr_stmt>
					<return>return <expr><literal type="number">2</literal></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<return>return <expr><call><name>FigureColnameInternal</name><argument_list>(<argument><expr><name><name>ind</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_FuncCall</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>llast</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>FuncCall</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>funcname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><literal type="number">2</literal></expr>;</return>
		<case>case <expr><name>T_A_Expr</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>A_Expr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>kind</name> <operator>==</operator> <name>AEXPR_NULLIF</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* make nullif() act like a regular function */</comment>
				<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"nullif"</literal></expr>;</expr_stmt>
				<return>return <expr><literal type="number">2</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>A_Expr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>kind</name> <operator>==</operator> <name>AEXPR_PAREN</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* look through dummy parenthesis node */</comment>
				<return>return <expr><call><name>FigureColnameInternal</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>A_Expr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>lexpr</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_TypeCast</name></expr>:</case>
			<expr_stmt><expr><name>strength</name> <operator>=</operator> <call><name>FigureColnameInternal</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>TypeCast</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>,
											 <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>strength</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>TypeCast</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>typeName</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>llast</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>TypeCast</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name><name>typeName</name><operator>-&gt;</operator><name>names</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><literal type="number">1</literal></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CollateClause</name></expr>:</case>
			<return>return <expr><call><name>FigureColnameInternal</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>CollateClause</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_GroupingFunc</name></expr>:</case>
			<comment type="block">/* make GROUPING() act like a regular function */</comment>
			<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"grouping"</literal></expr>;</expr_stmt>
			<return>return <expr><literal type="number">2</literal></expr>;</return>
		<case>case <expr><name>T_SubLink</name></expr>:</case>
			<switch>switch <condition>(<expr><operator>(</operator><operator>(</operator><name>SubLink</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>subLinkType</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>EXISTS_SUBLINK</name></expr>:</case>
					<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"exists"</literal></expr>;</expr_stmt>
					<return>return <expr><literal type="number">2</literal></expr>;</return>
				<case>case <expr><name>ARRAY_SUBLINK</name></expr>:</case>
					<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"array"</literal></expr>;</expr_stmt>
					<return>return <expr><literal type="number">2</literal></expr>;</return>
				<case>case <expr><name>EXPR_SUBLINK</name></expr>:</case>
					<block>{<block_content>
						<comment type="block">/* Get column name of the subquery's single target */</comment>
						<decl_stmt><decl><type><name>SubLink</name>    <modifier>*</modifier></type><name>sublink</name> <init>= <expr><operator>(</operator><name>SubLink</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>sublink</name><operator>-&gt;</operator><name>subselect</name></name></expr></init></decl>;</decl_stmt>

						<comment type="block">/*
						 * The subquery has probably already been transformed,
						 * but let's be careful and check that.  (The reason
						 * we can see a transformed subquery here is that
						 * transformSubLink is lazy and modifies the SubLink
						 * node in-place.)
						 */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

							<if_stmt><if>if <condition>(<expr><name><name>te</name><operator>-&gt;</operator><name>resname</name></name></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>resname</name></name></expr>;</expr_stmt>
								<return>return <expr><literal type="number">2</literal></expr>;</return>
							</block_content>}</block></if></if_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block>
					<break>break;</break>
					<comment type="block">/* As with other operator-like nodes, these have no names */</comment>
				<case>case <expr><name>MULTIEXPR_SUBLINK</name></expr>:</case>
				<case>case <expr><name>ALL_SUBLINK</name></expr>:</case>
				<case>case <expr><name>ANY_SUBLINK</name></expr>:</case>
				<case>case <expr><name>ROWCOMPARE_SUBLINK</name></expr>:</case>
				<case>case <expr><name>CTE_SUBLINK</name></expr>:</case>
					<break>break;</break>
			</block_content>}</block></switch>
			<break>break;</break>
		<case>case <expr><name>T_CaseExpr</name></expr>:</case>
			<expr_stmt><expr><name>strength</name> <operator>=</operator> <call><name>FigureColnameInternal</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>CaseExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>defresult</name></expr></argument>,
											 <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>strength</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"case"</literal></expr>;</expr_stmt>
				<return>return <expr><literal type="number">1</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_A_ArrayExpr</name></expr>:</case>
			<comment type="block">/* make ARRAY[] act like a function */</comment>
			<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"array"</literal></expr>;</expr_stmt>
			<return>return <expr><literal type="number">2</literal></expr>;</return>
		<case>case <expr><name>T_RowExpr</name></expr>:</case>
			<comment type="block">/* make ROW() act like a function */</comment>
			<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"row"</literal></expr>;</expr_stmt>
			<return>return <expr><literal type="number">2</literal></expr>;</return>
		<case>case <expr><name>T_CoalesceExpr</name></expr>:</case>
			<comment type="block">/* make coalesce() act like a regular function */</comment>
			<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"coalesce"</literal></expr>;</expr_stmt>
			<return>return <expr><literal type="number">2</literal></expr>;</return>
		<case>case <expr><name>T_MinMaxExpr</name></expr>:</case>
			<comment type="block">/* make greatest/least act like a regular function */</comment>
			<switch>switch <condition>(<expr><operator>(</operator><operator>(</operator><name>MinMaxExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>op</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>IS_GREATEST</name></expr>:</case>
					<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"greatest"</literal></expr>;</expr_stmt>
					<return>return <expr><literal type="number">2</literal></expr>;</return>
				<case>case <expr><name>IS_LEAST</name></expr>:</case>
					<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"least"</literal></expr>;</expr_stmt>
					<return>return <expr><literal type="number">2</literal></expr>;</return>
			</block_content>}</block></switch>
			<break>break;</break>
		<case>case <expr><name>T_SQLValueFunction</name></expr>:</case>
			<comment type="block">/* make these act like a function or variable */</comment>
			<switch>switch <condition>(<expr><operator>(</operator><operator>(</operator><name>SQLValueFunction</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>op</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>SVFOP_CURRENT_DATE</name></expr>:</case>
					<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"current_date"</literal></expr>;</expr_stmt>
					<return>return <expr><literal type="number">2</literal></expr>;</return>
				<case>case <expr><name>SVFOP_CURRENT_TIME</name></expr>:</case>
				<case>case <expr><name>SVFOP_CURRENT_TIME_N</name></expr>:</case>
					<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"current_time"</literal></expr>;</expr_stmt>
					<return>return <expr><literal type="number">2</literal></expr>;</return>
				<case>case <expr><name>SVFOP_CURRENT_TIMESTAMP</name></expr>:</case>
				<case>case <expr><name>SVFOP_CURRENT_TIMESTAMP_N</name></expr>:</case>
					<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"current_timestamp"</literal></expr>;</expr_stmt>
					<return>return <expr><literal type="number">2</literal></expr>;</return>
				<case>case <expr><name>SVFOP_LOCALTIME</name></expr>:</case>
				<case>case <expr><name>SVFOP_LOCALTIME_N</name></expr>:</case>
					<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"localtime"</literal></expr>;</expr_stmt>
					<return>return <expr><literal type="number">2</literal></expr>;</return>
				<case>case <expr><name>SVFOP_LOCALTIMESTAMP</name></expr>:</case>
				<case>case <expr><name>SVFOP_LOCALTIMESTAMP_N</name></expr>:</case>
					<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"localtimestamp"</literal></expr>;</expr_stmt>
					<return>return <expr><literal type="number">2</literal></expr>;</return>
				<case>case <expr><name>SVFOP_CURRENT_ROLE</name></expr>:</case>
					<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"current_role"</literal></expr>;</expr_stmt>
					<return>return <expr><literal type="number">2</literal></expr>;</return>
				<case>case <expr><name>SVFOP_CURRENT_USER</name></expr>:</case>
					<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"current_user"</literal></expr>;</expr_stmt>
					<return>return <expr><literal type="number">2</literal></expr>;</return>
				<case>case <expr><name>SVFOP_USER</name></expr>:</case>
					<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"user"</literal></expr>;</expr_stmt>
					<return>return <expr><literal type="number">2</literal></expr>;</return>
				<case>case <expr><name>SVFOP_SESSION_USER</name></expr>:</case>
					<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"session_user"</literal></expr>;</expr_stmt>
					<return>return <expr><literal type="number">2</literal></expr>;</return>
				<case>case <expr><name>SVFOP_CURRENT_CATALOG</name></expr>:</case>
					<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"current_catalog"</literal></expr>;</expr_stmt>
					<return>return <expr><literal type="number">2</literal></expr>;</return>
				<case>case <expr><name>SVFOP_CURRENT_SCHEMA</name></expr>:</case>
					<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"current_schema"</literal></expr>;</expr_stmt>
					<return>return <expr><literal type="number">2</literal></expr>;</return>
			</block_content>}</block></switch>
			<break>break;</break>
		<case>case <expr><name>T_XmlExpr</name></expr>:</case>
			<comment type="block">/* make SQL/XML functions act like a regular function */</comment>
			<switch>switch <condition>(<expr><operator>(</operator><operator>(</operator><name>XmlExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>op</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>IS_XMLCONCAT</name></expr>:</case>
					<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"xmlconcat"</literal></expr>;</expr_stmt>
					<return>return <expr><literal type="number">2</literal></expr>;</return>
				<case>case <expr><name>IS_XMLELEMENT</name></expr>:</case>
					<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"xmlelement"</literal></expr>;</expr_stmt>
					<return>return <expr><literal type="number">2</literal></expr>;</return>
				<case>case <expr><name>IS_XMLFOREST</name></expr>:</case>
					<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"xmlforest"</literal></expr>;</expr_stmt>
					<return>return <expr><literal type="number">2</literal></expr>;</return>
				<case>case <expr><name>IS_XMLPARSE</name></expr>:</case>
					<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"xmlparse"</literal></expr>;</expr_stmt>
					<return>return <expr><literal type="number">2</literal></expr>;</return>
				<case>case <expr><name>IS_XMLPI</name></expr>:</case>
					<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"xmlpi"</literal></expr>;</expr_stmt>
					<return>return <expr><literal type="number">2</literal></expr>;</return>
				<case>case <expr><name>IS_XMLROOT</name></expr>:</case>
					<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"xmlroot"</literal></expr>;</expr_stmt>
					<return>return <expr><literal type="number">2</literal></expr>;</return>
				<case>case <expr><name>IS_XMLSERIALIZE</name></expr>:</case>
					<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"xmlserialize"</literal></expr>;</expr_stmt>
					<return>return <expr><literal type="number">2</literal></expr>;</return>
				<case>case <expr><name>IS_DOCUMENT</name></expr>:</case>
					<comment type="block">/* nothing */</comment>
					<break>break;</break>
			</block_content>}</block></switch>
			<break>break;</break>
		<case>case <expr><name>T_XmlSerialize</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"xmlserialize"</literal></expr>;</expr_stmt>
			<return>return <expr><literal type="number">2</literal></expr>;</return>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>strength</name></expr>;</return>
</block_content>}</block></function>
</unit>
