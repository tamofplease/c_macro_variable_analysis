<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/libmdbx/src/lck-windows.c"><comment type="block">/*
 * Copyright 2015-2022 Leonid Yuriev &lt;leo@yuriev.ru&gt;
 * and other libmdbx authors: please see AUTHORS file.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted only as authorized by the OpenLDAP
 * Public License.
 *
 * A copy of this license is available in the file LICENSE in the
 * top-level directory of the distribution or, alternatively, at
 * &lt;http://www.OpenLDAP.org/license.html&gt;.
 */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_WIN64</name></expr></argument>)</argument_list></call></expr></cpp:if> <comment type="block">/* Windows LCK-implementation */</comment>

<comment type="block">/* PREAMBLE FOR WINDOWS:
 *
 * We are not concerned for performance here.
 * If you are running Windows a performance could NOT be the goal.
 * Otherwise please use Linux. */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internals.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>mdbx_winnt_import</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MDBX_BUILD_SHARED_LIBRARY</name></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MDBX_WITHOUT_MSVC_CRT</name> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* DEBUG/CHECKED builds still require MSVC's CRT for runtime checks.
 *
 * Define dll's entry point only for Release build when NDEBUG is defined and
 * MDBX_WITHOUT_MSVC_CRT=ON. if the entry point isn't defined then MSVC's will
 * automatically use DllMainCRTStartup() from CRT library, which also
 * automatically call DllMain() from our mdbx.dll */</comment>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>comment</name><name>(</name><name>linker</name><name>,</name> <cpp:literal>"/ENTRY:DllMain"</cpp:literal><name>)</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MDBX_WITHOUT_MSVC_CRT */</comment>

<decl_stmt><decl><type><name>BOOL</name> <name>APIENTRY</name></type> <name>DllMain</name><argument_list>(<argument><expr><name>HANDLE</name> <name>module</name></expr></argument>, <argument><expr><name>DWORD</name> <name>reason</name></expr></argument>, <argument><expr><name>LPVOID</name> <name>reserved</name></expr></argument>)</argument_list>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>MDBX_MANUAL_MODULE_HANDLER</name></expr></cpp:if>
static
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !MDBX_MANUAL_MODULE_HANDLER */</comment>
    <name>void</name> <name>NTAPI</name>
    <name>mdbx_module_handler</name><argument_list>(<argument><expr><name>PVOID</name> <name>module</name></expr></argument>, <argument><expr><name>DWORD</name> <name>reason</name></expr></argument>, <argument><expr><name>PVOID</name> <name>reserved</name></expr></argument>)</argument_list>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MDBX_BUILD_SHARED_LIBRARY */</comment>
<block>{<block_content>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>reserved</name></expr>;</expr_stmt>
  <switch>switch <condition>(<expr><name>reason</name></expr>)</condition> <block>{<block_content>
  <case>case <expr><name>DLL_PROCESS_ATTACH</name></expr>:</case>
    <expr_stmt><expr><call><name>mdbx_winnt_import</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mdbx_rthc_global_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  <case>case <expr><name>DLL_PROCESS_DETACH</name></expr>:</case>
    <expr_stmt><expr><call><name>mdbx_rthc_global_dtor</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

  <case>case <expr><name>DLL_THREAD_ATTACH</name></expr>:</case>
    <break>break;</break>
  <case>case <expr><name>DLL_THREAD_DETACH</name></expr>:</case>
    <expr_stmt><expr><call><name>mdbx_rthc_thread_dtor</name><argument_list>(<argument><expr><name>module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  </block_content>}</block></switch>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MDBX_BUILD_SHARED_LIBRARY</name></expr></cpp:if>
  <return>return <expr><name>TRUE</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></decl></decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>MDBX_BUILD_SHARED_LIBRARY</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>MDBX_MANUAL_MODULE_HANDLER</name></expr></cpp:if>
<comment type="block">/* *INDENT-OFF* */</comment>
<comment type="block">/* clang-format off */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:pragma>#  <cpp:directive>pragma</cpp:directive> <name>const_seg</name><name>(</name><name>push</name><name>)</name></cpp:pragma>
<cpp:pragma>#  <cpp:directive>pragma</cpp:directive> <name>data_seg</name><name>(</name><name>push</name><name>)</name></cpp:pragma>

<cpp:ifdef>#  <cpp:directive>ifdef</cpp:directive> <name>_WIN64</name></cpp:ifdef>
     <comment type="block">/* kick a linker to create the TLS directory if not already done */</comment>
<cpp:pragma>#    <cpp:directive>pragma</cpp:directive> <name>comment</name><name>(</name><name>linker</name><name>,</name> <cpp:literal>"/INCLUDE:_tls_used"</cpp:literal><name>)</name></cpp:pragma>
     <comment type="block">/* Force some symbol references. */</comment>
<cpp:pragma>#    <cpp:directive>pragma</cpp:directive> <name>comment</name><name>(</name><name>linker</name><name>,</name> <cpp:literal>"/INCLUDE:mdbx_tls_anchor"</cpp:literal><name>)</name></cpp:pragma>
     <comment type="block">/* specific const-segment for WIN64 */</comment>
<cpp:pragma>#    <cpp:directive>pragma</cpp:directive> <name>const_seg</name><name>(</name><cpp:literal>".CRT$XLB"</cpp:literal><name>)</name></cpp:pragma>
     <expr_stmt><expr><specifier>const</specifier>
<cpp:else>#  <cpp:directive>else</cpp:directive></cpp:else>
     <comment type="block">/* kick a linker to create the TLS directory if not already done */</comment>
<cpp:pragma>#    <cpp:directive>pragma</cpp:directive> <name>comment</name><name>(</name><name>linker</name><name>,</name> <cpp:literal>"/INCLUDE:__tls_used"</cpp:literal><name>)</name></cpp:pragma>
     <comment type="block">/* Force some symbol references. */</comment>
<cpp:pragma>#    <cpp:directive>pragma</cpp:directive> <name>comment</name><name>(</name><name>linker</name><name>,</name> <cpp:literal>"/INCLUDE:_mdbx_tls_anchor"</cpp:literal><name>)</name></cpp:pragma>
     <comment type="block">/* specific data-segment for WIN32 */</comment>
<cpp:pragma>#    <cpp:directive>pragma</cpp:directive> <name>data_seg</name><name>(</name><cpp:literal>".CRT$XLB"</cpp:literal><name>)</name></cpp:pragma>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>

   <macro><name>__declspec</name><argument_list>(<argument>allocate(<literal type="string">".CRT$XLB"</literal>)</argument>)</argument_list></macro> <name>PIMAGE_TLS_CALLBACK</name> <name>mdbx_tls_anchor</name> <operator>=</operator> <name>mdbx_module_handler</name></expr>;</expr_stmt>
<cpp:pragma>#  <cpp:directive>pragma</cpp:directive> <name>data_seg</name><name>(</name><name>pop</name><name>)</name></cpp:pragma>
<cpp:pragma>#  <cpp:directive>pragma</cpp:directive> <name>const_seg</name><name>(</name><name>pop</name><name>)</name></cpp:pragma>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:ifdef>#  <cpp:directive>ifdef</cpp:directive> <name>_WIN64</name></cpp:ifdef>
     <decl_stmt><decl><type><specifier>const</specifier>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
   <name>PIMAGE_TLS_CALLBACK</name> <name>mdbx_tls_anchor</name></type> <name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><call><name>__section__</name><argument_list>(<argument><expr><literal type="string">".CRT$XLB"</literal></expr></argument>)</argument_list></call><operator>,</operator> <name>used</name><operator>)</operator></expr></argument>)</argument_list> <init>= <expr><name>mdbx_module_handler</name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#  <cpp:directive>error</cpp:directive> FIXME</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* *INDENT-ON* */</comment>
<comment type="block">/* clang-format on */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !MDBX_BUILD_SHARED_LIBRARY &amp;&amp; !MDBX_MANUAL_MODULE_HANDLER */</comment>

<comment type="block">/*----------------------------------------------------------------------------*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LCK_SHARED</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LCK_EXCLUSIVE</name></cpp:macro> <cpp:value>LOCKFILE_EXCLUSIVE_LOCK</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LCK_WAITFOR</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LCK_DONTWAIT</name></cpp:macro> <cpp:value>LOCKFILE_FAIL_IMMEDIATELY</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>__inline</name> <name>BOOL</name></type> <name>flock</name><parameter_list>(<parameter><decl><type><name>mdbx_filehandle_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>DWORD</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>offset</name></decl></parameter>,
                           <parameter><decl><type><name>size_t</name></type> <name>bytes</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>OVERLAPPED</name></type> <name>ov</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>ov</name><operator>.</operator><name>hEvent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ov</name><operator>.</operator><name>Offset</name></name> <operator>=</operator> <operator>(</operator><name>DWORD</name><operator>)</operator><name>offset</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ov</name><operator>.</operator><name>OffsetHigh</name></name> <operator>=</operator> <call><name>HIGH_DWORD</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>LockFileEx</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>DWORD</name><operator>)</operator><name>bytes</name></expr></argument>, <argument><expr><call><name>HIGH_DWORD</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>ov</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>__inline</name> <name>BOOL</name></type> <name>funlock</name><parameter_list>(<parameter><decl><type><name>mdbx_filehandle_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>offset</name></decl></parameter>,
                             <parameter><decl><type><name>size_t</name></type> <name>bytes</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>UnlockFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>DWORD</name><operator>)</operator><name>offset</name></expr></argument>, <argument><expr><call><name>HIGH_DWORD</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>DWORD</name><operator>)</operator><name>bytes</name></expr></argument>,
                    <argument><expr><call><name>HIGH_DWORD</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*----------------------------------------------------------------------------*/</comment>
<comment type="block">/* global `write` lock for write-txt processing,
 * exclusive locking both meta-pages) */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LCK_MAXLEN</name></cpp:macro> <cpp:value>(1u + ((~(size_t)0) &gt;&gt; 1))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LCK_META_OFFSET</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LCK_META_LEN</name></cpp:macro> <cpp:value>(MAX_PAGESIZE * NUM_METAS)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LCK_BODY_OFFSET</name></cpp:macro> <cpp:value>LCK_META_LEN</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LCK_BODY_LEN</name></cpp:macro> <cpp:value>(LCK_MAXLEN - LCK_BODY_OFFSET)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LCK_BODY</name></cpp:macro> <cpp:value>LCK_BODY_OFFSET, LCK_BODY_LEN</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LCK_WHOLE</name></cpp:macro> <cpp:value>0, LCK_MAXLEN</cpp:value></cpp:define>

<function><type><name>int</name></type> <name>mdbx_txn_lock</name><parameter_list>(<parameter><decl><type><name>MDBX_env</name> <modifier>*</modifier></type><name>env</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>dontwait</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>dontwait</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TryEnterCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>env</name><operator>-&gt;</operator><name>me_windowsbug_lock</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>MDBX_BUSY</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <macro><name>__try</name></macro> <block>{<block_content>
      <expr_stmt><expr><call><name>EnterCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>env</name><operator>-&gt;</operator><name>me_windowsbug_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <macro><name>__except</name> <argument_list>(<argument>(GetExceptionCode() ==
                 <literal type="number">0xC0000194</literal> <comment type="block">/* STATUS_POSSIBLE_DEADLOCK / EXCEPTION_POSSIBLE_DEADLOCK */</comment>)
                    ? EXCEPTION_EXECUTE_HANDLER
                    : EXCEPTION_CONTINUE_SEARCH</argument>)</argument_list></macro> <block>{<block_content>
      <return>return <expr><name>ERROR_POSSIBLE_DEADLOCK</name></expr>;</return>
    </block_content>}</block>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>env</name><operator>-&gt;</operator><name>me_flags</name></name> <operator>&amp;</operator> <name>MDBX_EXCLUSIVE</name><operator>)</operator> <operator>||</operator>
      <call><name>flock</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>me_lazy_fd</name></name></expr></argument>,
            <argument><expr><ternary><condition><expr><name>dontwait</name></expr> ?</condition><then> <expr><operator>(</operator><name>LCK_EXCLUSIVE</name> <operator>|</operator> <name>LCK_DONTWAIT</name><operator>)</operator></expr>
                     </then><else>: <expr><operator>(</operator><name>LCK_EXCLUSIVE</name> <operator>|</operator> <name>LCK_WAITFOR</name><operator>)</operator></expr></else></ternary></expr></argument>,
            <argument><expr><name>LCK_BODY</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>MDBX_SUCCESS</name></expr>;</return></block_content></block></if></if_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>LeaveCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>env</name><operator>-&gt;</operator><name>me_windowsbug_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><ternary><condition><expr><operator>(</operator><operator>!</operator><name>dontwait</name> <operator>||</operator> <name>rc</name> <operator>!=</operator> <name>ERROR_LOCK_VIOLATION</name><operator>)</operator></expr> ?</condition><then> <expr><name>rc</name></expr> </then><else>: <expr><name>MDBX_BUSY</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>mdbx_txn_unlock</name><parameter_list>(<parameter><decl><type><name>MDBX_env</name> <modifier>*</modifier></type><name>env</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>env</name><operator>-&gt;</operator><name>me_flags</name></name> <operator>&amp;</operator> <name>MDBX_EXCLUSIVE</name><operator>)</operator></expr>
               ?</condition><then> <expr><name>TRUE</name></expr>
               </then><else>: <expr><call><name>funlock</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>me_lazy_fd</name></name></expr></argument>, <argument><expr><name>LCK_BODY</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>LeaveCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>env</name><operator>-&gt;</operator><name>me_windowsbug_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>rc</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>mdbx_panic</name><argument_list>(<argument><expr><literal type="string">"%s failed: err %u"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*----------------------------------------------------------------------------*/</comment>
<comment type="block">/* global `read` lock for readers registration,
 * exclusive locking `mti_numreaders` (second) cacheline */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LCK_LO_OFFSET</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LCK_LO_LEN</name></cpp:macro> <cpp:value>offsetof(MDBX_lockinfo, mti_numreaders)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LCK_UP_OFFSET</name></cpp:macro> <cpp:value>LCK_LO_LEN</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LCK_UP_LEN</name></cpp:macro> <cpp:value>(sizeof(MDBX_lockinfo) - LCK_UP_OFFSET)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LCK_LOWER</name></cpp:macro> <cpp:value>LCK_LO_OFFSET, LCK_LO_LEN</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LCK_UPPER</name></cpp:macro> <cpp:value>LCK_UP_OFFSET, LCK_UP_LEN</cpp:value></cpp:define>

<function><type><name>MDBX_INTERNAL_FUNC</name> <name>int</name></type> <name>mdbx_rdt_lock</name><parameter_list>(<parameter><decl><type><name>MDBX_env</name> <modifier>*</modifier></type><name>env</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>mdbx_srwlock_AcquireShared</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>env</name><operator>-&gt;</operator><name>me_remap_guard</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>env</name><operator>-&gt;</operator><name>me_lfd</name></name> <operator>==</operator> <name>INVALID_HANDLE_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>MDBX_SUCCESS</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* readonly database in readonly filesystem */</comment>

  <comment type="block">/* transition from S-? (used) to S-E (locked),
   * e.g. exclusive lock upper-part */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>env</name><operator>-&gt;</operator><name>me_flags</name></name> <operator>&amp;</operator> <name>MDBX_EXCLUSIVE</name><operator>)</operator> <operator>||</operator>
      <call><name>flock</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>me_lfd</name></name></expr></argument>, <argument><expr><name>LCK_EXCLUSIVE</name> <operator>|</operator> <name>LCK_WAITFOR</name></expr></argument>, <argument><expr><name>LCK_UPPER</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>MDBX_SUCCESS</name></expr>;</return></block_content></block></if></if_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>mdbx_srwlock_ReleaseShared</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>env</name><operator>-&gt;</operator><name>me_remap_guard</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>MDBX_INTERNAL_FUNC</name> <name>void</name></type> <name>mdbx_rdt_unlock</name><parameter_list>(<parameter><decl><type><name>MDBX_env</name> <modifier>*</modifier></type><name>env</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>env</name><operator>-&gt;</operator><name>me_lfd</name></name> <operator>!=</operator> <name>INVALID_HANDLE_VALUE</name></expr>)</condition> <block>{<block_content>
    <comment type="block">/* transition from S-E (locked) to S-? (used), e.g. unlock upper-part */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>env</name><operator>-&gt;</operator><name>me_flags</name></name> <operator>&amp;</operator> <name>MDBX_EXCLUSIVE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
        <operator>!</operator><call><name>funlock</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>me_lfd</name></name></expr></argument>, <argument><expr><name>LCK_UPPER</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>mdbx_panic</name><argument_list>(<argument><expr><literal type="string">"%s failed: err %u"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>mdbx_srwlock_ReleaseShared</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>env</name><operator>-&gt;</operator><name>me_remap_guard</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>MDBX_INTERNAL_FUNC</name> <name>int</name></type> <name>mdbx_lockfile</name><parameter_list>(<parameter><decl><type><name>mdbx_filehandle_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>wait</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><ternary><condition><expr><call><name>flock</name><argument_list>(<argument><expr><name>fd</name></expr></argument>,
               <argument><expr><ternary><condition><expr><name>wait</name></expr> ?</condition><then> <expr><name>LCK_EXCLUSIVE</name> <operator>|</operator> <name>LCK_WAITFOR</name></expr>
                    </then><else>: <expr><name>LCK_EXCLUSIVE</name> <operator>|</operator> <name>LCK_DONTWAIT</name></expr></else></ternary></expr></argument>,
               <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>LCK_MAXLEN</name></expr></argument>)</argument_list></call></expr>
             ?</condition><then> <expr><name>MDBX_SUCCESS</name></expr>
             </then><else>: <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>suspend_and_append</name><parameter_list>(<parameter><decl><type><name>mdbx_handle_array_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>array</name></decl></parameter>,
                              <parameter><decl><type><specifier>const</specifier> <name>DWORD</name></type> <name>ThreadId</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>limit</name> <init>= <expr><name><operator>(</operator><operator>*</operator><name>array</name><operator>)</operator><operator>-&gt;</operator><name>limit</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><operator>(</operator><operator>*</operator><name>array</name><operator>)</operator><operator>-&gt;</operator><name>count</name></name> <operator>==</operator> <name>limit</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>mdbx_realloc</name><argument_list>(
        <argument><expr><ternary><condition><expr><operator>(</operator><name>limit</name> <operator>&gt;</operator> <call><name>ARRAY_LENGTH</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>array</name><operator>)</operator><operator>-&gt;</operator><name>handles</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>
            ?</condition><then> <expr><operator>*</operator><name>array</name></expr>
            </then><else>: <comment type="block">/* don't free initial array on the stack */</comment> <expr><name>NULL</name></expr></else></ternary></expr></argument>,
        <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mdbx_handle_array_t</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
            <sizeof>sizeof<argument_list>(<argument><expr><name>HANDLE</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>limit</name> <operator>*</operator> <literal type="number">2</literal> <operator>-</operator> <call><name>ARRAY_LENGTH</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>array</name><operator>)</operator><operator>-&gt;</operator><name>handles</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>MDBX_ENOMEM</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>limit</name> <operator>==</operator> <call><name>ARRAY_LENGTH</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>array</name><operator>)</operator><operator>-&gt;</operator><name>handles</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><operator>*</operator><name>array</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mdbx_handle_array_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>array</name> <operator>=</operator> <operator>(</operator><name>mdbx_handle_array_t</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>array</name><operator>)</operator><operator>-&gt;</operator><name>limit</name></name> <operator>=</operator> <name>limit</name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>HANDLE</name></type> <name>hThread</name> <init>= <expr><call><name>OpenThread</name><argument_list>(<argument><expr><name>THREAD_SUSPEND_RESUME</name> <operator>|</operator> <name>THREAD_QUERY_INFORMATION</name></expr></argument>,
                              <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>ThreadId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>hThread</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>SuspendThread</name><argument_list>(<argument><expr><name>hThread</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>(</operator><name>DWORD</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DWORD</name></type> <name>ExitCode</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>err</name> <operator>==</operator> <comment type="block">/* workaround for Win10 UCRT bug */</comment> <name>ERROR_ACCESS_DENIED</name> <operator>||</operator>
        <operator>!</operator><call><name>GetExitCodeThread</name><argument_list>(<argument><expr><name>hThread</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ExitCode</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>ExitCode</name> <operator>!=</operator> <name>STILL_ACTIVE</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>err</name> <operator>=</operator> <name>MDBX_SUCCESS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hThread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>err</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>array</name><operator>)</operator><operator>-&gt;</operator><name>handles</name></name><index>[<expr><name><operator>(</operator><operator>*</operator><name>array</name><operator>)</operator><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>]</index> <operator>=</operator> <name>hThread</name></expr>;</expr_stmt>
  <return>return <expr><name>MDBX_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>MDBX_INTERNAL_FUNC</name> <name>int</name></type>
<name>mdbx_suspend_threads_before_remap</name><parameter_list>(<parameter><decl><type><name>MDBX_env</name> <modifier>*</modifier></type><name>env</name></decl></parameter>, <parameter><decl><type><name>mdbx_handle_array_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>array</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>mdbx_assert</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><operator>(</operator><name><name>env</name><operator>-&gt;</operator><name>me_flags</name></name> <operator>&amp;</operator> <name>MDBX_NOTLS</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uintptr_t</name></type> <name>CurrentTid</name> <init>= <expr><call><name>GetCurrentThreadId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>env</name><operator>-&gt;</operator><name>me_lck_mmap</name><operator>.</operator><name>lck</name></name></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Scan LCK for threads of the current process */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>MDBX_reader</name> <modifier>*</modifier><specifier>const</specifier></type> <name>begin</name> <init>= <expr><name><name>env</name><operator>-&gt;</operator><name>me_lck_mmap</name><operator>.</operator><name>lck</name><operator>-&gt;</operator><name>mti_readers</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>MDBX_reader</name> <modifier>*</modifier><specifier>const</specifier></type> <name>end</name> <init>=
        <expr><name>begin</name> <operator>+</operator>
        <call><name>atomic_load32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>env</name><operator>-&gt;</operator><name>me_lck_mmap</name><operator>.</operator><name>lck</name><operator>-&gt;</operator><name>mti_numreaders</name></name></expr></argument>, <argument><expr><name>mo_AcquireRelease</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>uintptr_t</name></type> <name>WriteTxnOwner</name> <init>= <expr><ternary><condition><expr><name><name>env</name><operator>-&gt;</operator><name>me_txn0</name></name></expr> ?</condition><then> <expr><name><name>env</name><operator>-&gt;</operator><name>me_txn0</name><operator>-&gt;</operator><name>mt_owner</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><specifier>const</specifier> <name>MDBX_reader</name> <modifier>*</modifier></type><name>reader</name> <init>= <expr><name>begin</name></expr></init></decl>;</init> <condition><expr><name>reader</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr><expr><operator>++</operator><name>reader</name></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>reader</name><operator>-&gt;</operator><name>mr_pid</name><operator>.</operator><name>weak</name></name> <operator>!=</operator> <name><name>env</name><operator>-&gt;</operator><name>me_pid</name></name> <operator>||</operator> <operator>!</operator><name><name>reader</name><operator>-&gt;</operator><name>mr_tid</name><operator>.</operator><name>weak</name></name></expr>)</condition> <block>{<block_content>
      <label><name>skip_lck</name>:</label>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>reader</name><operator>-&gt;</operator><name>mr_tid</name><operator>.</operator><name>weak</name></name> <operator>==</operator> <name>CurrentTid</name> <operator>||</operator>
          <name><name>reader</name><operator>-&gt;</operator><name>mr_tid</name><operator>.</operator><name>weak</name></name> <operator>==</operator> <name>WriteTxnOwner</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>skip_lck</name>;</goto></block_content></block></if></if_stmt>

      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>suspend_and_append</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><operator>(</operator><name>mdbx_tid_t</name><operator>)</operator><name><name>reader</name><operator>-&gt;</operator><name>mr_tid</name><operator>.</operator><name>weak</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>MDBX_SUCCESS</name></expr>)</condition> <block>{<block_content>
      <label><name>bailout_lck</name>:</label>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>mdbx_resume_threads_after_remap</name><argument_list>(<argument><expr><operator>*</operator><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>rc</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name>WriteTxnOwner</name> <operator>&amp;&amp;</operator> <name>WriteTxnOwner</name> <operator>!=</operator> <name>CurrentTid</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>suspend_and_append</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><operator>(</operator><name>mdbx_tid_t</name><operator>)</operator><name>WriteTxnOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>MDBX_SUCCESS</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>bailout_lck</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <comment type="block">/* Without LCK (i.e. read-only mode).
     * Walk through a snapshot of all running threads */</comment>
    <expr_stmt><expr><call><name>mdbx_assert</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><name><name>env</name><operator>-&gt;</operator><name>me_flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MDBX_EXCLUSIVE</name> <operator>|</operator> <name>MDBX_RDONLY</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>HANDLE</name></type> <name>hSnapshot</name> <init>= <expr><call><name>CreateToolhelp32Snapshot</name><argument_list>(<argument><expr><name>TH32CS_SNAPTHREAD</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>hSnapshot</name> <operator>==</operator> <name>INVALID_HANDLE_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>THREADENTRY32</name></type> <name>entry</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>.</operator><name>dwSize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>THREADENTRY32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>Thread32First</name><argument_list>(<argument><expr><name>hSnapshot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <label><name>bailout_toolhelp</name>:</label>
      <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>mdbx_resume_threads_after_remap</name><argument_list>(<argument><expr><operator>*</operator><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <do>do <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>th32OwnerProcessID</name></name> <operator>!=</operator> <name><name>env</name><operator>-&gt;</operator><name>me_pid</name></name> <operator>||</operator>
          <name><name>entry</name><operator>.</operator><name>th32ThreadID</name></name> <operator>==</operator> <name>CurrentTid</name></expr>)</condition><block type="pseudo"><block_content>
        <continue>continue;</continue></block_content></block></if></if_stmt>

      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>suspend_and_append</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>th32ThreadID</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>MDBX_SUCCESS</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>bailout_toolhelp</name>;</goto></block_content></block></if></if_stmt>

    </block_content>}</block> while <condition>(<expr><call><name>Thread32Next</name><argument_list>(<argument><expr><name>hSnapshot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>ERROR_NO_MORE_FILES</name></expr>)</condition><block type="pseudo"><block_content>
      <goto>goto <name>bailout_toolhelp</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>MDBX_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>MDBX_INTERNAL_FUNC</name> <name>int</name></type>
<name>mdbx_resume_threads_after_remap</name><parameter_list>(<parameter><decl><type><name>mdbx_handle_array_t</name> <modifier>*</modifier></type><name>array</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>MDBX_SUCCESS</name></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>array</name><operator>-&gt;</operator><name>count</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>HANDLE</name></type> <name>hThread</name> <init>= <expr><name><name>array</name><operator>-&gt;</operator><name>handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ResumeThread</name><argument_list>(<argument><expr><name>hThread</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>(</operator><name>DWORD</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>err</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>DWORD</name></type> <name>ExitCode</name></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <comment type="block">/* workaround for Win10 UCRT bug */</comment> <name>ERROR_ACCESS_DENIED</name> <operator>&amp;&amp;</operator>
          <call><name>GetExitCodeThread</name><argument_list>(<argument><expr><name>hThread</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ExitCode</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>ExitCode</name> <operator>==</operator> <name>STILL_ACTIVE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>err</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hThread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*----------------------------------------------------------------------------*/</comment>
<comment type="block">/* global `initial` lock for lockfile initialization,
 * exclusive/shared locking first cacheline */</comment>

<comment type="block">/* Briefly description of locking schema/algorithm:
 *  - Windows does not support upgrading or downgrading for file locking.
 *  - Therefore upgrading/downgrading is emulated by shared and exclusive
 *    locking of upper and lower halves.
 *  - In other words, we have FSM with possible 9 states,
 *    i.e. free/shared/exclusive x free/shared/exclusive == 9.
 *    Only 6 states of FSM are used, which 2 of ones are transitive.
 *
 * States:
 *   ?-?  = free, i.e. unlocked
 *   S-?  = used, i.e. shared lock
 *   E-?  = exclusive-read, i.e. operational exclusive
 *   ?-S
 *   ?-E  = middle (transitive state)
 *   S-S
 *   S-E  = locked (transitive state)
 *   E-S
 *   E-E  = exclusive-write, i.e. exclusive due (re)initialization
 *
 *  The mdbx_lck_seize() moves the locking-FSM from the initial free/unlocked
 *  state to the "exclusive write" (and returns MDBX_RESULT_TRUE) if possible,
 *  or to the "used" (and returns MDBX_RESULT_FALSE).
 *
 *  The mdbx_lck_downgrade() moves the locking-FSM from "exclusive write"
 *  state to the "used" (i.e. shared) state.
 *
 *  The mdbx_lck_upgrade() moves the locking-FSM from "used" (i.e. shared)
 *  state to the "exclusive write" state.
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>lck_unlock</name><parameter_list>(<parameter><decl><type><name>MDBX_env</name> <modifier>*</modifier></type><name>env</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>env</name><operator>-&gt;</operator><name>me_lfd</name></name> <operator>!=</operator> <name>INVALID_HANDLE_VALUE</name></expr>)</condition> <block>{<block_content>
    <comment type="block">/* double `unlock` for robustly remove overlapped shared/exclusive locks */</comment>
    <while>while <condition>(<expr><call><name>funlock</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>me_lfd</name></name></expr></argument>, <argument><expr><name>LCK_LOWER</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <empty_stmt>;</empty_stmt></block_content></block></while>
    <expr_stmt><expr><name>err</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>err</name> <operator>==</operator> <name>ERROR_NOT_LOCKED</name> <operator>||</operator>
           <operator>(</operator><call><name>mdbx_RunningUnderWine</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>err</name> <operator>==</operator> <name>ERROR_LOCK_VIOLATION</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>err</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SetLastError</name><argument_list>(<argument><expr><name>ERROR_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><call><name>funlock</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>me_lfd</name></name></expr></argument>, <argument><expr><name>LCK_UPPER</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <empty_stmt>;</empty_stmt></block_content></block></while>
    <expr_stmt><expr><name>err</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>err</name> <operator>==</operator> <name>ERROR_NOT_LOCKED</name> <operator>||</operator>
           <operator>(</operator><call><name>mdbx_RunningUnderWine</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>err</name> <operator>==</operator> <name>ERROR_LOCK_VIOLATION</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>err</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SetLastError</name><argument_list>(<argument><expr><name>ERROR_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>env</name><operator>-&gt;</operator><name>me_lazy_fd</name></name> <operator>!=</operator> <name>INVALID_HANDLE_VALUE</name></expr>)</condition> <block>{<block_content>
    <comment type="block">/* explicitly unlock to avoid latency for other processes (windows kernel
     * releases such locks via deferred queues) */</comment>
    <while>while <condition>(<expr><call><name>funlock</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>me_lazy_fd</name></name></expr></argument>, <argument><expr><name>LCK_BODY</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <empty_stmt>;</empty_stmt></block_content></block></while>
    <expr_stmt><expr><name>err</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>err</name> <operator>==</operator> <name>ERROR_NOT_LOCKED</name> <operator>||</operator>
           <operator>(</operator><call><name>mdbx_RunningUnderWine</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>err</name> <operator>==</operator> <name>ERROR_LOCK_VIOLATION</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>err</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SetLastError</name><argument_list>(<argument><expr><name>ERROR_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><call><name>funlock</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>me_lazy_fd</name></name></expr></argument>, <argument><expr><name>LCK_WHOLE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <empty_stmt>;</empty_stmt></block_content></block></while>
    <expr_stmt><expr><name>err</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>err</name> <operator>==</operator> <name>ERROR_NOT_LOCKED</name> <operator>||</operator>
           <operator>(</operator><call><name>mdbx_RunningUnderWine</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>err</name> <operator>==</operator> <name>ERROR_LOCK_VIOLATION</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>err</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SetLastError</name><argument_list>(<argument><expr><name>ERROR_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Seize state as 'exclusive-write' (E-E and returns MDBX_RESULT_TRUE)
 * or as 'used' (S-? and returns MDBX_RESULT_FALSE).
 * Otherwise returns an error. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>internal_seize_lck</name><parameter_list>(<parameter><decl><type><name>HANDLE</name></type> <name>lfd</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>lfd</name> <operator>!=</operator> <name>INVALID_HANDLE_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* 1) now on ?-? (free), get ?-E (middle) */</comment>
  <expr_stmt><expr><call><name>mdbx_jitter4testing</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>flock</name><argument_list>(<argument><expr><name>lfd</name></expr></argument>, <argument><expr><name>LCK_EXCLUSIVE</name> <operator>|</operator> <name>LCK_WAITFOR</name></expr></argument>, <argument><expr><name>LCK_UPPER</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>GetLastError</name><argument_list>()</argument_list></call></expr> <comment type="block">/* 2) something went wrong, give up */</comment>;</expr_stmt>
    <expr_stmt><expr><call><name>mdbx_error</name><argument_list>(<argument><expr><literal type="string">"%s, err %u"</literal></expr></argument>, <argument><expr><literal type="string">"?-?(free) &gt;&gt; ?-E(middle)"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* 3) now on ?-E (middle), try E-E (exclusive-write) */</comment>
  <expr_stmt><expr><call><name>mdbx_jitter4testing</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>flock</name><argument_list>(<argument><expr><name>lfd</name></expr></argument>, <argument><expr><name>LCK_EXCLUSIVE</name> <operator>|</operator> <name>LCK_DONTWAIT</name></expr></argument>, <argument><expr><name>LCK_LOWER</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>MDBX_RESULT_TRUE</name></expr> <comment type="block">/* 4) got E-E (exclusive-write), done */</comment>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* 5) still on ?-E (middle) */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>mdbx_jitter4testing</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>ERROR_SHARING_VIOLATION</name> <operator>&amp;&amp;</operator> <name>rc</name> <operator>!=</operator> <name>ERROR_LOCK_VIOLATION</name></expr>)</condition> <block>{<block_content>
    <comment type="block">/* 6) something went wrong, give up */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>funlock</name><argument_list>(<argument><expr><name>lfd</name></expr></argument>, <argument><expr><name>LCK_UPPER</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>mdbx_panic</name><argument_list>(<argument><expr><literal type="string">"%s(%s) failed: err %u"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>, <argument><expr><literal type="string">"?-E(middle) &gt;&gt; ?-?(free)"</literal></expr></argument>,
                 <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* 7) still on ?-E (middle), try S-E (locked) */</comment>
  <expr_stmt><expr><call><name>mdbx_jitter4testing</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <ternary><condition><expr><call><name>flock</name><argument_list>(<argument><expr><name>lfd</name></expr></argument>, <argument><expr><name>LCK_SHARED</name> <operator>|</operator> <name>LCK_DONTWAIT</name></expr></argument>, <argument><expr><name>LCK_LOWER</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>MDBX_RESULT_FALSE</name></expr>
                                                        </then><else>: <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>mdbx_jitter4testing</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>MDBX_RESULT_FALSE</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>mdbx_error</name><argument_list>(<argument><expr><literal type="string">"%s, err %u"</literal></expr></argument>, <argument><expr><literal type="string">"?-E(middle) &gt;&gt; S-E(locked)"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* 8) now on S-E (locked) or still on ?-E (middle),
   *    transition to S-? (used) or ?-? (free) */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>funlock</name><argument_list>(<argument><expr><name>lfd</name></expr></argument>, <argument><expr><name>LCK_UPPER</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>mdbx_panic</name><argument_list>(<argument><expr><literal type="string">"%s(%s) failed: err %u"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>,
               <argument><expr><literal type="string">"X-E(locked/middle) &gt;&gt; X-?(used/free)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* 9) now on S-? (used, DONE) or ?-? (free, FAILURE) */</comment>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>MDBX_INTERNAL_FUNC</name> <name>int</name></type> <name>mdbx_lck_seize</name><parameter_list>(<parameter><decl><type><name>MDBX_env</name> <modifier>*</modifier></type><name>env</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>me_lazy_fd</name></name> <operator>!=</operator> <name>INVALID_HANDLE_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>env</name><operator>-&gt;</operator><name>me_flags</name></name> <operator>&amp;</operator> <name>MDBX_EXCLUSIVE</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>MDBX_RESULT_TRUE</name></expr> <comment type="block">/* nope since files were must be opened
                               non-shareable */</comment>
        ;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>env</name><operator>-&gt;</operator><name>me_lfd</name></name> <operator>==</operator> <name>INVALID_HANDLE_VALUE</name></expr>)</condition> <block>{<block_content>
    <comment type="block">/* LY: without-lck mode (e.g. on read-only filesystem) */</comment>
    <expr_stmt><expr><call><name>mdbx_jitter4testing</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>flock</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>me_lazy_fd</name></name></expr></argument>, <argument><expr><name>LCK_SHARED</name> <operator>|</operator> <name>LCK_DONTWAIT</name></expr></argument>, <argument><expr><name>LCK_WHOLE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>mdbx_error</name><argument_list>(<argument><expr><literal type="string">"%s, err %u"</literal></expr></argument>, <argument><expr><literal type="string">"without-lck"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>MDBX_RESULT_FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>internal_seize_lck</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>me_lfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>mdbx_jitter4testing</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <name>MDBX_RESULT_TRUE</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>env</name><operator>-&gt;</operator><name>me_flags</name></name> <operator>&amp;</operator> <name>MDBX_RDONLY</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Check that another process don't operates in without-lck mode.
     * Doing such check by exclusive locking the body-part of db. Should be
     * noted:
     *  - we need an exclusive lock for do so;
     *  - we can't lock meta-pages, otherwise other process could get an error
     *    while opening db in valid (non-conflict) mode. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>flock</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>me_lazy_fd</name></name></expr></argument>, <argument><expr><name>LCK_EXCLUSIVE</name> <operator>|</operator> <name>LCK_DONTWAIT</name></expr></argument>, <argument><expr><name>LCK_BODY</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>mdbx_error</name><argument_list>(<argument><expr><literal type="string">"%s, err %u"</literal></expr></argument>, <argument><expr><literal type="string">"lock-against-without-lck"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>mdbx_jitter4testing</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lck_unlock</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>mdbx_jitter4testing</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>funlock</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>me_lazy_fd</name></name></expr></argument>, <argument><expr><name>LCK_BODY</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>mdbx_panic</name><argument_list>(<argument><expr><literal type="string">"%s(%s) failed: err %u"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>,
                   <argument><expr><literal type="string">"unlock-against-without-lck"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>MDBX_INTERNAL_FUNC</name> <name>int</name></type> <name>mdbx_lck_downgrade</name><parameter_list>(<parameter><decl><type><name>MDBX_env</name> <modifier>*</modifier></type><name>env</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* Transite from exclusive-write state (E-E) to used (S-?) */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>me_lazy_fd</name></name> <operator>!=</operator> <name>INVALID_HANDLE_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>me_lfd</name></name> <operator>!=</operator> <name>INVALID_HANDLE_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>env</name><operator>-&gt;</operator><name>me_flags</name></name> <operator>&amp;</operator> <name>MDBX_EXCLUSIVE</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>MDBX_SUCCESS</name></expr> <comment type="block">/* nope since files were must be opened non-shareable */</comment>
        ;</return></block_content></block></if></if_stmt>
  <comment type="block">/* 1) now at E-E (exclusive-write), transition to ?_E (middle) */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>funlock</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>me_lfd</name></name></expr></argument>, <argument><expr><name>LCK_LOWER</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>mdbx_panic</name><argument_list>(<argument><expr><literal type="string">"%s(%s) failed: err %u"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>,
               <argument><expr><literal type="string">"E-E(exclusive-write) &gt;&gt; ?-E(middle)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* 2) now at ?-E (middle), transition to S-E (locked) */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>flock</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>me_lfd</name></name></expr></argument>, <argument><expr><name>LCK_SHARED</name> <operator>|</operator> <name>LCK_DONTWAIT</name></expr></argument>, <argument><expr><name>LCK_LOWER</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></init></decl> <comment type="block">/* 3) something went wrong, give up */</comment>;</decl_stmt>
    <expr_stmt><expr><call><name>mdbx_error</name><argument_list>(<argument><expr><literal type="string">"%s, err %u"</literal></expr></argument>, <argument><expr><literal type="string">"?-E(middle) &gt;&gt; S-E(locked)"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* 4) got S-E (locked), continue transition to S-? (used) */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>funlock</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>me_lfd</name></name></expr></argument>, <argument><expr><name>LCK_UPPER</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>mdbx_panic</name><argument_list>(<argument><expr><literal type="string">"%s(%s) failed: err %u"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>, <argument><expr><literal type="string">"S-E(locked) &gt;&gt; S-?(used)"</literal></expr></argument>,
               <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <return>return <expr><name>MDBX_SUCCESS</name></expr> <comment type="block">/* 5) now at S-? (used), done */</comment>;</return>
</block_content>}</block></function>

<function><type><name>MDBX_INTERNAL_FUNC</name> <name>int</name></type> <name>mdbx_lck_upgrade</name><parameter_list>(<parameter><decl><type><name>MDBX_env</name> <modifier>*</modifier></type><name>env</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* Transite from used state (S-?) to exclusive-write (E-E) */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>me_lfd</name></name> <operator>!=</operator> <name>INVALID_HANDLE_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>env</name><operator>-&gt;</operator><name>me_flags</name></name> <operator>&amp;</operator> <name>MDBX_EXCLUSIVE</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>MDBX_SUCCESS</name></expr> <comment type="block">/* nope since files were must be opened non-shareable */</comment>
        ;</return></block_content></block></if></if_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <comment type="block">/* 1) now on S-? (used), try S-E (locked) */</comment>
  <expr_stmt><expr><call><name>mdbx_jitter4testing</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>flock</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>me_lfd</name></name></expr></argument>, <argument><expr><name>LCK_EXCLUSIVE</name> <operator>|</operator> <name>LCK_DONTWAIT</name></expr></argument>, <argument><expr><name>LCK_UPPER</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>GetLastError</name><argument_list>()</argument_list></call></expr> <comment type="block">/* 2) something went wrong, give up */</comment>;</expr_stmt>
    <expr_stmt><expr><call><name>mdbx_verbose</name><argument_list>(<argument><expr><literal type="string">"%s, err %u"</literal></expr></argument>, <argument><expr><literal type="string">"S-?(used) &gt;&gt; S-E(locked)"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* 3) now on S-E (locked), transition to ?-E (middle) */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>funlock</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>me_lfd</name></name></expr></argument>, <argument><expr><name>LCK_LOWER</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>mdbx_panic</name><argument_list>(<argument><expr><literal type="string">"%s(%s) failed: err %u"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>, <argument><expr><literal type="string">"S-E(locked) &gt;&gt; ?-E(middle)"</literal></expr></argument>,
               <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* 4) now on ?-E (middle), try E-E (exclusive-write) */</comment>
  <expr_stmt><expr><call><name>mdbx_jitter4testing</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>flock</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>me_lfd</name></name></expr></argument>, <argument><expr><name>LCK_EXCLUSIVE</name> <operator>|</operator> <name>LCK_DONTWAIT</name></expr></argument>, <argument><expr><name>LCK_LOWER</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>GetLastError</name><argument_list>()</argument_list></call></expr> <comment type="block">/* 5) something went wrong, give up */</comment>;</expr_stmt>
    <expr_stmt><expr><call><name>mdbx_verbose</name><argument_list>(<argument><expr><literal type="string">"%s, err %u"</literal></expr></argument>, <argument><expr><literal type="string">"?-E(middle) &gt;&gt; E-E(exclusive-write)"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>MDBX_SUCCESS</name></expr> <comment type="block">/* 6) now at E-E (exclusive-write), done */</comment>;</return>
</block_content>}</block></function>

<function><type><name>MDBX_INTERNAL_FUNC</name> <name>int</name></type> <name>mdbx_lck_init</name><parameter_list>(<parameter><decl><type><name>MDBX_env</name> <modifier>*</modifier></type><name>env</name></decl></parameter>,
                                     <parameter><decl><type><name>MDBX_env</name> <modifier>*</modifier></type><name>inprocess_neighbor</name></decl></parameter>,
                                     <parameter><decl><type><name>int</name></type> <name>global_uniqueness_flag</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>env</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>inprocess_neighbor</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>global_uniqueness_flag</name></expr>;</expr_stmt>
  <return>return <expr><name>MDBX_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>MDBX_INTERNAL_FUNC</name> <name>int</name></type> <name>mdbx_lck_destroy</name><parameter_list>(<parameter><decl><type><name>MDBX_env</name> <modifier>*</modifier></type><name>env</name></decl></parameter>,
                                        <parameter><decl><type><name>MDBX_env</name> <modifier>*</modifier></type><name>inprocess_neighbor</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* LY: should unmap before releasing the locks to avoid race condition and
   * STATUS_USER_MAPPED_FILE/ERROR_USER_MAPPED_FILE */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>env</name><operator>-&gt;</operator><name>me_map</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>mdbx_munmap</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>env</name><operator>-&gt;</operator><name>me_dxb_mmap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>env</name><operator>-&gt;</operator><name>me_lck_mmap</name><operator>.</operator><name>lck</name></name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>synced</name> <init>= <expr><name><name>env</name><operator>-&gt;</operator><name>me_lck_mmap</name><operator>.</operator><name>lck</name><operator>-&gt;</operator><name>mti_unsynced_pages</name><operator>.</operator><name>weak</name></name> <operator>==</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>mdbx_munmap</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>env</name><operator>-&gt;</operator><name>me_lck_mmap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>synced</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>inprocess_neighbor</name> <operator>&amp;&amp;</operator> <name><name>env</name><operator>-&gt;</operator><name>me_lfd</name></name> <operator>!=</operator> <name>INVALID_HANDLE_VALUE</name> <operator>&amp;&amp;</operator>
        <call><name>mdbx_lck_upgrade</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>MDBX_SUCCESS</name></expr>)</condition><block type="pseudo"><block_content>
      <comment type="block">/* this will fail if LCK is used/mmapped by other process(es) */</comment>
      <expr_stmt><expr><call><name>mdbx_ftruncate</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>me_lfd</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>lck_unlock</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>MDBX_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*----------------------------------------------------------------------------*/</comment>
<comment type="block">/* reader checking (by pid) */</comment>

<function><type><name>MDBX_INTERNAL_FUNC</name> <name>int</name></type> <name>mdbx_rpid_set</name><parameter_list>(<parameter><decl><type><name>MDBX_env</name> <modifier>*</modifier></type><name>env</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>env</name></expr>;</expr_stmt>
  <return>return <expr><name>MDBX_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>MDBX_INTERNAL_FUNC</name> <name>int</name></type> <name>mdbx_rpid_clear</name><parameter_list>(<parameter><decl><type><name>MDBX_env</name> <modifier>*</modifier></type><name>env</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>env</name></expr>;</expr_stmt>
  <return>return <expr><name>MDBX_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Checks reader by pid.
 *
 * Returns:
 *   MDBX_RESULT_TRUE, if pid is live (unable to acquire lock)
 *   MDBX_RESULT_FALSE, if pid is dead (lock acquired)
 *   or otherwise the errcode. */</comment>
<function><type><name>MDBX_INTERNAL_FUNC</name> <name>int</name></type> <name>mdbx_rpid_check</name><parameter_list>(<parameter><decl><type><name>MDBX_env</name> <modifier>*</modifier></type><name>env</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>pid</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>env</name></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>HANDLE</name></type> <name>hProcess</name> <init>= <expr><call><name>OpenProcess</name><argument_list>(<argument><expr><name>SYNCHRONIZE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><name>hProcess</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>WaitForSingleObject</name><argument_list>(<argument><expr><name>hProcess</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>rc</name> <operator>==</operator> <operator>(</operator><name>int</name><operator>)</operator><name>WAIT_FAILED</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hProcess</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <switch>switch <condition>(<expr><name>rc</name></expr>)</condition> <block>{<block_content>
  <case>case <expr><name>ERROR_INVALID_PARAMETER</name></expr>:</case>
    <comment type="block">/* pid seems invalid */</comment>
    <return>return <expr><name>MDBX_RESULT_FALSE</name></expr>;</return>
  <case>case <expr><name>WAIT_OBJECT_0</name></expr>:</case>
    <comment type="block">/* process just exited */</comment>
    <return>return <expr><name>MDBX_RESULT_FALSE</name></expr>;</return>
  <case>case <expr><name>ERROR_ACCESS_DENIED</name></expr>:</case>
    <comment type="block">/* The ERROR_ACCESS_DENIED would be returned for CSRSS-processes, etc.
     * assume pid exists */</comment>
    <return>return <expr><name>MDBX_RESULT_TRUE</name></expr>;</return>
  <case>case <expr><name>WAIT_TIMEOUT</name></expr>:</case>
    <comment type="block">/* pid running */</comment>
    <return>return <expr><name>MDBX_RESULT_TRUE</name></expr>;</return>
  <default>default:</default>
    <comment type="block">/* failure */</comment>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="line">//----------------------------------------------------------------------------</comment>
<comment type="line">// Stub for slim read-write lock</comment>
<comment type="line">// Copyright (C) 1995-2002 Brad Wilson</comment>

<function><type><specifier>static</specifier> <name>void</name> <name>WINAPI</name></type> <name>stub_srwlock_Init</name><parameter_list>(<parameter><decl><type><name>MDBX_srwlock</name> <modifier>*</modifier></type><name>srwl</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>srwl</name><operator>-&gt;</operator><name>readerCount</name></name> <operator>=</operator> <name><name>srwl</name><operator>-&gt;</operator><name>writerCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>WINAPI</name></type> <name>stub_srwlock_AcquireShared</name><parameter_list>(<parameter><decl><type><name>MDBX_srwlock</name> <modifier>*</modifier></type><name>srwl</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <while>while <condition>(<expr><name>true</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>srwl</name><operator>-&gt;</operator><name>writerCount</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>srwl</name><operator>-&gt;</operator><name>readerCount</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">//  If there's a writer already, spin without unnecessarily</comment>
    <comment type="line">//  interlocking the CPUs</comment>
    <if_stmt><if>if <condition>(<expr><name><name>srwl</name><operator>-&gt;</operator><name>writerCount</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>YieldProcessor</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//  Add to the readers list</comment>
    <expr_stmt><expr><call><name>_InterlockedIncrement</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>srwl</name><operator>-&gt;</operator><name>readerCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Check for writers again (we may have been preempted). If</comment>
    <comment type="line">// there are no writers writing or waiting, then we're done.</comment>
    <if_stmt><if>if <condition>(<expr><name><name>srwl</name><operator>-&gt;</operator><name>writerCount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <break>break;</break></block_content></block></if></if_stmt>

    <comment type="line">// Remove from the readers list, spin, try again</comment>
    <expr_stmt><expr><call><name>_InterlockedDecrement</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>srwl</name><operator>-&gt;</operator><name>readerCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>YieldProcessor</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>WINAPI</name></type> <name>stub_srwlock_ReleaseShared</name><parameter_list>(<parameter><decl><type><name>MDBX_srwlock</name> <modifier>*</modifier></type><name>srwl</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>srwl</name><operator>-&gt;</operator><name>readerCount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>_InterlockedDecrement</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>srwl</name><operator>-&gt;</operator><name>readerCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>WINAPI</name></type> <name>stub_srwlock_AcquireExclusive</name><parameter_list>(<parameter><decl><type><name>MDBX_srwlock</name> <modifier>*</modifier></type><name>srwl</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <while>while <condition>(<expr><name>true</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>srwl</name><operator>-&gt;</operator><name>writerCount</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>srwl</name><operator>-&gt;</operator><name>readerCount</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">//  If there's a writer already, spin without unnecessarily</comment>
    <comment type="line">//  interlocking the CPUs</comment>
    <if_stmt><if>if <condition>(<expr><name><name>srwl</name><operator>-&gt;</operator><name>writerCount</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>YieldProcessor</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// See if we can become the writer (expensive, because it inter-</comment>
    <comment type="line">// locks the CPUs, so writing should be an infrequent process)</comment>
    <if_stmt><if>if <condition>(<expr><call><name>_InterlockedExchange</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>srwl</name><operator>-&gt;</operator><name>writerCount</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></while>

  <comment type="line">// Now we're the writer, but there may be outstanding readers.</comment>
  <comment type="line">// Spin until there aren't any more; new readers will wait now</comment>
  <comment type="line">// that we're the writer.</comment>
  <while>while <condition>(<expr><name><name>srwl</name><operator>-&gt;</operator><name>readerCount</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>srwl</name><operator>-&gt;</operator><name>writerCount</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>srwl</name><operator>-&gt;</operator><name>readerCount</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>YieldProcessor</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>WINAPI</name></type> <name>stub_srwlock_ReleaseExclusive</name><parameter_list>(<parameter><decl><type><name>MDBX_srwlock</name> <modifier>*</modifier></type><name>srwl</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>srwl</name><operator>-&gt;</operator><name>writerCount</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>srwl</name><operator>-&gt;</operator><name>readerCount</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>srwl</name><operator>-&gt;</operator><name>writerCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint64_t</name> <name>WINAPI</name></type> <name>stub_GetTickCount64</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>LARGE_INTEGER</name></type> <name>Counter</name></decl>, <decl><type ref="prev"/><name>Frequency</name></decl>;</decl_stmt>
  <return>return <expr><ternary><condition><expr><operator>(</operator><call><name>QueryPerformanceFrequency</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Frequency</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
          <call><name>QueryPerformanceCounter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Counter</name></expr></argument>)</argument_list></call><operator>)</operator></expr>
             ?</condition><then> <expr><name><name>Counter</name><operator>.</operator><name>QuadPart</name></name> <operator>*</operator> <literal type="number">1000ul</literal> <operator>/</operator> <name><name>Frequency</name><operator>.</operator><name>QuadPart</name></name></expr>
             </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*----------------------------------------------------------------------------*/</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>xMDBX_ALLOY</name></cpp:ifndef>
<decl_stmt><decl><type><name>MDBX_srwlock_function</name></type> <name>mdbx_srwlock_Init</name></decl>, <decl><type ref="prev"/><name>mdbx_srwlock_AcquireShared</name></decl>,
    <decl><type ref="prev"/><name>mdbx_srwlock_ReleaseShared</name></decl>, <decl><type ref="prev"/><name>mdbx_srwlock_AcquireExclusive</name></decl>,
    <decl><type ref="prev"/><name>mdbx_srwlock_ReleaseExclusive</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>MDBX_NtExtendSection</name></type> <name>mdbx_NtExtendSection</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MDBX_GetFileInformationByHandleEx</name></type> <name>mdbx_GetFileInformationByHandleEx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MDBX_GetVolumeInformationByHandleW</name></type> <name>mdbx_GetVolumeInformationByHandleW</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MDBX_GetFinalPathNameByHandleW</name></type> <name>mdbx_GetFinalPathNameByHandleW</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MDBX_SetFileInformationByHandle</name></type> <name>mdbx_SetFileInformationByHandle</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MDBX_NtFsControlFile</name></type> <name>mdbx_NtFsControlFile</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MDBX_PrefetchVirtualMemory</name></type> <name>mdbx_PrefetchVirtualMemory</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MDBX_GetTickCount64</name></type> <name>mdbx_GetTickCount64</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MDBX_RegGetValueA</name></type> <name>mdbx_RegGetValueA</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* xMDBX_ALLOY */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>__GNUC_PREREQ</name><argument_list>(<argument><expr><literal type="number">8</literal><operator>,</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>GCC</name> <name>diagnostic</name> <name>push</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>GCC</name> <name>diagnostic</name> <name>ignored</name> <cpp:literal>"-Wcast-function-type"</cpp:literal></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* GCC/MINGW */</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>mdbx_winnt_import</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>HINSTANCE</name></type> <name>hNtdll</name> <init>= <expr><call><name>GetModuleHandleA</name><argument_list>(<argument><expr><literal type="string">"ntdll.dll"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_PROC_ADDR</name><parameter_list>(<parameter><type><name>dll</name></type></parameter>, <parameter><type><name>ENTRY</name></type></parameter>)</parameter_list></cpp:macro>                                              \
  <cpp:value>mdbx_##ENTRY = (MDBX_##ENTRY)GetProcAddress(dll, #ENTRY)</cpp:value></cpp:define>

  <if_stmt><if>if <condition>(<expr><call><name>GetProcAddress</name><argument_list>(<argument><expr><name>hNtdll</name></expr></argument>, <argument><expr><literal type="string">"wine_get_version"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>mdbx_RunningUnderWine</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>GET_PROC_ADDR</name><argument_list>(<argument><expr><name>hNtdll</name></expr></argument>, <argument><expr><name>NtFsControlFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GET_PROC_ADDR</name><argument_list>(<argument><expr><name>hNtdll</name></expr></argument>, <argument><expr><name>NtExtendSection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>mdbx_RunningUnderWine</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <decl_stmt><decl><type><specifier>const</specifier> <name>HINSTANCE</name></type> <name>hKernel32dll</name> <init>= <expr><call><name>GetModuleHandleA</name><argument_list>(<argument><expr><literal type="string">"kernel32.dll"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>GET_PROC_ADDR</name><argument_list>(<argument><expr><name>hKernel32dll</name></expr></argument>, <argument><expr><name>GetFileInformationByHandleEx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>GET_PROC_ADDR</name><argument_list>(<argument><expr><name>hKernel32dll</name></expr></argument>, <argument><expr><name>GetTickCount64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>mdbx_GetTickCount64</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>mdbx_GetTickCount64</name> <operator>=</operator> <name>stub_GetTickCount64</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>mdbx_RunningUnderWine</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>GET_PROC_ADDR</name><argument_list>(<argument><expr><name>hKernel32dll</name></expr></argument>, <argument><expr><name>SetFileInformationByHandle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GET_PROC_ADDR</name><argument_list>(<argument><expr><name>hKernel32dll</name></expr></argument>, <argument><expr><name>GetVolumeInformationByHandleW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GET_PROC_ADDR</name><argument_list>(<argument><expr><name>hKernel32dll</name></expr></argument>, <argument><expr><name>GetFinalPathNameByHandleW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GET_PROC_ADDR</name><argument_list>(<argument><expr><name>hKernel32dll</name></expr></argument>, <argument><expr><name>PrefetchVirtualMemory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><specifier>const</specifier> <name>HINSTANCE</name></type> <name>hAdvapi32dll</name> <init>= <expr><call><name>GetModuleHandleA</name><argument_list>(<argument><expr><literal type="string">"advapi32.dll"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>GET_PROC_ADDR</name><argument_list>(<argument><expr><name>hAdvapi32dll</name></expr></argument>, <argument><expr><name>RegGetValueA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GET_PROC_ADDR</name></cpp:undef>

  <decl_stmt><decl><type><specifier>const</specifier> <name>MDBX_srwlock_function</name></type> <name>init</name> <init>=
      <expr><operator>(</operator><name>MDBX_srwlock_function</name><operator>)</operator><call><name>GetProcAddress</name><argument_list>(<argument><expr><name>hKernel32dll</name></expr></argument>, <argument><expr><literal type="string">"InitializeSRWLock"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>init</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>mdbx_srwlock_Init</name> <operator>=</operator> <name>init</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mdbx_srwlock_AcquireShared</name> <operator>=</operator> <operator>(</operator><name>MDBX_srwlock_function</name><operator>)</operator><call><name>GetProcAddress</name><argument_list>(
        <argument><expr><name>hKernel32dll</name></expr></argument>, <argument><expr><literal type="string">"AcquireSRWLockShared"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mdbx_srwlock_ReleaseShared</name> <operator>=</operator> <operator>(</operator><name>MDBX_srwlock_function</name><operator>)</operator><call><name>GetProcAddress</name><argument_list>(
        <argument><expr><name>hKernel32dll</name></expr></argument>, <argument><expr><literal type="string">"ReleaseSRWLockShared"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mdbx_srwlock_AcquireExclusive</name> <operator>=</operator> <operator>(</operator><name>MDBX_srwlock_function</name><operator>)</operator><call><name>GetProcAddress</name><argument_list>(
        <argument><expr><name>hKernel32dll</name></expr></argument>, <argument><expr><literal type="string">"AcquireSRWLockExclusive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mdbx_srwlock_ReleaseExclusive</name> <operator>=</operator> <operator>(</operator><name>MDBX_srwlock_function</name><operator>)</operator><call><name>GetProcAddress</name><argument_list>(
        <argument><expr><name>hKernel32dll</name></expr></argument>, <argument><expr><literal type="string">"ReleaseSRWLockExclusive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>mdbx_srwlock_Init</name> <operator>=</operator> <name>stub_srwlock_Init</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mdbx_srwlock_AcquireShared</name> <operator>=</operator> <name>stub_srwlock_AcquireShared</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mdbx_srwlock_ReleaseShared</name> <operator>=</operator> <name>stub_srwlock_ReleaseShared</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mdbx_srwlock_AcquireExclusive</name> <operator>=</operator> <name>stub_srwlock_AcquireExclusive</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mdbx_srwlock_ReleaseExclusive</name> <operator>=</operator> <name>stub_srwlock_ReleaseExclusive</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>__GNUC_PREREQ</name><argument_list>(<argument><expr><literal type="number">8</literal><operator>,</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>GCC</name> <name>diagnostic</name> <name>pop</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* GCC/MINGW */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* Windows LCK-implementation */</comment>
</unit>
