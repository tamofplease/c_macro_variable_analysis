<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sqlitestudio/SQLiteStudio3/coreSQLiteStudio/parser/lempar.c"><comment type="block">/* Driver template for the LEMON parser generator.
** The author disclaims copyright to this source code.
**
** This version of "lempar.c" is modified, slightly, for use by SQLite.
** The only modifications are the addition of a couple of NEVER()
** macros to disable tests that are needed in the case of a general
** LALR(1) grammar but which are always false in the
** specific grammar used by SQLite.
*/</comment>
<comment type="block">/* First off, code is included that follows the "include" declaration
** in the input grammar file. */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<expr_stmt><expr><operator>%</operator><operator>%</operator>
<comment type="block">/* Next is all token values, in a form suitable for use by makeheaders.
** This section will be null unless lemon is run with the -m switch.
*/</comment>
<comment type="block">/*
** These constants (all generated automatically by the parser generator)
** specify the various kinds of tokens (terminals) that the parser
** understands.
**
** Each symbol here is a terminal symbol in the grammar.
*/</comment>
<operator>%</operator><operator>%</operator>
<comment type="block">/* Make sure the INTERFACE macro is defined.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>INTERFACE</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>INTERFACE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* The next thing included is series of defines which control
** various aspects of the generated parser.
**    YYCODETYPE         is the data type used for storing terminal
**                       and nonterminal numbers.  "unsigned char" is
**                       used if there are fewer than 250 terminals
**                       and nonterminals.  "int" is used otherwise.
**    YYNOCODE           is a number of type YYCODETYPE which corresponds
**                       to no legal terminal or nonterminal number.  This
**                       number is used to fill in empty slots of the hash
**                       table.
**    YYFALLBACK         If defined, this indicates that one or more tokens
**                       have fall-back values which should be used if the
**                       original value of the token will not parse.
**    YYACTIONTYPE       is the data type used for storing terminal
**                       and nonterminal numbers.  "unsigned char" is
**                       used if there are fewer than 250 rules and
**                       states combined.  "int" is used otherwise.
**    ParseTOKENTYPE     is the data type used for minor tokens given
**                       directly to the parser from the tokenizer.
**    YYMINORTYPE        is the data type used for all minor tokens.
**                       This is typically a union of many types, one of
**                       which is ParseTOKENTYPE.  The entry in the union
**                       for base tokens is called "yy0".
**    YYSTACKDEPTH       is the maximum depth of the parser's stack.  If
**                       zero the stack is dynamically sized using realloc()
**    ParseARG_SDECL     A static variable declaration for the %extra_argument
**    ParseARG_PDECL     A parameter declaration for the %extra_argument
**    ParseARG_STORE     Code to store %extra_argument into yypParser
**    ParseARG_FETCH     Code to extract %extra_argument from yypParser
**    YYNSTATE           the combined number of states.
**    YYNRULE            the number of rules in the grammar
**    YYERRORSYMBOL      is the code number of the error symbol.  If not
**                       defined, then do no error processing.
*/</comment>
<operator>%</operator><operator>%</operator>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_NO_ACTION</name></cpp:macro>      <cpp:value>(YYNSTATE+YYNRULE+2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_ACCEPT_ACTION</name></cpp:macro>  <cpp:value>(YYNSTATE+YYNRULE+1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_ERROR_ACTION</name></cpp:macro>   <cpp:value>(YYNSTATE+YYNRULE)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_CONTEXT</name></cpp:macro> <cpp:value>yyParser* yypParser = pParser; ParseARG_FETCH</cpp:value></cpp:define>

<comment type="block">/* The yyzerominor constant is used to initialize instances of
** YYMINORTYPE objects to zero. */</comment>
<specifier>static</specifier> <specifier>const</specifier> <name>YYMINORTYPE</name> <name>yyzerominor</name> <operator>=</operator> <block>{ <expr><literal type="number">0</literal></expr> }</block></expr>;</expr_stmt>

<comment type="block">/* Define the yytestcase() macro to be a no-op if is not already defined
** otherwise.
**
** Applications can choose to define yytestcase() in the %include section
** to a macro that can assist in verifying code coverage.  For production
** code the yytestcase() macro should be turned off.  But it is useful
** for testing.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>yytestcase</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>yytestcase</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* Next are the tables used to determine what action to take based on the
** current state and lookahead token.  These tables are used to implement
** functions that take a state number and lookahead value and return an
** action integer.
**
** Suppose the action integer is N.  Then the action is determined as
** follows
**
**   0 &lt;= N &lt; YYNSTATE                  Shift N.  That is, push the lookahead
**                                      token onto the stack and goto state N.
**
**   YYNSTATE &lt;= N &lt; YYNSTATE+YYNRULE   Reduce by rule N-YYNSTATE.
**
**   N == YYNSTATE+YYNRULE              A syntax error has occurred.
**
**   N == YYNSTATE+YYNRULE+1            The parser accepts its input.
**
**   N == YYNSTATE+YYNRULE+2            No such action.  Denotes unused
**                                      slots in the yy_action[] table.
**
** The action table is constructed as a single large table named yy_action[].
** Given state S and lookahead X, the action is computed as
**
**      yy_action[ yy_shift_ofst[S] + X ]
**
** If the index value yy_shift_ofst[S]+X is out of range or if the value
** yy_lookahead[yy_shift_ofst[S]+X] is not equal to X or if yy_shift_ofst[S]
** is equal to YY_SHIFT_USE_DFLT, it means that the action is not in the table
** and that yy_default[S] should be used instead.
**
** The formula above is for computing the action when the lookahead is
** a terminal symbol.  If the lookahead is a non-terminal (as occurs after
** a reduce action) then the yy_reduce_ofst[] array is used in place of
** the yy_shift_ofst[] array and YY_REDUCE_USE_DFLT is used in place of
** YY_SHIFT_USE_DFLT.
**
** The following are the tables generated in this section:
**
**  yy_action[]        A single table containing all actions.
**  yy_lookahead[]     A table containing the lookahead for each entry in
**                     yy_action.  Used to detect hash collisions.
**  yy_shift_ofst[]    For each state, the offset into yy_action for
**                     shifting terminals.
**  yy_reduce_ofst[]   For each state, the offset into yy_action for
**                     shifting non-terminals after a reduce.
**  yy_default[]       Default action for each state.
*/</comment>
<expr_stmt><expr><operator>%</operator><operator>%</operator>

<comment type="block">/* The next table maps tokens into fallback tokens.  If a construct
** like the following:
**
**      %fallback ID X Y Z.
**
** appears in the grammar, then ID becomes a fallback token for X, Y,
** and Z.  Whenever one of the tokens X, Y, or Z is input to the parser
** but it does not parse, the type of the token is changed to ID and
** the parse is retried before an error is thrown.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYFALLBACK</name></cpp:ifdef>
<specifier>static</specifier> <specifier>const</specifier> <name>YYCODETYPE</name> <name><name>yyFallback</name><index>[]</index></name> <operator>=</operator> <block>{
<expr><operator>%</operator><operator>%</operator></expr>
}</block></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* YYFALLBACK */</comment>

<comment type="block">/* The following structure represents a single element of the
** parser's stack.  Information stored includes:
**
**   +  The state number for the parser at this level of the stack.
**
**   +  The value of the token stored at this level of the stack.
**      (In other words, the "major" token.)
**
**   +  The semantic value stored at this level of the stack.  This is
**      the information used by the action routines in the grammar.
**      It is sometimes called the "minor" token.
*/</comment>
<struct>struct <name>yyStackEntry</name> <block>{
  <decl_stmt><decl><type><name>YYACTIONTYPE</name></type> <name>stateno</name></decl>;</decl_stmt>  <comment type="block">/* The state-number */</comment>
  <decl_stmt><decl><type><name>YYCODETYPE</name></type> <name>major</name></decl>;</decl_stmt>      <comment type="block">/* The major token value.  This is the code
                         ** number for the token at this stack level */</comment>
  <decl_stmt><decl><type><name>YYMINORTYPE</name></type> <name>minor</name></decl>;</decl_stmt>     <comment type="block">/* The user-supplied minor token value.  This
                         ** is the value of the token  */</comment>
  <decl_stmt><decl><type><name><name>QList</name><argument_list type="generic">&lt;<argument><expr><name>Token</name><modifier>*</modifier></expr></argument>&gt;</argument_list></name><modifier>*</modifier></type> <name>tokens</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
}</block>;</struct>
<typedef>typedef <type><name><name>struct</name> <name>yyStackEntry</name></name></type> <name>yyStackEntry</name>;</typedef>

<comment type="block">/* The state of the parser is completely contained in an instance of
** the following structure */</comment>
<struct>struct <name>yyParser</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>yyidx</name></decl>;</decl_stmt>                    <comment type="block">/* Index of top element in stack */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYTRACKMAXSTACKDEPTH</name></cpp:ifdef>
  <decl_stmt><decl><type><name>int</name></type> <name>yyidxMax</name></decl>;</decl_stmt>                 <comment type="block">/* Maximum value of yyidx */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>int</name></type> <name>yyerrcnt</name></decl>;</decl_stmt>                 <comment type="block">/* Shifts left before out of the error */</comment>
  <decl_stmt><decl><type><name>ParseARG_SDECL</name>                <comment type="block">/* A place to hold %extra_argument */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>YYSTACKDEPTH</name><operator>&lt;=</operator><literal type="number">0</literal></expr></cpp:if>
  <name>int</name></type> <name>yystksz</name></decl>;</decl_stmt>                  <comment type="block">/* Current side of the stack */</comment>
  <decl_stmt><decl><type><name>yyStackEntry</name> <modifier>*</modifier></type><name>yystack</name></decl>;</decl_stmt>        <comment type="block">/* The parser's stack */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>yyStackEntry</name></type> <name><name>yystack</name><index>[<expr><name>YYSTACKDEPTH</name></expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* The parser's stack */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct>
<typedef>typedef <type><name><name>struct</name> <name>yyParser</name></name></type> <name>yyParser</name>;</typedef>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<decl_stmt><decl><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type><name>yyTraceFILE</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>yyTracePrompt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* NDEBUG */</comment>

<function><type><name>void</name> <modifier>*</modifier></type><name>ParseCopyParserState</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>other</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>pParser</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>otherParser</name> <init>= <expr><operator>(</operator><name>yyParser</name><operator>*</operator><operator>)</operator><name>other</name></expr></init></decl>;</decl_stmt>

  <comment type="line">// Copy parser</comment>
  <expr_stmt><expr><name>pParser</name> <operator>=</operator> <operator>(</operator><name>yyParser</name><operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>yyParser</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pParser</name></expr></argument>, <argument><expr><name>other</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>yyParser</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>YYSTACKDEPTH</name><operator>&lt;=</operator><literal type="number">0</literal></expr></cpp:if>
  <comment type="line">// Copy stack</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>stackSize</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>yyStackEntry</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>pParser</name><operator>-&gt;</operator><name>yystksz</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pParser</name><operator>-&gt;</operator><name>yystack</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>stackSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pParser</name><operator>-&gt;</operator><name>yystack</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>yyParser</name><operator>*</operator><operator>)</operator><name>other</name><operator>)</operator><operator>-&gt;</operator><name>yystack</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>stackSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>pParser</name><operator>-&gt;</operator><name>yyidx</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
      <expr_stmt><expr><name><name>pParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tokens</name> <operator>=</operator> <name>new</name> <call><name><name>QList</name><argument_list type="generic">&lt;<argument><expr><name>Token</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>pParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tokens</name><operator>)</operator> <operator>=</operator> <operator>*</operator><operator>(</operator><name><name>otherParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tokens</name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></for>

  <return>return <expr><name>pParser</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>ParseAddToken</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>other</name></decl></parameter>, <parameter><decl><type><name>Token</name><modifier>*</modifier></type> <name>token</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>otherParser</name> <init>= <expr><operator>(</operator><name>yyParser</name><operator>*</operator><operator>)</operator><name>other</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>otherParser</name><operator>-&gt;</operator><name>yyidx</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt> <comment type="line">// Nothing on stack yet. Might happen when parsing just whitespaces, nothing else.</comment>

    <expr_stmt><expr><name><name>otherParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><name><name>otherParser</name><operator>-&gt;</operator><name>yyidx</name></name></expr>]</index></name><operator>.</operator><call><name><name>tokens</name><operator>-&gt;</operator><name>append</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>ParseRestoreParserState</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>saved</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>pParser</name> <init>= <expr><operator>(</operator><name>yyParser</name><operator>*</operator><operator>)</operator><name>target</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>savedParser</name> <init>= <expr><operator>(</operator><name>yyParser</name><operator>*</operator><operator>)</operator><name>saved</name></expr></init></decl>;</decl_stmt>

  <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>pParser</name><operator>-&gt;</operator><name>yyidx</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
      <expr_stmt><expr><name>delete</name> <name><name>pParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tokens</name></expr>;</expr_stmt></block_content></block></for>

  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pParser</name></expr></argument>, <argument><expr><name>saved</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>yyParser</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>savedParser</name><operator>-&gt;</operator><name>yyidx</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
      <expr_stmt><expr><name><name>pParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tokens</name> <operator>=</operator> <name>new</name> <call><name><name>QList</name><argument_list type="generic">&lt;<argument><expr><name>Token</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>pParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tokens</name><operator>)</operator> <operator>=</operator> <operator>*</operator><operator>(</operator><name><name>savedParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tokens</name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></for>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>YYSTACKDEPTH</name><operator>&lt;=</operator><literal type="number">0</literal></expr></cpp:if>
  <comment type="line">// Copy stack</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>stackSize</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>yyStackEntry</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>pParser</name><operator>-&gt;</operator><name>yystksz</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pParser</name><operator>-&gt;</operator><name>yystack</name></name> <operator>=</operator> <call><name>relloc</name><argument_list>(<argument><expr><name><name>pParser</name><operator>-&gt;</operator><name>yystack</name></name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>stackSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pParser</name><operator>-&gt;</operator><name>yystack</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>yyParser</name><operator>*</operator><operator>)</operator><name>saved</name><operator>)</operator><operator>-&gt;</operator><name>yystack</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>stackSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>ParseFreeSavedState</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>other</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>pParser</name> <init>= <expr><operator>(</operator><name>yyParser</name><operator>*</operator><operator>)</operator><name>other</name></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>pParser</name><operator>-&gt;</operator><name>yyidx</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name>delete</name> <name><name>pParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tokens</name></expr>;</expr_stmt></block_content></block></for>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>YYSTACKDEPTH</name><operator>&lt;=</operator><literal type="number">0</literal></expr></cpp:if>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>pParser</name><operator>-&gt;</operator><name>yystack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<comment type="block">/*
** Turn parser tracing on by giving a stream to which to write the trace
** and a prompt to preface each trace message.  Tracing is turned off
** by making either argument NULL
**
** Inputs:
** &lt;ul&gt;
** &lt;li&gt; A FILE* to which trace output should be written.
**      If NULL, then tracing is turned off.
** &lt;li&gt; A prefix string written at the beginning of every
**      line of trace output.  If NULL, then tracing is
**      turned off.
** &lt;/ul&gt;
**
** Outputs:
** None.
*/</comment>
<function><type><name>void</name></type> <name>ParseTrace</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>TraceFILE</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zTracePrompt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name>yyTraceFILE</name> <operator>=</operator> <name>TraceFILE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>yyTracePrompt</name> <operator>=</operator> <name>zTracePrompt</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>yyTraceFILE</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>yyTracePrompt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if<condition>( <expr><name>yyTracePrompt</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>yyTraceFILE</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* NDEBUG */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<comment type="block">/* For tracing shifts, the names of all terminals and nonterminals
** are required.  The following table supplies these names */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>yyTokenName</name><index>[]</index></name> <init>= <expr><block>{
<expr><operator>%</operator><operator>%</operator></expr>
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* NDEBUG */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<comment type="block">/* For tracing reduce actions, the names of all rules are required.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>yyRuleName</name><index>[]</index></name> <init>= <expr><block>{
<expr><operator>%</operator><operator>%</operator></expr>
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* NDEBUG */</comment>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>YYSTACKDEPTH</name><operator>&lt;=</operator><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/*
** Try to increase the size of the parser stack.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>yyGrowStack</name><parameter_list>(<parameter><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>newSize</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>yyStackEntry</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>newSize</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>yystksz</name></name><operator>*</operator><literal type="number">2</literal> <operator>+</operator> <literal type="number">100</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>yystack</name></name></expr></argument>, <argument><expr><name>newSize</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>pNew</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>yystack</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>yystksz</name></name> <operator>=</operator> <name>newSize</name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><name>yyTraceFILE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>,<argument><expr><literal type="string">"%sStack grows to %d entries!\n"</literal></expr></argument>,
              <argument><expr><name>yyTracePrompt</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>yystksz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** This function allocates a new parser.
** The only argument is a pointer to a function which works like
** malloc.
**
** Inputs:
** A pointer to the function used to allocate memory.
**
** Outputs:
** A pointer to a parser.  This pointer is used in subsequent calls
** to Parse and ParseFree.
*/</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>ParseAlloc</name><parameter_list>(<parameter><function_decl><type><name>void</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>mallocProc</name>)<parameter_list>(<parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>pParser</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pParser</name> <operator>=</operator> <operator>(</operator><name>yyParser</name><operator>*</operator><operator>)</operator><call>(<modifier>*</modifier><name>mallocProc</name>)<argument_list>( <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>yyParser</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pParser</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pParser</name><operator>-&gt;</operator><name>yyidx</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYTRACKMAXSTACKDEPTH</name></cpp:ifdef>
    <expr_stmt><expr><name><name>pParser</name><operator>-&gt;</operator><name>yyidxMax</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>YYSTACKDEPTH</name><operator>&lt;=</operator><literal type="number">0</literal></expr></cpp:if>
    <expr_stmt><expr><name><name>pParser</name><operator>-&gt;</operator><name>yystack</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParser</name><operator>-&gt;</operator><name>yystksz</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>yyGrowStack</name><argument_list>(<argument><expr><name>pParser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pParser</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* The following function deletes the value associated with a
** symbol.  The symbol can be either a terminal or nonterminal.
** "yymajor" is the symbol code, and "yypminor" is a pointer to
** the value.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>yy_destructor</name><parameter_list>(
  <parameter><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>yypParser</name></decl></parameter>,    <comment type="block">/* The parser */</comment>
  <parameter><decl><type><name>YYCODETYPE</name></type> <name>yymajor</name></decl></parameter>,     <comment type="block">/* Type code for object to destroy */</comment>
  <parameter><decl><type><name>YYMINORTYPE</name> <modifier>*</modifier></type><name>yypminor</name></decl></parameter>   <comment type="block">/* The object to be destroyed */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name>ParseARG_FETCH</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>parserContext</name><operator>-&gt;</operator><name>executeRules</name></name></expr>)</condition>
  <block>{<block_content>
      <switch>switch<condition>( <expr><name>yymajor</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* Here is inserted the actions which take place when a
        ** terminal or non-terminal is destroyed.  This can happen
        ** when the symbol is popped from the stack during a
        ** reduce or during error processing or when a parser is
        ** being destroyed before it is finished parsing.
        **
        ** Note: during a reduce, the only symbols destroyed are those
        ** which appear on the RHS of the rule, but which are not used
        ** inside the C code.
        */</comment>
<expr_stmt><expr><operator>%</operator><operator>%</operator></expr></expr_stmt>
        <default>default:</default>  <break>break;</break>   <comment type="block">/* If no destructor action specified: do nothing */</comment>
      </block_content>}</block></switch>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Pop the parser's stack once.
**
** If there is a destructor routine associated with the token which
** is popped from the stack, then call it.
**
** Return the major token number for the symbol popped.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>yy_pop_parser_stack</name><parameter_list>(<parameter><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>pParser</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>YYCODETYPE</name></type> <name>yymajor</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>yyStackEntry</name> <modifier>*</modifier></type><name>yytos</name> <init>= <expr><operator>&amp;</operator><name><name>pParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><name><name>pParser</name><operator>-&gt;</operator><name>yyidx</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* There is no mechanism by which the parser stack can be popped below
  ** empty in SQLite.  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pParser</name><operator>-&gt;</operator><name>yyidx</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name>yyTraceFILE</name> <operator>&amp;&amp;</operator> <name><name>pParser</name><operator>-&gt;</operator><name>yyidx</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>,<argument><expr><literal type="string">"%sPopping %s\n"</literal></expr></argument>,
      <argument><expr><name>yyTracePrompt</name></expr></argument>,
      <argument><expr><name><name>yyTokenName</name><index>[<expr><name><name>yytos</name><operator>-&gt;</operator><name>major</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>yymajor</name> <operator>=</operator> <name><name>yytos</name><operator>-&gt;</operator><name>major</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>yy_destructor</name><argument_list>(<argument><expr><name>pParser</name></expr></argument>, <argument><expr><name>yymajor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>yytos</name><operator>-&gt;</operator><name>minor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>delete</name></type> <name><name>yytos</name><operator>-&gt;</operator><name>tokens</name></name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>yytos</name><operator>-&gt;</operator><name>tokens</name></name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParser</name><operator>-&gt;</operator><name>yyidx</name></name><operator>--</operator></expr>;</expr_stmt>
  <return>return <expr><name>yymajor</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Deallocate and destroy a parser.  Destructors are all called for
** all stack elements before shutting the parser down.
**
** Inputs:
** &lt;ul&gt;
** &lt;li&gt;  A pointer to the parser.  This should be a pointer
**       obtained from ParseAlloc.
** &lt;li&gt;  A pointer to a function used to reclaim memory obtained
**       from malloc.
** &lt;/ul&gt;
*/</comment>
<function><type><name>void</name></type> <name>ParseFree</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                    <comment type="block">/* The parser to be deleted */</comment>
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>freeProc</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>     <comment type="block">/* Function used to reclaim memory */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>pParser</name> <init>= <expr><operator>(</operator><name>yyParser</name><operator>*</operator><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>
  <comment type="block">/* In SQLite, we never try to destroy a parser that was not successfully
  ** created in the first place. */</comment>
  <if_stmt><if>if<condition>( <expr><name>pParser</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <while>while<condition>( <expr><name><name>pParser</name><operator>-&gt;</operator><name>yyidx</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>yy_pop_parser_stack</name><argument_list>(<argument><expr><name>pParser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>YYSTACKDEPTH</name><operator>&lt;=</operator><literal type="number">0</literal></expr></cpp:if>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>pParser</name><operator>-&gt;</operator><name>yystack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call>(<modifier>*</modifier><name>freeProc</name>)<argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pParser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the peak depth of the stack for a parser.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYTRACKMAXSTACKDEPTH</name></cpp:ifdef>
<function><type><name>int</name></type> <name>ParseStackPeak</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>pParser</name> <init>= <expr><operator>(</operator><name>yyParser</name><operator>*</operator><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><name><name>pParser</name><operator>-&gt;</operator><name>yyidxMax</name></name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Find the appropriate action for a parser given the terminal
** look-ahead token iLookAhead.
**
** If the look-ahead token is YYNOCODE, then check to see if the action is
** independent of the look-ahead.  If it is, return the action, otherwise
** return YY_NO_ACTION.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>yy_find_shift_action</name><parameter_list>(
  <parameter><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>pParser</name></decl></parameter>,        <comment type="block">/* The parser */</comment>
  <parameter><decl><type><name>YYCODETYPE</name></type> <name>iLookAhead</name></decl></parameter>     <comment type="block">/* The look-ahead token */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>stateno</name> <init>= <expr><name><name>pParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><name><name>pParser</name><operator>-&gt;</operator><name>yyidx</name></name></expr>]</index></name><operator>.</operator><name>stateno</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>GET_CONTEXT</name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>stateno</name><operator>&gt;</operator><name>YY_SHIFT_COUNT</name>
   <operator>||</operator> <operator>(</operator><name>i</name> <operator>=</operator> <name><name>yy_shift_ofst</name><index>[<expr><name>stateno</name></expr>]</index></name><operator>)</operator><operator>==</operator><name>YY_SHIFT_USE_DFLT</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name><name>yy_default</name><index>[<expr><name>stateno</name></expr>]</index></name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iLookAhead</name><operator>!=</operator><name>YYNOCODE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>i</name> <operator>+=</operator> <name>iLookAhead</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <name>i</name><operator>&gt;=</operator><name>YY_ACTTAB_COUNT</name> <operator>||</operator> <name><name>yy_lookahead</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><name>iLookAhead</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>iLookAhead</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYFALLBACK</name></cpp:ifdef>
      <decl_stmt><decl><type><name>YYCODETYPE</name></type> <name>iFallback</name></decl>;</decl_stmt>            <comment type="block">/* Fallback token */</comment>
      <if_stmt><if>if<condition>( <expr><name>iLookAhead</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>yyFallback</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>yyFallback</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof>
             <operator>&amp;&amp;</operator> <operator>(</operator><name>iFallback</name> <operator>=</operator> <name><name>yyFallback</name><index>[<expr><name>iLookAhead</name></expr>]</index></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal>
             <operator>&amp;&amp;</operator> <name><name>parserContext</name><operator>-&gt;</operator><name>doFallbacks</name></name></expr> )</condition><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
        <if_stmt><if>if<condition>( <expr><name>yyTraceFILE</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>, <argument><expr><literal type="string">"%sFALLBACK %s =&gt; %s\n"</literal></expr></argument>,
             <argument><expr><name>yyTracePrompt</name></expr></argument>, <argument><expr><name><name>yyTokenName</name><index>[<expr><name>iLookAhead</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>yyTokenName</name><index>[<expr><name>iFallback</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <return>return <expr><call><name>yy_find_shift_action</name><argument_list>(<argument><expr><name>pParser</name></expr></argument>, <argument><expr><name>iFallback</name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYWILDCARD</name></cpp:ifdef>
      <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name>i</name> <operator>-</operator> <name>iLookAhead</name> <operator>+</operator> <name>YYWILDCARD</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>(
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>YY_SHIFT_MIN</name><operator>+</operator><name>YYWILDCARD</name><operator>&lt;</operator><literal type="number">0</literal></expr></cpp:if>
          <expr><name>j</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>YY_SHIFT_MAX</name><operator>+</operator><name>YYWILDCARD</name><operator>&gt;=</operator><name>YY_ACTTAB_COUNT</name></expr></cpp:if>
          <name>j</name><operator>&lt;</operator><name>YY_ACTTAB_COUNT</name> <operator>&amp;&amp;</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <name><name>yy_lookahead</name><index>[<expr><name>j</name></expr>]</index></name><operator>==</operator><name>YYWILDCARD</name></expr>
        )</condition><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
          <if_stmt><if>if<condition>( <expr><name>yyTraceFILE</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>, <argument><expr><literal type="string">"%sWILDCARD %s =&gt; %s\n"</literal></expr></argument>,
               <argument><expr><name>yyTracePrompt</name></expr></argument>, <argument><expr><name><name>yyTokenName</name><index>[<expr><name>iLookAhead</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>yyTokenName</name><index>[<expr><name>YYWILDCARD</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* NDEBUG */</comment>
          <return>return <expr><name><name>yy_action</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* YYWILDCARD */</comment>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name><name>yy_default</name><index>[<expr><name>stateno</name></expr>]</index></name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><name><name>yy_action</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Find the appropriate action for a parser given the non-terminal
** look-ahead token iLookAhead.
**
** If the look-ahead token is YYNOCODE, then check to see if the action is
** independent of the look-ahead.  If it is, return the action, otherwise
** return YY_NO_ACTION.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>yy_find_reduce_action</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>stateno</name></decl></parameter>,              <comment type="block">/* Current state number */</comment>
  <parameter><decl><type><name>YYCODETYPE</name></type> <name>iLookAhead</name></decl></parameter>     <comment type="block">/* The look-ahead token */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYERRORSYMBOL</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>stateno</name><operator>&gt;</operator><name>YY_REDUCE_COUNT</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name><name>yy_default</name><index>[<expr><name>stateno</name></expr>]</index></name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>stateno</name><operator>&lt;=</operator><name>YY_REDUCE_COUNT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>yy_reduce_ofst</name><index>[<expr><name>stateno</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>!=</operator><name>YY_REDUCE_USE_DFLT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iLookAhead</name><operator>!=</operator><name>YYNOCODE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>i</name> <operator>+=</operator> <name>iLookAhead</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYERRORSYMBOL</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <name>i</name><operator>&gt;=</operator><name>YY_ACTTAB_COUNT</name> <operator>||</operator> <name><name>yy_lookahead</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><name>iLookAhead</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name><name>yy_default</name><index>[<expr><name>stateno</name></expr>]</index></name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name>YY_ACTTAB_COUNT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>yy_lookahead</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name>iLookAhead</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name><name>yy_action</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The following routine is called if the stack overflows.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>yyStackOverflow</name><parameter_list>(<parameter><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>yypParser</name></decl></parameter>, <parameter><decl><type><name>YYMINORTYPE</name> <modifier>*</modifier></type><name>yypMinor</name></decl></parameter>)</parameter_list><block>{<block_content>
   <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>yypMinor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <expr_stmt><expr><name>ParseARG_FETCH</name></expr>;</expr_stmt>
   <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name><operator>--</operator></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
   <if_stmt><if>if<condition>( <expr><name>yyTraceFILE</name></expr> )</condition><block>{<block_content>
     <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>,<argument><expr><literal type="string">"%sStack Overflow!\n"</literal></expr></argument>,<argument><expr><name>yyTracePrompt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
   <while>while<condition>( <expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>yy_pop_parser_stack</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
   <comment type="block">/* Here code is inserted which will execute if the parser
   ** stack every overflows */</comment>
<expr_stmt><expr><operator>%</operator><operator>%</operator>
   <name>ParseARG_STORE</name></expr>;</expr_stmt> <comment type="block">/* Suppress warning about unused %extra_argument var */</comment>
</block_content>}</block></function>

<comment type="block">/*
** Perform a shift action.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>yy_shift</name><parameter_list>(
  <parameter><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>yypParser</name></decl></parameter>,          <comment type="block">/* The parser to be shifted */</comment>
  <parameter><decl><type><name>int</name></type> <name>yyNewState</name></decl></parameter>,               <comment type="block">/* The new state to shift in */</comment>
  <parameter><decl><type><name>int</name></type> <name>yyMajor</name></decl></parameter>,                  <comment type="block">/* The major token to shift in */</comment>
  <parameter><decl><type><name>YYMINORTYPE</name> <modifier>*</modifier></type><name>yypMinor</name></decl></parameter>         <comment type="block">/* Pointer to the minor token to shift in */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>yyStackEntry</name> <modifier>*</modifier></type><name>yytos</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name><operator>++</operator></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYTRACKMAXSTACKDEPTH</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name><operator>&gt;</operator><name><name>yypParser</name><operator>-&gt;</operator><name>yyidxMax</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidxMax</name></name> <operator>=</operator> <name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>YYSTACKDEPTH</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name><operator>&gt;=</operator><name>YYSTACKDEPTH</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>yyStackOverflow</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>, <argument><expr><name>yypMinor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <if_stmt><if>if<condition>( <expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name><operator>&gt;=</operator><name><name>yypParser</name><operator>-&gt;</operator><name>yystksz</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>yyGrowStack</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name><operator>&gt;=</operator><name><name>yypParser</name><operator>-&gt;</operator><name>yystksz</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>yyStackOverflow</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>, <argument><expr><name>yypMinor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>yytos</name> <operator>=</operator> <operator>&amp;</operator><name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>yytos</name><operator>-&gt;</operator><name>stateno</name></name> <operator>=</operator> <operator>(</operator><name>YYACTIONTYPE</name><operator>)</operator><name>yyNewState</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>yytos</name><operator>-&gt;</operator><name>major</name></name> <operator>=</operator> <operator>(</operator><name>YYCODETYPE</name><operator>)</operator><name>yyMajor</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>yytos</name><operator>-&gt;</operator><name>minor</name></name> <operator>=</operator> <operator>*</operator><name>yypMinor</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>yytos</name><operator>-&gt;</operator><name>tokens</name></name> <operator>=</operator> <name>new</name> <call><name><name>QList</name><argument_list type="generic">&lt;<argument><expr><name>Token</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name>yyTraceFILE</name> <operator>&amp;&amp;</operator> <name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>,<argument><expr><literal type="string">"%sShift %d\n"</literal></expr></argument>,<argument><expr><name>yyTracePrompt</name></expr></argument>,<argument><expr><name>yyNewState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>,<argument><expr><literal type="string">"%sStack:"</literal></expr></argument>,<argument><expr><name>yyTracePrompt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>,<argument><expr><literal type="string">" %s"</literal></expr></argument>,<argument><expr><name><name>yyTokenName</name><index>[<expr><name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>major</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>,<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/* The following table contains information about every rule that
** is used during the reduce.
*/</comment>
<struct><specifier>static</specifier> <specifier>const</specifier> struct <block>{
  <decl_stmt><decl><type><name>YYCODETYPE</name></type> <name>lhs</name></decl>;</decl_stmt>         <comment type="block">/* Symbol on the left-hand side of the rule */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>nrhs</name></decl>;</decl_stmt>     <comment type="block">/* Number of right-hand side symbols in the rule */</comment>
}</block> <decl><name><name>yyRuleInfo</name><index>[]</index></name> <init>= <expr><block>{
<expr><operator>%</operator><operator>%</operator></expr>
}</block></expr></init></decl>;</struct>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>yy_accept</name><parameter_list>(<parameter><decl><type><name>yyParser</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>  <comment type="block">/* Forward Declaration */</comment>

<comment type="block">/*
** Perform a reduce action and the shift that must immediately
** follow the reduce.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>yy_reduce</name><parameter_list>(
  <parameter><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>yypParser</name></decl></parameter>,         <comment type="block">/* The parser */</comment>
  <parameter><decl><type><name>int</name></type> <name>yyruleno</name></decl></parameter>                 <comment type="block">/* Number of the rule by which to reduce */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>yygoto</name></decl>;</decl_stmt>                     <comment type="block">/* The next state */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>yyact</name></decl>;</decl_stmt>                      <comment type="block">/* The next action */</comment>
  <decl_stmt><decl><type><name>YYMINORTYPE</name></type> <name>yygotominor</name></decl>;</decl_stmt>        <comment type="block">/* The LHS of the rule reduced */</comment>
  <decl_stmt><decl><type><name>yyStackEntry</name> <modifier>*</modifier></type><name>yymsp</name></decl>;</decl_stmt>            <comment type="block">/* The top of the parser's stack */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>yysize</name></decl>;</decl_stmt>                     <comment type="block">/* Amount to pop the stack */</comment>
  <expr_stmt><expr><name>ParseARG_FETCH</name></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>SqliteStatement</name><modifier>*</modifier></type> <name>objectForTokens</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>QStringList</name></type> <name>noTokenInheritanceFields</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>yymsp</name> <operator>=</operator> <operator>&amp;</operator><name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name></expr>]</index></name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name>yyTraceFILE</name> <operator>&amp;&amp;</operator> <name>yyruleno</name><operator>&gt;=</operator><literal type="number">0</literal>
        <operator>&amp;&amp;</operator> <name>yyruleno</name><operator>&lt;</operator><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>yyRuleName</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>yyRuleName</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>, <argument><expr><literal type="string">"%sReduce [%s].\n"</literal></expr></argument>, <argument><expr><name>yyTracePrompt</name></expr></argument>,
      <argument><expr><name><name>yyRuleName</name><index>[<expr><name>yyruleno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* NDEBUG */</comment>

  <comment type="block">/* Silence complaints from purify about yygotominor being uninitialized
  ** in some cases when it is copied into the stack after the following
  ** switch.  yygotominor is uninitialized when a rule reduces that does
  ** not set the value of its left-hand side nonterminal.  Leaving the
  ** value of the nonterminal uninitialized is utterly harmless as long
  ** as the value is never used.  So really the only thing this code
  ** accomplishes is to quieten purify.
  **
  ** 2007-01-16:  The wireshark project (www.wireshark.org) reports that
  ** without this code, their parser segfaults.  I'm not sure what there
  ** parser is doing to make this happen.  This is the second bug report
  ** from wireshark this week.  Clearly they are stressing Lemon in ways
  ** that it has not been previously stressed...  (SQLite ticket #2172)
  */</comment>
  <comment type="block">/*memset(&amp;yygotominor, 0, sizeof(yygotominor));*/</comment>
  <expr_stmt><expr><name>yygotominor</name> <operator>=</operator> <name>yyzerominor</name></expr>;</expr_stmt>


  <if_stmt><if>if <condition>(<expr><name><name>parserContext</name><operator>-&gt;</operator><name>executeRules</name></name></expr>)</condition>
  <block>{<block_content>
      <switch>switch<condition>( <expr><name>yyruleno</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Beginning here are the reduction cases.  A typical example
      ** follows:
      **   case 0:
      **  #line &lt;lineno&gt; &lt;grammarfile&gt;
      **     { ... }           // User supplied code
      **  #line &lt;lineno&gt; &lt;thisfile&gt;
      **     break;
      */</comment>
<expr_stmt><expr><operator>%</operator><operator>%</operator></expr></expr_stmt>
      </block_content>}</block></switch><empty_stmt>;</empty_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>yyruleno</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>yyruleno</name><operator>&lt;</operator><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>yyRuleInfo</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>yyRuleInfo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>yygoto</name> <operator>=</operator> <name><name>yyRuleInfo</name><index>[<expr><name>yyruleno</name></expr>]</index></name><operator>.</operator><name>lhs</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>yysize</name> <operator>=</operator> <name><name>yyRuleInfo</name><index>[<expr><name>yyruleno</name></expr>]</index></name><operator>.</operator><name>nrhs</name></expr>;</expr_stmt>

  <comment type="line">// Store tokens for the rule in parser context</comment>
  <decl_stmt><decl><type><name><name>QList</name><argument_list type="generic">&lt;<argument><expr><name>Token</name><modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>allTokens</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>QList</name><argument_list type="generic">&lt;<argument><expr><name>Token</name><modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>allTokensWithAllInherited</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>QString</name></type> <name>keyForTokensMap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>tokensMapKeyCnt</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>parserContext</name><operator>-&gt;</operator><name>setupTokens</name></name></expr>)</condition>
  <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>objectForTokens</name></expr>)</condition>
      <block>{<block_content>
          <comment type="line">// In case this is a list with recurrent references we need</comment>
          <comment type="line">// to clear tokens before adding the new and extended list.</comment>
          <expr_stmt><expr><call><name><name>objectForTokens</name><operator>-&gt;</operator><name>tokens</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <decl_stmt><decl><type><name><name>QList</name><argument_list type="generic">&lt;<argument><expr><name>Token</name><modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>tokens</name></decl>;</decl_stmt>
      <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name> <operator>-</operator> <name>yysize</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
      <block>{<block_content>
          <expr_stmt><expr><call><name><name>tokens</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>fieldName</name> <init>= <expr><name><name>yyTokenName</name><index>[<expr><name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>major</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

          <comment type="line">// Adding token being subject of this reduction. It's usually not includes in the inherited tokens,</comment>
          <comment type="line">// although if inheriting from simple statements, like "FAIL" or "ROLLBACK", this tends to be redundant with the inherited tokens.</comment>
          <comment type="line">// That's why we're checking if it's not contained in the inherited tokens and add it only then.</comment>
          <if_stmt><if>if <condition>(<expr><call><name><name>parserContext</name><operator>-&gt;</operator><name>isManagedToken</name></name><argument_list>(<argument><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>minor</name><operator>.</operator><name>yy0</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name><name>tokens</name><operator>-&gt;</operator><name>contains</name></name><argument_list>(<argument><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>minor</name><operator>.</operator><name>yy0</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><name>tokens</name> <operator>+=</operator> <name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>minor</name><operator>.</operator><name>yy0</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

          <expr_stmt><expr><name>tokens</name> <operator>+=</operator> <operator>*</operator><operator>(</operator><name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tokens</name><operator>)</operator></expr>;</expr_stmt>

          <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>noTokenInheritanceFields</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>)</condition>
          <block>{<block_content>
              <if_stmt><if>if <condition>(<expr><name>objectForTokens</name></expr>)</condition>
              <block>{<block_content>
                  <expr_stmt><expr><name>keyForTokensMap</name> <operator>=</operator> <name>fieldName</name></expr>;</expr_stmt>
                  <expr_stmt><expr><name>tokensMapKeyCnt</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                  <while>while <condition>(<expr><call><name><name>objectForTokens</name><operator>-&gt;</operator><name>tokensMap</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>keyForTokensMap</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                      <expr_stmt><expr><name>keyForTokensMap</name> <operator>=</operator> <name>fieldName</name> <operator>+</operator> <name>QString</name><operator>::</operator><call><name>number</name><argument_list>(<argument><expr><name>tokensMapKeyCnt</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

                  <expr_stmt><expr><name><name>objectForTokens</name><operator>-&gt;</operator><name>tokensMap</name><index>[<expr><name>keyForTokensMap</name></expr>]</index></name> <operator>=</operator> <call><name><name>parserContext</name><operator>-&gt;</operator><name>getTokenPtrList</name></name><argument_list>(<argument><expr><name>tokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>

              <expr_stmt><expr><name>allTokens</name> <operator>+=</operator> <name>tokens</name></expr>;</expr_stmt>
          </block_content>}</block></if>
          <else>else
          <block>{<block_content>
              <comment type="line">// If field is mentioned only once, then only one occurance of it will be ignored.</comment>
              <comment type="line">// Second one should be inherited. See "anylist" definition for explanation why.</comment>
              <expr_stmt><expr><call><name><name>noTokenInheritanceFields</name><operator>.</operator><name>removeOne</name></name><argument_list>(<argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <expr_stmt><expr><name>allTokensWithAllInherited</name> <operator>+=</operator> <name>tokens</name></expr>;</expr_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if <condition>(<expr><name>objectForTokens</name></expr>)</condition>
      <block>{<block_content>
          <expr_stmt><expr><name><name>objectForTokens</name><operator>-&gt;</operator><name>tokens</name></name> <operator>+=</operator> <call><name><name>parserContext</name><operator>-&gt;</operator><name>getTokenPtrList</name></name><argument_list>(<argument><expr><name>allTokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="line">// Clear token lists</comment>
  <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name> <operator>-</operator> <name>yysize</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
      <expr_stmt><expr><name>delete</name> <name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tokens</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tokens</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name> <operator>-=</operator> <name>yysize</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>yyact</name> <operator>=</operator> <call><name>yy_find_reduce_action</name><argument_list>(<argument><expr><name><name>yymsp</name><index>[<expr><operator>-</operator><name>yysize</name></expr>]</index></name><operator>.</operator><name>stateno</name></expr></argument>,<argument><expr><operator>(</operator><name>YYCODETYPE</name><operator>)</operator><name>yygoto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>yyact</name> <operator>&lt;</operator> <name>YYNSTATE</name></expr> )</condition><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NDEBUG</name></cpp:ifdef>
    <comment type="block">/* If we are not debugging and the reduce action popped at least
    ** one element off the stack, then we can push the new element back
    ** onto the stack here, and skip the stack overflow test in yy_shift().
    ** That gives a significant speed improvement. */</comment>
    <if_stmt><if>if<condition>( <expr><name>yysize</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>yymsp</name> <operator>-=</operator> <name>yysize</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>yymsp</name><operator>-&gt;</operator><name>stateno</name></name> <operator>=</operator> <operator>(</operator><name>YYACTIONTYPE</name><operator>)</operator><name>yyact</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>yymsp</name><operator>-&gt;</operator><name>major</name></name> <operator>=</operator> <operator>(</operator><name>YYCODETYPE</name><operator>)</operator><name>yygoto</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>yymsp</name><operator>-&gt;</operator><name>minor</name></name> <operator>=</operator> <name>yygotominor</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>parserContext</name><operator>-&gt;</operator><name>setupTokens</name></name></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name></expr>]</index></name><operator>.</operator><name>tokens</name><operator>)</operator> <operator>=</operator> <name>allTokens</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{<block_content>
      <expr_stmt><expr><call><name>yy_shift</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>,<argument><expr><name>yyact</name></expr></argument>,<argument><expr><name>yygoto</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>yygotominor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>parserContext</name><operator>-&gt;</operator><name>setupTokens</name></name></expr>)</condition>
      <block>{<block_content>
          <decl_stmt><decl><type><name><name>QList</name><argument_list type="generic">&lt;<argument><expr><name>Token</name><modifier>*</modifier></expr></argument>&gt;</argument_list></name><modifier>*</modifier></type> <name>tokensPtr</name> <init>= <expr><name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name></expr>]</index></name><operator>.</operator><name>tokens</name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><operator>*</operator><name>tokensPtr</name> <operator>=</operator> <name>allTokensWithAllInherited</name> <operator>+</operator> <operator>*</operator><name>tokensPtr</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>yyact</name> <operator>==</operator> <name>YYNSTATE</name> <operator>+</operator> <name>YYNRULE</name> <operator>+</operator> <literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>yy_accept</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The following code executes when the parse fails
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YYNOERRORRECOVERY</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>yy_parse_failed</name><parameter_list>(
  <parameter><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>yypParser</name></decl></parameter>           <comment type="block">/* The parser */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name>ParseARG_FETCH</name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name>yyTraceFILE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>,<argument><expr><literal type="string">"%sFail!\n"</literal></expr></argument>,<argument><expr><name>yyTracePrompt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <while>while<condition>( <expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>yy_pop_parser_stack</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
  <comment type="block">/* Here code is inserted which will be executed whenever the
  ** parser fails */</comment>
<expr_stmt><expr><operator>%</operator><operator>%</operator>
  <name>ParseARG_STORE</name></expr>;</expr_stmt> <comment type="block">/* Suppress warning about unused %extra_argument variable */</comment>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* YYNOERRORRECOVERY */</comment>

<comment type="block">/*
** The following code executes when a syntax error first occurs.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>yy_syntax_error</name><parameter_list>(
  <parameter><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>yypParser</name></decl></parameter>,           <comment type="block">/* The parser */</comment>
  <parameter><decl><type><name>int</name></type> <name>yymajor</name></decl></parameter>,                   <comment type="block">/* The major type of the error token */</comment>
  <parameter><decl><type><name>YYMINORTYPE</name></type> <name>yyminor</name></decl></parameter>            <comment type="block">/* The minor type of the error token */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name>ParseARG_FETCH</name></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TOKEN</name></cpp:macro> <cpp:value>(yyminor.yy0)</cpp:value></cpp:define>
<expr_stmt><expr><operator>%</operator><operator>%</operator>
  <name>ParseARG_STORE</name></expr>;</expr_stmt> <comment type="block">/* Suppress warning about unused %extra_argument variable */</comment>
</block_content>}</block></function>

<comment type="block">/*
** The following is executed when the parser accepts
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>yy_accept</name><parameter_list>(
  <parameter><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>yypParser</name></decl></parameter>           <comment type="block">/* The parser */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name>ParseARG_FETCH</name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name>yyTraceFILE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>,<argument><expr><literal type="string">"%sAccept!\n"</literal></expr></argument>,<argument><expr><name>yyTracePrompt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <while>while<condition>( <expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>yy_pop_parser_stack</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
  <comment type="block">/* Here code is inserted which will be executed whenever the
  ** parser accepts */</comment>
<expr_stmt><expr><operator>%</operator><operator>%</operator>
  <name>ParseARG_STORE</name></expr>;</expr_stmt> <comment type="block">/* Suppress warning about unused %extra_argument variable */</comment>
</block_content>}</block></function>

<comment type="block">/* The main parser program.
** The first argument is a pointer to a structure obtained from
** "ParseAlloc" which describes the current state of the parser.
** The second argument is the major token number.  The third is
** the minor token.  The fourth optional argument is whatever the
** user wants (and specified in the grammar) and is available for
** use by the action routines.
**
** Inputs:
** &lt;ul&gt;
** &lt;li&gt; A pointer to the parser (an opaque structure.)
** &lt;li&gt; The major token number.
** &lt;li&gt; The minor token number.
** &lt;li&gt; An option argument of a grammar-specified type.
** &lt;/ul&gt;
**
** Outputs:
** None.
*/</comment>
<function><type><name>void</name></type> <name>Parse</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>yyp</name></decl></parameter>,                   <comment type="block">/* The parser */</comment>
  <parameter><decl><type><name>int</name></type> <name>yymajor</name></decl></parameter>,                 <comment type="block">/* The major token code number */</comment>
  <parameter><decl><type><name>ParseTOKENTYPE</name> <name>yyminor</name></type>       <comment type="block">/* The value for the token */</comment>
  <name>ParseARG_PDECL</name></decl></parameter>               <comment type="block">/* Optional %extra_argument parameter */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>YYMINORTYPE</name></type> <name>yyminorunion</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>yyact</name></decl>;</decl_stmt>            <comment type="block">/* The parser action. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>YYERRORSYMBOL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>YYNOERRORRECOVERY</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type><name>int</name></type> <name>yyendofinput</name></decl>;</decl_stmt>     <comment type="block">/* True if we are at the end of input */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYERRORSYMBOL</name></cpp:ifdef>
  <decl_stmt><decl><type><name>int</name></type> <name>yyerrorhit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* True if yymajor has invoked an error */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>yypParser</name></decl>;</decl_stmt>  <comment type="block">/* The parser */</comment>

  <comment type="block">/* (re)initialize the parser, if necessary */</comment>
  <expr_stmt><expr><name>yypParser</name> <operator>=</operator> <operator>(</operator><name>yyParser</name><operator>*</operator><operator>)</operator><name>yyp</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>YYSTACKDEPTH</name><operator>&lt;=</operator><literal type="number">0</literal></expr></cpp:if>
    <if_stmt><if>if<condition>( <expr><name><name>yypParser</name><operator>-&gt;</operator><name>yystksz</name></name> <operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/*memset(&amp;yyminorunion, 0, sizeof(yyminorunion));*/</comment>
      <expr_stmt><expr><name>yyminorunion</name> <operator>=</operator> <name>yyzerominor</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>yyStackOverflow</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>yyminorunion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyerrcnt</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>stateno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>major</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>tokens</name> <operator>=</operator> <name>new</name> <call><name><name>QList</name><argument_list type="generic">&lt;<argument><expr><name>Token</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>yyminorunion</name><operator>.</operator><name>yy0</name></name> <operator>=</operator> <name>yyminor</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>YYERRORSYMBOL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>YYNOERRORRECOVERY</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><name>yyendofinput</name> <operator>=</operator> <operator>(</operator><name>yymajor</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>ParseARG_STORE</name></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name>yyTraceFILE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>,<argument><expr><literal type="string">"%sInput %s [%s] (lemon type: %s)\n"</literal></expr></argument>,
            <argument><expr><name>yyTracePrompt</name></expr></argument>,
            <argument><expr><call><name><name>yyminor</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>toLatin1</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>data</name><argument_list>()</argument_list></call></expr></argument>,
            <argument><expr><call><name><name>yyminor</name><operator>-&gt;</operator><name>typeString</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>toLatin1</name><argument_list>()</argument_list></call><operator>.</operator><call><name>data</name><argument_list>()</argument_list></call></expr></argument>,
            <argument><expr><name><name>yyTokenName</name><index>[<expr><name>yymajor</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <do>do<block>{<block_content>
    <expr_stmt><expr><name>yyact</name> <operator>=</operator> <call><name>yy_find_shift_action</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>,<argument><expr><operator>(</operator><name>YYCODETYPE</name><operator>)</operator><name>yymajor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>yyact</name><operator>&lt;</operator><name>YYNSTATE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>yy_shift</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>,<argument><expr><name>yyact</name></expr></argument>,<argument><expr><name>yymajor</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>yyminorunion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyerrcnt</name></name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>yymajor</name> <operator>=</operator> <name>YYNOCODE</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>yyact</name> <operator>&lt;</operator> <name>YYNSTATE</name> <operator>+</operator> <name>YYNRULE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>yy_reduce</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>,<argument><expr><name>yyact</name><operator>-</operator><name>YYNSTATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>yyact</name> <operator>==</operator> <name>YY_ERROR_ACTION</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYERRORSYMBOL</name></cpp:ifdef>
      <decl_stmt><decl><type><name>int</name></type> <name>yymx</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
      <if_stmt><if>if<condition>( <expr><name>yyTraceFILE</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>,<argument><expr><literal type="string">"%sSyntax Error!\n"</literal></expr></argument>,<argument><expr><name>yyTracePrompt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYERRORSYMBOL</name></cpp:ifdef>
      <comment type="block">/* A syntax error has occurred.
      ** The response to an error depends upon whether or not the
      ** grammar defines an error token "ERROR".
      **
      ** This is what we do if the grammar does define ERROR:
      **
      **  * Call the %syntax_error function.
      **
      **  * Begin popping the stack until we enter a state where
      **    it is legal to shift the error symbol, then shift
      **    the error symbol.
      **
      **  * Set the error count to three.
      **
      **  * Begin accepting and shifting new tokens.  No new error
      **    processing will occur until three tokens have been
      **    shifted successfully.
      **
      */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyerrcnt</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>yy_syntax_error</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>,<argument><expr><name>yymajor</name></expr></argument>,<argument><expr><name>yyminorunion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>yymx</name> <operator>=</operator> <name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name></expr>]</index></name><operator>.</operator><name>major</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>yymx</name><operator>==</operator><name>YYERRORSYMBOL</name> <operator>||</operator> <name>yyerrorhit</name></expr> )</condition><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
        <if_stmt><if>if<condition>( <expr><name>yyTraceFILE</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>,<argument><expr><literal type="string">"%sDiscard input token %s\n"</literal></expr></argument>,
             <argument><expr><name>yyTracePrompt</name></expr></argument>,<argument><expr><name><name>yyTokenName</name><index>[<expr><name>yymajor</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>yy_destructor</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>, <argument><expr><operator>(</operator><name>YYCODETYPE</name><operator>)</operator><name>yymajor</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>yyminorunion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>yymajor</name> <operator>=</operator> <name>YYNOCODE</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
         <while>while<condition>(
          <expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
          <name>yymx</name> <operator>!=</operator> <name>YYERRORSYMBOL</name> <operator>&amp;&amp;</operator>
          <operator>(</operator><name>yyact</name> <operator>=</operator> <call><name>yy_find_reduce_action</name><argument_list>(
                        <argument><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name></expr>]</index></name><operator>.</operator><name>stateno</name></expr></argument>,
                        <argument><expr><name>YYERRORSYMBOL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <name>YYNSTATE</name></expr>
        )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>yy_pop_parser_stack</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if<condition>( <expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>yymajor</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>yy_destructor</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>,<argument><expr><operator>(</operator><name>YYCODETYPE</name><operator>)</operator><name>yymajor</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>yyminorunion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>yy_parse_failed</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>yymajor</name> <operator>=</operator> <name>YYNOCODE</name></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>yymx</name><operator>!=</operator><name>YYERRORSYMBOL</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>YYMINORTYPE</name></type> <name>u2</name></decl>;</decl_stmt>
          <expr_stmt><expr><name><name>u2</name><operator>.</operator><name>YYERRSYMDT</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>yy_shift</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>,<argument><expr><name>yyact</name></expr></argument>,<argument><expr><name>YYERRORSYMBOL</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>u2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyerrcnt</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="line">// not 3 valid tokens, but 1</comment>
      <expr_stmt><expr><name>yyerrorhit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYNOERRORRECOVERY</name></expr></argument>)</argument_list></call></expr></cpp:elif>
      <comment type="block">/* If the YYNOERRORRECOVERY macro is defined, then do not attempt to
      ** do any kind of error recovery.  Instead, simply invoke the syntax
      ** error routine and continue going as if nothing had happened.
      **
      ** Applications can set this macro (for example inside %include) if
      ** they intend to abandon the parse upon the first syntax error seen.
      */</comment>
      <expr_stmt><expr><call><name>yy_syntax_error</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>,<argument><expr><name>yymajor</name></expr></argument>,<argument><expr><name>yyminorunion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>yy_destructor</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>,<argument><expr><operator>(</operator><name>YYCODETYPE</name><operator>)</operator><name>yymajor</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>yyminorunion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>yymajor</name> <operator>=</operator> <name>YYNOCODE</name></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* YYERRORSYMBOL is not defined */</comment>
      <comment type="block">/* This is what we do if the grammar does not define ERROR:
      **
      **  * Report an error message, and throw away the input token.
      **
      **  * If the input token is $, then fail the parse.
      **
      ** As before, subsequent error messages are suppressed until
      ** three input tokens have been successfully shifted.
      */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyerrcnt</name></name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>yy_syntax_error</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>,<argument><expr><name>yymajor</name></expr></argument>,<argument><expr><name>yyminorunion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyerrcnt</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="line">// not 3 valid tokens, but 1</comment>
      <expr_stmt><expr><call><name>yy_destructor</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>,<argument><expr><operator>(</operator><name>YYCODETYPE</name><operator>)</operator><name>yymajor</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>yyminorunion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>yyendofinput</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>yy_parse_failed</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>yymajor</name> <operator>=</operator> <name>YYNOCODE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block>while<condition>( <expr><name>yymajor</name><operator>!=</operator><name>YYNOCODE</name> <operator>&amp;&amp;</operator> <name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition>;</do>
  <return>return;</return>
</block_content>}</block></function></unit>
