<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/contrib/pg_standby/pg_standby.c"><comment type="block">/*
 * contrib/pg_standby/pg_standby.c
 *
 *
 * pg_standby.c
 *
 * Production-ready example of how to create a Warm Standby
 * database server using continuous archiving as a
 * replication mechanism
 *
 * We separate the parameters for archive and nextWALfile
 * so that we can check the archive exists, even if the
 * WAL file doesn't (yet).
 *
 * This program will be executed once in full for each file
 * requested by the warm standby server.
 *
 * It is designed to cater to a variety of needs, as well
 * providing a customizable section.
 *
 * Original author:		Simon Riggs  simon@2ndquadrant.com
 * Current maintainer:	Simon Riggs
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dirent.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_getopt.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type>			<name>WalSegSz</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* Options and defaults */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>sleeptime</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* amount of time to sleep between file checks */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>waittime</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* how long we have been waiting, -1 no wait
								 * yet */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>maxwaittime</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* how long are we prepared to wait for? */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>keepfiles</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* number of WAL files to keep, 0 keep all */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>maxretries</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* number of retries on restore command */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>debug</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>		<comment type="block">/* are we debugging? */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>need_cleanup</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* do we need to remove files from
									 * archive? */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>signaled</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>archiveLocation</name></decl>;</decl_stmt>	<comment type="block">/* where to find the archive? */</comment>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>triggerPath</name></decl>;</decl_stmt>		<comment type="block">/* where to find the trigger file? */</comment>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>xlogFilePath</name></decl>;</decl_stmt>		<comment type="block">/* where we are going to restore to */</comment>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nextWALFileName</name></decl>;</decl_stmt>	<comment type="block">/* the file we need to get from archive */</comment>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>restartWALFileName</name></decl>;</decl_stmt> <comment type="block">/* the file from which we can restart restore */</comment>
<decl_stmt><decl><type><name>char</name></type>		<name><name>WALFilePath</name><index>[<expr><name>MAXPGPATH</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* the file path including archive */</comment>
<decl_stmt><decl><type><name>char</name></type>		<name><name>restoreCommand</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* run this to restore */</comment>
<decl_stmt><decl><type><name>char</name></type>		<name><name>exclusiveCleanupFileName</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* the file we need to get
													 * from archive */</comment>

<comment type="block">/*
 * Two types of failover are supported (smart and fast failover).
 *
 * The content of the trigger file determines the type of failover. If the
 * trigger file contains the word "smart" (or the file is empty), smart
 * failover is chosen: pg_standby acts as cp or ln command itself, on
 * successful completion all the available WAL records will be applied
 * resulting in zero data loss. But, it might take a long time to finish
 * recovery if there's a lot of unapplied WAL.
 *
 * On the other hand, if the trigger file contains the word "fast", the
 * recovery is finished immediately even if unapplied WAL files remain. Any
 * transactions in the unapplied WAL files are lost.
 *
 * An empty trigger file performs smart failover. SIGUSR or SIGINT triggers
 * fast failover. A timeout causes fast failover (smart failover would have
 * the same effect, since if the timeout is reached there is no unapplied WAL).
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NoFailover</name></cpp:macro>		<cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SmartFailover</name></cpp:macro>	<cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FastFailover</name></cpp:macro>	<cpp:value>2</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>Failover</name> <init>= <expr><name>NoFailover</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RESTORE_COMMAND_COPY</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RESTORE_COMMAND_LINK</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<decl_stmt><decl><type><name>int</name></type>			<name>restoreCommandType</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XLOG_DATA</name></cpp:macro>			 <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XLOG_HISTORY</name></cpp:macro>		 <cpp:value>1</cpp:value></cpp:define>
<decl_stmt><decl><type><name>int</name></type>			<name>nextWALFileType</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_RESTORE_COMMAND</name><parameter_list>(<parameter><type><name>cmd</name></type></parameter>, <parameter><type><name>arg1</name></type></parameter>, <parameter><type><name>arg2</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>snprintf(restoreCommand, MAXPGPATH, cmd " \"%s\" \"%s\"", arg1, arg2)</cpp:value></cpp:define>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_buf</name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>SetWALFileNameForCleanup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>SetWALSegSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* =====================================================================
 *
 *		  Customizable section
 *
 * =====================================================================
 *
 *	Currently, this section assumes that the Archive is a locally
 *	accessible directory. If you want to make other assumptions,
 *	such as using a vendor-specific archive and access API, these
 *	routines are the ones you'll need to change. You're
 *	encouraged to submit any changes to pgsql-hackers@lists.postgresql.org
 *	or personally to the current maintainer. Those changes may be
 *	folded in to later versions of this program.
 */</comment>

<comment type="block">/*
 *	Initialize allows customized commands into the warm standby program.
 *
 *	As an example, and probably the common case, we use either
 *	cp/ln commands on *nix, or copy/move command on Windows.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CustomizableInitialize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>WALFilePath</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s\\%s"</literal></expr></argument>, <argument><expr><name>archiveLocation</name></expr></argument>, <argument><expr><name>nextWALFileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>restoreCommandType</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RESTORE_COMMAND_LINK</name></expr>:</case>
			<expr_stmt><expr><call><name>SET_RESTORE_COMMAND</name><argument_list>(<argument><expr><literal type="string">"mklink"</literal></expr></argument>, <argument><expr><name>WALFilePath</name></expr></argument>, <argument><expr><name>xlogFilePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RESTORE_COMMAND_COPY</name></expr>:</case>
		<default>default:</default>
			<expr_stmt><expr><call><name>SET_RESTORE_COMMAND</name><argument_list>(<argument><expr><literal type="string">"copy"</literal></expr></argument>, <argument><expr><name>WALFilePath</name></expr></argument>, <argument><expr><name>xlogFilePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>WALFilePath</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>archiveLocation</name></expr></argument>, <argument><expr><name>nextWALFileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>restoreCommandType</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RESTORE_COMMAND_LINK</name></expr>:</case>
			<expr_stmt><expr><call><name>SET_RESTORE_COMMAND</name><argument_list>(<argument><expr><literal type="string">"ln -s -f"</literal></expr></argument>, <argument><expr><name>WALFilePath</name></expr></argument>, <argument><expr><name>xlogFilePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RESTORE_COMMAND_COPY</name></expr>:</case>
		<default>default:</default>
			<expr_stmt><expr><call><name>SET_RESTORE_COMMAND</name><argument_list>(<argument><expr><literal type="string">"cp"</literal></expr></argument>, <argument><expr><name>WALFilePath</name></expr></argument>, <argument><expr><name>xlogFilePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * This code assumes that archiveLocation is a directory You may wish to
	 * add code to check for tape libraries, etc.. So, since it is a
	 * directory, we use stat to test if it's accessible
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>archiveLocation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: archive location \"%s\" does not exist\n"</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>archiveLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * CustomizableNextWALFileReady()
 *
 *	  Is the requested file ready yet?
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CustomizableNextWALFileReady</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>WALFilePath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we've not seen any WAL segments, we don't know the WAL segment
		 * size, which we need. If it looks like a WAL segment, determine size
		 * of segments for the cluster.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>WalSegSz</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>IsXLogFileName</name><argument_list>(<argument><expr><name>nextWALFileName</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>SetWALSegSize</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Successfully determined WAL segment size. Can compute
				 * cleanup cutoff now.
				 */</comment>
				<expr_stmt><expr><name>need_cleanup</name> <operator>=</operator> <call><name>SetWALFileNameForCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>debug</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
							<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"WAL segment size:     %d \n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>WalSegSz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Keep archive history: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>need_cleanup</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s and later\n"</literal></expr></argument>,
								<argument><expr><name>exclusiveCleanupFileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"no cleanup required\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Return only if it's the right size already.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>WalSegSz</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>stat_buf</name><operator>.</operator><name>st_size</name></name> <operator>==</operator> <name>WalSegSz</name></expr>)</condition>
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>

			<comment type="block">/*
			 * Windows 'cp' sets the final file size before the copy is
			 * complete, and not yet ready to be opened by pg_standby. So we
			 * wait for sleeptime secs before attempting to restore. If that
			 * is not enough, we will rely on the retry/holdoff mechanism.
			 * GNUWin32's cp does not have this problem.
			 */</comment>
			<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>sleeptime</name> <operator>*</operator> <literal type="number">1000000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><name>nextWALFileType</name> <operator>=</operator> <name>XLOG_DATA</name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If still too small, wait until it is the correct size
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>WalSegSz</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>stat_buf</name><operator>.</operator><name>st_size</name></name> <operator>&gt;</operator> <name>WalSegSz</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>debug</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"file size greater than expected\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>CustomizableCleanupPriorWALFiles</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Work out name of prior file from current filename
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nextWALFileType</name> <operator>==</operator> <name>XLOG_DATA</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>xldir</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>xlde</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Assume it's OK to keep failing. The failure situation may change
		 * over time, so we'd rather keep going on the main processing than
		 * fail because we couldn't clean up yet.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>xldir</name> <operator>=</operator> <call><name>opendir</name><argument_list>(<argument><expr><name>archiveLocation</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<while>while <condition>(<expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><operator>(</operator><name>xlde</name> <operator>=</operator> <call><name>readdir</name><argument_list>(<argument><expr><name>xldir</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * We ignore the timeline part of the XLOG segment identifiers
				 * in deciding whether a segment is still needed.  This
				 * ensures that we won't prematurely remove a segment from a
				 * parent timeline. We could probably be a little more
				 * proactive about removing segments of non-parent timelines,
				 * but that would be a whole lot more complicated.
				 *
				 * We use the alphanumeric sorting property of the filenames
				 * to decide which ones are earlier than the
				 * exclusiveCleanupFileName file. Note that this means files
				 * are not removed in the order they were originally written,
				 * in case this worries you.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>IsXLogFileName</name><argument_list>(<argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<call><name>strcmp</name><argument_list>(<argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name> <operator>+</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><name>exclusiveCleanupFileName</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
					<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>WALFilePath</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WALFilePath</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s\\%s"</literal></expr></argument>, <argument><expr><name>archiveLocation</name></expr></argument>, <argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
					<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>WALFilePath</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WALFilePath</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>archiveLocation</name></expr></argument>, <argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

					<if_stmt><if>if <condition>(<expr><name>debug</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\nremoving file \"%s\""</literal></expr></argument>, <argument><expr><name>WALFilePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unlink</name><argument_list>(<argument><expr><name>WALFilePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n%s: ERROR: could not remove file \"%s\": %s\n"</literal></expr></argument>,
								<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>WALFilePath</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></while>

			<if_stmt><if>if <condition>(<expr><name>errno</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: could not read archive location \"%s\": %s\n"</literal></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>archiveLocation</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>debug</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: could not open archive location \"%s\": %s\n"</literal></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>archiveLocation</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>closedir</name><argument_list>(<argument><expr><name>xldir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: could not close archive location \"%s\": %s\n"</literal></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>archiveLocation</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* =====================================================================
 *		  End of Customizable section
 * =====================================================================
 */</comment>

<comment type="block">/*
 * SetWALFileNameForCleanup()
 *
 *	  Set the earliest WAL filename that we want to keep on the archive
 *	  and decide whether we need_cleanup
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>SetWALFileNameForCleanup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>tli</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>log</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>seg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>log_diff</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>seg_diff</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>cleanup</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>max_segments_per_logfile</name> <init>= <expr><operator>(</operator><literal type="number">0xFFFFFFFF</literal> <operator>/</operator> <name>WalSegSz</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>restartWALFileName</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Don't do cleanup if the restartWALFileName provided is later than
		 * the xlog file requested. This is an error and we must not remove
		 * these files from archive. This shouldn't happen, but better safe
		 * than sorry.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>restartWALFileName</name></expr></argument>, <argument><expr><name>nextWALFileName</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>exclusiveCleanupFileName</name></expr></argument>, <argument><expr><name>restartWALFileName</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>exclusiveCleanupFileName</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>keepfiles</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>sscanf</name><argument_list>(<argument><expr><name>nextWALFileName</name></expr></argument>, <argument><expr><literal type="string">"%08X%08X%08X"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>tli</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>log</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tli</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>seg</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>log_diff</name> <operator>=</operator> <name>keepfiles</name> <operator>/</operator> <name>max_segments_per_logfile</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>seg_diff</name> <operator>=</operator> <name>keepfiles</name> <operator>%</operator> <name>max_segments_per_logfile</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>seg_diff</name> <operator>&gt;</operator> <name>seg</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>log_diff</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>seg</name> <operator>=</operator> <name>max_segments_per_logfile</name> <operator>-</operator> <operator>(</operator><name>seg_diff</name> <operator>-</operator> <name>seg</name><operator>)</operator></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>seg</name> <operator>-=</operator> <name>seg_diff</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>log</name> <operator>&gt;=</operator> <name>log_diff</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>log</name> <operator>-=</operator> <name>log_diff</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>cleanup</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>log</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>seg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>XLogFileNameById</name><argument_list>(<argument><expr><name>exclusiveCleanupFileName</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>, <argument><expr><name>log</name></expr></argument>, <argument><expr><name>seg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>cleanup</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Try to set the wal segment size from the WAL file specified by WALFilePath.
 *
 * Return true if size could be determined, false otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>SetWALSegSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ret_val</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGAlignedXLogBlock</name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>WalSegSz</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>WALFilePath</name></expr></argument>, <argument><expr><name>O_RDWR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: could not open WAL file \"%s\": %s\n"</literal></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>WALFilePath</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>XLOG_BLCKSZ</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>XLOG_BLCKSZ</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogLongPageHeader</name></type> <name>longhdr</name> <init>= <expr><operator>(</operator><name>XLogLongPageHeader</name><operator>)</operator> <name><name>buf</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>WalSegSz</name> <operator>=</operator> <name><name>longhdr</name><operator>-&gt;</operator><name>xlp_seg_size</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsValidWalSegSize</name><argument_list>(<argument><expr><name>WalSegSz</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* successfully retrieved WAL segment size */</comment>
			<expr_stmt><expr><name>ret_val</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><literal type="string">"%s: WAL segment size must be a power of two between 1MB and 1GB, but the WAL file header specifies %d bytes\n"</literal></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>WalSegSz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Don't complain loudly, this is to be expected for segments being
		 * created.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>debug</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"could not read file \"%s\": %s\n"</literal></expr></argument>,
						<argument><expr><name>WALFilePath</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>debug</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"not enough data in file \"%s\"\n"</literal></expr></argument>,
						<argument><expr><name>WALFilePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret_val</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CheckForExternalTrigger()
 *
 *	  Is there a trigger file? Sets global 'Failover' variable to indicate
 *	  what kind of a trigger file it was. A "fast" trigger file is turned
 *	  into a "smart" file as a side-effect.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CheckForExternalTrigger</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Look for a trigger file, if that option has been selected
	 *
	 * We use stat() here because triggerPath is always a file rather than
	 * potentially being in an archive
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>triggerPath</name> <operator>||</operator> <call><name>stat</name><argument_list>(<argument><expr><name>triggerPath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * An empty trigger file performs smart failover. There's a little race
	 * condition here: if the writer of the trigger file has just created the
	 * file, but not yet written anything to it, we'll treat that as smart
	 * shutdown even if the other process was just about to write "fast" to
	 * it. But that's fine: we'll restore one more WAL file, and when we're
	 * invoked next time, we'll see the word "fast" and fail over immediately.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stat_buf</name><operator>.</operator><name>st_size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>Failover</name> <operator>=</operator> <name>SmartFailover</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"trigger file found: smart failover\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>triggerPath</name></expr></argument>, <argument><expr><name>O_RDWR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"WARNING: could not open \"%s\": %s\n"</literal></expr></argument>,
				<argument><expr><name>triggerPath</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>len</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"WARNING: could not read \"%s\": %s\n"</literal></expr></argument>,
				<argument><expr><name>triggerPath</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"smart"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>Failover</name> <operator>=</operator> <name>SmartFailover</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"trigger file found: smart failover\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"fast"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>Failover</name> <operator>=</operator> <name>FastFailover</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"trigger file found: fast failover\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Turn it into a "smart" trigger by truncating the file. Otherwise if
		 * the server asks us again to restore a segment that was restored
		 * already, we would return "not found" and upset the server.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ftruncate</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"WARNING: could not read \"%s\": %s\n"</literal></expr></argument>,
					<argument><expr><name>triggerPath</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"WARNING: invalid content in \"%s\"\n"</literal></expr></argument>, <argument><expr><name>triggerPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RestoreWALFileForRecovery()
 *
 *	  Perform the action required to restore the file from archive
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>RestoreWALFileForRecovery</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numretries</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>debug</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"running restore:      "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><name>numretries</name> <operator>&lt;=</operator> <name>maxretries</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>system</name><argument_list>(<argument><expr><name>restoreCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>debug</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"OK\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>numretries</name><operator>++</operator> <operator>*</operator> <name>sleeptime</name> <operator>*</operator> <literal type="number">1000000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Allow caller to add additional info
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>debug</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"not restored\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>usage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s allows PostgreSQL warm standby servers to be configured.\n\n"</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Usage:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  %s [OPTION]... ARCHIVELOCATION NEXTWALFILE XLOGFILEPATH [RESTARTWALFILE]\n"</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nOptions:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -c                 copy file from archive (default)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -d                 generate lots of debugging output (testing only)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -k NUMFILESTOKEEP  if RESTARTWALFILE is not used, remove files prior to limit\n"</literal>
		   <literal type="string">"                     (0 keeps all)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -l                 does nothing; use of link is now deprecated\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -r MAXRETRIES      max number of times to retry, with progressive wait\n"</literal>
		   <literal type="string">"                     (default=3)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -s SLEEPTIME       seconds to wait between file checks (min=1, max=60,\n"</literal>
		   <literal type="string">"                     default=5)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -t TRIGGERFILE     trigger file to initiate failover (no default)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -V, --version      output version information, then exit\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -w MAXWAITTIME     max seconds to wait for a file (0=no limit) (default=0)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -?, --help         show this help, then exit\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal>
		   <literal type="string">"Main intended use as restore_command in postgresql.conf:\n"</literal>
		   <literal type="string">"  restore_command = 'pg_standby [OPTION]... ARCHIVELOCATION %%f %%p %%r'\n"</literal>
		   <literal type="string">"e.g.\n"</literal>
		   <literal type="string">"  restore_command = 'pg_standby /mnt/server/archiverdir %%f %%p %%r'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nReport bugs to &lt;%s&gt;.\n"</literal></expr></argument>, <argument><expr><name>PACKAGE_BUGREPORT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s home page: &lt;%s&gt;\n"</literal></expr></argument>, <argument><expr><name>PACKAGE_NAME</name></expr></argument>, <argument><expr><name>PACKAGE_URL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sighandler</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>signaled</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* We don't want SIGQUIT to core dump */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sigquit_handler</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SIGINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*------------ MAIN ----------------------------------------*/</comment>
<function><type><name>int</name></type>
<name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>c</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>progname</name> <operator>=</operator> <call><name>get_progname</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--help"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-?"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--version"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-V"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><literal type="string">"pg_standby (PostgreSQL) "</literal> <name>PG_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>

	<comment type="block">/*
	 * You can send SIGUSR1 to trigger failover.
	 *
	 * Postmaster uses SIGQUIT to request immediate shutdown. The default
	 * action is to core dump, but we don't want that, so trap it and commit
	 * suicide without core dump.
	 *
	 * We used to use SIGINT and SIGQUIT to trigger failover, but that turned
	 * out to be a bad idea because postmaster uses SIGQUIT to request
	 * immediate shutdown. We still trap SIGINT, but that may change in a
	 * future release.
	 *
	 * There's no way to trigger failover via signal on Windows.
	 */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>, <argument><expr><name>sighandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>sighandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* deprecated, use SIGUSR1 */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>, <argument><expr><name>sigquit_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>getopt</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"cdk:lr:s:t:w:"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name>c</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'c'</literal></expr>:</case>			<comment type="block">/* Use copy */</comment>
				<expr_stmt><expr><name>restoreCommandType</name> <operator>=</operator> <name>RESTORE_COMMAND_COPY</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'d'</literal></expr>:</case>			<comment type="block">/* Debug mode */</comment>
				<expr_stmt><expr><name>debug</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'k'</literal></expr>:</case>			<comment type="block">/* keepfiles */</comment>
				<expr_stmt><expr><name>keepfiles</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>keepfiles</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: -k keepfiles must be &gt;= 0\n"</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'l'</literal></expr>:</case>			<comment type="block">/* Use link */</comment>

				<comment type="block">/*
				 * Link feature disabled, possibly permanently. Linking causes
				 * a problem after recovery ends that is not currently
				 * resolved by PostgreSQL. 25 Jun 2009
				 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
				<expr_stmt><expr><name>restoreCommandType</name> <operator>=</operator> <name>RESTORE_COMMAND_LINK</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<break>break;</break>
			<case>case <expr><literal type="char">'r'</literal></expr>:</case>			<comment type="block">/* Retries */</comment>
				<expr_stmt><expr><name>maxretries</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>maxretries</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: -r maxretries must be &gt;= 0\n"</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'s'</literal></expr>:</case>			<comment type="block">/* Sleep time */</comment>
				<expr_stmt><expr><name>sleeptime</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>sleeptime</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>sleeptime</name> <operator>&gt;</operator> <literal type="number">60</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: -s sleeptime incorrectly set\n"</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'t'</literal></expr>:</case>			<comment type="block">/* Trigger file */</comment>
				<expr_stmt><expr><name>triggerPath</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'w'</literal></expr>:</case>			<comment type="block">/* Max wait time */</comment>
				<expr_stmt><expr><name>maxwaittime</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>maxwaittime</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: -w maxwaittime incorrectly set\n"</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Parameter checking - after checking to see if trigger file present
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: not enough command-line arguments\n"</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We will go to the archiveLocation to get nextWALFileName.
	 * nextWALFileName may not exist yet, which would not be an error, so we
	 * separate the archiveLocation and nextWALFileName so we can check
	 * separately whether archiveLocation exists, if not that is an error
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>optind</name> <operator>&lt;</operator> <name>argc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>archiveLocation</name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>optind</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: must specify archive location\n"</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>optind</name> <operator>&lt;</operator> <name>argc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>nextWALFileName</name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>optind</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: must specify WAL file name as second non-option argument (use \"%%f\")\n"</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>optind</name> <operator>&lt;</operator> <name>argc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>xlogFilePath</name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>optind</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: must specify xlog destination as third non-option argument (use \"%%p\")\n"</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>optind</name> <operator>&lt;</operator> <name>argc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>restartWALFileName</name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>optind</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>CustomizableInitialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>debug</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Trigger file:         %s\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>triggerPath</name></expr> ?</condition><then> <expr><name>triggerPath</name></expr> </then><else>: <expr><literal type="string">"&lt;not set&gt;"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Waiting for WAL file: %s\n"</literal></expr></argument>, <argument><expr><name>nextWALFileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"WAL file path:        %s\n"</literal></expr></argument>, <argument><expr><name>WALFilePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Restoring to:         %s\n"</literal></expr></argument>, <argument><expr><name>xlogFilePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Sleep interval:       %d second%s\n"</literal></expr></argument>,
				<argument><expr><name>sleeptime</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>sleeptime</name> <operator>&gt;</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="string">"s"</literal></expr> </then><else>: <expr><literal type="string">" "</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Max wait interval:    %d %s\n"</literal></expr></argument>,
				<argument><expr><name>maxwaittime</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>maxwaittime</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">"seconds"</literal></expr> </then><else>: <expr><literal type="string">"forever"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Command for restore:  %s\n"</literal></expr></argument>, <argument><expr><name>restoreCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check for initial history file: always the first file to be requested
	 * It's OK if the file isn't there - all other files need to wait
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsTLHistoryFileName</name><argument_list>(<argument><expr><name>nextWALFileName</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>nextWALFileType</name> <operator>=</operator> <name>XLOG_HISTORY</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>RestoreWALFileForRecovery</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>debug</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"history file not found\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Main wait loop
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/* Check for trigger file or signal first */</comment>
		<expr_stmt><expr><call><name>CheckForExternalTrigger</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
		<if_stmt><if>if <condition>(<expr><name>signaled</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>Failover</name> <operator>=</operator> <name>FastFailover</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>debug</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"signaled to exit: fast failover\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/*
		 * Check for fast failover immediately, before checking if the
		 * requested WAL file is available
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>Failover</name> <operator>==</operator> <name>FastFailover</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>CustomizableNextWALFileReady</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Once we have restored this file successfully we can remove some
			 * prior WAL files. If this restore fails we mustn't remove any
			 * file because some of them will be requested again immediately
			 * after the failed restore, or when we restart recovery.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>RestoreWALFileForRecovery</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>need_cleanup</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>CustomizableCleanupPriorWALFiles</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Something went wrong in copying the file */</comment>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Check for smart failover if the next WAL file was not available */</comment>
		<if_stmt><if>if <condition>(<expr><name>Failover</name> <operator>==</operator> <name>SmartFailover</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>sleeptime</name> <operator>&lt;=</operator> <literal type="number">60</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>sleeptime</name> <operator>*</operator> <literal type="number">1000000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>waittime</name> <operator>+=</operator> <name>sleeptime</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>waittime</name> <operator>&gt;=</operator> <name>maxwaittime</name> <operator>&amp;&amp;</operator> <name>maxwaittime</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>Failover</name> <operator>=</operator> <name>FastFailover</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>debug</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Timed out after %d seconds: fast failover\n"</literal></expr></argument>,
						<argument><expr><name>waittime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>debug</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"WAL file not present yet."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>triggerPath</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" Checking for trigger file..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>
</unit>
