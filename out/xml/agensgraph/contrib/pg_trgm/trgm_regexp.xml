<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/contrib/pg_trgm/trgm_regexp.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * trgm_regexp.c
 *	  Regular expression matching using trigrams.
 *
 * The general idea of trigram index support for a regular expression (regex)
 * search is to transform the regex into a logical expression on trigrams.
 * For example:
 *
 *	 (ab|cd)efg  =&gt;  ((abe &amp; bef) | (cde &amp; def)) &amp; efg
 *
 * If a string matches the regex, then it must match the logical expression on
 * trigrams.  The opposite is not necessarily true, however: a string that
 * matches the logical expression might not match the original regex.  Such
 * false positives are removed via recheck, by running the regular regex match
 * operator on the retrieved heap tuple.
 *
 * Since the trigram expression involves both AND and OR operators, we can't
 * expect the core index machinery to evaluate it completely.  Instead, the
 * result of regex analysis is a list of trigrams to be sought in the index,
 * plus a simplified graph that is used by trigramsMatchGraph() to determine
 * whether a particular indexed value matches the expression.
 *
 * Converting a regex to a trigram expression is based on analysis of an
 * automaton corresponding to the regex.  The algorithm consists of four
 * stages:
 *
 * 1) Compile the regexp to NFA form.  This is handled by the PostgreSQL
 *	  regexp library, which provides accessors for its opaque regex_t struct
 *	  to expose the NFA state graph and the "colors" (sets of equivalent
 *	  characters) used as state transition labels.
 *
 * 2) Transform the original NFA into an expanded graph, where arcs
 *	  are labeled with trigrams that must be present in order to move from
 *	  one state to another via the arcs.  The trigrams used in this stage
 *	  consist of colors, not characters, as in the original NFA.
 *
 * 3) Expand the color trigrams into regular trigrams consisting of
 *	  characters.  If too many distinct trigrams are produced, trigrams are
 *	  eliminated and the graph is simplified until it's simple enough.
 *
 * 4) Finally, the resulting graph is packed into a TrgmPackedGraph struct,
 *	  and returned to the caller.
 *
 * 1) Compile the regexp to NFA form
 * ---------------------------------
 * The automaton returned by the regexp compiler is a graph where vertices
 * are "states" and arcs are labeled with colors.  Each color represents
 * a set of characters, so that all characters assigned to the same color
 * are interchangeable, so far as matching the regexp is concerned.  There
 * are two special states: "initial" and "final".  A state can have multiple
 * outgoing arcs labeled with the same color, which makes the automaton
 * non-deterministic, because it can be in many states simultaneously.
 *
 * Note that this NFA is already lossy compared to the original regexp,
 * since it ignores some regex features such as lookahead constraints and
 * backref matching.  This is OK for our purposes since it's still the case
 * that only strings matching the NFA can possibly satisfy the regexp.
 *
 * 2) Transform the original NFA into an expanded graph
 * ----------------------------------------------------
 * In the 2nd stage, the automaton is transformed into a graph based on the
 * original NFA.  Each state in the expanded graph represents a state from
 * the original NFA, plus a prefix identifying the last two characters
 * (colors, to be precise) seen before entering the state.  There can be
 * multiple states in the expanded graph for each state in the original NFA,
 * depending on what characters can precede it.  A prefix position can be
 * "unknown" if it's uncertain what the preceding character was, or "blank"
 * if the character was a non-word character (we don't need to distinguish
 * which non-word character it was, so just think of all of them as blanks).
 *
 * For convenience in description, call an expanded-state identifier
 * (two prefix colors plus a state number from the original NFA) an
 * "enter key".
 *
 * Each arc of the expanded graph is labeled with a trigram that must be
 * present in the string to match.  We can construct this from an out-arc of
 * the underlying NFA state by combining the expanded state's prefix with the
 * color label of the underlying out-arc, if neither prefix position is
 * "unknown".  But note that some of the colors in the trigram might be
 * "blank".  This is OK since we want to generate word-boundary trigrams as
 * the regular trigram machinery would, if we know that some word characters
 * must be adjacent to a word boundary in all strings matching the NFA.
 *
 * The expanded graph can also have fewer states than the original NFA,
 * because we don't bother to make a separate state entry unless the state
 * is reachable by a valid arc.  When an enter key is reachable from a state
 * of the expanded graph, but we do not know a complete trigram associated
 * with that transition, we cannot make a valid arc; instead we insert the
 * enter key into the enterKeys list of the source state.  This effectively
 * means that the two expanded states are not reliably distinguishable based
 * on examining trigrams.
 *
 * So the expanded graph resembles the original NFA, but the arcs are
 * labeled with trigrams instead of individual characters, and there may be
 * more or fewer states.  It is a lossy representation of the original NFA:
 * any string that matches the original regexp must match the expanded graph,
 * but the reverse is not true.
 *
 * We build the expanded graph through a breadth-first traversal of states
 * reachable from the initial state.  At each reachable state, we identify the
 * states reachable from it without traversing a predictable trigram, and add
 * those states' enter keys to the current state.  Then we generate all
 * out-arcs leading out of this collection of states that have predictable
 * trigrams, adding their target states to the queue of states to examine.
 *
 * When building the graph, if the number of states or arcs exceed pre-defined
 * limits, we give up and simply mark any states not yet processed as final
 * states.  Roughly speaking, that means that we make use of some portion from
 * the beginning of the regexp.  Also, any colors that have too many member
 * characters are treated as "unknown", so that we can't derive trigrams
 * from them.
 *
 * 3) Expand the color trigrams into regular trigrams
 * --------------------------------------------------
 * The trigrams in the expanded graph are "color trigrams", consisting
 * of three consecutive colors that must be present in the string. But for
 * search, we need regular trigrams consisting of characters. In the 3rd
 * stage, the color trigrams are expanded into regular trigrams. Since each
 * color can represent many characters, the total number of regular trigrams
 * after expansion could be very large. Because searching the index for
 * thousands of trigrams would be slow, and would likely produce so many
 * false positives that we would have to traverse a large fraction of the
 * index, the graph is simplified further in a lossy fashion by removing
 * color trigrams. When a color trigram is removed, the states connected by
 * any arcs labeled with that trigram are merged.
 *
 * Trigrams do not all have equivalent value for searching: some of them are
 * more frequent and some of them are less frequent. Ideally, we would like
 * to know the distribution of trigrams, but we don't. But because of padding
 * we know for sure that the empty character is more frequent than others,
 * so we can penalize trigrams according to presence of whitespace. The
 * penalty assigned to each color trigram is the number of simple trigrams
 * it would produce, times the penalties[] multiplier associated with its
 * whitespace content. (The penalties[] constants were calculated by analysis
 * of some real-life text.) We eliminate color trigrams starting with the
 * highest-penalty one, until we get to a total penalty of no more than
 * WISH_TRGM_PENALTY. However, we cannot remove a color trigram if that would
 * lead to merging the initial and final states, so we may not be able to
 * reach WISH_TRGM_PENALTY. It's still okay so long as we have no more than
 * MAX_TRGM_COUNT simple trigrams in total, otherwise we fail.
 *
 * 4) Pack the graph into a compact representation
 * -----------------------------------------------
 * The 2nd and 3rd stages might have eliminated or merged many of the states
 * and trigrams created earlier, so in this final stage, the graph is
 * compacted and packed into a simpler struct that contains only the
 * information needed to evaluate it.
 *
 * ALGORITHM EXAMPLE:
 *
 * Consider the example regex "ab[cd]".  This regex is transformed into the
 * following NFA (for simplicity we show colors as their single members):
 *
 *					  4#
 *					c/
 *		 a	   b	/
 *	 1* --- 2 ---- 3
 *					\
 *					d\
 *					  5#
 *
 * We use * to mark initial state and # to mark final state. It's not depicted,
 * but states 1, 4, 5 have self-referencing arcs for all possible characters,
 * because this pattern can match to any part of a string.
 *
 * As the result of stage 2 we will have the following graph:
 *
 *		  abc	 abd
 *	 2# &lt;---- 1* ----&gt; 3#
 *
 * The process for generating this graph is:
 * 1) Create state 1 with enter key (UNKNOWN, UNKNOWN, 1).
 * 2) Add key (UNKNOWN, "a", 2) to state 1.
 * 3) Add key ("a", "b", 3) to state 1.
 * 4) Create new state 2 with enter key ("b", "c", 4).  Add an arc
 *	  from state 1 to state 2 with label trigram "abc".
 * 5) Mark state 2 final because state 4 of source NFA is marked as final.
 * 6) Create new state 3 with enter key ("b", "d", 5).  Add an arc
 *	  from state 1 to state 3 with label trigram "abd".
 * 7) Mark state 3 final because state 5 of source NFA is marked as final.
 *
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  contrib/pg_trgm/trgm_regexp.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"regex/regexport.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"trgm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tsearch/ts_locale.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/hsearch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Uncomment (or use -DTRGM_REGEXP_DEBUG) to print debug info,
 * for exploring and debugging the algorithm implementation.
 * This produces three graph files in /tmp, in Graphviz .gv format.
 * Some progress information is also printed to postmaster stderr.
 */</comment>
<comment type="block">/* #define TRGM_REGEXP_DEBUG */</comment>

<comment type="block">/*
 * These parameters are used to limit the amount of work done.
 * Otherwise regex processing could be too slow and memory-consuming.
 *
 *	MAX_EXPANDED_STATES - How many states we allow in expanded graph
 *	MAX_EXPANDED_ARCS - How many arcs we allow in expanded graph
 *	MAX_TRGM_COUNT - How many simple trigrams we allow to be extracted
 *	WISH_TRGM_PENALTY - Maximum desired sum of color trigram penalties
 *	COLOR_COUNT_LIMIT - Maximum number of characters per color
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_EXPANDED_STATES</name></cpp:macro> <cpp:value>128</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_EXPANDED_ARCS</name></cpp:macro>	<cpp:value>1024</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_TRGM_COUNT</name></cpp:macro>		<cpp:value>256</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WISH_TRGM_PENALTY</name></cpp:macro>	<cpp:value>16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COLOR_COUNT_LIMIT</name></cpp:macro>	<cpp:value>256</cpp:value></cpp:define>

<comment type="block">/*
 * Penalty multipliers for trigram counts depending on whitespace contents.
 * Numbers based on analysis of real-life texts.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>float4</name></type> <name><name>penalties</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <init>= <expr><block>{
	<expr><literal type="number">1.0f</literal></expr>,						<comment type="block">/* "aaa" */</comment>
	<expr><literal type="number">3.5f</literal></expr>,						<comment type="block">/* "aa " */</comment>
	<expr><literal type="number">0.0f</literal></expr>,						<comment type="block">/* "a a" (impossible) */</comment>
	<expr><literal type="number">0.0f</literal></expr>,						<comment type="block">/* "a  " (impossible) */</comment>
	<expr><literal type="number">4.2f</literal></expr>,						<comment type="block">/* " aa" */</comment>
	<expr><literal type="number">2.1f</literal></expr>,						<comment type="block">/* " a " */</comment>
	<expr><literal type="number">25.0f</literal></expr>,						<comment type="block">/* "  a" */</comment>
	<expr><literal type="number">0.0f</literal></expr>						<comment type="block">/* "   " (impossible) */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Struct representing a single pg_wchar, converted back to multibyte form */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>char</name></type>		<name><name>bytes</name><index>[<expr><name>MAX_MULTIBYTE_CHAR_LEN</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>trgm_mb_char</name>;</typedef>

<comment type="block">/*
 * Attributes of NFA colors:
 *
 *	expandable				- we know the character expansion of this color
 *	containsNonWord			- color contains non-word characters
 *							  (which will not be extracted into trigrams)
 *	wordCharsCount			- count of word characters in color
 *	wordChars				- array of this color's word characters
 *							  (which can be extracted into trigrams)
 *
 * When expandable is false, the other attributes don't matter; we just
 * assume this color represents unknown character(s).
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>bool</name></type>		<name>expandable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>containsNonWord</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>wordCharsCount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>trgm_mb_char</name> <modifier>*</modifier></type><name>wordChars</name></decl>;</decl_stmt>
}</block></struct></type> <name>TrgmColorInfo</name>;</typedef>

<comment type="block">/*
 * A "prefix" is information about the colors of the last two characters read
 * before reaching a specific NFA state.  These colors can have special values
 * COLOR_UNKNOWN and COLOR_BLANK.  COLOR_UNKNOWN means that we have no
 * information, for example because we read some character of an unexpandable
 * color.  COLOR_BLANK means that we read a non-word character.
 *
 * We call a prefix ambiguous if at least one of its colors is unknown.  It's
 * fully ambiguous if both are unknown, partially ambiguous if only the first
 * is unknown.  (The case of first color known, second unknown is not valid.)
 *
 * Wholly- or partly-blank prefixes are mostly handled the same as regular
 * color prefixes.  This allows us to generate appropriate partly-blank
 * trigrams when the NFA requires word character(s) to appear adjacent to
 * non-word character(s).
 */</comment>
<typedef>typedef <type><name>int</name></type> <name>TrgmColor</name>;</typedef>

<comment type="block">/* We assume that colors returned by the regexp engine cannot be these: */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COLOR_UNKNOWN</name></cpp:macro>	<cpp:value>(-1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COLOR_BLANK</name></cpp:macro>		<cpp:value>(-2)</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>TrgmColor</name></type>	<name><name>colors</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>TrgmPrefix</name>;</typedef>

<comment type="block">/*
 * Color-trigram data type.  Note that some elements of the trigram can be
 * COLOR_BLANK, but we don't allow COLOR_UNKNOWN.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>TrgmColor</name></type>	<name><name>colors</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>ColorTrgm</name>;</typedef>

<comment type="block">/*
 * Key identifying a state of our expanded graph: color prefix, and number
 * of the corresponding state in the underlying regex NFA.  The color prefix
 * shows how we reached the regex state (to the extent that we know it).
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>TrgmPrefix</name></type>	<name>prefix</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nstate</name></decl>;</decl_stmt>
}</block></struct></type> <name>TrgmStateKey</name>;</typedef>

<comment type="block">/*
 * One state of the expanded graph.
 *
 *	stateKey - ID of this state
 *	arcs	 - outgoing arcs of this state (List of TrgmArc)
 *	enterKeys - enter keys reachable from this state without reading any
 *			   predictable trigram (List of TrgmStateKey)
 *	flags	 - flag bits
 *	snumber  - number of this state (initially assigned as -1, -2, etc,
 *			   for debugging purposes only; then at the packaging stage,
 *			   surviving states are renumbered with positive numbers)
 *	parent	 - parent state, if this state has been merged into another
 *	tentFlags - flags this state would acquire via planned merges
 *	tentParent - planned parent state, if considering a merge
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TSTATE_INIT</name></cpp:macro>		<cpp:value>0x01</cpp:value></cpp:define>	<comment type="block">/* flag indicating this state is initial */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TSTATE_FIN</name></cpp:macro>		<cpp:value>0x02</cpp:value></cpp:define>	<comment type="block">/* flag indicating this state is final */</comment>

<typedef>typedef <type><struct>struct <name>TrgmState</name>
<block>{
	<decl_stmt><decl><type><name>TrgmStateKey</name></type> <name>stateKey</name></decl>;</decl_stmt>		<comment type="block">/* hashtable key: must be first field */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>arcs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>enterKeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>flags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>snumber</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>TrgmState</name></name> <modifier>*</modifier></type><name>parent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tentFlags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>TrgmState</name></name> <modifier>*</modifier></type><name>tentParent</name></decl>;</decl_stmt>
}</block></struct></type> <name>TrgmState</name>;</typedef>

<comment type="block">/*
 * One arc in the expanded graph.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>ColorTrgm</name></type>	<name>ctrgm</name></decl>;</decl_stmt>			<comment type="block">/* trigram needed to traverse arc */</comment>
	<decl_stmt><decl><type><name>TrgmState</name>  <modifier>*</modifier></type><name>target</name></decl>;</decl_stmt>			<comment type="block">/* next state */</comment>
}</block></struct></type> <name>TrgmArc</name>;</typedef>

<comment type="block">/*
 * Information about arc of specific color trigram (used in stage 3)
 *
 * Contains pointers to the source and target states.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>TrgmState</name>  <modifier>*</modifier></type><name>source</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TrgmState</name>  <modifier>*</modifier></type><name>target</name></decl>;</decl_stmt>
}</block></struct></type> <name>TrgmArcInfo</name>;</typedef>

<comment type="block">/*
 * Information about color trigram (used in stage 3)
 *
 * ctrgm	- trigram itself
 * cnumber	- number of this trigram (used in the packaging stage)
 * count	- number of simple trigrams created from this color trigram
 * expanded - indicates this color trigram is expanded into simple trigrams
 * arcs		- list of all arcs labeled with this color trigram.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>ColorTrgm</name></type>	<name>ctrgm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cnumber</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>penalty</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>expanded</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>arcs</name></decl>;</decl_stmt>
}</block></struct></type> <name>ColorTrgmInfo</name>;</typedef>

<comment type="block">/*
 * Data structure representing all the data we need during regex processing.
 *
 *	regex			- compiled regex
 *	colorInfo		- extracted information about regex's colors
 *	ncolors			- number of colors in colorInfo[]
 *	states			- hashtable of TrgmStates (states of expanded graph)
 *	initState		- pointer to initial state of expanded graph
 *	queue			- queue of to-be-processed TrgmStates
 *	keysQueue		- queue of to-be-processed TrgmStateKeys
 *	arcsCount		- total number of arcs of expanded graph (for resource
 *					  limiting)
 *	overflowed		- we have exceeded resource limit for transformation
 *	colorTrgms		- array of all color trigrams present in graph
 *	colorTrgmsCount - count of those color trigrams
 *	totalTrgmCount	- total count of extracted simple trigrams
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<comment type="block">/* Source regexp, and color information extracted from it (stage 1) */</comment>
	<decl_stmt><decl><type><name>regex_t</name>    <modifier>*</modifier></type><name>regex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TrgmColorInfo</name> <modifier>*</modifier></type><name>colorInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ncolors</name></decl>;</decl_stmt>

	<comment type="block">/* Expanded graph (stage 2) */</comment>
	<decl_stmt><decl><type><name>HTAB</name>	   <modifier>*</modifier></type><name>states</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TrgmState</name>  <modifier>*</modifier></type><name>initState</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nstates</name></decl>;</decl_stmt>

	<comment type="block">/* Workspace for stage 2 */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>queue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>keysQueue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>arcsCount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>overflowed</name></decl>;</decl_stmt>

	<comment type="block">/* Information about distinct color trigrams in the graph (stage 3) */</comment>
	<decl_stmt><decl><type><name>ColorTrgmInfo</name> <modifier>*</modifier></type><name>colorTrgms</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>colorTrgmsCount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>totalTrgmCount</name></decl>;</decl_stmt>
}</block></struct></type> <name>TrgmNFA</name>;</typedef>

<comment type="block">/*
 * Final, compact representation of expanded graph.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>targetState</name></decl>;</decl_stmt>	<comment type="block">/* index of target state (zero-based) */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>colorTrgm</name></decl>;</decl_stmt>		<comment type="block">/* index of color trigram for transition */</comment>
}</block></struct></type> <name>TrgmPackedArc</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>arcsCount</name></decl>;</decl_stmt>		<comment type="block">/* number of out-arcs for this state */</comment>
	<decl_stmt><decl><type><name>TrgmPackedArc</name> <modifier>*</modifier></type><name>arcs</name></decl>;</decl_stmt>		<comment type="block">/* array of arcsCount packed arcs */</comment>
}</block></struct></type> <name>TrgmPackedState</name>;</typedef>

<comment type="block">/* "typedef struct TrgmPackedGraph TrgmPackedGraph" appears in trgm.h */</comment>
<struct>struct <name>TrgmPackedGraph</name>
<block>{
	<comment type="block">/*
	 * colorTrigramsCount and colorTrigramGroups contain information about how
	 * trigrams are grouped into color trigrams.  "colorTrigramsCount" is the
	 * count of color trigrams and "colorTrigramGroups" contains number of
	 * simple trigrams for each color trigram.  The array of simple trigrams
	 * (stored separately from this struct) is ordered so that the simple
	 * trigrams for each color trigram are consecutive, and they're in order
	 * by color trigram number.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>colorTrigramsCount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>colorTrigramGroups</name></decl>;</decl_stmt> <comment type="block">/* array of size colorTrigramsCount */</comment>

	<comment type="block">/*
	 * The states of the simplified NFA.  State number 0 is always initial
	 * state and state number 1 is always final state.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>statesCount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TrgmPackedState</name> <modifier>*</modifier></type><name>states</name></decl>;</decl_stmt>	<comment type="block">/* array of size statesCount */</comment>

	<comment type="block">/* Temporary work space for trigramsMatchGraph() */</comment>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>colorTrigramsActive</name></decl>;</decl_stmt>	<comment type="block">/* array of size colorTrigramsCount */</comment>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>statesActive</name></decl>;</decl_stmt>	<comment type="block">/* array of size statesCount */</comment>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>statesQueue</name></decl>;</decl_stmt>	<comment type="block">/* array of size statesCount */</comment>
}</block>;</struct>

<comment type="block">/*
 * Temporary structure for representing an arc during packaging.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>sourceState</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>targetState</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>colorTrgm</name></decl>;</decl_stmt>
}</block></struct></type> <name>TrgmPackArcInfo</name>;</typedef>


<comment type="block">/* prototypes for private functions */</comment>
<function_decl><type><specifier>static</specifier> <name>TRGM</name> <modifier>*</modifier></type><name>createTrgmNFAInternal</name><parameter_list>(<parameter><decl><type><name>regex_t</name> <modifier>*</modifier></type><name>regex</name></decl></parameter>, <parameter><decl><type><name>TrgmPackedGraph</name> <modifier>*</modifier><modifier>*</modifier></type><name>graph</name></decl></parameter>,
								   <parameter><decl><type><name>MemoryContext</name></type> <name>rcontext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RE_compile</name><parameter_list>(<parameter><decl><type><name>regex_t</name> <modifier>*</modifier></type><name>regex</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>text_re</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>cflags</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>getColorInfo</name><parameter_list>(<parameter><decl><type><name>regex_t</name> <modifier>*</modifier></type><name>regex</name></decl></parameter>, <parameter><decl><type><name>TrgmNFA</name> <modifier>*</modifier></type><name>trgmNFA</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>convertPgWchar</name><parameter_list>(<parameter><decl><type><name>pg_wchar</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>trgm_mb_char</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>transformGraph</name><parameter_list>(<parameter><decl><type><name>TrgmNFA</name> <modifier>*</modifier></type><name>trgmNFA</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>processState</name><parameter_list>(<parameter><decl><type><name>TrgmNFA</name> <modifier>*</modifier></type><name>trgmNFA</name></decl></parameter>, <parameter><decl><type><name>TrgmState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>addKey</name><parameter_list>(<parameter><decl><type><name>TrgmNFA</name> <modifier>*</modifier></type><name>trgmNFA</name></decl></parameter>, <parameter><decl><type><name>TrgmState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>TrgmStateKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>addKeyToQueue</name><parameter_list>(<parameter><decl><type><name>TrgmNFA</name> <modifier>*</modifier></type><name>trgmNFA</name></decl></parameter>, <parameter><decl><type><name>TrgmStateKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>addArcs</name><parameter_list>(<parameter><decl><type><name>TrgmNFA</name> <modifier>*</modifier></type><name>trgmNFA</name></decl></parameter>, <parameter><decl><type><name>TrgmState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>addArc</name><parameter_list>(<parameter><decl><type><name>TrgmNFA</name> <modifier>*</modifier></type><name>trgmNFA</name></decl></parameter>, <parameter><decl><type><name>TrgmState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>TrgmStateKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>,
				   <parameter><decl><type><name>TrgmColor</name></type> <name>co</name></decl></parameter>, <parameter><decl><type><name>TrgmStateKey</name> <modifier>*</modifier></type><name>destKey</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>validArcLabel</name><parameter_list>(<parameter><decl><type><name>TrgmStateKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>TrgmColor</name></type> <name>co</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TrgmState</name> <modifier>*</modifier></type><name>getState</name><parameter_list>(<parameter><decl><type><name>TrgmNFA</name> <modifier>*</modifier></type><name>trgmNFA</name></decl></parameter>, <parameter><decl><type><name>TrgmStateKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>prefixContains</name><parameter_list>(<parameter><decl><type><name>TrgmPrefix</name> <modifier>*</modifier></type><name>prefix1</name></decl></parameter>, <parameter><decl><type><name>TrgmPrefix</name> <modifier>*</modifier></type><name>prefix2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>selectColorTrigrams</name><parameter_list>(<parameter><decl><type><name>TrgmNFA</name> <modifier>*</modifier></type><name>trgmNFA</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TRGM</name> <modifier>*</modifier></type><name>expandColorTrigrams</name><parameter_list>(<parameter><decl><type><name>TrgmNFA</name> <modifier>*</modifier></type><name>trgmNFA</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>rcontext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>fillTrgm</name><parameter_list>(<parameter><decl><type><name>trgm</name> <modifier>*</modifier></type><name>ptrgm</name></decl></parameter>, <parameter><decl><type><name>trgm_mb_char</name></type> <name><name>s</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>mergeStates</name><parameter_list>(<parameter><decl><type><name>TrgmState</name> <modifier>*</modifier></type><name>state1</name></decl></parameter>, <parameter><decl><type><name>TrgmState</name> <modifier>*</modifier></type><name>state2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>colorTrgmInfoCmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>colorTrgmInfoPenaltyCmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TrgmPackedGraph</name> <modifier>*</modifier></type><name>packGraph</name><parameter_list>(<parameter><decl><type><name>TrgmNFA</name> <modifier>*</modifier></type><name>trgmNFA</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>rcontext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>packArcInfoCmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a2</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRGM_REGEXP_DEBUG</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>printSourceNFA</name><parameter_list>(<parameter><decl><type><name>regex_t</name> <modifier>*</modifier></type><name>regex</name></decl></parameter>, <parameter><decl><type><name>TrgmColorInfo</name> <modifier>*</modifier></type><name>colors</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ncolors</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>printTrgmNFA</name><parameter_list>(<parameter><decl><type><name>TrgmNFA</name> <modifier>*</modifier></type><name>trgmNFA</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>printTrgmColor</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>TrgmColor</name></type> <name>co</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>printTrgmPackedGraph</name><parameter_list>(<parameter><decl><type><name>TrgmPackedGraph</name> <modifier>*</modifier></type><name>packedGraph</name></decl></parameter>, <parameter><decl><type><name>TRGM</name> <modifier>*</modifier></type><name>trigrams</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
 * Main entry point to process a regular expression.
 *
 * Returns an array of trigrams required by the regular expression, or NULL if
 * the regular expression was too complex to analyze.  In addition, a packed
 * graph representation of the regex is returned into *graph.  The results
 * must be allocated in rcontext (which might or might not be the current
 * context).
 */</comment>
<function><type><name>TRGM</name> <modifier>*</modifier></type>
<name>createTrgmNFA</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>text_re</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>,
			  <parameter><decl><type><name>TrgmPackedGraph</name> <modifier>*</modifier><modifier>*</modifier></type><name>graph</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>rcontext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TRGM</name>	   <modifier>*</modifier></type><name>trg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>regex_t</name></type>		<name>regex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>tmpcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * This processing generates a great deal of cruft, which we'd like to
	 * clean up before returning (since this function may be called in a
	 * query-lifespan memory context).  Make a temp context we can work in so
	 * that cleanup is easy.
	 */</comment>
	<expr_stmt><expr><name>tmpcontext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
									   <argument><expr><literal type="string">"createTrgmNFA temporary context"</literal></expr></argument>,
									   <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>tmpcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Stage 1: Compile the regexp into a NFA, using the regexp library.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IGNORECASE</name></cpp:ifdef>
	<expr_stmt><expr><call><name>RE_compile</name><argument_list>(<argument><expr><operator>&amp;</operator><name>regex</name></expr></argument>, <argument><expr><name>text_re</name></expr></argument>, <argument><expr><name>REG_ADVANCED</name> <operator>|</operator> <name>REG_ICASE</name></expr></argument>, <argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>RE_compile</name><argument_list>(<argument><expr><operator>&amp;</operator><name>regex</name></expr></argument>, <argument><expr><name>text_re</name></expr></argument>, <argument><expr><name>REG_ADVANCED</name></expr></argument>, <argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Since the regexp library allocates its internal data structures with
	 * malloc, we need to use a PG_TRY block to ensure that pg_regfree() gets
	 * done even if there's an error.
	 */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>trg</name> <operator>=</operator> <call><name>createTrgmNFAInternal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>regex</name></expr></argument>, <argument><expr><name>graph</name></expr></argument>, <argument><expr><name>rcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_FINALLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_regfree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>regex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Clean up all the cruft we created */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>tmpcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>trg</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Body of createTrgmNFA, exclusive of regex compilation/freeing.
 */</comment>
<function><type><specifier>static</specifier> <name>TRGM</name> <modifier>*</modifier></type>
<name>createTrgmNFAInternal</name><parameter_list>(<parameter><decl><type><name>regex_t</name> <modifier>*</modifier></type><name>regex</name></decl></parameter>, <parameter><decl><type><name>TrgmPackedGraph</name> <modifier>*</modifier><modifier>*</modifier></type><name>graph</name></decl></parameter>,
					  <parameter><decl><type><name>MemoryContext</name></type> <name>rcontext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TRGM</name>	   <modifier>*</modifier></type><name>trg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TrgmNFA</name></type>		<name>trgmNFA</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>trgmNFA</name><operator>.</operator><name>regex</name></name> <operator>=</operator> <name>regex</name></expr>;</expr_stmt>

	<comment type="block">/* Collect color information from the regex */</comment>
	<expr_stmt><expr><call><name>getColorInfo</name><argument_list>(<argument><expr><name>regex</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>trgmNFA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRGM_REGEXP_DEBUG</name></cpp:ifdef>
	<expr_stmt><expr><call><name>printSourceNFA</name><argument_list>(<argument><expr><name>regex</name></expr></argument>, <argument><expr><name><name>trgmNFA</name><operator>.</operator><name>colorInfo</name></name></expr></argument>, <argument><expr><name><name>trgmNFA</name><operator>.</operator><name>ncolors</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Stage 2: Create an expanded graph from the source NFA.
	 */</comment>
	<expr_stmt><expr><call><name>transformGraph</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trgmNFA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRGM_REGEXP_DEBUG</name></cpp:ifdef>
	<expr_stmt><expr><call><name>printTrgmNFA</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trgmNFA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Fail if we were unable to make a nontrivial graph, ie it is possible to
	 * get from the initial state to the final state without reading any
	 * predictable trigram.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>trgmNFA</name><operator>.</operator><name>initState</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>TSTATE_FIN</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Stage 3: Select color trigrams to expand.  Fail if too many trigrams.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>selectColorTrigrams</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trgmNFA</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Stage 4: Expand color trigrams and pack graph into final
	 * representation.
	 */</comment>
	<expr_stmt><expr><name>trg</name> <operator>=</operator> <call><name>expandColorTrigrams</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trgmNFA</name></expr></argument>, <argument><expr><name>rcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>graph</name> <operator>=</operator> <call><name>packGraph</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trgmNFA</name></expr></argument>, <argument><expr><name>rcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRGM_REGEXP_DEBUG</name></cpp:ifdef>
	<expr_stmt><expr><call><name>printTrgmPackedGraph</name><argument_list>(<argument><expr><operator>*</operator><name>graph</name></expr></argument>, <argument><expr><name>trg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>trg</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Main entry point for evaluating a graph during index scanning.
 *
 * The check[] array is indexed by trigram number (in the array of simple
 * trigrams returned by createTrgmNFA), and holds true for those trigrams
 * that are present in the index entry being checked.
 */</comment>
<function><type><name>bool</name></type>
<name>trigramsMatchGraph</name><parameter_list>(<parameter><decl><type><name>TrgmPackedGraph</name> <modifier>*</modifier></type><name>graph</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>check</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>,
				<decl><type ref="prev"/><name>k</name></decl>,
				<decl><type ref="prev"/><name>queueIn</name></decl>,
				<decl><type ref="prev"/><name>queueOut</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Reset temporary working areas.
	 */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>graph</name><operator>-&gt;</operator><name>colorTrigramsActive</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
		   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>graph</name><operator>-&gt;</operator><name>colorTrigramsCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>graph</name><operator>-&gt;</operator><name>statesActive</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>graph</name><operator>-&gt;</operator><name>statesCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check which color trigrams were matched.  A match for any simple
	 * trigram associated with a color trigram counts as a match of the color
	 * trigram.
	 */</comment>
	<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>graph</name><operator>-&gt;</operator><name>colorTrigramsCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>cnt</name> <init>= <expr><name><name>graph</name><operator>-&gt;</operator><name>colorTrigramGroups</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <name>j</name></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>j</name> <operator>+</operator> <name>cnt</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>check</name><index>[<expr><name>k</name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Found one matched trigram in the group. Can skip the rest
				 * of them and go to the next group.
				 */</comment>
				<expr_stmt><expr><name><name>graph</name><operator>-&gt;</operator><name>colorTrigramsActive</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name>j</name> <operator>=</operator> <name>j</name> <operator>+</operator> <name>cnt</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Initialize the statesQueue to hold just the initial state.  Note:
	 * statesQueue has room for statesCount entries, which is certainly enough
	 * since no state will be put in the queue more than once. The
	 * statesActive array marks which states have been queued.
	 */</comment>
	<expr_stmt><expr><name><name>graph</name><operator>-&gt;</operator><name>statesActive</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>graph</name><operator>-&gt;</operator><name>statesQueue</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>queueIn</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>queueOut</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* Process queued states as long as there are any. */</comment>
	<while>while <condition>(<expr><name>queueIn</name> <operator>&lt;</operator> <name>queueOut</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>stateno</name> <init>= <expr><name><name>graph</name><operator>-&gt;</operator><name>statesQueue</name><index>[<expr><name>queueIn</name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TrgmPackedState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>&amp;</operator><name><name>graph</name><operator>-&gt;</operator><name>states</name><index>[<expr><name>stateno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>cnt</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>arcsCount</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Loop over state's out-arcs */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TrgmPackedArc</name> <modifier>*</modifier></type><name>arc</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>arcs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * If corresponding color trigram is present then activate the
			 * corresponding state.  We're done if that's the final state,
			 * otherwise queue the state if it's not been queued already.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>graph</name><operator>-&gt;</operator><name>colorTrigramsActive</name><index>[<expr><name><name>arc</name><operator>-&gt;</operator><name>colorTrgm</name></name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>nextstate</name> <init>= <expr><name><name>arc</name><operator>-&gt;</operator><name>targetState</name></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>nextstate</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* success: final state is reachable */</comment>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>graph</name><operator>-&gt;</operator><name>statesActive</name><index>[<expr><name>nextstate</name></expr>]</index></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>graph</name><operator>-&gt;</operator><name>statesActive</name><index>[<expr><name>nextstate</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>graph</name><operator>-&gt;</operator><name>statesQueue</name><index>[<expr><name>queueOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>nextstate</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></while>

	<comment type="block">/* Queue is empty, so match fails. */</comment>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Compile regex string into struct at *regex.
 * NB: pg_regfree must be applied to regex if this completes successfully.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RE_compile</name><parameter_list>(<parameter><decl><type><name>regex_t</name> <modifier>*</modifier></type><name>regex</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>text_re</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cflags</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>text_re_len</name> <init>= <expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>text_re</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>text_re_val</name> <init>= <expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>text_re</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_wchar</name>   <modifier>*</modifier></type><name>pattern</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>pattern_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>regcomp_result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>errMsg</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* Convert pattern string to wide characters */</comment>
	<expr_stmt><expr><name>pattern</name> <operator>=</operator> <operator>(</operator><name>pg_wchar</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>text_re_len</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pg_wchar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pattern_len</name> <operator>=</operator> <call><name>pg_mb2wchar_with_len</name><argument_list>(<argument><expr><name>text_re_val</name></expr></argument>,
									   <argument><expr><name>pattern</name></expr></argument>,
									   <argument><expr><name>text_re_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Compile regex */</comment>
	<expr_stmt><expr><name>regcomp_result</name> <operator>=</operator> <call><name>pg_regcomp</name><argument_list>(<argument><expr><name>regex</name></expr></argument>,
								<argument><expr><name>pattern</name></expr></argument>,
								<argument><expr><name>pattern_len</name></expr></argument>,
								<argument><expr><name>cflags</name></expr></argument>,
								<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>regcomp_result</name> <operator>!=</operator> <name>REG_OKAY</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* re didn't compile (no need for pg_regfree, if so) */</comment>
		<expr_stmt><expr><call><name>pg_regerror</name><argument_list>(<argument><expr><name>regcomp_result</name></expr></argument>, <argument><expr><name>regex</name></expr></argument>, <argument><expr><name>errMsg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errMsg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_REGULAR_EXPRESSION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid regular expression: %s"</literal></expr></argument>, <argument><expr><name>errMsg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*---------------------
 * Subroutines for pre-processing the color map (stage 1).
 *---------------------
 */</comment>

<comment type="block">/*
 * Fill TrgmColorInfo structure for each color using regex export functions.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>getColorInfo</name><parameter_list>(<parameter><decl><type><name>regex_t</name> <modifier>*</modifier></type><name>regex</name></decl></parameter>, <parameter><decl><type><name>TrgmNFA</name> <modifier>*</modifier></type><name>trgmNFA</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>colorsCount</name> <init>= <expr><call><name>pg_reg_getnumcolors</name><argument_list>(<argument><expr><name>regex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>ncolors</name></name> <operator>=</operator> <name>colorsCount</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>colorInfo</name></name> <operator>=</operator> <operator>(</operator><name>TrgmColorInfo</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><name>colorsCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TrgmColorInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Loop over colors, filling TrgmColorInfo about each.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>colorsCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TrgmColorInfo</name> <modifier>*</modifier></type><name>colorInfo</name> <init>= <expr><operator>&amp;</operator><name><name>trgmNFA</name><operator>-&gt;</operator><name>colorInfo</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>charsCount</name> <init>= <expr><call><name>pg_reg_getnumcharacters</name><argument_list>(<argument><expr><name>regex</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>pg_wchar</name>   <modifier>*</modifier></type><name>chars</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>charsCount</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>charsCount</name></expr></argument> &gt;</argument_list></name> <name>COLOR_COUNT_LIMIT</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Non expandable, or too large to work with */</comment>
			<expr_stmt><expr><name><name>colorInfo</name><operator>-&gt;</operator><name>expandable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>colorInfo</name><operator>-&gt;</operator><name>expandable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>colorInfo</name><operator>-&gt;</operator><name>containsNonWord</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>colorInfo</name><operator>-&gt;</operator><name>wordChars</name></name> <operator>=</operator> <operator>(</operator><name>trgm_mb_char</name> <operator>*</operator><operator>)</operator>
			<call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>trgm_mb_char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>charsCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>colorInfo</name><operator>-&gt;</operator><name>wordCharsCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/* Extract all the chars in this color */</comment>
		<expr_stmt><expr><name>chars</name> <operator>=</operator> <operator>(</operator><name>pg_wchar</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pg_wchar</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>charsCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_reg_getcharacters</name><argument_list>(<argument><expr><name>regex</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>chars</name></expr></argument>, <argument><expr><name>charsCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Convert characters back to multibyte form, and save only those that
		 * are word characters.  Set "containsNonWord" if any non-word
		 * character.  (Note: it'd probably be nicer to keep the chars in
		 * pg_wchar format for now, but ISWORDCHR wants to see multibyte.)
		 */</comment>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>charsCount</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>trgm_mb_char</name></type> <name>c</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>convertPgWchar</name><argument_list>(<argument><expr><name><name>chars</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* ok to ignore it altogether */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>ISWORDCHR</name><argument_list>(<argument><expr><name><name>c</name><operator>.</operator><name>bytes</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>colorInfo</name><operator>-&gt;</operator><name>wordChars</name><index>[<expr><name><name>colorInfo</name><operator>-&gt;</operator><name>wordCharsCount</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>colorInfo</name><operator>-&gt;</operator><name>containsNonWord</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>chars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Convert pg_wchar to multibyte format.
 * Returns false if the character should be ignored completely.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>convertPgWchar</name><parameter_list>(<parameter><decl><type><name>pg_wchar</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>trgm_mb_char</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* "s" has enough space for a multibyte character and a trailing NUL */</comment>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>s</name><index>[<expr><name>MAX_MULTIBYTE_CHAR_LEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We can ignore the NUL character, since it can never appear in a PG text
	 * string.  This avoids the need for various special cases when
	 * reconstructing trigrams.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Do the conversion, making sure the result is NUL-terminated */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_wchar2mb_with_len</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In IGNORECASE mode, we can ignore uppercase characters.  We assume that
	 * the regex engine generated both uppercase and lowercase equivalents
	 * within each color, since we used the REG_ICASE option; so there's no
	 * need to process the uppercase version.
	 *
	 * XXX this code is dependent on the assumption that lowerstr() works the
	 * same as the regex engine's internal case folding machinery.  Might be
	 * wiser to expose pg_wc_tolower and test whether c == pg_wc_tolower(c).
	 * On the other hand, the trigrams in the index were created using
	 * lowerstr(), so we're probably screwed if there's any incompatibility
	 * anyway.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IGNORECASE</name></cpp:ifdef>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>lowerCased</name> <init>= <expr><call><name>lowerstr</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>lowerCased</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>lowerCased</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>lowerCased</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Fill result with exactly MAX_MULTIBYTE_CHAR_LEN bytes */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>bytes</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>MAX_MULTIBYTE_CHAR_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*---------------------
 * Subroutines for expanding original NFA graph into a trigram graph (stage 2).
 *---------------------
 */</comment>

<comment type="block">/*
 * Transform the graph, given a regex and extracted color information.
 *
 * We create and process a queue of expanded-graph states until all the states
 * are processed.
 *
 * This algorithm may be stopped due to resource limitation. In this case we
 * force every unprocessed branch to immediately finish with matching (this
 * can give us false positives but no false negatives) by marking all
 * unprocessed states as final.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>transformGraph</name><parameter_list>(<parameter><decl><type><name>TrgmNFA</name> <modifier>*</modifier></type><name>trgmNFA</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>hashCtl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TrgmStateKey</name></type> <name>initkey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TrgmState</name>  <modifier>*</modifier></type><name>initstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Initialize this stage's workspace in trgmNFA struct */</comment>
	<expr_stmt><expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>queue</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>keysQueue</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>arcsCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>overflowed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Create hashtable for states */</comment>
	<expr_stmt><expr><name><name>hashCtl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TrgmStateKey</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashCtl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TrgmState</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashCtl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>states</name></name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"Trigram NFA"</literal></expr></argument>,
								  <argument><expr><literal type="number">1024</literal></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>hashCtl</name></expr></argument>,
								  <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>nstates</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Create initial state: ambiguous prefix, NFA's initial state */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>initkey</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>initkey</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>initkey</name><operator>.</operator><name>prefix</name><operator>.</operator><name>colors</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>COLOR_UNKNOWN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>initkey</name><operator>.</operator><name>prefix</name><operator>.</operator><name>colors</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>COLOR_UNKNOWN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>initkey</name><operator>.</operator><name>nstate</name></name> <operator>=</operator> <call><name>pg_reg_getinitialstate</name><argument_list>(<argument><expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>regex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>initstate</name> <operator>=</operator> <call><name>getState</name><argument_list>(<argument><expr><name>trgmNFA</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>initkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>initstate</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>TSTATE_INIT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>initState</name></name> <operator>=</operator> <name>initstate</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Recursively build the expanded graph by processing queue of states
	 * (breadth-first search).  getState already put initstate in the queue.
	 * Note that getState will append new states to the queue within the loop,
	 * too; this works as long as we don't do repeat fetches using the "lc"
	 * pointer.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>trgmNFA-&gt;queue</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TrgmState</name>  <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>TrgmState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If we overflowed then just mark state as final.  Otherwise do
		 * actual processing.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>overflowed</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>TSTATE_FIN</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>processState</name><argument_list>(<argument><expr><name>trgmNFA</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Did we overflow? */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>arcsCount</name></name> <operator>&gt;</operator> <name>MAX_EXPANDED_ARCS</name> <operator>||</operator>
			<call><name>hash_get_num_entries</name><argument_list>(<argument><expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>states</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>MAX_EXPANDED_STATES</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>overflowed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Process one state: add enter keys and then add outgoing arcs.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>processState</name><parameter_list>(<parameter><decl><type><name>TrgmNFA</name> <modifier>*</modifier></type><name>trgmNFA</name></decl></parameter>, <parameter><decl><type><name>TrgmState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* keysQueue should be NIL already, but make sure */</comment>
	<expr_stmt><expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>keysQueue</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Add state's own key, and then process all keys added to keysQueue until
	 * queue is finished.  But we can quit if the state gets marked final.
	 */</comment>
	<expr_stmt><expr><call><name>addKey</name><argument_list>(<argument><expr><name>trgmNFA</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>stateKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>trgmNFA-&gt;keysQueue</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TrgmStateKey</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><operator>(</operator><name>TrgmStateKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>TSTATE_FIN</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>addKey</name><argument_list>(<argument><expr><name>trgmNFA</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Release keysQueue to clean up for next cycle */</comment>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>keysQueue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>keysQueue</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Add outgoing arcs only if state isn't final (we have no interest in
	 * outgoing arcs if we already match)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>TSTATE_FIN</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>addArcs</name><argument_list>(<argument><expr><name>trgmNFA</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add the given enter key into the state's enterKeys list, and determine
 * whether this should result in any further enter keys being added.
 * If so, add those keys to keysQueue so that processState will handle them.
 *
 * If the enter key is for the NFA's final state, mark state as TSTATE_FIN.
 * This situation means that we can reach the final state from this expanded
 * state without reading any predictable trigram, so we must consider this
 * state as an accepting one.
 *
 * The given key could be a duplicate of one already in enterKeys, or be
 * redundant with some enterKeys.  So we check that before doing anything.
 *
 * Note that we don't generate any actual arcs here.  addArcs will do that
 * later, after we have identified all the enter keys for this state.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>addKey</name><parameter_list>(<parameter><decl><type><name>TrgmNFA</name> <modifier>*</modifier></type><name>trgmNFA</name></decl></parameter>, <parameter><decl><type><name>TrgmState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>TrgmStateKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>regex_arc_t</name> <modifier>*</modifier></type><name>arcs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TrgmStateKey</name></type> <name>destKey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>arcsCount</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Ensure any pad bytes in destKey are zero, since it may get used as a
	 * hashtable key by getState.
	 */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>destKey</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>destKey</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compare key to each existing enter key of the state to check for
	 * redundancy.  We can drop either old key(s) or the new key if we find
	 * redundancy.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>state-&gt;enterKeys</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TrgmStateKey</name> <modifier>*</modifier></type><name>existingKey</name> <init>= <expr><operator>(</operator><name>TrgmStateKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>existingKey</name><operator>-&gt;</operator><name>nstate</name></name> <operator>==</operator> <name><name>key</name><operator>-&gt;</operator><name>nstate</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>prefixContains</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>existingKey</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* This old key already covers the new key. Nothing to do */</comment>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>prefixContains</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>existingKey</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * The new key covers this old key. Remove the old key, it's
				 * no longer needed once we add this key to the list.
				 */</comment>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>enterKeys</name></name> <operator>=</operator> <call><name>foreach_delete_current</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>enterKeys</name></name></expr></argument>,
														  <argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* No redundancy, so add this key to the state's list */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>enterKeys</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>enterKeys</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If state is now known final, mark it and we're done */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>nstate</name></name> <operator>==</operator> <call><name>pg_reg_getfinalstate</name><argument_list>(<argument><expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>regex</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>TSTATE_FIN</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Loop through all outgoing arcs of the corresponding state in the
	 * original NFA.
	 */</comment>
	<expr_stmt><expr><name>arcsCount</name> <operator>=</operator> <call><name>pg_reg_getnumoutarcs</name><argument_list>(<argument><expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>regex</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>nstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>arcs</name> <operator>=</operator> <operator>(</operator><name>regex_arc_t</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>regex_arc_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>arcsCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_reg_getoutarcs</name><argument_list>(<argument><expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>regex</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>nstate</name></name></expr></argument>, <argument><expr><name>arcs</name></expr></argument>, <argument><expr><name>arcsCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>arcsCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>regex_arc_t</name> <modifier>*</modifier></type><name>arc</name> <init>= <expr><operator>&amp;</operator><name><name>arcs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>pg_reg_colorisbegin</name><argument_list>(<argument><expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>regex</name></name></expr></argument>, <argument><expr><name><name>arc</name><operator>-&gt;</operator><name>co</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Start of line/string (^).  Trigram extraction treats start of
			 * line same as start of word: double space prefix is added.
			 * Hence, make an enter key showing we can reach the arc
			 * destination with all-blank prefix.
			 */</comment>
			<expr_stmt><expr><name><name>destKey</name><operator>.</operator><name>prefix</name><operator>.</operator><name>colors</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>COLOR_BLANK</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>destKey</name><operator>.</operator><name>prefix</name><operator>.</operator><name>colors</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>COLOR_BLANK</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>destKey</name><operator>.</operator><name>nstate</name></name> <operator>=</operator> <name><name>arc</name><operator>-&gt;</operator><name>to</name></name></expr>;</expr_stmt>

			<comment type="block">/* Add enter key to this state */</comment>
			<expr_stmt><expr><call><name>addKeyToQueue</name><argument_list>(<argument><expr><name>trgmNFA</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>destKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>pg_reg_colorisend</name><argument_list>(<argument><expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>regex</name></name></expr></argument>, <argument><expr><name><name>arc</name><operator>-&gt;</operator><name>co</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * End of line/string ($).  We must consider this arc as a
			 * transition that doesn't read anything.  The reason for adding
			 * this enter key to the state is that if the arc leads to the
			 * NFA's final state, we must mark this expanded state as final.
			 */</comment>
			<expr_stmt><expr><name><name>destKey</name><operator>.</operator><name>prefix</name><operator>.</operator><name>colors</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>COLOR_UNKNOWN</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>destKey</name><operator>.</operator><name>prefix</name><operator>.</operator><name>colors</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>COLOR_UNKNOWN</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>destKey</name><operator>.</operator><name>nstate</name></name> <operator>=</operator> <name><name>arc</name><operator>-&gt;</operator><name>to</name></name></expr>;</expr_stmt>

			<comment type="block">/* Add enter key to this state */</comment>
			<expr_stmt><expr><call><name>addKeyToQueue</name><argument_list>(<argument><expr><name>trgmNFA</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>destKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Regular color */</comment>
			<decl_stmt><decl><type><name>TrgmColorInfo</name> <modifier>*</modifier></type><name>colorInfo</name> <init>= <expr><operator>&amp;</operator><name><name>trgmNFA</name><operator>-&gt;</operator><name>colorInfo</name><index>[<expr><name><name>arc</name><operator>-&gt;</operator><name>co</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>colorInfo</name><operator>-&gt;</operator><name>expandable</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>colorInfo</name><operator>-&gt;</operator><name>containsNonWord</name></name> <operator>&amp;&amp;</operator>
					<operator>!</operator><call><name>validArcLabel</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>COLOR_BLANK</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * We can reach the arc destination after reading a
					 * non-word character, but the prefix is not something
					 * that addArc will accept with COLOR_BLANK, so no trigram
					 * arc can get made for this transition.  We must make an
					 * enter key to show that the arc destination is
					 * reachable.  Set it up with an all-blank prefix, since
					 * that corresponds to what the trigram extraction code
					 * will do at a word starting boundary.
					 */</comment>
					<expr_stmt><expr><name><name>destKey</name><operator>.</operator><name>prefix</name><operator>.</operator><name>colors</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>COLOR_BLANK</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>destKey</name><operator>.</operator><name>prefix</name><operator>.</operator><name>colors</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>COLOR_BLANK</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>destKey</name><operator>.</operator><name>nstate</name></name> <operator>=</operator> <name><name>arc</name><operator>-&gt;</operator><name>to</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>addKeyToQueue</name><argument_list>(<argument><expr><name>trgmNFA</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>destKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>colorInfo</name><operator>-&gt;</operator><name>wordCharsCount</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
					<operator>!</operator><call><name>validArcLabel</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>arc</name><operator>-&gt;</operator><name>co</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * We can reach the arc destination after reading a word
					 * character, but the prefix is not something that addArc
					 * will accept, so no trigram arc can get made for this
					 * transition.  We must make an enter key to show that the
					 * arc destination is reachable.  The prefix for the enter
					 * key should reflect the info we have for this arc.
					 */</comment>
					<expr_stmt><expr><name><name>destKey</name><operator>.</operator><name>prefix</name><operator>.</operator><name>colors</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>prefix</name><operator>.</operator><name>colors</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>destKey</name><operator>.</operator><name>prefix</name><operator>.</operator><name>colors</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>arc</name><operator>-&gt;</operator><name>co</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>destKey</name><operator>.</operator><name>nstate</name></name> <operator>=</operator> <name><name>arc</name><operator>-&gt;</operator><name>to</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>addKeyToQueue</name><argument_list>(<argument><expr><name>trgmNFA</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>destKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Unexpandable color.  Add enter key with ambiguous prefix,
				 * showing we can reach the destination from this state, but
				 * the preceding colors will be uncertain.  (We do not set the
				 * first prefix color to key-&gt;prefix.colors[1], because a
				 * prefix of known followed by unknown is invalid.)
				 */</comment>
				<expr_stmt><expr><name><name>destKey</name><operator>.</operator><name>prefix</name><operator>.</operator><name>colors</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>COLOR_UNKNOWN</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>destKey</name><operator>.</operator><name>prefix</name><operator>.</operator><name>colors</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>COLOR_UNKNOWN</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>destKey</name><operator>.</operator><name>nstate</name></name> <operator>=</operator> <name><name>arc</name><operator>-&gt;</operator><name>to</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>addKeyToQueue</name><argument_list>(<argument><expr><name>trgmNFA</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>destKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>arcs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add copy of given key to keysQueue for later processing.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>addKeyToQueue</name><parameter_list>(<parameter><decl><type><name>TrgmNFA</name> <modifier>*</modifier></type><name>trgmNFA</name></decl></parameter>, <parameter><decl><type><name>TrgmStateKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TrgmStateKey</name> <modifier>*</modifier></type><name>keyCopy</name> <init>= <expr><operator>(</operator><name>TrgmStateKey</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TrgmStateKey</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>keyCopy</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TrgmStateKey</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>keysQueue</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>keysQueue</name></name></expr></argument>, <argument><expr><name>keyCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add outgoing arcs from given state, whose enter keys are all now known.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>addArcs</name><parameter_list>(<parameter><decl><type><name>TrgmNFA</name> <modifier>*</modifier></type><name>trgmNFA</name></decl></parameter>, <parameter><decl><type><name>TrgmState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TrgmStateKey</name></type> <name>destKey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>regex_arc_t</name> <modifier>*</modifier></type><name>arcs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>arcsCount</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Ensure any pad bytes in destKey are zero, since it may get used as a
	 * hashtable key by getState.
	 */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>destKey</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>destKey</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Iterate over enter keys associated with this expanded-graph state. This
	 * includes both the state's own stateKey, and any enter keys we added to
	 * it during addKey (which represent expanded-graph states that are not
	 * distinguishable from this one by means of trigrams).  For each such
	 * enter key, examine all the out-arcs of the key's underlying NFA state,
	 * and try to make a trigram arc leading to where the out-arc leads.
	 * (addArc will deal with whether the arc is valid or not.)
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>state-&gt;enterKeys</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TrgmStateKey</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><operator>(</operator><name>TrgmStateKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>arcsCount</name> <operator>=</operator> <call><name>pg_reg_getnumoutarcs</name><argument_list>(<argument><expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>regex</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>nstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>arcs</name> <operator>=</operator> <operator>(</operator><name>regex_arc_t</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>regex_arc_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>arcsCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_reg_getoutarcs</name><argument_list>(<argument><expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>regex</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>nstate</name></name></expr></argument>, <argument><expr><name>arcs</name></expr></argument>, <argument><expr><name>arcsCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>arcsCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>regex_arc_t</name> <modifier>*</modifier></type><name>arc</name> <init>= <expr><operator>&amp;</operator><name><name>arcs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TrgmColorInfo</name> <modifier>*</modifier></type><name>colorInfo</name> <init>= <expr><operator>&amp;</operator><name><name>trgmNFA</name><operator>-&gt;</operator><name>colorInfo</name><index>[<expr><name><name>arc</name><operator>-&gt;</operator><name>co</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Ignore non-expandable colors; addKey already handled the case.
			 *
			 * We need no special check for begin/end pseudocolors here.  We
			 * don't need to do any processing for them, and they will be
			 * marked non-expandable since the regex engine will have reported
			 * them that way.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>colorInfo</name><operator>-&gt;</operator><name>expandable</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>colorInfo</name><operator>-&gt;</operator><name>containsNonWord</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Color includes non-word character(s).
				 *
				 * Generate an arc, treating this transition as occurring on
				 * BLANK.  This allows word-ending trigrams to be manufactured
				 * if possible.
				 */</comment>
				<expr_stmt><expr><name><name>destKey</name><operator>.</operator><name>prefix</name><operator>.</operator><name>colors</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>prefix</name><operator>.</operator><name>colors</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>destKey</name><operator>.</operator><name>prefix</name><operator>.</operator><name>colors</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>COLOR_BLANK</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>destKey</name><operator>.</operator><name>nstate</name></name> <operator>=</operator> <name><name>arc</name><operator>-&gt;</operator><name>to</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>addArc</name><argument_list>(<argument><expr><name>trgmNFA</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>COLOR_BLANK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>destKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>colorInfo</name><operator>-&gt;</operator><name>wordCharsCount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Color includes word character(s).
				 *
				 * Generate an arc.  Color is pushed into prefix of target
				 * state.
				 */</comment>
				<expr_stmt><expr><name><name>destKey</name><operator>.</operator><name>prefix</name><operator>.</operator><name>colors</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>prefix</name><operator>.</operator><name>colors</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>destKey</name><operator>.</operator><name>prefix</name><operator>.</operator><name>colors</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>arc</name><operator>-&gt;</operator><name>co</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>destKey</name><operator>.</operator><name>nstate</name></name> <operator>=</operator> <name><name>arc</name><operator>-&gt;</operator><name>to</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>addArc</name><argument_list>(<argument><expr><name>trgmNFA</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>arc</name><operator>-&gt;</operator><name>co</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>destKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>arcs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Generate an out-arc of the expanded graph, if it's valid and not redundant.
 *
 * state: expanded-graph state we want to add an out-arc to
 * key: provides prefix colors (key-&gt;nstate is not used)
 * co: transition color
 * destKey: identifier for destination state of expanded graph
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>addArc</name><parameter_list>(<parameter><decl><type><name>TrgmNFA</name> <modifier>*</modifier></type><name>trgmNFA</name></decl></parameter>, <parameter><decl><type><name>TrgmState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>TrgmStateKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>,
	   <parameter><decl><type><name>TrgmColor</name></type> <name>co</name></decl></parameter>, <parameter><decl><type><name>TrgmStateKey</name> <modifier>*</modifier></type><name>destKey</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TrgmArc</name>    <modifier>*</modifier></type><name>arc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<comment type="block">/* Do nothing if this wouldn't be a valid arc label trigram */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>validArcLabel</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>co</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check if we are going to reach key which is covered by a key which is
	 * already listed in this state.  If so arc is useless: the NFA can bypass
	 * it through a path that doesn't require any predictable trigram, so
	 * whether the arc's trigram is present or not doesn't really matter.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>state-&gt;enterKeys</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TrgmStateKey</name> <modifier>*</modifier></type><name>existingKey</name> <init>= <expr><operator>(</operator><name>TrgmStateKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>existingKey</name><operator>-&gt;</operator><name>nstate</name></name> <operator>==</operator> <name><name>destKey</name><operator>-&gt;</operator><name>nstate</name></name> <operator>&amp;&amp;</operator>
			<call><name>prefixContains</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>existingKey</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>destKey</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Checks were successful, add new arc */</comment>
	<expr_stmt><expr><name>arc</name> <operator>=</operator> <operator>(</operator><name>TrgmArc</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TrgmArc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>arc</name><operator>-&gt;</operator><name>target</name></name> <operator>=</operator> <call><name>getState</name><argument_list>(<argument><expr><name>trgmNFA</name></expr></argument>, <argument><expr><name>destKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>arc</name><operator>-&gt;</operator><name>ctrgm</name><operator>.</operator><name>colors</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>prefix</name><operator>.</operator><name>colors</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>arc</name><operator>-&gt;</operator><name>ctrgm</name><operator>.</operator><name>colors</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>prefix</name><operator>.</operator><name>colors</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>arc</name><operator>-&gt;</operator><name>ctrgm</name><operator>.</operator><name>colors</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>co</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>arcs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>arcs</name></name></expr></argument>, <argument><expr><name>arc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>arcsCount</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Can we make a valid trigram arc label from the given prefix and arc color?
 *
 * This is split out so that tests in addKey and addArc will stay in sync.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>validArcLabel</name><parameter_list>(<parameter><decl><type><name>TrgmStateKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>TrgmColor</name></type> <name>co</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We have to know full trigram in order to add outgoing arc.  So we can't
	 * do it if prefix is ambiguous.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>prefix</name><operator>.</operator><name>colors</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>COLOR_UNKNOWN</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If key-&gt;prefix.colors[0] isn't unknown, its second color isn't either */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>prefix</name><operator>.</operator><name>colors</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>COLOR_UNKNOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* And we should not be called with an unknown arc color anytime */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>co</name> <operator>!=</operator> <name>COLOR_UNKNOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We don't bother with making arcs representing three non-word
	 * characters, since that's useless for trigram extraction.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>prefix</name><operator>.</operator><name>colors</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>COLOR_BLANK</name> <operator>&amp;&amp;</operator>
		<name><name>key</name><operator>-&gt;</operator><name>prefix</name><operator>.</operator><name>colors</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>COLOR_BLANK</name> <operator>&amp;&amp;</operator>
		<name>co</name> <operator>==</operator> <name>COLOR_BLANK</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We also reject nonblank-blank-anything.  The nonblank-blank-nonblank
	 * case doesn't correspond to any trigram the trigram extraction code
	 * would make.  The nonblank-blank-blank case is also not possible with
	 * RPADDING = 1.  (Note that in many cases we'd fail to generate such a
	 * trigram even if it were valid, for example processing "foo bar" will
	 * not result in considering the trigram "o  ".  So if you want to support
	 * RPADDING = 2, there's more to do than just twiddle this test.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>prefix</name><operator>.</operator><name>colors</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>COLOR_BLANK</name> <operator>&amp;&amp;</operator>
		<name><name>key</name><operator>-&gt;</operator><name>prefix</name><operator>.</operator><name>colors</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>COLOR_BLANK</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Other combinations involving blank are valid, in particular we assume
	 * blank-blank-nonblank is valid, which presumes that LPADDING is 2.
	 *
	 * Note: Using again the example "foo bar", we will not consider the
	 * trigram "  b", though this trigram would be found by the trigram
	 * extraction code.  Since we will find " ba", it doesn't seem worth
	 * trying to hack the algorithm to generate the additional trigram.
	 */</comment>

	<comment type="block">/* arc label is valid */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get state of expanded graph for given state key,
 * and queue the state for processing if it didn't already exist.
 */</comment>
<function><type><specifier>static</specifier> <name>TrgmState</name> <modifier>*</modifier></type>
<name>getState</name><parameter_list>(<parameter><decl><type><name>TrgmNFA</name> <modifier>*</modifier></type><name>trgmNFA</name></decl></parameter>, <parameter><decl><type><name>TrgmStateKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TrgmState</name>  <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>TrgmState</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>states</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* New state: initialize and queue it */</comment>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>arcs</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>enterKeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<comment type="block">/* states are initially given negative numbers */</comment>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>snumber</name></name> <operator>=</operator> <operator>-</operator><operator>(</operator><operator>++</operator><name><name>trgmNFA</name><operator>-&gt;</operator><name>nstates</name></name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tentFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tentParent</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>queue</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>queue</name></name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check if prefix1 "contains" prefix2.
 *
 * "contains" means that any exact prefix (with no ambiguity) that satisfies
 * prefix2 also satisfies prefix1.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prefixContains</name><parameter_list>(<parameter><decl><type><name>TrgmPrefix</name> <modifier>*</modifier></type><name>prefix1</name></decl></parameter>, <parameter><decl><type><name>TrgmPrefix</name> <modifier>*</modifier></type><name>prefix2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>prefix1</name><operator>-&gt;</operator><name>colors</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>COLOR_UNKNOWN</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Fully ambiguous prefix contains everything */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>prefix1</name><operator>-&gt;</operator><name>colors</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>COLOR_UNKNOWN</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Prefix with only first unknown color contains every prefix with
		 * same second color.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>prefix1</name><operator>-&gt;</operator><name>colors</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>prefix2</name><operator>-&gt;</operator><name>colors</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Exact prefix contains only the exact same prefix */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>prefix1</name><operator>-&gt;</operator><name>colors</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name><name>prefix2</name><operator>-&gt;</operator><name>colors</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator>
			<name><name>prefix1</name><operator>-&gt;</operator><name>colors</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>prefix2</name><operator>-&gt;</operator><name>colors</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*---------------------
 * Subroutines for expanding color trigrams into regular trigrams (stage 3).
 *---------------------
 */</comment>

<comment type="block">/*
 * Get vector of all color trigrams in graph and select which of them
 * to expand into simple trigrams.
 *
 * Returns true if OK, false if exhausted resource limits.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>selectColorTrigrams</name><parameter_list>(<parameter><decl><type><name>TrgmNFA</name> <modifier>*</modifier></type><name>trgmNFA</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>scan_status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>arcsCount</name> <init>= <expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>arcsCount</name></name></expr></init></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TrgmState</name>  <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ColorTrgmInfo</name> <modifier>*</modifier></type><name>colorTrgms</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>totalTrgmCount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>totalTrgmPenalty</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cnumber</name></decl>;</decl_stmt>

	<comment type="block">/* Collect color trigrams from all arcs */</comment>
	<expr_stmt><expr><name>colorTrgms</name> <operator>=</operator> <operator>(</operator><name>ColorTrgmInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ColorTrgmInfo</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>arcsCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>colorTrgms</name></name> <operator>=</operator> <name>colorTrgms</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan_status</name></expr></argument>, <argument><expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>states</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>state</name> <operator>=</operator> <operator>(</operator><name>TrgmState</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan_status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>state-&gt;arcs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TrgmArc</name>    <modifier>*</modifier></type><name>arc</name> <init>= <expr><operator>(</operator><name>TrgmArc</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TrgmArcInfo</name> <modifier>*</modifier></type><name>arcInfo</name> <init>= <expr><operator>(</operator><name>TrgmArcInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TrgmArcInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ColorTrgmInfo</name> <modifier>*</modifier></type><name>trgmInfo</name> <init>= <expr><operator>&amp;</operator><name><name>colorTrgms</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>arcInfo</name><operator>-&gt;</operator><name>source</name></name> <operator>=</operator> <name>state</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>arcInfo</name><operator>-&gt;</operator><name>target</name></name> <operator>=</operator> <name><name>arc</name><operator>-&gt;</operator><name>target</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>trgmInfo</name><operator>-&gt;</operator><name>ctrgm</name></name> <operator>=</operator> <name><name>arc</name><operator>-&gt;</operator><name>ctrgm</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>trgmInfo</name><operator>-&gt;</operator><name>cnumber</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<comment type="block">/* count and penalty will be set below */</comment>
			<expr_stmt><expr><name><name>trgmInfo</name><operator>-&gt;</operator><name>expanded</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>trgmInfo</name><operator>-&gt;</operator><name>arcs</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>arcInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>==</operator> <name>arcsCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Remove duplicates, merging their arcs lists */</comment>
	<if_stmt><if>if <condition>(<expr><name>arcsCount</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ColorTrgmInfo</name> <modifier>*</modifier></type><name>p1</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>p2</name></decl>;</decl_stmt>

		<comment type="block">/* Sort trigrams to ease duplicate detection */</comment>
		<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>colorTrgms</name></expr></argument>, <argument><expr><name>arcsCount</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ColorTrgmInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>colorTrgmInfoCmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* p1 is probe point, p2 is last known non-duplicate. */</comment>
		<expr_stmt><expr><name>p2</name> <operator>=</operator> <name>colorTrgms</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>p1</name> <operator>=</operator> <name>colorTrgms</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>p1</name> <operator>&lt;</operator> <name>colorTrgms</name> <operator>+</operator> <name>arcsCount</name></expr>;</condition> <incr><expr><name>p1</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>colorTrgmInfoCmp</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>p2</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>p2</name> <operator>=</operator> <operator>*</operator><name>p1</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>p2</name><operator>-&gt;</operator><name>arcs</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>p2</name><operator>-&gt;</operator><name>arcs</name></name></expr></argument>, <argument><expr><name><name>p1</name><operator>-&gt;</operator><name>arcs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>colorTrgmsCount</name></name> <operator>=</operator> <operator>(</operator><name>p2</name> <operator>-</operator> <name>colorTrgms</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>colorTrgmsCount</name></name> <operator>=</operator> <name>arcsCount</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Count number of simple trigrams generated by each color trigram, and
	 * also compute a penalty value, which is the number of simple trigrams
	 * times a multiplier that depends on its whitespace content.
	 *
	 * Note: per-color-trigram counts cannot overflow an int so long as
	 * COLOR_COUNT_LIMIT is not more than the cube root of INT_MAX, ie about
	 * 1290.  However, the grand total totalTrgmCount might conceivably
	 * overflow an int, so we use int64 for that within this routine.  Also,
	 * penalties are calculated in float4 arithmetic to avoid any overflow
	 * worries.
	 */</comment>
	<expr_stmt><expr><name>totalTrgmCount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>totalTrgmPenalty</name> <operator>=</operator> <literal type="number">0.0f</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>trgmNFA</name><operator>-&gt;</operator><name>colorTrgmsCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ColorTrgmInfo</name> <modifier>*</modifier></type><name>trgmInfo</name> <init>= <expr><operator>&amp;</operator><name><name>colorTrgms</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>,
					<decl><type ref="prev"/><name>count</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
					<decl><type ref="prev"/><name>typeIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TrgmColor</name></type>	<name>c</name> <init>= <expr><name><name>trgmInfo</name><operator>-&gt;</operator><name>ctrgm</name><operator>.</operator><name>colors</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>typeIndex</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>COLOR_BLANK</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>typeIndex</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>count</name> <operator>*=</operator> <name><name>trgmNFA</name><operator>-&gt;</operator><name>colorInfo</name><index>[<expr><name>c</name></expr>]</index></name><operator>.</operator><name>wordCharsCount</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name><name>trgmInfo</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>totalTrgmCount</name> <operator>+=</operator> <name>count</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trgmInfo</name><operator>-&gt;</operator><name>penalty</name></name> <operator>=</operator> <name><name>penalties</name><index>[<expr><name>typeIndex</name></expr>]</index></name> <operator>*</operator> <operator>(</operator><name>float4</name><operator>)</operator> <name>count</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>totalTrgmPenalty</name> <operator>+=</operator> <name><name>trgmInfo</name><operator>-&gt;</operator><name>penalty</name></name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Sort color trigrams in descending order of their penalties */</comment>
	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>colorTrgms</name></expr></argument>, <argument><expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>colorTrgmsCount</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ColorTrgmInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>,
		  <argument><expr><name>colorTrgmInfoPenaltyCmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Remove color trigrams from the graph so long as total penalty of color
	 * trigrams exceeds WISH_TRGM_PENALTY.  (If we fail to get down to
	 * WISH_TRGM_PENALTY, it's OK so long as total count is no more than
	 * MAX_TRGM_COUNT.)  We prefer to remove color trigrams with higher
	 * penalty, since those are the most promising for reducing the total
	 * penalty.  When removing a color trigram we have to merge states
	 * connected by arcs labeled with that trigram.  It's necessary to not
	 * merge initial and final states, because our graph becomes useless if
	 * that happens; so we cannot always remove the trigram we'd prefer to.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>trgmNFA</name><operator>-&gt;</operator><name>colorTrgmsCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ColorTrgmInfo</name> <modifier>*</modifier></type><name>trgmInfo</name> <init>= <expr><operator>&amp;</operator><name><name>colorTrgms</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>canRemove</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

		<comment type="block">/* Done if we've reached the target */</comment>
		<if_stmt><if>if <condition>(<expr><name>totalTrgmPenalty</name> <operator>&lt;=</operator> <name>WISH_TRGM_PENALTY</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRGM_REGEXP_DEBUG</name></cpp:ifdef>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"considering ctrgm %d %d %d, penalty %f, %d arcs\n"</literal></expr></argument>,
				<argument><expr><name><name>trgmInfo</name><operator>-&gt;</operator><name>ctrgm</name><operator>.</operator><name>colors</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name><name>trgmInfo</name><operator>-&gt;</operator><name>ctrgm</name><operator>.</operator><name>colors</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name><name>trgmInfo</name><operator>-&gt;</operator><name>ctrgm</name><operator>.</operator><name>colors</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name><name>trgmInfo</name><operator>-&gt;</operator><name>penalty</name></name></expr></argument>,
				<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>trgmInfo</name><operator>-&gt;</operator><name>arcs</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/*
		 * Does any arc of this color trigram connect initial and final
		 * states?	If so we can't remove it.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>trgmInfo-&gt;arcs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TrgmArcInfo</name> <modifier>*</modifier></type><name>arcInfo</name> <init>= <expr><operator>(</operator><name>TrgmArcInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TrgmState</name>  <modifier>*</modifier></type><name>source</name> <init>= <expr><name><name>arcInfo</name><operator>-&gt;</operator><name>source</name></name></expr></init></decl>,
					   <decl><type ref="prev"><modifier>*</modifier></type><name>target</name> <init>= <expr><name><name>arcInfo</name><operator>-&gt;</operator><name>target</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>source_flags</name></decl>,
						<decl><type ref="prev"/><name>target_flags</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRGM_REGEXP_DEBUG</name></cpp:ifdef>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"examining arc to s%d (%x) from s%d (%x)\n"</literal></expr></argument>,
					<argument><expr><operator>-</operator><name><name>target</name><operator>-&gt;</operator><name>snumber</name></name></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>,
					<argument><expr><operator>-</operator><name><name>source</name><operator>-&gt;</operator><name>snumber</name></name></expr></argument>, <argument><expr><name><name>source</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<comment type="block">/* examine parent states, if any merging has already happened */</comment>
			<while>while <condition>(<expr><name><name>source</name><operator>-&gt;</operator><name>parent</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>source</name> <operator>=</operator> <name><name>source</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt></block_content></block></while>
			<while>while <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>parent</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>target</name> <operator>=</operator> <name><name>target</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt></block_content></block></while>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRGM_REGEXP_DEBUG</name></cpp:ifdef>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" ... after completed merges: to s%d (%x) from s%d (%x)\n"</literal></expr></argument>,
					<argument><expr><operator>-</operator><name><name>target</name><operator>-&gt;</operator><name>snumber</name></name></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>,
					<argument><expr><operator>-</operator><name><name>source</name><operator>-&gt;</operator><name>snumber</name></name></expr></argument>, <argument><expr><name><name>source</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<comment type="block">/* we must also consider merges we are planning right now */</comment>
			<expr_stmt><expr><name>source_flags</name> <operator>=</operator> <name><name>source</name><operator>-&gt;</operator><name>flags</name></name> <operator>|</operator> <name><name>source</name><operator>-&gt;</operator><name>tentFlags</name></name></expr>;</expr_stmt>
			<while>while <condition>(<expr><name><name>source</name><operator>-&gt;</operator><name>tentParent</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>source</name> <operator>=</operator> <name><name>source</name><operator>-&gt;</operator><name>tentParent</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>source_flags</name> <operator>|=</operator> <name><name>source</name><operator>-&gt;</operator><name>flags</name></name> <operator>|</operator> <name><name>source</name><operator>-&gt;</operator><name>tentFlags</name></name></expr>;</expr_stmt>
			</block_content>}</block></while>
			<expr_stmt><expr><name>target_flags</name> <operator>=</operator> <name><name>target</name><operator>-&gt;</operator><name>flags</name></name> <operator>|</operator> <name><name>target</name><operator>-&gt;</operator><name>tentFlags</name></name></expr>;</expr_stmt>
			<while>while <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>tentParent</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>target</name> <operator>=</operator> <name><name>target</name><operator>-&gt;</operator><name>tentParent</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>target_flags</name> <operator>|=</operator> <name><name>target</name><operator>-&gt;</operator><name>flags</name></name> <operator>|</operator> <name><name>target</name><operator>-&gt;</operator><name>tentFlags</name></name></expr>;</expr_stmt>
			</block_content>}</block></while>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRGM_REGEXP_DEBUG</name></cpp:ifdef>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" ... after tentative merges: to s%d (%x) from s%d (%x)\n"</literal></expr></argument>,
					<argument><expr><operator>-</operator><name><name>target</name><operator>-&gt;</operator><name>snumber</name></name></expr></argument>, <argument><expr><name>target_flags</name></expr></argument>,
					<argument><expr><operator>-</operator><name><name>source</name><operator>-&gt;</operator><name>snumber</name></name></expr></argument>, <argument><expr><name>source_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<comment type="block">/* would fully-merged state have both INIT and FIN set? */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>source_flags</name> <operator>|</operator> <name>target_flags</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>TSTATE_INIT</name> <operator>|</operator> <name>TSTATE_FIN</name><operator>)</operator><operator>)</operator> <operator>==</operator>
				<operator>(</operator><name>TSTATE_INIT</name> <operator>|</operator> <name>TSTATE_FIN</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>canRemove</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* ok so far, so remember planned merge */</comment>
			<if_stmt><if>if <condition>(<expr><name>source</name> <operator>!=</operator> <name>target</name></expr>)</condition>
			<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRGM_REGEXP_DEBUG</name></cpp:ifdef>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" ... tentatively merging s%d into s%d\n"</literal></expr></argument>,
						<argument><expr><operator>-</operator><name><name>target</name><operator>-&gt;</operator><name>snumber</name></name></expr></argument>, <argument><expr><operator>-</operator><name><name>source</name><operator>-&gt;</operator><name>snumber</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>tentParent</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>source</name><operator>-&gt;</operator><name>tentFlags</name></name> <operator>|=</operator> <name>target_flags</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * We must reset all the tentFlags/tentParent fields before
		 * continuing.  tentFlags could only have become set in states that
		 * are the source or parent or tentative parent of one of the current
		 * arcs; likewise tentParent could only have become set in states that
		 * are the target or parent or tentative parent of one of the current
		 * arcs.  There might be some overlap between those sets, but if we
		 * clear tentFlags in target states as well as source states, we
		 * should be okay even if we visit a state as target before visiting
		 * it as a source.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>trgmInfo-&gt;arcs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TrgmArcInfo</name> <modifier>*</modifier></type><name>arcInfo</name> <init>= <expr><operator>(</operator><name>TrgmArcInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TrgmState</name>  <modifier>*</modifier></type><name>source</name> <init>= <expr><name><name>arcInfo</name><operator>-&gt;</operator><name>source</name></name></expr></init></decl>,
					   <decl><type ref="prev"><modifier>*</modifier></type><name>target</name> <init>= <expr><name><name>arcInfo</name><operator>-&gt;</operator><name>target</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TrgmState</name>  <modifier>*</modifier></type><name>ttarget</name></decl>;</decl_stmt>

			<comment type="block">/* no need to touch previously-merged states */</comment>
			<while>while <condition>(<expr><name><name>source</name><operator>-&gt;</operator><name>parent</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>source</name> <operator>=</operator> <name><name>source</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt></block_content></block></while>
			<while>while <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>parent</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>target</name> <operator>=</operator> <name><name>target</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt></block_content></block></while>

			<while>while <condition>(<expr><name>source</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>source</name><operator>-&gt;</operator><name>tentFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>source</name> <operator>=</operator> <name><name>source</name><operator>-&gt;</operator><name>tentParent</name></name></expr>;</expr_stmt>
			</block_content>}</block></while>

			<while>while <condition>(<expr><operator>(</operator><name>ttarget</name> <operator>=</operator> <name><name>target</name><operator>-&gt;</operator><name>tentParent</name></name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>tentParent</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>tentFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/* in case it was also a source */</comment>
				<expr_stmt><expr><name>target</name> <operator>=</operator> <name>ttarget</name></expr>;</expr_stmt>
			</block_content>}</block></while>
		</block_content>}</block>

		<comment type="block">/* Now, move on if we can't drop this trigram */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>canRemove</name></expr>)</condition>
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRGM_REGEXP_DEBUG</name></cpp:ifdef>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" ... not ok to merge\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* OK, merge states linked by each arc labeled by the trigram */</comment>
		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>trgmInfo-&gt;arcs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TrgmArcInfo</name> <modifier>*</modifier></type><name>arcInfo</name> <init>= <expr><operator>(</operator><name>TrgmArcInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TrgmState</name>  <modifier>*</modifier></type><name>source</name> <init>= <expr><name><name>arcInfo</name><operator>-&gt;</operator><name>source</name></name></expr></init></decl>,
					   <decl><type ref="prev"><modifier>*</modifier></type><name>target</name> <init>= <expr><name><name>arcInfo</name><operator>-&gt;</operator><name>target</name></name></expr></init></decl>;</decl_stmt>

			<while>while <condition>(<expr><name><name>source</name><operator>-&gt;</operator><name>parent</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>source</name> <operator>=</operator> <name><name>source</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt></block_content></block></while>
			<while>while <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>parent</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>target</name> <operator>=</operator> <name><name>target</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt></block_content></block></while>
			<if_stmt><if>if <condition>(<expr><name>source</name> <operator>!=</operator> <name>target</name></expr>)</condition>
			<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRGM_REGEXP_DEBUG</name></cpp:ifdef>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"merging s%d into s%d\n"</literal></expr></argument>,
						<argument><expr><operator>-</operator><name><name>target</name><operator>-&gt;</operator><name>snumber</name></name></expr></argument>, <argument><expr><operator>-</operator><name><name>source</name><operator>-&gt;</operator><name>snumber</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<expr_stmt><expr><call><name>mergeStates</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Assert we didn't merge initial and final states */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>source</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>TSTATE_INIT</name> <operator>|</operator> <name>TSTATE_FIN</name><operator>)</operator><operator>)</operator> <operator>!=</operator>
					   <operator>(</operator><name>TSTATE_INIT</name> <operator>|</operator> <name>TSTATE_FIN</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/* Mark trigram unexpanded, and update totals */</comment>
		<expr_stmt><expr><name><name>trgmInfo</name><operator>-&gt;</operator><name>expanded</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>totalTrgmCount</name> <operator>-=</operator> <name><name>trgmInfo</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>totalTrgmPenalty</name> <operator>-=</operator> <name><name>trgmInfo</name><operator>-&gt;</operator><name>penalty</name></name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Did we succeed in fitting into MAX_TRGM_COUNT? */</comment>
	<if_stmt><if>if <condition>(<expr><name>totalTrgmCount</name> <operator>&gt;</operator> <name>MAX_TRGM_COUNT</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>totalTrgmCount</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>totalTrgmCount</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Sort color trigrams by colors (will be useful for bsearch in packGraph)
	 * and enumerate the color trigrams that are expanded.
	 */</comment>
	<expr_stmt><expr><name>cnumber</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>colorTrgms</name></expr></argument>, <argument><expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>colorTrgmsCount</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ColorTrgmInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>,
		  <argument><expr><name>colorTrgmInfoCmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>trgmNFA</name><operator>-&gt;</operator><name>colorTrgmsCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>colorTrgms</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>expanded</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>colorTrgms</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cnumber</name> <operator>=</operator> <name>cnumber</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>cnumber</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Expand selected color trigrams into regular trigrams.
 *
 * Returns the TRGM array to be passed to the index machinery.
 * The array must be allocated in rcontext.
 */</comment>
<function><type><specifier>static</specifier> <name>TRGM</name> <modifier>*</modifier></type>
<name>expandColorTrigrams</name><parameter_list>(<parameter><decl><type><name>TrgmNFA</name> <modifier>*</modifier></type><name>trgmNFA</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>rcontext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TRGM</name>	   <modifier>*</modifier></type><name>trg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>trgm</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TrgmColorInfo</name></type> <name>blankColor</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>trgm_mb_char</name></type> <name>blankChar</name></decl>;</decl_stmt>

	<comment type="block">/* Set up "blank" color structure containing a single zero character */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>blankChar</name><operator>.</operator><name>bytes</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>blankChar</name><operator>.</operator><name>bytes</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>blankColor</name><operator>.</operator><name>wordCharsCount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>blankColor</name><operator>.</operator><name>wordChars</name></name> <operator>=</operator> <operator>&amp;</operator><name>blankChar</name></expr>;</expr_stmt>

	<comment type="block">/* Construct the trgm array */</comment>
	<expr_stmt><expr><name>trg</name> <operator>=</operator> <operator>(</operator><name>TRGM</name> <operator>*</operator><operator>)</operator>
		<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>rcontext</name></expr></argument>,
							   <argument><expr><name>TRGMHDRSIZE</name> <operator>+</operator>
							   <name><name>trgmNFA</name><operator>-&gt;</operator><name>totalTrgmCount</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>trgm</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trg</name><operator>-&gt;</operator><name>flag</name></name> <operator>=</operator> <name>ARRKEY</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>trg</name></expr></argument>, <argument><expr><call><name>CALCGTSIZE</name><argument_list>(<argument><expr><name>ARRKEY</name></expr></argument>, <argument><expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>totalTrgmCount</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>GETARR</name><argument_list>(<argument><expr><name>trg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>trgmNFA</name><operator>-&gt;</operator><name>colorTrgmsCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ColorTrgmInfo</name> <modifier>*</modifier></type><name>colorTrgm</name> <init>= <expr><operator>&amp;</operator><name><name>trgmNFA</name><operator>-&gt;</operator><name>colorTrgms</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TrgmColorInfo</name> <modifier>*</modifier></type><name><name>c</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>trgm_mb_char</name></type> <name><name>s</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>,
					<decl><type ref="prev"/><name>i1</name></decl>,
					<decl><type ref="prev"/><name>i2</name></decl>,
					<decl><type ref="prev"/><name>i3</name></decl>;</decl_stmt>

		<comment type="block">/* Ignore any unexpanded trigrams ... */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>colorTrgm</name><operator>-&gt;</operator><name>expanded</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Get colors, substituting the dummy struct for COLOR_BLANK */</comment>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>colorTrgm</name><operator>-&gt;</operator><name>ctrgm</name><operator>.</operator><name>colors</name><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <name>COLOR_BLANK</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>c</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>trgmNFA</name><operator>-&gt;</operator><name>colorInfo</name><index>[<expr><name><name>colorTrgm</name><operator>-&gt;</operator><name>ctrgm</name><operator>.</operator><name>colors</name><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>c</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name>blankColor</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Iterate over all possible combinations of colors' characters */</comment>
		<for>for <control>(<init><expr><name>i1</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i1</name> <operator>&lt;</operator> <name><name>c</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>wordCharsCount</name></expr>;</condition> <incr><expr><name>i1</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>c</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>wordChars</name><index>[<expr><name>i1</name></expr>]</index></name></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i2</name> <operator>&lt;</operator> <name><name>c</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>wordCharsCount</name></expr>;</condition> <incr><expr><name>i2</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>c</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name><name>wordChars</name><index>[<expr><name>i2</name></expr>]</index></name></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>i3</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i3</name> <operator>&lt;</operator> <name><name>c</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>wordCharsCount</name></expr>;</condition> <incr><expr><name>i3</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<expr_stmt><expr><name><name>s</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>c</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name><name>wordChars</name><index>[<expr><name>i3</name></expr>]</index></name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>fillTrgm</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></for>
			</block_content>}</block></for>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<return>return <expr><name>trg</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert trigram into trgm datatype.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fillTrgm</name><parameter_list>(<parameter><decl><type><name>trgm</name> <modifier>*</modifier></type><name>ptrgm</name></decl></parameter>, <parameter><decl><type><name>trgm_mb_char</name></type> <name><name>s</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>str</name><index>[<expr><literal type="number">3</literal> <operator>*</operator> <name>MAX_MULTIBYTE_CHAR_LEN</name></expr>]</index></name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

	<comment type="block">/* Write multibyte string into "str" (we don't need null termination) */</comment>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>bytes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>MAX_MULTIBYTE_CHAR_LEN</name> <operator>&amp;&amp;</operator> <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>bytes</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>bytes</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Emit a space in place of COLOR_BLANK */</comment>
			<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Convert "str" to a standard trigram (possibly hashing it) */</comment>
	<expr_stmt><expr><call><name>compact_trigram</name><argument_list>(<argument><expr><name>ptrgm</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Merge two states of graph.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>mergeStates</name><parameter_list>(<parameter><decl><type><name>TrgmState</name> <modifier>*</modifier></type><name>state1</name></decl></parameter>, <parameter><decl><type><name>TrgmState</name> <modifier>*</modifier></type><name>state2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>state1</name> <operator>!=</operator> <name>state2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>state1</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>state2</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* state1 absorbs state2's flags */</comment>
	<expr_stmt><expr><name><name>state1</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name><name>state2</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>

	<comment type="block">/* state2, and indirectly all its children, become children of state1 */</comment>
	<expr_stmt><expr><name><name>state2</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>state1</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Compare function for sorting of color trigrams by their colors.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>colorTrgmInfoCmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ColorTrgmInfo</name> <modifier>*</modifier></type><name>c1</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>ColorTrgmInfo</name> <operator>*</operator><operator>)</operator> <name>p1</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ColorTrgmInfo</name> <modifier>*</modifier></type><name>c2</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>ColorTrgmInfo</name> <operator>*</operator><operator>)</operator> <name>p2</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c1</name><operator>-&gt;</operator><name>ctrgm</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>c2</name><operator>-&gt;</operator><name>ctrgm</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ColorTrgm</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Compare function for sorting color trigrams in descending order of
 * their penalty fields.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>colorTrgmInfoPenaltyCmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>penalty1</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>ColorTrgmInfo</name> <operator>*</operator><operator>)</operator> <name>p1</name><operator>)</operator><operator>-&gt;</operator><name>penalty</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>penalty2</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>ColorTrgmInfo</name> <operator>*</operator><operator>)</operator> <name>p2</name><operator>)</operator><operator>-&gt;</operator><name>penalty</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>penalty1</name> <operator>&lt;</operator> <name>penalty2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>penalty1</name> <operator>==</operator> <name>penalty2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*---------------------
 * Subroutines for packing the graph into final representation (stage 4).
 *---------------------
 */</comment>

<comment type="block">/*
 * Pack expanded graph into final representation.
 *
 * The result data must be allocated in rcontext.
 */</comment>
<function><type><specifier>static</specifier> <name>TrgmPackedGraph</name> <modifier>*</modifier></type>
<name>packGraph</name><parameter_list>(<parameter><decl><type><name>TrgmNFA</name> <modifier>*</modifier></type><name>trgmNFA</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>rcontext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>snumber</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>arcIndex</name></decl>,
				<decl><type ref="prev"/><name>arcsCount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>scan_status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TrgmState</name>  <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TrgmPackArcInfo</name> <modifier>*</modifier></type><name>arcs</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>p1</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>p2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TrgmPackedArc</name> <modifier>*</modifier></type><name>packedArcs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TrgmPackedGraph</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

	<comment type="block">/* Enumerate surviving states, giving init and fin reserved numbers */</comment>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan_status</name></expr></argument>, <argument><expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>states</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>state</name> <operator>=</operator> <operator>(</operator><name>TrgmState</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan_status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<while>while <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>parent</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>state</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt></block_content></block></while>

		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>snumber</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>TSTATE_INIT</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>snumber</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>TSTATE_FIN</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>snumber</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>snumber</name></name> <operator>=</operator> <name>snumber</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>snumber</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Collect array of all arcs */</comment>
	<expr_stmt><expr><name>arcs</name> <operator>=</operator> <operator>(</operator><name>TrgmPackArcInfo</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TrgmPackArcInfo</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>trgmNFA</name><operator>-&gt;</operator><name>arcsCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>arcIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan_status</name></expr></argument>, <argument><expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>states</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>state</name> <operator>=</operator> <operator>(</operator><name>TrgmState</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan_status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TrgmState</name>  <modifier>*</modifier></type><name>source</name> <init>= <expr><name>state</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

		<while>while <condition>(<expr><name><name>source</name><operator>-&gt;</operator><name>parent</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>source</name> <operator>=</operator> <name><name>source</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt></block_content></block></while>

		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>state-&gt;arcs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TrgmArc</name>    <modifier>*</modifier></type><name>arc</name> <init>= <expr><operator>(</operator><name>TrgmArc</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TrgmState</name>  <modifier>*</modifier></type><name>target</name> <init>= <expr><name><name>arc</name><operator>-&gt;</operator><name>target</name></name></expr></init></decl>;</decl_stmt>

			<while>while <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>parent</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>target</name> <operator>=</operator> <name><name>target</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt></block_content></block></while>

			<if_stmt><if>if <condition>(<expr><name><name>source</name><operator>-&gt;</operator><name>snumber</name></name> <operator>!=</operator> <name><name>target</name><operator>-&gt;</operator><name>snumber</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ColorTrgmInfo</name> <modifier>*</modifier></type><name>ctrgm</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>ctrgm</name> <operator>=</operator> <operator>(</operator><name>ColorTrgmInfo</name> <operator>*</operator><operator>)</operator> <call><name>bsearch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arc</name><operator>-&gt;</operator><name>ctrgm</name></name></expr></argument>,
												  <argument><expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>colorTrgms</name></name></expr></argument>,
												  <argument><expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>colorTrgmsCount</name></name></expr></argument>,
												  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ColorTrgmInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>,
												  <argument><expr><name>colorTrgmInfoCmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ctrgm</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ctrgm</name><operator>-&gt;</operator><name>expanded</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>arcs</name><index>[<expr><name>arcIndex</name></expr>]</index></name><operator>.</operator><name>sourceState</name> <operator>=</operator> <name><name>source</name><operator>-&gt;</operator><name>snumber</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>arcs</name><index>[<expr><name>arcIndex</name></expr>]</index></name><operator>.</operator><name>targetState</name> <operator>=</operator> <name><name>target</name><operator>-&gt;</operator><name>snumber</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>arcs</name><index>[<expr><name>arcIndex</name></expr>]</index></name><operator>.</operator><name>colorTrgm</name> <operator>=</operator> <name><name>ctrgm</name><operator>-&gt;</operator><name>cnumber</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>arcIndex</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></while>

	<comment type="block">/* Sort arcs to ease duplicate detection */</comment>
	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>arcs</name></expr></argument>, <argument><expr><name>arcIndex</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TrgmPackArcInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>packArcInfoCmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We could have duplicates because states were merged. Remove them. */</comment>
	<comment type="block">/* p1 is probe point, p2 is last known non-duplicate. */</comment>
	<expr_stmt><expr><name>p2</name> <operator>=</operator> <name>arcs</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>p1</name> <operator>=</operator> <name>arcs</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>p1</name> <operator>&lt;</operator> <name>arcs</name> <operator>+</operator> <name>arcIndex</name></expr>;</condition> <incr><expr><name>p1</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>packArcInfoCmp</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>p2</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>p2</name> <operator>=</operator> <operator>*</operator><name>p1</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name>arcsCount</name> <operator>=</operator> <operator>(</operator><name>p2</name> <operator>-</operator> <name>arcs</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* Create packed representation */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>TrgmPackedGraph</name> <operator>*</operator><operator>)</operator>
		<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>rcontext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TrgmPackedGraph</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Pack color trigrams information */</comment>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>colorTrigramsCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>trgmNFA</name><operator>-&gt;</operator><name>colorTrgmsCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>colorTrgms</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>expanded</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>colorTrigramsCount</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>colorTrigramGroups</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator>
		<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>rcontext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>result</name><operator>-&gt;</operator><name>colorTrigramsCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>trgmNFA</name><operator>-&gt;</operator><name>colorTrgmsCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>colorTrgms</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>expanded</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>colorTrigramGroups</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>trgmNFA</name><operator>-&gt;</operator><name>colorTrgms</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>count</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Pack states and arcs information */</comment>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>statesCount</name></name> <operator>=</operator> <name>snumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>states</name></name> <operator>=</operator> <operator>(</operator><name>TrgmPackedState</name> <operator>*</operator><operator>)</operator>
		<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>rcontext</name></expr></argument>, <argument><expr><name>snumber</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TrgmPackedState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>packedArcs</name> <operator>=</operator> <operator>(</operator><name>TrgmPackedArc</name> <operator>*</operator><operator>)</operator>
		<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>rcontext</name></expr></argument>, <argument><expr><name>arcsCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TrgmPackedArc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>snumber</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>states</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>arcs</name> <operator>=</operator> <operator>&amp;</operator><name><name>packedArcs</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>j</name> <operator>&lt;</operator> <name>arcsCount</name> <operator>&amp;&amp;</operator> <name><name>arcs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>sourceState</name> <operator>==</operator> <name>i</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>packedArcs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>targetState</name> <operator>=</operator> <name><name>arcs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>targetState</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>packedArcs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>colorTrgm</name> <operator>=</operator> <name><name>arcs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>colorTrgm</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>states</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>arcsCount</name> <operator>=</operator> <name>cnt</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Allocate working memory for trigramsMatchGraph() */</comment>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>colorTrigramsActive</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator>
		<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>rcontext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>result</name><operator>-&gt;</operator><name>colorTrigramsCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>statesActive</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator>
		<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>rcontext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>result</name><operator>-&gt;</operator><name>statesCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>statesQueue</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator>
		<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>rcontext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>result</name><operator>-&gt;</operator><name>statesCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Comparison function for sorting TrgmPackArcInfos.
 *
 * Compares arcs in following order: sourceState, colorTrgm, targetState.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>packArcInfoCmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>TrgmPackArcInfo</name> <modifier>*</modifier></type><name>p1</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>TrgmPackArcInfo</name> <operator>*</operator><operator>)</operator> <name>a1</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>TrgmPackArcInfo</name> <modifier>*</modifier></type><name>p2</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>TrgmPackArcInfo</name> <operator>*</operator><operator>)</operator> <name>a2</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>p1</name><operator>-&gt;</operator><name>sourceState</name></name> <operator>&lt;</operator> <name><name>p2</name><operator>-&gt;</operator><name>sourceState</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>p1</name><operator>-&gt;</operator><name>sourceState</name></name> <operator>&gt;</operator> <name><name>p2</name><operator>-&gt;</operator><name>sourceState</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>p1</name><operator>-&gt;</operator><name>colorTrgm</name></name> <operator>&lt;</operator> <name><name>p2</name><operator>-&gt;</operator><name>colorTrgm</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>p1</name><operator>-&gt;</operator><name>colorTrgm</name></name> <operator>&gt;</operator> <name><name>p2</name><operator>-&gt;</operator><name>colorTrgm</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>p1</name><operator>-&gt;</operator><name>targetState</name></name> <operator>&lt;</operator> <name><name>p2</name><operator>-&gt;</operator><name>targetState</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>p1</name><operator>-&gt;</operator><name>targetState</name></name> <operator>&gt;</operator> <name><name>p2</name><operator>-&gt;</operator><name>targetState</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*---------------------
 * Debugging functions
 *
 * These are designed to emit GraphViz files.
 *---------------------
 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRGM_REGEXP_DEBUG</name></cpp:ifdef>

<comment type="block">/*
 * Print initial NFA, in regexp library's representation
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>printSourceNFA</name><parameter_list>(<parameter><decl><type><name>regex_t</name> <modifier>*</modifier></type><name>regex</name></decl></parameter>, <parameter><decl><type><name>TrgmColorInfo</name> <modifier>*</modifier></type><name>colors</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ncolors</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nstates</name> <init>= <expr><call><name>pg_reg_getnumstates</name><argument_list>(<argument><expr><name>regex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\ndigraph sourceNFA {\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>state</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>state</name> <operator>&lt;</operator> <name>nstates</name></expr>;</condition> <incr><expr><name>state</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>regex_arc_t</name> <modifier>*</modifier></type><name>arcs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
					<decl><type ref="prev"/><name>arcsCount</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"s%d"</literal></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>pg_reg_getfinalstate</name><argument_list>(<argument><expr><name>regex</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>state</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" [shape = doublecircle]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>arcsCount</name> <operator>=</operator> <call><name>pg_reg_getnumoutarcs</name><argument_list>(<argument><expr><name>regex</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>arcs</name> <operator>=</operator> <operator>(</operator><name>regex_arc_t</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>regex_arc_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>arcsCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_reg_getoutarcs</name><argument_list>(<argument><expr><name>regex</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>arcs</name></expr></argument>, <argument><expr><name>arcsCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>arcsCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"  s%d -&gt; s%d [label = \"%d\"];\n"</literal></expr></argument>,
							 <argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>arcs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>to</name></expr></argument>, <argument><expr><name><name>arcs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>co</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>arcs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" node [shape = point ]; initial;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" initial -&gt; s%d;\n"</literal></expr></argument>,
					 <argument><expr><call><name>pg_reg_getinitialstate</name><argument_list>(<argument><expr><name>regex</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Print colors */</comment>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" { rank = sink;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"  Colors [shape = none, margin=0, label=&lt;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ncolors</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TrgmColorInfo</name> <modifier>*</modifier></type><name>color</name> <init>= <expr><operator>&amp;</operator><name><name>colors</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"&lt;br/&gt;Color %d: "</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>color</name><operator>-&gt;</operator><name>expandable</name></name></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>color</name><operator>-&gt;</operator><name>wordCharsCount</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name></type>		<name><name>s</name><index>[<expr><name>MAX_MULTIBYTE_CHAR_LEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>color</name><operator>-&gt;</operator><name>wordChars</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>bytes</name></expr></argument>, <argument><expr><name>MAX_MULTIBYTE_CHAR_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>s</name><index>[<expr><name>MAX_MULTIBYTE_CHAR_LEN</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"not expandable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"  &gt;];\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" }\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"}\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<block>{<block_content>
		<comment type="block">/* dot -Tpng -o /tmp/source.png &lt; /tmp/source.gv */</comment>
		<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>fp</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><literal type="string">"/tmp/source.gv"</literal></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Print expanded graph.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>printTrgmNFA</name><parameter_list>(<parameter><decl><type><name>TrgmNFA</name> <modifier>*</modifier></type><name>trgmNFA</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>scan_status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TrgmState</name>  <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TrgmState</name>  <modifier>*</modifier></type><name>initstate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\ndigraph transformedNFA {\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan_status</name></expr></argument>, <argument><expr><name><name>trgmNFA</name><operator>-&gt;</operator><name>states</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>state</name> <operator>=</operator> <operator>(</operator><name>TrgmState</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan_status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"s%d"</literal></expr></argument>, <argument><expr><operator>-</operator><name><name>state</name><operator>-&gt;</operator><name>snumber</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>TSTATE_FIN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" [shape = doublecircle]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>TSTATE_INIT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>initstate</name> <operator>=</operator> <name>state</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" [label = \"%d\"]"</literal></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>stateKey</name><operator>.</operator><name>nstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>state-&gt;arcs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TrgmArc</name>    <modifier>*</modifier></type><name>arc</name> <init>= <expr><operator>(</operator><name>TrgmArc</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"  s%d -&gt; s%d [label = \""</literal></expr></argument>,
							 <argument><expr><operator>-</operator><name><name>state</name><operator>-&gt;</operator><name>snumber</name></name></expr></argument>, <argument><expr><operator>-</operator><name><name>arc</name><operator>-&gt;</operator><name>target</name><operator>-&gt;</operator><name>snumber</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>printTrgmColor</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>arc</name><operator>-&gt;</operator><name>ctrgm</name><operator>.</operator><name>colors</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>printTrgmColor</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>arc</name><operator>-&gt;</operator><name>ctrgm</name><operator>.</operator><name>colors</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>printTrgmColor</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>arc</name><operator>-&gt;</operator><name>ctrgm</name><operator>.</operator><name>colors</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\"];\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>initstate</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" node [shape = point ]; initial;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" initial -&gt; s%d;\n"</literal></expr></argument>, <argument><expr><operator>-</operator><name><name>initstate</name><operator>-&gt;</operator><name>snumber</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"}\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<block>{<block_content>
		<comment type="block">/* dot -Tpng -o /tmp/transformed.png &lt; /tmp/transformed.gv */</comment>
		<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>fp</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><literal type="string">"/tmp/transformed.gv"</literal></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Print a TrgmColor readably.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>printTrgmColor</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>TrgmColor</name></type> <name>co</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>co</name> <operator>==</operator> <name>COLOR_UNKNOWN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'u'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>co</name> <operator>==</operator> <name>COLOR_BLANK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'b'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>co</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Print final packed representation of trigram-based expanded graph.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>printTrgmPackedGraph</name><parameter_list>(<parameter><decl><type><name>TrgmPackedGraph</name> <modifier>*</modifier></type><name>packedGraph</name></decl></parameter>, <parameter><decl><type><name>TRGM</name> <modifier>*</modifier></type><name>trigrams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>trgm</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\ndigraph packedGraph {\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>packedGraph</name><operator>-&gt;</operator><name>statesCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TrgmPackedState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>&amp;</operator><name><name>packedGraph</name><operator>-&gt;</operator><name>states</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" s%d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" [shape = doublecircle]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" [label = &lt;s%d&gt;];\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>arcsCount</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TrgmPackedArc</name> <modifier>*</modifier></type><name>arc</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>arcs</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"  s%d -&gt; s%d [label = \"trigram %d\"];\n"</literal></expr></argument>,
							 <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>arc</name><operator>-&gt;</operator><name>targetState</name></name></expr></argument>, <argument><expr><name><name>arc</name><operator>-&gt;</operator><name>colorTrgm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" node [shape = point ]; initial;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" initial -&gt; s%d;\n"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Print trigrams */</comment>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" { rank = sink;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"  Trigrams [shape = none, margin=0, label=&lt;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>GETARR</name><argument_list>(<argument><expr><name>trigrams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>packedGraph</name><operator>-&gt;</operator><name>colorTrigramsCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>count</name> <init>= <expr><name><name>packedGraph</name><operator>-&gt;</operator><name>colorTrigramGroups</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"&lt;br/&gt;Trigram %d: "</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * XXX This representation is nice only for all-ASCII trigrams.
			 */</comment>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\"%c%c%c\""</literal></expr></argument>, <argument><expr><operator>(</operator><operator>*</operator><name>p</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>, <argument><expr><operator>(</operator><operator>*</operator><name>p</name><operator>)</operator><index>[<expr><literal type="number">1</literal></expr>]</index></expr></argument>, <argument><expr><operator>(</operator><operator>*</operator><name>p</name><operator>)</operator><index>[<expr><literal type="number">2</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"  &gt;];\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" }\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"}\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<block>{<block_content>
		<comment type="block">/* dot -Tpng -o /tmp/packed.png &lt; /tmp/packed.gv */</comment>
		<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>fp</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><literal type="string">"/tmp/packed.gv"</literal></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* TRGM_REGEXP_DEBUG */</comment>
</unit>
