<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/contrib/file_fdw/file_fdw.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * file_fdw.c
 *		  foreign-data wrapper for server-side flat files (or programs).
 *
 * Copyright (c) 2010-2020, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *		  contrib/file_fdw/file_fdw.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/reloptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_foreign_table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/copy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/explain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/vacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"foreign/fdwapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"foreign/foreign.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pathnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planmain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/restrictinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/sampling.h"</cpp:file></cpp:include>

<expr_stmt><expr><name>PG_MODULE_MAGIC</name></expr>;</expr_stmt>

<comment type="block">/*
 * Describes the valid options for objects that use this wrapper.
 */</comment>
<struct>struct <name>FileFdwOption</name>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>optname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>optcontext</name></decl>;</decl_stmt>		<comment type="block">/* Oid of catalog in which option may appear */</comment>
}</block>;</struct>

<comment type="block">/*
 * Valid options for file_fdw.
 * These options are based on the options for the COPY FROM command.
 * But note that force_not_null and force_null are handled as boolean options
 * attached to a column, not as table options.
 *
 * Note: If you are adding new option for user mapping, you need to modify
 * fileGetOptions(), which currently doesn't bother to look at user mappings.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>FileFdwOption</name></name></type> <name><name>valid_options</name><index>[]</index></name> <init>= <expr><block>{
	<comment type="block">/* Data source options */</comment>
	<expr><block>{<expr><literal type="string">"filename"</literal></expr>, <expr><name>ForeignTableRelationId</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"program"</literal></expr>, <expr><name>ForeignTableRelationId</name></expr>}</block></expr>,

	<comment type="block">/* Format options */</comment>
	<comment type="block">/* oids option is not supported */</comment>
	<expr><block>{<expr><literal type="string">"format"</literal></expr>, <expr><name>ForeignTableRelationId</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"header"</literal></expr>, <expr><name>ForeignTableRelationId</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"delimiter"</literal></expr>, <expr><name>ForeignTableRelationId</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"quote"</literal></expr>, <expr><name>ForeignTableRelationId</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"escape"</literal></expr>, <expr><name>ForeignTableRelationId</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"null"</literal></expr>, <expr><name>ForeignTableRelationId</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"encoding"</literal></expr>, <expr><name>ForeignTableRelationId</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"force_not_null"</literal></expr>, <expr><name>AttributeRelationId</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"force_null"</literal></expr>, <expr><name>AttributeRelationId</name></expr>}</block></expr>,

	<comment type="block">/*
	 * force_quote is not supported by file_fdw because it's for COPY TO.
	 */</comment>

	<comment type="block">/* Sentinel */</comment>
	<expr><block>{<expr><name>NULL</name></expr>, <expr><name>InvalidOid</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * FDW-specific information for RelOptInfo.fdw_private.
 */</comment>
<typedef>typedef <type><struct>struct <name>FileFdwPlanState</name>
<block>{
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>		<comment type="block">/* file or program to read from */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_program</name></decl>;</decl_stmt>		<comment type="block">/* true if filename represents an OS command */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>options</name></decl>;</decl_stmt>		<comment type="block">/* merged COPY options, excluding filename and
								 * is_program */</comment>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>pages</name></decl>;</decl_stmt>			<comment type="block">/* estimate of file's physical size */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>ntuples</name></decl>;</decl_stmt>		<comment type="block">/* estimate of number of data rows */</comment>
}</block></struct></type> <name>FileFdwPlanState</name>;</typedef>

<comment type="block">/*
 * FDW-specific information for ForeignScanState.fdw_state.
 */</comment>
<typedef>typedef <type><struct>struct <name>FileFdwExecutionState</name>
<block>{
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>		<comment type="block">/* file or program to read from */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_program</name></decl>;</decl_stmt>		<comment type="block">/* true if filename represents an OS command */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>options</name></decl>;</decl_stmt>		<comment type="block">/* merged COPY options, excluding filename and
								 * is_program */</comment>
	<decl_stmt><decl><type><name>CopyState</name></type>	<name>cstate</name></decl>;</decl_stmt>			<comment type="block">/* COPY execution state */</comment>
}</block></struct></type> <name>FileFdwExecutionState</name>;</typedef>

<comment type="block">/*
 * SQL functions
 */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>file_fdw_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>file_fdw_validator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * FDW callback routines
 */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>fileGetForeignRelSize</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
								  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name></decl></parameter>,
								  <parameter><decl><type><name>Oid</name></type> <name>foreigntableid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>fileGetForeignPaths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
								<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name></decl></parameter>,
								<parameter><decl><type><name>Oid</name></type> <name>foreigntableid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ForeignScan</name> <modifier>*</modifier></type><name>fileGetForeignPlan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
									   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name></decl></parameter>,
									   <parameter><decl><type><name>Oid</name></type> <name>foreigntableid</name></decl></parameter>,
									   <parameter><decl><type><name>ForeignPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
									   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
									   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>,
									   <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>outer_plan</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>fileExplainForeignScan</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>fileBeginForeignScan</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>fileIterateForeignScan</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>fileReScanForeignScan</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>fileEndForeignScan</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>fileAnalyzeForeignTable</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
									<parameter><decl><type><name>AcquireSampleRowsFunc</name> <modifier>*</modifier></type><name>func</name></decl></parameter>,
									<parameter><decl><type><name>BlockNumber</name> <modifier>*</modifier></type><name>totalpages</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>fileIsForeignScanParallelSafe</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
										  <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Helper functions
 */</comment>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_valid_option</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>option</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>fileGetOptions</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>foreigntableid</name></decl></parameter>,
						   <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>filename</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_program</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>other_options</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>get_file_fdw_attribute_options</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_selective_binary_conversion</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name></decl></parameter>,
											  <parameter><decl><type><name>Oid</name></type> <name>foreigntableid</name></decl></parameter>,
											  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>columns</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>estimate_size</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name></decl></parameter>,
						  <parameter><decl><type><name>FileFdwPlanState</name> <modifier>*</modifier></type><name>fdw_private</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>estimate_costs</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name></decl></parameter>,
						   <parameter><decl><type><name>FileFdwPlanState</name> <modifier>*</modifier></type><name>fdw_private</name></decl></parameter>,
						   <parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>startup_cost</name></decl></parameter>, <parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>total_cost</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>file_acquire_sample_rows</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>,
									 <parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>targrows</name></decl></parameter>,
									 <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>totalrows</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>totaldeadrows</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Foreign-data wrapper handler function: return a struct with pointers
 * to my callback routines.
 */</comment>
<function><type><name>Datum</name></type>
<name>file_fdw_handler</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FdwRoutine</name> <modifier>*</modifier></type><name>fdwroutine</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>FdwRoutine</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>GetForeignRelSize</name></name> <operator>=</operator> <name>fileGetForeignRelSize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>GetForeignPaths</name></name> <operator>=</operator> <name>fileGetForeignPaths</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>GetForeignPlan</name></name> <operator>=</operator> <name>fileGetForeignPlan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>ExplainForeignScan</name></name> <operator>=</operator> <name>fileExplainForeignScan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>BeginForeignScan</name></name> <operator>=</operator> <name>fileBeginForeignScan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>IterateForeignScan</name></name> <operator>=</operator> <name>fileIterateForeignScan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>ReScanForeignScan</name></name> <operator>=</operator> <name>fileReScanForeignScan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>EndForeignScan</name></name> <operator>=</operator> <name>fileEndForeignScan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>AnalyzeForeignTable</name></name> <operator>=</operator> <name>fileAnalyzeForeignTable</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>IsForeignScanParallelSafe</name></name> <operator>=</operator> <name>fileIsForeignScanParallelSafe</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>fdwroutine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Validate the generic options given to a FOREIGN DATA WRAPPER, SERVER,
 * USER MAPPING or FOREIGN TABLE that uses file_fdw.
 *
 * Raise an ERROR if the option or its value is considered invalid.
 */</comment>
<function><type><name>Datum</name></type>
<name>file_fdw_validator</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>options_list</name> <init>= <expr><call><name>untransformRelOptions</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>catalog</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>filename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>force_not_null</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>force_null</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>other_options</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check that only options supported by file_fdw, and allowed for the
	 * current object type, are given.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>options_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>def</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_valid_option</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><name>catalog</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>FileFdwOption</name></name> <modifier>*</modifier></type><name>opt</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Unknown option specified, complain about it. Provide a hint
			 * with list of valid options for the object.
			 */</comment>
			<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>opt</name> <operator>=</operator> <name>valid_options</name></expr>;</init> <condition><expr><name><name>opt</name><operator>-&gt;</operator><name>optname</name></name></expr>;</condition> <incr><expr><name>opt</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>catalog</name> <operator>==</operator> <name><name>opt</name><operator>-&gt;</operator><name>optcontext</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name><name>buf</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">", "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
									 <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>optname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FDW_INVALID_OPTION_NAME</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid option \"%s\""</literal></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
					 <ternary><condition><expr><name><name>buf</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>
					 ?</condition><then> <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Valid options in this context are: %s"</literal></expr></argument>,
							   <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>
					 </then><else>: <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"There are no valid options in this context."</literal></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Separate out filename, program, and column-specific options, since
		 * ProcessCopyOptions won't accept them.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"filename"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"program"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>filename</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Check permissions for changing which file or program is used by
			 * the file_fdw.
			 *
			 * Only members of the role 'pg_read_server_files' are allowed to
			 * set the 'filename' option of a file_fdw foreign table, while
			 * only members of the role 'pg_execute_server_program' are
			 * allowed to set the 'program' option.  This is because we don't
			 * want regular users to be able to control which file gets read
			 * or which program gets executed.
			 *
			 * Putting this sort of permissions check in a validator is a bit
			 * of a crock, but there doesn't seem to be any other place that
			 * can enforce the check more cleanly.
			 *
			 * Note that the valid_options[] array disallows setting filename
			 * and program at any options level other than foreign table ---
			 * otherwise there'd still be a security hole.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"filename"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<operator>!</operator><call><name>is_member_of_role</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>DEFAULT_ROLE_READ_SERVER_FILES</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only superuser or a member of the pg_read_server_files role may specify the filename option of a file_fdw foreign table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"program"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<operator>!</operator><call><name>is_member_of_role</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>DEFAULT_ROLE_EXECUTE_SERVER_PROGRAM</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only superuser or a member of the pg_execute_server_program role may specify the program option of a file_fdw foreign table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>

		<comment type="block">/*
		 * force_not_null is a boolean option; after validation we can discard
		 * it - it will be retrieved later in get_file_fdw_attribute_options()
		 */</comment>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"force_not_null"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>force_not_null</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Option \"force_not_null\" supplied more than once for a column."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>force_not_null</name> <operator>=</operator> <name>def</name></expr>;</expr_stmt>
			<comment type="block">/* Don't care what the value is, as long as it's a legal boolean */</comment>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<comment type="block">/* See comments for force_not_null above */</comment>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"force_null"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>force_null</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Option \"force_null\" supplied more than once for a column."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>force_null</name> <operator>=</operator> <name>def</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>other_options</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>other_options</name></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Now apply the core COPY code's validation logic for more checks.
	 */</comment>
	<expr_stmt><expr><call><name>ProcessCopyOptions</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>other_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Either filename or program option is required for file_fdw foreign
	 * tables.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>catalog</name> <operator>==</operator> <name>ForeignTableRelationId</name> <operator>&amp;&amp;</operator> <name>filename</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FDW_DYNAMIC_PARAMETER_VALUE_NEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"either filename or program is required for file_fdw foreign tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check if the provided option is one of the valid options.
 * context is the Oid of the catalog holding the object the option is for.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_valid_option</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>option</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>FileFdwOption</name></name> <modifier>*</modifier></type><name>opt</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>opt</name> <operator>=</operator> <name>valid_options</name></expr>;</init> <condition><expr><name><name>opt</name><operator>-&gt;</operator><name>optname</name></name></expr>;</condition> <incr><expr><name>opt</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>context</name> <operator>==</operator> <name><name>opt</name><operator>-&gt;</operator><name>optcontext</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>optname</name></name></expr></argument>, <argument><expr><name>option</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch the options for a file_fdw foreign table.
 *
 * We have to separate out filename/program from the other options because
 * those must not appear in the options list passed to the core COPY code.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fileGetOptions</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>foreigntableid</name></decl></parameter>,
			   <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_program</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>other_options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ForeignTable</name> <modifier>*</modifier></type><name>table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignServer</name> <modifier>*</modifier></type><name>server</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignDataWrapper</name> <modifier>*</modifier></type><name>wrapper</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>options</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Extract options from FDW objects.  We ignore user mappings because
	 * file_fdw doesn't have any options that can be specified there.
	 *
	 * (XXX Actually, given the current contents of valid_options[], there's
	 * no point in examining anything except the foreign table's own options.
	 * Simplify?)
	 */</comment>
	<expr_stmt><expr><name>table</name> <operator>=</operator> <call><name>GetForeignTable</name><argument_list>(<argument><expr><name>foreigntableid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>server</name> <operator>=</operator> <call><name>GetForeignServer</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>serverid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>wrapper</name> <operator>=</operator> <call><name>GetForeignDataWrapper</name><argument_list>(<argument><expr><name><name>server</name><operator>-&gt;</operator><name>fdwid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>options</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><name><name>wrapper</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><name><name>server</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><call><name>get_file_fdw_attribute_options</name><argument_list>(<argument><expr><name>foreigntableid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Separate out the filename or program option (we assume there is only
	 * one).
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>filename</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>is_program</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>options</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>def</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"filename"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>filename</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>foreach_delete_current</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"program"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>filename</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>is_program</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>foreach_delete_current</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * The validator should have checked that filename or program was included
	 * in the options, but check again, just in case.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>filename</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"either filename or program is required for file_fdw foreign tables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>other_options</name> <operator>=</operator> <name>options</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Retrieve per-column generic options from pg_attribute and construct a list
 * of DefElems representing them.
 *
 * At the moment we only have "force_not_null", and "force_null",
 * which should each be combined into a single DefElem listing all such
 * columns, since that's what COPY expects.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_file_fdw_attribute_options</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupleDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>natts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>fnncolumns</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>fncolumns</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>options</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupleDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>natts</name> <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>

	<comment type="block">/* Retrieve FDW options for all user-defined attributes. */</comment>
	<for>for <control>(<init><expr><name>attnum</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>attnum</name> <operator>&lt;=</operator> <name>natts</name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>options</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<comment type="block">/* Skip dropped attributes. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>GetForeignColumnOptions</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>options</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>def</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"force_not_null"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>defGetBoolean</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attname</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name>fnncolumns</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>fnncolumns</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"force_null"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>defGetBoolean</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attname</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name>fncolumns</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>fncolumns</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* maybe in future handle other options here */</comment>
		</block_content>}</block>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Return DefElem only when some column(s) have force_not_null /
	 * force_null options set
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>fnncolumns</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"force_not_null"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>fnncolumns</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>fncolumns</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"force_null"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>fncolumns</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>options</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * fileGetForeignRelSize
 *		Obtain relation size estimates for a foreign table
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fileGetForeignRelSize</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name></decl></parameter>,
					  <parameter><decl><type><name>Oid</name></type> <name>foreigntableid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FileFdwPlanState</name> <modifier>*</modifier></type><name>fdw_private</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Fetch options.  We only need filename (or program) at this point, but
	 * we might as well get everything and not need to re-fetch it later in
	 * planning.
	 */</comment>
	<expr_stmt><expr><name>fdw_private</name> <operator>=</operator> <operator>(</operator><name>FileFdwPlanState</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FileFdwPlanState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fileGetOptions</name><argument_list>(<argument><expr><name>foreigntableid</name></expr></argument>,
				   <argument><expr><operator>&amp;</operator><name><name>fdw_private</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,
				   <argument><expr><operator>&amp;</operator><name><name>fdw_private</name><operator>-&gt;</operator><name>is_program</name></name></expr></argument>,
				   <argument><expr><operator>&amp;</operator><name><name>fdw_private</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>baserel</name><operator>-&gt;</operator><name>fdw_private</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>fdw_private</name></expr>;</expr_stmt>

	<comment type="block">/* Estimate relation size */</comment>
	<expr_stmt><expr><call><name>estimate_size</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>, <argument><expr><name>fdw_private</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * fileGetForeignPaths
 *		Create possible access paths for a scan on the foreign table
 *
 *		Currently we don't support any push-down feature, so there is only one
 *		possible access path, which simply returns all records in the order in
 *		the data file.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fileGetForeignPaths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name></decl></parameter>,
					<parameter><decl><type><name>Oid</name></type> <name>foreigntableid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FileFdwPlanState</name> <modifier>*</modifier></type><name>fdw_private</name> <init>= <expr><operator>(</operator><name>FileFdwPlanState</name> <operator>*</operator><operator>)</operator> <name><name>baserel</name><operator>-&gt;</operator><name>fdw_private</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>startup_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>total_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>columns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>coptions</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Decide whether to selectively perform binary conversion */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>check_selective_binary_conversion</name><argument_list>(<argument><expr><name>baserel</name></expr></argument>,
										  <argument><expr><name>foreigntableid</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>columns</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>coptions</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"convert_selectively"</literal></expr></argument>,
										  <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>columns</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Estimate costs */</comment>
	<expr_stmt><expr><call><name>estimate_costs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>, <argument><expr><name>fdw_private</name></expr></argument>,
				   <argument><expr><operator>&amp;</operator><name>startup_cost</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>total_cost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create a ForeignPath node and add it as only possible path.  We use the
	 * fdw_private list of the path to carry the convert_selectively option;
	 * it will be propagated into the fdw_private list of the Plan node.
	 *
	 * We don't support pushing join clauses into the quals of this path, but
	 * it could still have required parameterization due to LATERAL refs in
	 * its tlist.
	 */</comment>
	<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>baserel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
			 <call><name>create_foreignscan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>,	<comment type="block">/* default pathtarget */</comment>
									 <argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
									 <argument><expr><name>startup_cost</name></expr></argument>,
									 <argument><expr><name>total_cost</name></expr></argument>,
									 <argument><expr><name>NIL</name></expr></argument>,	<comment type="block">/* no pathkeys */</comment>
									 <argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>,	<comment type="block">/* no extra plan */</comment>
									 <argument><expr><name>coptions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If data file was sorted, and we knew it somehow, we could insert
	 * appropriate pathkeys into the ForeignPath node to tell the planner
	 * that.
	 */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * fileGetForeignPlan
 *		Create a ForeignScan plan node for scanning the foreign table
 */</comment>
<function><type><specifier>static</specifier> <name>ForeignScan</name> <modifier>*</modifier></type>
<name>fileGetForeignPlan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
				   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name></decl></parameter>,
				   <parameter><decl><type><name>Oid</name></type> <name>foreigntableid</name></decl></parameter>,
				   <parameter><decl><type><name>ForeignPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>,
				   <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>outer_plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Index</name></type>		<name>scan_relid</name> <init>= <expr><name><name>baserel</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We have no native ability to evaluate restriction clauses, so we just
	 * put all the scan_clauses into the plan node's qual list for the
	 * executor to check.  So all we have to do here is strip RestrictInfo
	 * nodes from the clauses and ignore pseudoconstants (which will be
	 * handled elsewhere).
	 */</comment>
	<expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name>scan_clauses</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create the ForeignScan node */</comment>
	<return>return <expr><call><name>make_foreignscan</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
							<argument><expr><name>scan_clauses</name></expr></argument>,
							<argument><expr><name>scan_relid</name></expr></argument>,
							<argument><expr><name>NIL</name></expr></argument>,	<comment type="block">/* no expressions to evaluate */</comment>
							<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>fdw_private</name></name></expr></argument>,
							<argument><expr><name>NIL</name></expr></argument>,	<comment type="block">/* no custom tlist */</comment>
							<argument><expr><name>NIL</name></expr></argument>,	<comment type="block">/* no remote quals */</comment>
							<argument><expr><name>outer_plan</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * fileExplainForeignScan
 *		Produce extra output for EXPLAIN
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fileExplainForeignScan</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_program</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>options</name></decl>;</decl_stmt>

	<comment type="block">/* Fetch options --- we only need filename and is_program at this point */</comment>
	<expr_stmt><expr><call><name>fileGetOptions</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentRelation</name></name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><operator>&amp;</operator><name>filename</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_program</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_program</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Foreign Program"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Foreign File"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Suppress file size if we're not showing cost details */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>costs</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_buf</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_program</name> <operator>&amp;&amp;</operator>
			<call><name>stat</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Foreign File Size"</literal></expr></argument>, <argument><expr><literal type="string">"b"</literal></expr></argument>,
								   <argument><expr><operator>(</operator><name>int64</name><operator>)</operator> <name><name>stat_buf</name><operator>.</operator><name>st_size</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * fileBeginForeignScan
 *		Initiate access to the file by creating CopyState
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fileBeginForeignScan</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ForeignScan</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>ForeignScan</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_program</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>options</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CopyState</name></type>	<name>cstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FileFdwExecutionState</name> <modifier>*</modifier></type><name>festate</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Do nothing in EXPLAIN (no ANALYZE) case.  node-&gt;fdw_state stays NULL.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>eflags</name> <operator>&amp;</operator> <name>EXEC_FLAG_EXPLAIN_ONLY</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Fetch options of foreign table */</comment>
	<expr_stmt><expr><call><name>fileGetOptions</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentRelation</name></name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><operator>&amp;</operator><name>filename</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_program</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add any options from the plan (currently only convert_selectively) */</comment>
	<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>fdw_private</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create CopyState from FDW options.  We always acquire all columns, so
	 * as to match the expected ScanTupleSlot signature.
	 */</comment>
	<expr_stmt><expr><name>cstate</name> <operator>=</operator> <call><name>BeginCopyFrom</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
						   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentRelation</name></name></expr></argument>,
						   <argument><expr><name>filename</name></expr></argument>,
						   <argument><expr><name>is_program</name></expr></argument>,
						   <argument><expr><name>NULL</name></expr></argument>,
						   <argument><expr><name>NIL</name></expr></argument>,
						   <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Save state in node-&gt;fdw_state.  We must save enough information to call
	 * BeginCopyFrom() again.
	 */</comment>
	<expr_stmt><expr><name>festate</name> <operator>=</operator> <operator>(</operator><name>FileFdwExecutionState</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FileFdwExecutionState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>festate</name><operator>-&gt;</operator><name>filename</name></name> <operator>=</operator> <name>filename</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>festate</name><operator>-&gt;</operator><name>is_program</name></name> <operator>=</operator> <name>is_program</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>festate</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>options</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>festate</name><operator>-&gt;</operator><name>cstate</name></name> <operator>=</operator> <name>cstate</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>fdw_state</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>festate</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * fileIterateForeignScan
 *		Read next record from the data file and store it into the
 *		ScanTupleSlot as a virtual tuple
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>fileIterateForeignScan</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FileFdwExecutionState</name> <modifier>*</modifier></type><name>festate</name> <init>= <expr><operator>(</operator><name>FileFdwExecutionState</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>fdw_state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>errcallback</name></decl>;</decl_stmt>

	<comment type="block">/* Set up callback to identify error line number. */</comment>
	<expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>CopyFromErrorCallback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>festate</name><operator>-&gt;</operator><name>cstate</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>errcallback</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * The protocol for loading a virtual tuple into a slot is first
	 * ExecClearTuple, then fill the values/isnull arrays, then
	 * ExecStoreVirtualTuple.  If we don't find another row in the file, we
	 * just skip the last step, leaving the slot empty as required.
	 *
	 * We can pass ExprContext = NULL because we read all columns from the
	 * file, so no need to evaluate default expressions.
	 */</comment>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>NextCopyFrom</name><argument_list>(<argument><expr><name><name>festate</name><operator>-&gt;</operator><name>cstate</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						 <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecStoreVirtualTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Remove error callback. */</comment>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>errcallback</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>

	<return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * fileReScanForeignScan
 *		Rescan table, possibly with new parameters
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fileReScanForeignScan</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FileFdwExecutionState</name> <modifier>*</modifier></type><name>festate</name> <init>= <expr><operator>(</operator><name>FileFdwExecutionState</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>fdw_state</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>EndCopyFrom</name><argument_list>(<argument><expr><name><name>festate</name><operator>-&gt;</operator><name>cstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>festate</name><operator>-&gt;</operator><name>cstate</name></name> <operator>=</operator> <call><name>BeginCopyFrom</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
									<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentRelation</name></name></expr></argument>,
									<argument><expr><name><name>festate</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,
									<argument><expr><name><name>festate</name><operator>-&gt;</operator><name>is_program</name></name></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>,
									<argument><expr><name>NIL</name></expr></argument>,
									<argument><expr><name><name>festate</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * fileEndForeignScan
 *		Finish scanning foreign table and dispose objects used for this scan
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fileEndForeignScan</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FileFdwExecutionState</name> <modifier>*</modifier></type><name>festate</name> <init>= <expr><operator>(</operator><name>FileFdwExecutionState</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>fdw_state</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* if festate is NULL, we are in EXPLAIN; nothing to do */</comment>
	<if_stmt><if>if <condition>(<expr><name>festate</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>EndCopyFrom</name><argument_list>(<argument><expr><name><name>festate</name><operator>-&gt;</operator><name>cstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * fileAnalyzeForeignTable
 *		Test whether analyzing this foreign table is supported
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>fileAnalyzeForeignTable</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
						<parameter><decl><type><name>AcquireSampleRowsFunc</name> <modifier>*</modifier></type><name>func</name></decl></parameter>,
						<parameter><decl><type><name>BlockNumber</name> <modifier>*</modifier></type><name>totalpages</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_program</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>options</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_buf</name></decl>;</decl_stmt>

	<comment type="block">/* Fetch options of foreign table */</comment>
	<expr_stmt><expr><call><name>fileGetOptions</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>filename</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_program</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If this is a program instead of a file, just return false to skip
	 * analyzing the table.  We could run the program and collect stats on
	 * whatever it currently returns, but it seems likely that in such cases
	 * the output would be too volatile for the stats to be useful.  Maybe
	 * there should be an option to enable doing this?
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_program</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Get size of the file.  (XXX if we fail here, would it be better to just
	 * return false to skip analyzing the table?)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not stat file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Convert size to pages.  Must return at least 1 so that we can tell
	 * later on that pg_class.relpages is not default.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>totalpages</name> <operator>=</operator> <operator>(</operator><name><name>stat_buf</name><operator>.</operator><name>st_size</name></name> <operator>+</operator> <operator>(</operator><name>BLCKSZ</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <name>BLCKSZ</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>totalpages</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>totalpages</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>func</name> <operator>=</operator> <name>file_acquire_sample_rows</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * fileIsForeignScanParallelSafe
 *		Reading a file, or external program, in a parallel worker should work
 *		just the same as reading it in the leader, so mark scans safe.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>fileIsForeignScanParallelSafe</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
							  <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * check_selective_binary_conversion
 *
 * Check to see if it's useful to convert only a subset of the file's columns
 * to binary.  If so, construct a list of the column names to be converted,
 * return that at *columns, and return true.  (Note that it's possible to
 * determine that no columns need be converted, for instance with a COUNT(*)
 * query.  So we can't use returning a NIL list to indicate failure.)
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_selective_binary_conversion</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name></decl></parameter>,
								  <parameter><decl><type><name>Oid</name></type> <name>foreigntableid</name></decl></parameter>,
								  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>columns</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ForeignTable</name> <modifier>*</modifier></type><name>table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupleDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>attrs_used</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>has_wholerow</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numattrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>columns</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>				<comment type="block">/* default result */</comment>

	<comment type="block">/*
	 * Check format of the file.  If binary format, this is irrelevant.
	 */</comment>
	<expr_stmt><expr><name>table</name> <operator>=</operator> <call><name>GetForeignTable</name><argument_list>(<argument><expr><name>foreigntableid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>table-&gt;options</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>def</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"format"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>format</name> <init>= <expr><call><name>defGetString</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><literal type="string">"binary"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Collect all the attributes needed for joins or final output. */</comment>
	<expr_stmt><expr><call><name>pull_varattnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>baserel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>, <argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
				   <argument><expr><operator>&amp;</operator><name>attrs_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add all the attributes used by restriction clauses. */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>baserel-&gt;baserestrictinfo</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pull_varattnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>, <argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
					   <argument><expr><operator>&amp;</operator><name>attrs_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Convert attribute numbers to column names. */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>foreigntableid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupleDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>attnum</name> <operator>=</operator> <call><name>bms_first_member</name><argument_list>(<argument><expr><name>attrs_used</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Adjust for system attributes. */</comment>
		<expr_stmt><expr><name>attnum</name> <operator>+=</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>has_wholerow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Ignore system attributes. */</comment>
		<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Get user attributes. */</comment>
		<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attname</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Skip dropped attributes (probably shouldn't see any here). */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Skip generated columns (COPY won't accept them in the column
			 * list)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attgenerated</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><operator>*</operator><name>columns</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>columns</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Count non-dropped user attributes while we have the tupdesc. */</comment>
	<expr_stmt><expr><name>numattrs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>numattrs</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If there's a whole-row reference, fail: we need all the columns. */</comment>
	<if_stmt><if>if <condition>(<expr><name>has_wholerow</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>columns</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If all the user attributes are needed, fail. */</comment>
	<if_stmt><if>if <condition>(<expr><name>numattrs</name> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><operator>*</operator><name>columns</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>columns</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Estimate size of a foreign table.
 *
 * The main result is returned in baserel-&gt;rows.  We also set
 * fdw_private-&gt;pages and fdw_private-&gt;ntuples for later use in the cost
 * calculation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>estimate_size</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name></decl></parameter>,
			  <parameter><decl><type><name>FileFdwPlanState</name> <modifier>*</modifier></type><name>fdw_private</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>pages</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>ntuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>nrows</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Get size of the file.  It might not be there at plan time, though, in
	 * which case we have to use a default estimate.  We also have to fall
	 * back to the default if using a program as the input.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fdw_private</name><operator>-&gt;</operator><name>is_program</name></name> <operator>||</operator> <call><name>stat</name><argument_list>(<argument><expr><name><name>fdw_private</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>stat_buf</name><operator>.</operator><name>st_size</name></name> <operator>=</operator> <literal type="number">10</literal> <operator>*</operator> <name>BLCKSZ</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Convert size to pages for use in I/O cost estimate later.
	 */</comment>
	<expr_stmt><expr><name>pages</name> <operator>=</operator> <operator>(</operator><name><name>stat_buf</name><operator>.</operator><name>st_size</name></name> <operator>+</operator> <operator>(</operator><name>BLCKSZ</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <name>BLCKSZ</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pages</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>pages</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>fdw_private</name><operator>-&gt;</operator><name>pages</name></name> <operator>=</operator> <name>pages</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Estimate the number of tuples in the file.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>baserel</name><operator>-&gt;</operator><name>pages</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We have # of pages and # of tuples from pg_class (that is, from a
		 * previous ANALYZE), so compute a tuples-per-page estimate and scale
		 * that by the current file size.
		 */</comment>
		<decl_stmt><decl><type><name>double</name></type>		<name>density</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>density</name> <operator>=</operator> <name><name>baserel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>baserel</name><operator>-&gt;</operator><name>pages</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ntuples</name> <operator>=</operator> <call><name>clamp_row_est</name><argument_list>(<argument><expr><name>density</name> <operator>*</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Otherwise we have to fake it.  We back into this estimate using the
		 * planner's idea of the relation width; which is bogus if not all
		 * columns are being read, not to mention that the text representation
		 * of a row probably isn't the same size as its internal
		 * representation.  Possibly we could do something better, but the
		 * real answer to anyone who complains is "ANALYZE" ...
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>tuple_width</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tuple_width</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>)</argument_list></call> <operator>+</operator>
			<call><name>MAXALIGN</name><argument_list>(<argument><expr><name>SizeofHeapTupleHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ntuples</name> <operator>=</operator> <call><name>clamp_row_est</name><argument_list>(<argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name><name>stat_buf</name><operator>.</operator><name>st_size</name></name> <operator>/</operator>
								<operator>(</operator><name>double</name><operator>)</operator> <name>tuple_width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>fdw_private</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>=</operator> <name>ntuples</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now estimate the number of rows returned by the scan after applying the
	 * baserestrictinfo quals.
	 */</comment>
	<expr_stmt><expr><name>nrows</name> <operator>=</operator> <name>ntuples</name> <operator>*</operator>
		<call><name>clauselist_selectivity</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
							   <argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name></expr></argument>,
							   <argument><expr><literal type="number">0</literal></expr></argument>,
							   <argument><expr><name>JOIN_INNER</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>nrows</name> <operator>=</operator> <call><name>clamp_row_est</name><argument_list>(<argument><expr><name>nrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Save the output-rows estimate for the planner */</comment>
	<expr_stmt><expr><name><name>baserel</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name>nrows</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Estimate costs of scanning a foreign table.
 *
 * Results are returned in *startup_cost and *total_cost.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>estimate_costs</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name></decl></parameter>,
			   <parameter><decl><type><name>FileFdwPlanState</name> <modifier>*</modifier></type><name>fdw_private</name></decl></parameter>,
			   <parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>startup_cost</name></decl></parameter>, <parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>total_cost</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>pages</name> <init>= <expr><name><name>fdw_private</name><operator>-&gt;</operator><name>pages</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>ntuples</name> <init>= <expr><name><name>fdw_private</name><operator>-&gt;</operator><name>ntuples</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>run_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>cpu_per_tuple</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We estimate costs almost the same way as cost_seqscan(), thus assuming
	 * that I/O costs are equivalent to a regular table file of the same size.
	 * However, we take per-tuple CPU costs as 10x of a seqscan, to account
	 * for the cost of parsing records.
	 *
	 * In the case of a program source, this calculation is even more divorced
	 * from reality, but we have no good alternative; and it's not clear that
	 * the numbers we produce here matter much anyway, since there's only one
	 * access path for the rel.
	 */</comment>
	<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>seq_page_cost</name> <operator>*</operator> <name>pages</name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>startup_cost</name> <operator>=</operator> <name><name>baserel</name><operator>-&gt;</operator><name>baserestrictcost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cpu_per_tuple</name> <operator>=</operator> <name>cpu_tuple_cost</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <name><name>baserel</name><operator>-&gt;</operator><name>baserestrictcost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>cpu_per_tuple</name> <operator>*</operator> <name>ntuples</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>total_cost</name> <operator>=</operator> <operator>*</operator><name>startup_cost</name> <operator>+</operator> <name>run_cost</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * file_acquire_sample_rows -- acquire a random sample of rows from the table
 *
 * Selected rows are returned in the caller-allocated array rows[],
 * which must have at least targrows entries.
 * The actual number of rows selected is returned as the function result.
 * We also count the total number of rows in the file and return it into
 * *totalrows.  Note that *totaldeadrows is always set to 0.
 *
 * Note that the returned list of rows is not always in order by physical
 * position in the file.  Therefore, correlation estimates derived later
 * may be meaningless, but it's OK because we don't use the estimates
 * currently (the planner only pays attention to correlation for indexscans).
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>file_acquire_sample_rows</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>,
						 <parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>targrows</name></decl></parameter>,
						 <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>totalrows</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>totaldeadrows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>numrows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>rowstoskip</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* -1 means not set yet */</comment>
	<decl_stmt><decl><type><name>ReservoirStateData</name></type> <name>rstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_program</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>options</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CopyState</name></type>	<name>cstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>errcallback</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>tupcontext</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>targrows</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nulls</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fetch options of foreign table */</comment>
	<expr_stmt><expr><call><name>fileGetOptions</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>filename</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_program</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create CopyState from FDW options.
	 */</comment>
	<expr_stmt><expr><name>cstate</name> <operator>=</operator> <call><name>BeginCopyFrom</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>is_program</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
						   <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Use per-tuple memory context to prevent leak of memory used to read
	 * rows from the file with Copy routines.
	 */</comment>
	<expr_stmt><expr><name>tupcontext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
									   <argument><expr><literal type="string">"file_fdw temporary context"</literal></expr></argument>,
									   <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Prepare for sampling rows */</comment>
	<expr_stmt><expr><call><name>reservoir_init_selection_state</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rstate</name></expr></argument>, <argument><expr><name>targrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up callback to identify error line number. */</comment>
	<expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>CopyFromErrorCallback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>cstate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>errcallback</name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>totalrows</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>totaldeadrows</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/* Check for user-requested abort or sleep */</comment>
		<expr_stmt><expr><call><name>vacuum_delay_point</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Fetch next row */</comment>
		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>tupcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>tupcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>NextCopyFrom</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * The first targrows sample rows are simply copied into the
		 * reservoir.  Then we start replacing tuples in the sample until we
		 * reach the end of the relation. This algorithm is from Jeff Vitter's
		 * paper (see more info in commands/analyze.c).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>numrows</name> <operator>&lt;</operator> <name>targrows</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>rows</name><index>[<expr><name>numrows</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * t in Vitter's paper is the number of records already processed.
			 * If we need to compute a new S value, we must use the
			 * not-yet-incremented value of totalrows as t.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>rowstoskip</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>rowstoskip</name> <operator>=</operator> <call><name>reservoir_get_next_S</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rstate</name></expr></argument>, <argument><expr><operator>*</operator><name>totalrows</name></expr></argument>, <argument><expr><name>targrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>rowstoskip</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Found a suitable tuple, so save it, replacing one old tuple
				 * at random
				 */</comment>
				<decl_stmt><decl><type><name>int</name></type>			<name>k</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>targrows</name> <operator>*</operator> <call><name>sampler_random_fract</name><argument_list>(<argument><expr><name><name>rstate</name><operator>.</operator><name>randstate</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>k</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>k</name> <operator>&lt;</operator> <name>targrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name><name>rows</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rows</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>rowstoskip</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>totalrows</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Remove error callback. */</comment>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>errcallback</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>

	<comment type="block">/* Clean up. */</comment>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>tupcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EndCopyFrom</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Emit some interesting relation info
	 */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\": file contains %.0f rows; "</literal>
					<literal type="string">"%d rows in sample"</literal></expr></argument>,
					<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><operator>*</operator><name>totalrows</name></expr></argument>, <argument><expr><name>numrows</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>numrows</name></expr>;</return>
</block_content>}</block></function>
</unit>
