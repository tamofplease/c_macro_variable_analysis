<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/contrib/pgcrypto/rijndael.c"><comment type="block">/*	$OpenBSD: rijndael.c,v 1.6 2000/12/09 18:51:34 markus Exp $ */</comment>

<comment type="block">/* contrib/pgcrypto/rijndael.c */</comment>

<comment type="block">/* This is an independent implementation of the encryption algorithm:	*/</comment>
<comment type="block">/*																		*/</comment>
<comment type="block">/*		   RIJNDAEL by Joan Daemen and Vincent Rijmen					*/</comment>
<comment type="block">/*																		*/</comment>
<comment type="block">/* which is a candidate algorithm in the Advanced Encryption Standard	*/</comment>
<comment type="block">/* programme of the US National Institute of Standards and Technology.  */</comment>
<comment type="block">/*																		*/</comment>
<comment type="block">/* Copyright in this implementation is held by Dr B R Gladman but I		*/</comment>
<comment type="block">/* hereby give permission for its free direct or derivative use subject */</comment>
<comment type="block">/* to acknowledgment of its origin and compliance with any conditions	*/</comment>
<comment type="block">/* that the originators of the algorithm place on its exploitation.     */</comment>
<comment type="block">/*																		*/</comment>
<comment type="block">/* Dr Brian Gladman (gladman@seven77.demon.co.uk) 14th January 1999		*/</comment>

<comment type="block">/* Timing data for Rijndael (rijndael.c)

Algorithm: rijndael (rijndael.c)

128 bit key:
Key Setup:	  305/1389 cycles (encrypt/decrypt)
Encrypt:	   374 cycles =    68.4 mbits/sec
Decrypt:	   352 cycles =    72.7 mbits/sec
Mean:		   363 cycles =    70.5 mbits/sec

192 bit key:
Key Setup:	  277/1595 cycles (encrypt/decrypt)
Encrypt:	   439 cycles =    58.3 mbits/sec
Decrypt:	   425 cycles =    60.2 mbits/sec
Mean:		   432 cycles =    59.3 mbits/sec

256 bit key:
Key Setup:	  374/1960 cycles (encrypt/decrypt)
Encrypt:	   502 cycles =    51.0 mbits/sec
Decrypt:	   498 cycles =    51.4 mbits/sec
Mean:		   500 cycles =    51.2 mbits/sec

*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rijndael.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRE_CALC_TABLES</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LARGE_TABLES</name></cpp:macro></cpp:define>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gen_tabs</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* 3. Basic macros for speeding up generic operations				*/</comment>

<comment type="block">/* Circular rotate of 32 bit values									*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rotr</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(((x) &gt;&gt; ((int)(n))) | ((x) &lt;&lt; (32 - (int)(n))))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rotl</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(((x) &lt;&lt; ((int)(n))) | ((x) &gt;&gt; (32 - (int)(n))))</cpp:value></cpp:define>

<comment type="block">/* Invert byte order in a 32 bit variable							*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>bswap</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((rotl((x), 8) &amp; 0x00ff00ff) | (rotr((x), 8) &amp; 0xff00ff00))</cpp:value></cpp:define>

<comment type="block">/* Extract byte from a 32 bit quantity (little endian notation)		*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>byte</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((u1byte)((x) &gt;&gt; (8 * (n))))</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WORDS_BIGENDIAN</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>io_swap</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>bswap(x)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>io_swap</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(x)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PRINT_TABS</name></cpp:ifdef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PRE_CALC_TABLES</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PRE_CALC_TABLES</name></cpp:ifdef>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rijndael.tbl"</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tab_gen</name></cpp:macro>		<cpp:value>1</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* !PRE_CALC_TABLES */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>u1byte</name></type> <name><name>pow_tab</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>u1byte</name></type> <name><name>log_tab</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>u1byte</name></type> <name><name>sbx_tab</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>u1byte</name></type> <name><name>isb_tab</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>u4byte</name></type> <name><name>rco_tab</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>u4byte</name></type> <name><name>ft_tab</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>u4byte</name></type> <name><name>it_tab</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>LARGE_TABLES</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>u4byte</name></type> <name><name>fl_tab</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>u4byte</name></type> <name><name>il_tab</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>u4byte</name></type> <name>tab_gen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* !PRE_CALC_TABLES */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ff_mult</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((a) &amp;&amp; (b) ? pow_tab[(log_tab[a] + log_tab[b]) % 255] : 0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>f_rn</name><parameter_list>(<parameter><type><name>bo</name></type></parameter>, <parameter><type><name>bi</name></type></parameter>, <parameter><type><name>n</name></type></parameter>, <parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro>								\
	<cpp:value>(bo)[n] =  ft_tab[0][byte((bi)[n],0)] ^				\
			 ft_tab[1][byte((bi)[((n) + 1) &amp; 3],1)] ^	\
			 ft_tab[2][byte((bi)[((n) + 2) &amp; 3],2)] ^	\
			 ft_tab[3][byte((bi)[((n) + 3) &amp; 3],3)] ^ *((k) + (n))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>i_rn</name><parameter_list>(<parameter><type><name>bo</name></type></parameter>, <parameter><type><name>bi</name></type></parameter>, <parameter><type><name>n</name></type></parameter>, <parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro>							\
	<cpp:value>(bo)[n] =  it_tab[0][byte((bi)[n],0)] ^				\
			 it_tab[1][byte((bi)[((n) + 3) &amp; 3],1)] ^	\
			 it_tab[2][byte((bi)[((n) + 2) &amp; 3],2)] ^	\
			 it_tab[3][byte((bi)[((n) + 1) &amp; 3],3)] ^ *((k) + (n))</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LARGE_TABLES</name></cpp:ifdef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ls_box</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>				 \
	<cpp:value>( fl_tab[0][byte(x, 0)] ^	 \
	  fl_tab[1][byte(x, 1)] ^	 \
	  fl_tab[2][byte(x, 2)] ^	 \
	  fl_tab[3][byte(x, 3)] )</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>f_rl</name><parameter_list>(<parameter><type><name>bo</name></type></parameter>, <parameter><type><name>bi</name></type></parameter>, <parameter><type><name>n</name></type></parameter>, <parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro>								\
	<cpp:value>(bo)[n] =  fl_tab[0][byte((bi)[n],0)] ^				\
			 fl_tab[1][byte((bi)[((n) + 1) &amp; 3],1)] ^	\
			 fl_tab[2][byte((bi)[((n) + 2) &amp; 3],2)] ^	\
			 fl_tab[3][byte((bi)[((n) + 3) &amp; 3],3)] ^ *((k) + (n))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>i_rl</name><parameter_list>(<parameter><type><name>bo</name></type></parameter>, <parameter><type><name>bi</name></type></parameter>, <parameter><type><name>n</name></type></parameter>, <parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro>								\
	<cpp:value>(bo)[n] =  il_tab[0][byte((bi)[n],0)] ^				\
			 il_tab[1][byte((bi)[((n) + 3) &amp; 3],1)] ^	\
			 il_tab[2][byte((bi)[((n) + 2) &amp; 3],2)] ^	\
			 il_tab[3][byte((bi)[((n) + 1) &amp; 3],3)] ^ *((k) + (n))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ls_box</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>							 \
	<cpp:value>((u4byte)sbx_tab[byte(x, 0)] &lt;&lt;  0) ^	 \
	((u4byte)sbx_tab[byte(x, 1)] &lt;&lt;  8) ^	 \
	((u4byte)sbx_tab[byte(x, 2)] &lt;&lt; 16) ^	 \
	((u4byte)sbx_tab[byte(x, 3)] &lt;&lt; 24)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>f_rl</name><parameter_list>(<parameter><type><name>bo</name></type></parameter>, <parameter><type><name>bi</name></type></parameter>, <parameter><type><name>n</name></type></parameter>, <parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro>											\
	<cpp:value>(bo)[n] = (u4byte)sbx_tab[byte((bi)[n],0)] ^					\
		rotl(((u4byte)sbx_tab[byte((bi)[((n) + 1) &amp; 3],1)]),  8) ^	\
		rotl(((u4byte)sbx_tab[byte((bi)[((n) + 2) &amp; 3],2)]), 16) ^	\
		rotl(((u4byte)sbx_tab[byte((bi)[((n) + 3) &amp; 3],3)]), 24) ^ *((k) + (n))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>i_rl</name><parameter_list>(<parameter><type><name>bo</name></type></parameter>, <parameter><type><name>bi</name></type></parameter>, <parameter><type><name>n</name></type></parameter>, <parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro>											\
	<cpp:value>(bo)[n] = (u4byte)isb_tab[byte((bi)[n],0)] ^					\
		rotl(((u4byte)isb_tab[byte((bi)[((n) + 3) &amp; 3],1)]),  8) ^	\
		rotl(((u4byte)isb_tab[byte((bi)[((n) + 2) &amp; 3],2)]), 16) ^	\
		rotl(((u4byte)isb_tab[byte((bi)[((n) + 1) &amp; 3],3)]), 24) ^ *((k) + (n))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>gen_tabs</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PRE_CALC_TABLES</name></cpp:ifndef>
	<decl_stmt><decl><type><name>u4byte</name></type>		<name>i</name></decl>,
				<decl><type ref="prev"/><name>t</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>u1byte</name></type>		<name>p</name></decl>,
				<decl><type ref="prev"/><name>q</name></decl>;</decl_stmt>

	<comment type="block">/* log and power tables for GF(2**8) finite field with	*/</comment>
	<comment type="block">/* 0x11b as modular polynomial - the simplest primitive	*/</comment>
	<comment type="block">/* root is 0x11, used here to generate the tables		*/</comment>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>p</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>pow_tab</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u1byte</name><operator>)</operator> <name>p</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>log_tab</name><index>[<expr><name>p</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u1byte</name><operator>)</operator> <name>i</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>p</name> <operator>=</operator> <name>p</name> <operator>^</operator> <operator>(</operator><name>p</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>^</operator> <operator>(</operator><ternary><condition><expr><name>p</name> <operator>&amp;</operator> <literal type="number">0x80</literal></expr> ?</condition><then> <expr><literal type="number">0x01b</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>log_tab</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>rco_tab</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>p</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>^</operator> <operator>(</operator><ternary><condition><expr><name>p</name> <operator>&amp;</operator> <literal type="number">0x80</literal></expr> ?</condition><then> <expr><literal type="number">0x1b</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* note that the affine byte transformation matrix in	*/</comment>
	<comment type="block">/* rijndael specification is in big endian format with	*/</comment>
	<comment type="block">/* bit 0 as the most significant bit. In the remainder	*/</comment>
	<comment type="block">/* of the specification the bits are numbered from the	*/</comment>
	<comment type="block">/* least significant end of a byte.                     */</comment>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>i</name></expr> ?</condition><then> <expr><name><name>pow_tab</name><index>[<expr><literal type="number">255</literal> <operator>-</operator> <name><name>log_tab</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>q</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>q</name> <operator>=</operator> <operator>(</operator><name>q</name> <operator>&gt;&gt;</operator> <literal type="number">7</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>q</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> <operator>^=</operator> <name>q</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>q</name> <operator>=</operator> <operator>(</operator><name>q</name> <operator>&gt;&gt;</operator> <literal type="number">7</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>q</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> <operator>^=</operator> <name>q</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>q</name> <operator>=</operator> <operator>(</operator><name>q</name> <operator>&gt;&gt;</operator> <literal type="number">7</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>q</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> <operator>^=</operator> <name>q</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>q</name> <operator>=</operator> <operator>(</operator><name>q</name> <operator>&gt;&gt;</operator> <literal type="number">7</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>q</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> <operator>^=</operator> <name>q</name> <operator>^</operator> <literal type="number">0x63</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sbx_tab</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u1byte</name><operator>)</operator> <name>p</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>isb_tab</name><index>[<expr><name>p</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u1byte</name><operator>)</operator> <name>i</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>sbx_tab</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>LARGE_TABLES</name></cpp:ifdef>

		<expr_stmt><expr><name>t</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fl_tab</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fl_tab</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>rotl</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fl_tab</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>rotl</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fl_tab</name><index>[<expr><literal type="number">3</literal></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>rotl</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>u4byte</name><operator>)</operator> <call><name>ff_mult</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>|</operator>
			<operator>(</operator><operator>(</operator><name>u4byte</name><operator>)</operator> <name>p</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator>
			<operator>(</operator><operator>(</operator><name>u4byte</name><operator>)</operator> <name>p</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>|</operator>
			<operator>(</operator><operator>(</operator><name>u4byte</name><operator>)</operator> <call><name>ff_mult</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>ft_tab</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ft_tab</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>rotl</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ft_tab</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>rotl</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ft_tab</name><index>[<expr><literal type="number">3</literal></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>rotl</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>isb_tab</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>LARGE_TABLES</name></cpp:ifdef>

		<expr_stmt><expr><name>t</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>il_tab</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>il_tab</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>rotl</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>il_tab</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>rotl</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>il_tab</name><index>[<expr><literal type="number">3</literal></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>rotl</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>u4byte</name><operator>)</operator> <call><name>ff_mult</name><argument_list>(<argument><expr><literal type="number">14</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>|</operator>
			<operator>(</operator><operator>(</operator><name>u4byte</name><operator>)</operator> <call><name>ff_mult</name><argument_list>(<argument><expr><literal type="number">9</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator>
			<operator>(</operator><operator>(</operator><name>u4byte</name><operator>)</operator> <call><name>ff_mult</name><argument_list>(<argument><expr><literal type="number">13</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>|</operator>
			<operator>(</operator><operator>(</operator><name>u4byte</name><operator>)</operator> <call><name>ff_mult</name><argument_list>(<argument><expr><literal type="number">11</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>it_tab</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>it_tab</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>rotl</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>it_tab</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>rotl</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>it_tab</name><index>[<expr><literal type="number">3</literal></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>rotl</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>tab_gen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* !PRE_CALC_TABLES */</comment>
</block_content>}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>star_x</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((x) &amp; 0x7f7f7f7f) &lt;&lt; 1) ^ ((((x) &amp; 0x80808080) &gt;&gt; 7) * 0x1b)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>imix_col</name><parameter_list>(<parameter><type><name>y</name></type></parameter>,<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>		\
<cpp:value>do { \
	u	= star_x(x);		\
	v	= star_x(u);		\
	w	= star_x(v);		\
	t	= w ^ (x);			\
   (y)	= u ^ v ^ w;		\
   (y) ^= rotr(u ^ t,  8) ^ \
		  rotr(v ^ t, 16) ^ \
		  rotr(t,24);		\
} while (0)</cpp:value></cpp:define>

<comment type="block">/* initialise the key schedule from the user supplied key	*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>loop4</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>									\
<cpp:value>do {   t = ls_box(rotr(t,  8)) ^ rco_tab[i];		   \
	t ^= e_key[4 * i];	   e_key[4 * i + 4] = t;	\
	t ^= e_key[4 * i + 1]; e_key[4 * i + 5] = t;	\
	t ^= e_key[4 * i + 2]; e_key[4 * i + 6] = t;	\
	t ^= e_key[4 * i + 3]; e_key[4 * i + 7] = t;	\
} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>loop6</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>									\
<cpp:value>do {   t = ls_box(rotr(t,  8)) ^ rco_tab[i];		   \
	t ^= e_key[6 * (i)];	   e_key[6 * (i) + 6] = t;	\
	t ^= e_key[6 * (i) + 1]; e_key[6 * (i) + 7] = t;	\
	t ^= e_key[6 * (i) + 2]; e_key[6 * (i) + 8] = t;	\
	t ^= e_key[6 * (i) + 3]; e_key[6 * (i) + 9] = t;	\
	t ^= e_key[6 * (i) + 4]; e_key[6 * (i) + 10] = t;	\
	t ^= e_key[6 * (i) + 5]; e_key[6 * (i) + 11] = t;	\
} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>loop8</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>									\
<cpp:value>do {   t = ls_box(rotr(t,  8)) ^ rco_tab[i];		   \
	t ^= e_key[8 * (i)];	 e_key[8 * (i) + 8] = t;	\
	t ^= e_key[8 * (i) + 1]; e_key[8 * (i) + 9] = t;	\
	t ^= e_key[8 * (i) + 2]; e_key[8 * (i) + 10] = t;	\
	t ^= e_key[8 * (i) + 3]; e_key[8 * (i) + 11] = t;	\
	t  = e_key[8 * (i) + 4] ^ ls_box(t);				\
	e_key[8 * (i) + 12] = t;							\
	t ^= e_key[8 * (i) + 5]; e_key[8 * (i) + 13] = t;	\
	t ^= e_key[8 * (i) + 6]; e_key[8 * (i) + 14] = t;	\
	t ^= e_key[8 * (i) + 7]; e_key[8 * (i) + 15] = t;	\
} while (0)</cpp:value></cpp:define>

<function><type><name>rijndael_ctx</name> <modifier>*</modifier></type>
<name>rijndael_set_key</name><parameter_list>(<parameter><decl><type><name>rijndael_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>u4byte</name> <modifier>*</modifier></type><name>in_key</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>u4byte</name></type> <name>key_len</name></decl></parameter>,
				 <parameter><decl><type><name>int</name></type> <name>encrypt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>u4byte</name></type>		<name>i</name></decl>,
				<decl><type ref="prev"/><name>t</name></decl>,
				<decl><type ref="prev"/><name>u</name></decl>,
				<decl><type ref="prev"/><name>v</name></decl>,
				<decl><type ref="prev"/><name>w</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>u4byte</name>	   <modifier>*</modifier></type><name>e_key</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>e_key</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>u4byte</name>	   <modifier>*</modifier></type><name>d_key</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>d_key</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>decrypt</name></name> <operator>=</operator> <operator>!</operator><name>encrypt</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tab_gen</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>gen_tabs</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>k_len</name></name> <operator>=</operator> <operator>(</operator><name>key_len</name> <operator>+</operator> <literal type="number">31</literal><operator>)</operator> <operator>/</operator> <literal type="number">32</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>e_key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>io_swap</name><argument_list>(<argument><expr><name><name>in_key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e_key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>io_swap</name><argument_list>(<argument><expr><name><name>in_key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e_key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>io_swap</name><argument_list>(<argument><expr><name><name>in_key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e_key</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>io_swap</name><argument_list>(<argument><expr><name><name>in_key</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>k_len</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="number">4</literal></expr>:</case>
			<expr_stmt><expr><name>t</name> <operator>=</operator> <name><name>e_key</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>loop4</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
			<break>break;</break>

		<case>case <expr><literal type="number">6</literal></expr>:</case>
			<expr_stmt><expr><name><name>e_key</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>io_swap</name><argument_list>(<argument><expr><name><name>in_key</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>t</name> <operator>=</operator> <name><name>e_key</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <call><name>io_swap</name><argument_list>(<argument><expr><name><name>in_key</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>loop6</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
			<break>break;</break>

		<case>case <expr><literal type="number">8</literal></expr>:</case>
			<expr_stmt><expr><name><name>e_key</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>io_swap</name><argument_list>(<argument><expr><name><name>in_key</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>e_key</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <call><name>io_swap</name><argument_list>(<argument><expr><name><name>in_key</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>e_key</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <call><name>io_swap</name><argument_list>(<argument><expr><name><name>in_key</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>t</name> <operator>=</operator> <name><name>e_key</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <call><name>io_swap</name><argument_list>(<argument><expr><name><name>in_key</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">7</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>loop8</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
			<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>encrypt</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>d_key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>e_key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>d_key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>e_key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>d_key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>e_key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>d_key</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>e_key</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">4</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal> <operator>*</operator> <name><name>ctx</name><operator>-&gt;</operator><name>k_len</name></name> <operator>+</operator> <literal type="number">24</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>imix_col</name><argument_list>(<argument><expr><name><name>d_key</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>e_key</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>ctx</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* encrypt a block of text	*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>f_nround</name><parameter_list>(<parameter><type><name>bo</name></type></parameter>, <parameter><type><name>bi</name></type></parameter>, <parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do { \
	f_rn(bo, bi, 0, k);		\
	f_rn(bo, bi, 1, k);		\
	f_rn(bo, bi, 2, k);		\
	f_rn(bo, bi, 3, k);		\
	k += 4;					\
} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>f_lround</name><parameter_list>(<parameter><type><name>bo</name></type></parameter>, <parameter><type><name>bi</name></type></parameter>, <parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do { \
	f_rl(bo, bi, 0, k);		\
	f_rl(bo, bi, 1, k);		\
	f_rl(bo, bi, 2, k);		\
	f_rl(bo, bi, 3, k);		\
} while (0)</cpp:value></cpp:define>

<function><type><name>void</name></type>
<name>rijndael_encrypt</name><parameter_list>(<parameter><decl><type><name>rijndael_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>u4byte</name> <modifier>*</modifier></type><name>in_blk</name></decl></parameter>, <parameter><decl><type><name>u4byte</name> <modifier>*</modifier></type><name>out_blk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>u4byte</name></type>		<name>k_len</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>k_len</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>u4byte</name>	   <modifier>*</modifier></type><name>e_key</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>e_key</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>u4byte</name></type>		<name><name>b0</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>,
				<decl><type ref="prev"/><name><name>b1</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>kp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>b0</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>io_swap</name><argument_list>(<argument><expr><name><name>in_blk</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>^</operator> <name><name>e_key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>b0</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>io_swap</name><argument_list>(<argument><expr><name><name>in_blk</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>^</operator> <name><name>e_key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>b0</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>io_swap</name><argument_list>(<argument><expr><name><name>in_blk</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>^</operator> <name><name>e_key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>b0</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>io_swap</name><argument_list>(<argument><expr><name><name>in_blk</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>^</operator> <name><name>e_key</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>kp</name> <operator>=</operator> <name>e_key</name> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>k_len</name> <operator>&gt;</operator> <literal type="number">6</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>f_nround</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>, <argument><expr><name>kp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>f_nround</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>, <argument><expr><name>kp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>k_len</name> <operator>&gt;</operator> <literal type="number">4</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>f_nround</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>, <argument><expr><name>kp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>f_nround</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>, <argument><expr><name>kp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>f_nround</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>, <argument><expr><name>kp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f_nround</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>, <argument><expr><name>kp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f_nround</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>, <argument><expr><name>kp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f_nround</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>, <argument><expr><name>kp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f_nround</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>, <argument><expr><name>kp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f_nround</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>, <argument><expr><name>kp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f_nround</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>, <argument><expr><name>kp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f_nround</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>, <argument><expr><name>kp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f_nround</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>, <argument><expr><name>kp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f_lround</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>, <argument><expr><name>kp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>out_blk</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>io_swap</name><argument_list>(<argument><expr><name><name>b0</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>out_blk</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>io_swap</name><argument_list>(<argument><expr><name><name>b0</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>out_blk</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>io_swap</name><argument_list>(<argument><expr><name><name>b0</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>out_blk</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>io_swap</name><argument_list>(<argument><expr><name><name>b0</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* decrypt a block of text	*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>i_nround</name><parameter_list>(<parameter><type><name>bo</name></type></parameter>, <parameter><type><name>bi</name></type></parameter>, <parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do { \
	i_rn(bo, bi, 0, k);		\
	i_rn(bo, bi, 1, k);		\
	i_rn(bo, bi, 2, k);		\
	i_rn(bo, bi, 3, k);		\
	k -= 4;					\
} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>i_lround</name><parameter_list>(<parameter><type><name>bo</name></type></parameter>, <parameter><type><name>bi</name></type></parameter>, <parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do { \
	i_rl(bo, bi, 0, k);		\
	i_rl(bo, bi, 1, k);		\
	i_rl(bo, bi, 2, k);		\
	i_rl(bo, bi, 3, k);		\
} while (0)</cpp:value></cpp:define>

<function><type><name>void</name></type>
<name>rijndael_decrypt</name><parameter_list>(<parameter><decl><type><name>rijndael_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>u4byte</name> <modifier>*</modifier></type><name>in_blk</name></decl></parameter>, <parameter><decl><type><name>u4byte</name> <modifier>*</modifier></type><name>out_blk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>u4byte</name></type>		<name><name>b0</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>,
				<decl><type ref="prev"/><name><name>b1</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>kp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>u4byte</name></type>		<name>k_len</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>k_len</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>u4byte</name>	   <modifier>*</modifier></type><name>e_key</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>e_key</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>u4byte</name>	   <modifier>*</modifier></type><name>d_key</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>d_key</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>b0</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>io_swap</name><argument_list>(<argument><expr><name><name>in_blk</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>^</operator> <name><name>e_key</name><index>[<expr><literal type="number">4</literal> <operator>*</operator> <name>k_len</name> <operator>+</operator> <literal type="number">24</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>b0</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>io_swap</name><argument_list>(<argument><expr><name><name>in_blk</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>^</operator> <name><name>e_key</name><index>[<expr><literal type="number">4</literal> <operator>*</operator> <name>k_len</name> <operator>+</operator> <literal type="number">25</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>b0</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>io_swap</name><argument_list>(<argument><expr><name><name>in_blk</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>^</operator> <name><name>e_key</name><index>[<expr><literal type="number">4</literal> <operator>*</operator> <name>k_len</name> <operator>+</operator> <literal type="number">26</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>b0</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>io_swap</name><argument_list>(<argument><expr><name><name>in_blk</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>^</operator> <name><name>e_key</name><index>[<expr><literal type="number">4</literal> <operator>*</operator> <name>k_len</name> <operator>+</operator> <literal type="number">27</literal></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>kp</name> <operator>=</operator> <name>d_key</name> <operator>+</operator> <literal type="number">4</literal> <operator>*</operator> <operator>(</operator><name>k_len</name> <operator>+</operator> <literal type="number">5</literal><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>k_len</name> <operator>&gt;</operator> <literal type="number">6</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>i_nround</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>, <argument><expr><name>kp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>i_nround</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>, <argument><expr><name>kp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>k_len</name> <operator>&gt;</operator> <literal type="number">4</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>i_nround</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>, <argument><expr><name>kp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>i_nround</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>, <argument><expr><name>kp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>i_nround</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>, <argument><expr><name>kp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>i_nround</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>, <argument><expr><name>kp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>i_nround</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>, <argument><expr><name>kp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>i_nround</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>, <argument><expr><name>kp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>i_nround</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>, <argument><expr><name>kp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>i_nround</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>, <argument><expr><name>kp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>i_nround</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>, <argument><expr><name>kp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>i_nround</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>, <argument><expr><name>kp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>i_nround</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>, <argument><expr><name>kp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>i_lround</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>, <argument><expr><name>kp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>out_blk</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>io_swap</name><argument_list>(<argument><expr><name><name>b0</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>out_blk</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>io_swap</name><argument_list>(<argument><expr><name><name>b0</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>out_blk</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>io_swap</name><argument_list>(<argument><expr><name><name>b0</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>out_blk</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>io_swap</name><argument_list>(<argument><expr><name><name>b0</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * conventional interface
 *
 * ATM it hopes all data is 4-byte aligned - which
 * should be true for PX.  -marko
 */</comment>

<function><type><name>void</name></type>
<name>aes_set_key</name><parameter_list>(<parameter><decl><type><name>rijndael_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>keybits</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name>	   <modifier>*</modifier></type><name>k</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>k</name> <operator>=</operator> <operator>(</operator><name>uint32</name> <operator>*</operator><operator>)</operator> <name>key</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>rijndael_set_key</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>keybits</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>aes_ecb_encrypt</name><parameter_list>(<parameter><decl><type><name>rijndael_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name></type>	<name>bs</name> <init>= <expr><literal type="number">16</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name>	   <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>len</name> <operator>&gt;=</operator> <name>bs</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>d</name> <operator>=</operator> <operator>(</operator><name>uint32</name> <operator>*</operator><operator>)</operator> <name>data</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>rijndael_encrypt</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>len</name> <operator>-=</operator> <name>bs</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>data</name> <operator>+=</operator> <name>bs</name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>aes_ecb_decrypt</name><parameter_list>(<parameter><decl><type><name>rijndael_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name></type>	<name>bs</name> <init>= <expr><literal type="number">16</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name>	   <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>len</name> <operator>&gt;=</operator> <name>bs</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>d</name> <operator>=</operator> <operator>(</operator><name>uint32</name> <operator>*</operator><operator>)</operator> <name>data</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>rijndael_decrypt</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>len</name> <operator>-=</operator> <name>bs</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>data</name> <operator>+=</operator> <name>bs</name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>aes_cbc_encrypt</name><parameter_list>(<parameter><decl><type><name>rijndael_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>iva</name></decl></parameter>, <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name>	   <modifier>*</modifier></type><name>iv</name> <init>= <expr><operator>(</operator><name>uint32</name> <operator>*</operator><operator>)</operator> <name>iva</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name>	   <modifier>*</modifier></type><name>d</name> <init>= <expr><operator>(</operator><name>uint32</name> <operator>*</operator><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type>	<name>bs</name> <init>= <expr><literal type="number">16</literal></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>len</name> <operator>&gt;=</operator> <name>bs</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>^=</operator> <name><name>iv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>^=</operator> <name><name>iv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>^=</operator> <name><name>iv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>^=</operator> <name><name>iv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>rijndael_encrypt</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>iv</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>d</name> <operator>+=</operator> <name>bs</name> <operator>/</operator> <literal type="number">4</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> <operator>-=</operator> <name>bs</name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>aes_cbc_decrypt</name><parameter_list>(<parameter><decl><type><name>rijndael_ctx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>iva</name></decl></parameter>, <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name>	   <modifier>*</modifier></type><name>d</name> <init>= <expr><operator>(</operator><name>uint32</name> <operator>*</operator><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type>	<name>bs</name> <init>= <expr><literal type="number">16</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name><name>buf</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>,
				<decl><type ref="prev"/><name><name>iv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>iv</name></expr></argument>, <argument><expr><name>iva</name></expr></argument>, <argument><expr><name>bs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>len</name> <operator>&gt;=</operator> <name>bs</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>d</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>d</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>d</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>d</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>rijndael_decrypt</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>^=</operator> <name><name>iv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>^=</operator> <name><name>iv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>^=</operator> <name><name>iv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>^=</operator> <name><name>iv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>iv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>buf</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>d</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> <operator>-=</operator> <name>bs</name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * pre-calculate tables.
 *
 * On i386 lifts 17k from .bss to .rodata
 * and avoids 1k code and setup time.
 *	  -marko
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PRINT_TABS</name></cpp:ifdef>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>show256u8</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"static const u1byte  %s[256] = {\n  "</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name><name>pow_tab</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><ternary><condition><expr><name>i</name> <operator>%</operator> <literal type="number">16</literal></expr> ?</condition><then> <expr><literal type="string">", "</literal></expr> </then><else>: <expr><literal type="string">",\n  "</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n};\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>show4x256u32</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name><name>data</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"static const u4byte  %s[4][256] = {\n{\n  "</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>;</condition><incr/>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"0x%08x"</literal></expr></argument>, <argument><expr><name><name>data</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><ternary><condition><expr><name>j</name> <operator>%</operator> <literal type="number">4</literal></expr> ?</condition><then> <expr><literal type="string">", "</literal></expr> </then><else>: <expr><literal type="string">",\n  "</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><ternary><condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">3</literal></expr> ?</condition><then> <expr><literal type="string">"\n}, {\n  "</literal></expr> </then><else>: <expr><literal type="string">"\n}\n"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"};\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>main</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>hdr</name> <init>= <expr><literal type="string">"/* Generated by rijndael.c */\n\n"</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>gen_tabs</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>show256u8</name><argument_list>(<argument><expr><literal type="string">"pow_tab"</literal></expr></argument>, <argument><expr><name>pow_tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>show256u8</name><argument_list>(<argument><expr><literal type="string">"log_tab"</literal></expr></argument>, <argument><expr><name>log_tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>show256u8</name><argument_list>(<argument><expr><literal type="string">"sbx_tab"</literal></expr></argument>, <argument><expr><name>sbx_tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>show256u8</name><argument_list>(<argument><expr><literal type="string">"isb_tab"</literal></expr></argument>, <argument><expr><name>isb_tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>show4x256u32</name><argument_list>(<argument><expr><literal type="string">"ft_tab"</literal></expr></argument>, <argument><expr><name>ft_tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>show4x256u32</name><argument_list>(<argument><expr><literal type="string">"it_tab"</literal></expr></argument>, <argument><expr><name>it_tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LARGE_TABLES</name></cpp:ifdef>
	<expr_stmt><expr><call><name>show4x256u32</name><argument_list>(<argument><expr><literal type="string">"fl_tab"</literal></expr></argument>, <argument><expr><name>fl_tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>show4x256u32</name><argument_list>(<argument><expr><literal type="string">"il_tab"</literal></expr></argument>, <argument><expr><name>il_tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"static const u4byte rco_tab[10] = {\n  "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"0x%08x"</literal></expr></argument>, <argument><expr><name><name>rco_tab</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">9</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n  "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n};\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
