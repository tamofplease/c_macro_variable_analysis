<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/contrib/pgcrypto/imath.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * imath.c
 *
 * Last synchronized from https://github.com/creachadair/imath/tree/v1.29,
 * using the following procedure:
 *
 * 1. Download imath.c and imath.h of the last synchronized version.  Remove
 *    "#ifdef __cplusplus" blocks, which upset pgindent.  Run pgindent on the
 *    two files.  Filter the two files through "unexpand -t4 --first-only".
 *    Diff the result against the PostgreSQL versions.  As of the last
 *    synchronization, changes were as follows:
 *
 *    - replace malloc(), realloc() and free() with px_ versions
 *    - redirect assert() to Assert()
 *    - #undef MIN, #undef MAX before defining them
 *    - remove includes covered by c.h
 *    - rename DEBUG to IMATH_DEBUG
 *    - replace stdint.h usage with c.h equivalents
 *    - suppress MSVC warning 4146
 *    - add required PG_USED_FOR_ASSERTS_ONLY
 *
 * 2. Download a newer imath.c and imath.h.  Transform them like in step 1.
 *    Apply to these files the diff you saved in step 1.  Look for new lines
 *    requiring the same kind of change, such as new malloc() calls.
 *
 * 3. Configure PostgreSQL using --without-openssl.  Run "make -C
 *    contrib/pgcrypto check".
 *
 * 4. Update this header comment.
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *	  contrib/pgcrypto/imath.c
 *
 * Upstream copyright terms follow.
 *-------------------------------------------------------------------------
 */</comment>

<comment type="block">/*
  Name:		imath.c
  Purpose:	Arbitrary precision integer arithmetic routines.
  Author:   M. J. Fromberger

  Copyright (C) 2002-2007 Michael J. Fromberger, All Rights Reserved.

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"imath.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px.h"</cpp:file></cpp:include>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>assert</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>assert</name><parameter_list>(<parameter><type><name>TEST</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>Assert(TEST)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>const</specifier> <name>mp_result</name></type> <name>MP_OK</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* no error, all is well  */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>mp_result</name></type> <name>MP_FALSE</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* boolean false          */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>mp_result</name></type> <name>MP_TRUE</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* boolean true           */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>mp_result</name></type> <name>MP_MEMORY</name> <init>= <expr><operator>-</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* out of memory          */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>mp_result</name></type> <name>MP_RANGE</name> <init>= <expr><operator>-</operator><literal type="number">3</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* argument out of range  */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>mp_result</name></type> <name>MP_UNDEF</name> <init>= <expr><operator>-</operator><literal type="number">4</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* result undefined       */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>mp_result</name></type> <name>MP_TRUNC</name> <init>= <expr><operator>-</operator><literal type="number">5</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* output truncated       */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>mp_result</name></type> <name>MP_BADARG</name> <init>= <expr><operator>-</operator><literal type="number">6</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* invalid null argument  */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>mp_result</name></type> <name>MP_MINERR</name> <init>= <expr><operator>-</operator><literal type="number">6</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>mp_sign</name></type> <name>MP_NEG</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* value is strictly negative */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>mp_sign</name></type> <name>MP_ZPOS</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* value is non-negative      */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s_unknown_err</name> <init>= <expr><literal type="string">"unknown result code"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>s_error_msg</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"error code 0"</literal></expr>, <expr><literal type="string">"boolean true"</literal></expr>,
	<expr><literal type="string">"out of memory"</literal></expr>, <expr><literal type="string">"argument out of range"</literal></expr>,
	<expr><literal type="string">"result undefined"</literal></expr>, <expr><literal type="string">"output truncated"</literal></expr>,
<expr><literal type="string">"invalid argument"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* The ith entry of this table gives the value of log_i(2).

   An integer value n requires ceil(log_i(n)) digits to be represented
   in base i.  Since it is easy to compute lg(n), by counting bits, we
   can compute log_i(n) = lg(n) * log_i(2).

   The use of this table eliminates a dependency upon linkage against
   the standard math libraries.

   If MP_MAX_RADIX is increased, this table should be expanded too.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>double</name></type> <name><name>s_log2</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="number">0.000000000</literal></expr>, <expr><literal type="number">0.000000000</literal></expr>, <expr><literal type="number">1.000000000</literal></expr>, <expr><literal type="number">0.630929754</literal></expr>, <comment type="block">/* (D)(D) 2  3 */</comment>
	<expr><literal type="number">0.500000000</literal></expr>, <expr><literal type="number">0.430676558</literal></expr>, <expr><literal type="number">0.386852807</literal></expr>, <expr><literal type="number">0.356207187</literal></expr>, <comment type="block">/* 4  5  6  7 */</comment>
	<expr><literal type="number">0.333333333</literal></expr>, <expr><literal type="number">0.315464877</literal></expr>, <expr><literal type="number">0.301029996</literal></expr>, <expr><literal type="number">0.289064826</literal></expr>, <comment type="block">/* 8  9 10 11 */</comment>
	<expr><literal type="number">0.278942946</literal></expr>, <expr><literal type="number">0.270238154</literal></expr>, <expr><literal type="number">0.262649535</literal></expr>, <expr><literal type="number">0.255958025</literal></expr>, <comment type="block">/* 12 13 14 15 */</comment>
	<expr><literal type="number">0.250000000</literal></expr>, <expr><literal type="number">0.244650542</literal></expr>, <expr><literal type="number">0.239812467</literal></expr>, <expr><literal type="number">0.235408913</literal></expr>, <comment type="block">/* 16 17 18 19 */</comment>
	<expr><literal type="number">0.231378213</literal></expr>, <expr><literal type="number">0.227670249</literal></expr>, <expr><literal type="number">0.224243824</literal></expr>, <expr><literal type="number">0.221064729</literal></expr>, <comment type="block">/* 20 21 22 23 */</comment>
	<expr><literal type="number">0.218104292</literal></expr>, <expr><literal type="number">0.215338279</literal></expr>, <expr><literal type="number">0.212746054</literal></expr>, <expr><literal type="number">0.210309918</literal></expr>, <comment type="block">/* 24 25 26 27 */</comment>
	<expr><literal type="number">0.208014598</literal></expr>, <expr><literal type="number">0.205846832</literal></expr>, <expr><literal type="number">0.203795047</literal></expr>, <expr><literal type="number">0.201849087</literal></expr>, <comment type="block">/* 28 29 30 31 */</comment>
	<expr><literal type="number">0.200000000</literal></expr>, <expr><literal type="number">0.198239863</literal></expr>, <expr><literal type="number">0.196561632</literal></expr>, <expr><literal type="number">0.194959022</literal></expr>, <comment type="block">/* 32 33 34 35 */</comment>
	<expr><literal type="number">0.193426404</literal></expr>,				<comment type="block">/* 36          */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Return the number of digits needed to represent a static value */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MP_VALUE_DIGITS</name><parameter_list>(<parameter><type><name>V</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>((sizeof(V) + (sizeof(mp_digit) - 1)) / sizeof(mp_digit))</cpp:value></cpp:define>

<comment type="block">/* Round precision P to nearest word boundary */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>mp_size</name></type>
<name>s_round_prec</name><parameter_list>(<parameter><decl><type><name>mp_size</name></type> <name>P</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><literal type="number">2</literal> <operator>*</operator> <operator>(</operator><operator>(</operator><name>P</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Set array P of S digits to zero */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>ZERO</name><parameter_list>(<parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>P</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>S</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>i__</name> <init>= <expr><name>S</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>mp_digit</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>p__</name> <init>= <expr><name>P</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p__</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Copy S digits from array P to array Q */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>COPY</name><parameter_list>(<parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>P</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>Q</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>S</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>i__</name> <init>= <expr><name>S</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>mp_digit</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>p__</name> <init>= <expr><name>P</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>q__</name> <init>= <expr><name>Q</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>q__</name></expr></argument>, <argument><expr><name>p__</name></expr></argument>, <argument><expr><name>i__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Reverse N elements of unsigned char in A. */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>REV</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>A</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>u_</name> <init>= <expr><name>A</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>v_</name> <init>= <expr><name>u_</name> <operator>+</operator> <name>N</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>u_</name> <operator>&lt;</operator> <name>v_</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>xch</name> <init>= <expr><operator>*</operator><name>u_</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><operator>*</operator><name>u_</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>v_</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>v_</name><operator>--</operator> <operator>=</operator> <name>xch</name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* Strip leading zeroes from z_ in-place. */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>CLAMP</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>uz_</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>z_</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>dz_</name> <init>= <expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z_</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>uz_</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>uz_</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>dz_</name><operator>--</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>--</operator><name>uz_</name></expr>;</expr_stmt></block_content></block></while>
	<expr_stmt><expr><name><name>z_</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <name>uz_</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Select min/max. */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MIN</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MAX</name></cpp:undef>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>
<name>MIN</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>A</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>B</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><ternary><condition><expr><name>B</name> <operator>&lt;</operator> <name>A</name></expr> ?</condition><then> <expr><name>B</name></expr> </then><else>: <expr><name>A</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>mp_size</name></type>
<name>MAX</name><parameter_list>(<parameter><decl><type><name>mp_size</name></type> <name>A</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>B</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><ternary><condition><expr><name>B</name> <operator>&gt;</operator> <name>A</name></expr> ?</condition><then> <expr><name>B</name></expr> </then><else>: <expr><name>A</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Exchange lvalues A and B of type T, e.g.
   SWAP(int, x, y) where x and y are variables of type int. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SWAP</name><parameter_list>(<parameter><type><name>T</name></type></parameter>, <parameter><type><name>A</name></type></parameter>, <parameter><type><name>B</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>do {                \
	T t_ = (A);       \
	A = (B);          \
	B = t_;           \
  } while (0)</cpp:value></cpp:define>

<comment type="block">/* Declare a block of N temporary mpz_t values.
   These values are initialized to zero.
   You must add CLEANUP_TEMP() at the end of the function.
   Use TEMP(i) to access a pointer to the ith value.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DECLARE_TEMP</name><parameter_list>(<parameter><type><name>N</name></type></parameter>)</parameter_list></cpp:macro>                   \
  <cpp:value>struct {                                \
	mpz_t value[(N)];                     \
	int len;                              \
	mp_result err;                        \
  } temp_ = {                             \
	  .len = (N),                         \
	  .err = MP_OK,                       \
  };                                      \
  do {                                    \
	for (int i = 0; i &lt; temp_.len; i++) { \
	  mp_int_init(TEMP(i));               \
	}                                     \
  } while (0)</cpp:value></cpp:define>

<comment type="block">/* Clear all allocated temp values. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLEANUP_TEMP</name><parameter_list>()</parameter_list></cpp:macro>                    \
  <cpp:value>CLEANUP:                                \
  do {                                    \
	for (int i = 0; i &lt; temp_.len; i++) { \
	  mp_int_clear(TEMP(i));              \
	}                                     \
	if (temp_.err != MP_OK) {             \
	  return temp_.err;                   \
	}                                     \
  } while (0)</cpp:value></cpp:define>

<comment type="block">/* A pointer to the kth temp value. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEMP</name><parameter_list>(<parameter><type><name>K</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(temp_.value + (K))</cpp:value></cpp:define>

<comment type="block">/* Evaluate E, an expression of type mp_result expected to return MP_OK.  If
   the value is not MP_OK, the error is cached and control resumes at the
   cleanup handler, which returns it.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REQUIRE</name><parameter_list>(<parameter><type><name>E</name></type></parameter>)</parameter_list></cpp:macro>                        \
  <cpp:value>do {                                    \
	temp_.err = (E);                      \
	if (temp_.err != MP_OK) goto CLEANUP; \
  } while (0)</cpp:value></cpp:define>

<comment type="block">/* Compare value to zero. */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>
<name>CMPZ</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>Z</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>Z</name><operator>-&gt;</operator><name>used</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>Z</name><operator>-&gt;</operator><name>digits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><ternary><condition><expr><operator>(</operator><name><name>Z</name><operator>-&gt;</operator><name>sign</name></name> <operator>==</operator> <name>MP_NEG</name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>mp_word</name></type>
<name>UPPER_HALF</name><parameter_list>(<parameter><decl><type><name>mp_word</name></type> <name>W</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>W</name> <operator>&gt;&gt;</operator> <name>MP_DIGIT_BIT</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>mp_digit</name></type>
<name>LOWER_HALF</name><parameter_list>(<parameter><decl><type><name>mp_word</name></type> <name>W</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>mp_digit</name><operator>)</operator> <operator>(</operator><name>W</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Report whether the highest-order bit of W is 1. */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>HIGH_BIT_SET</name><parameter_list>(<parameter><decl><type><name>mp_word</name></type> <name>W</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>W</name> <operator>&gt;&gt;</operator> <operator>(</operator><name>MP_WORD_BIT</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Report whether adding W + V will carry out. */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>ADD_WILL_OVERFLOW</name><parameter_list>(<parameter><decl><type><name>mp_word</name></type> <name>W</name></decl></parameter>, <parameter><decl><type><name>mp_word</name></type> <name>V</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><operator>(</operator><name>MP_WORD_MAX</name> <operator>-</operator> <name>V</name><operator>)</operator> <operator>&lt;</operator> <name>W</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Default number of digits allocated to a new mp_int */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>mp_size</name></type> <name>default_precision</name> <init>= <expr><literal type="number">8</literal></expr></init></decl>;</decl_stmt>

<function><type><name>void</name></type>
<name>mp_int_default_precision</name><parameter_list>(<parameter><decl><type><name>mp_size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>default_precision</name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Minimum number of digits to invoke recursive multiply */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>mp_size</name></type> <name>multiply_threshold</name> <init>= <expr><literal type="number">32</literal></expr></init></decl>;</decl_stmt>

<function><type><name>void</name></type>
<name>mp_int_multiply_threshold</name><parameter_list>(<parameter><decl><type><name>mp_size</name></type> <name>thresh</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>thresh</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>mp_word</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>multiply_threshold</name> <operator>=</operator> <name>thresh</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Allocate a buffer of (at least) num digits, or return
   NULL if that couldn't be done.  */</comment>
<function_decl><type><specifier>static</specifier> <name>mp_digit</name> <modifier>*</modifier></type><name>s_alloc</name><parameter_list>(<parameter><decl><type><name>mp_size</name></type> <name>num</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Release a buffer of digits allocated by s_alloc(). */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>s_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Insure that z has at least min digits allocated, resizing if
   necessary.  Returns true if successful, false if out of memory. */</comment>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>s_pad</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>min</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Ensure Z has at least N digits allocated. */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>mp_result</name></type>
<name>GROW</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>Z</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>N</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><ternary><condition><expr><call><name>s_pad</name><argument_list>(<argument><expr><name>Z</name></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>MP_OK</name></expr> </then><else>: <expr><name>MP_MEMORY</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Fill in a "fake" mp_int on the stack with a given value */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>s_fake</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_small</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name></type> <name><name>vbuf</name><index>[]</index></name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>s_ufake</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_usmall</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name></type> <name><name>vbuf</name><index>[]</index></name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Compare two runs of digits of given length, returns &lt;0, 0, &gt;0 */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>s_cdig</name><parameter_list>(<parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>da</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Pack the unsigned digits of v into array t */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>s_uvpack</name><parameter_list>(<parameter><decl><type><name>mp_usmall</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name></type> <name><name>t</name><index>[]</index></name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Compare magnitudes of a and b, returns &lt;0, 0, &gt;0 */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>s_ucmp</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>b</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Compare magnitudes of a and v, returns &lt;0, 0, &gt;0 */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>s_vcmp</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_small</name></type> <name>v</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>s_uvcmp</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_usmall</name></type> <name>uv</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Unsigned magnitude addition; assumes dc is big enough.
   Carry out is returned (no memory allocated). */</comment>
<function_decl><type><specifier>static</specifier> <name>mp_digit</name></type> <name>s_uadd</name><parameter_list>(<parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>da</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>dc</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>size_a</name></decl></parameter>,
					   <parameter><decl><type><name>mp_size</name></type> <name>size_b</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Unsigned magnitude subtraction.  Assumes dc is big enough. */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>s_usub</name><parameter_list>(<parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>da</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>dc</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>size_a</name></decl></parameter>,
				   <parameter><decl><type><name>mp_size</name></type> <name>size_b</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Unsigned recursive multiplication.  Assumes dc is big enough. */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>s_kmul</name><parameter_list>(<parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>da</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>dc</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>size_a</name></decl></parameter>,
				   <parameter><decl><type><name>mp_size</name></type> <name>size_b</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Unsigned magnitude multiplication.  Assumes dc is big enough. */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>s_umul</name><parameter_list>(<parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>da</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>dc</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>size_a</name></decl></parameter>,
				   <parameter><decl><type><name>mp_size</name></type> <name>size_b</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Unsigned recursive squaring.  Assumes dc is big enough. */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>s_ksqr</name><parameter_list>(<parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>da</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>dc</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>size_a</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Unsigned magnitude squaring.  Assumes dc is big enough. */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>s_usqr</name><parameter_list>(<parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>da</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>dc</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>size_a</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Single digit addition.  Assumes a is big enough. */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>s_dadd</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name></type> <name>b</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Single digit multiplication.  Assumes a is big enough. */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>s_dmul</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name></type> <name>b</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Single digit multiplication on buffers; assumes dc is big enough. */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>s_dbmul</name><parameter_list>(<parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>da</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>dc</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>size_a</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Single digit division.  Replaces a with the quotient,
   returns the remainder.  */</comment>
<function_decl><type><specifier>static</specifier> <name>mp_digit</name></type> <name>s_ddiv</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name></type> <name>b</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Quick division by a power of 2, replaces z (no allocation) */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>s_qdiv</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>p2</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Quick remainder by a power of 2, replaces z (no allocation) */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>s_qmod</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>p2</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Quick multiplication by a power of 2, replaces z.
   Allocates if necessary; returns false in case this fails. */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>s_qmul</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>p2</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Quick subtraction from a power of 2, replaces z.
   Allocates if necessary; returns false in case this fails. */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>s_qsub</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>p2</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Return maximum k such that 2^k divides z. */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>s_dp2k</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Return k &gt;= 0 such that z = 2^k, or -1 if there is no such k. */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>s_isp2</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Set z to 2^k.  May allocate; returns false in case this fails. */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>s_2expt</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_small</name></type> <name>k</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Normalize a and b for division, returns normalization constant */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>s_norm</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>b</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Compute constant mu for Barrett reduction, given modulus m, result
   replaces z, m is untouched. */</comment>
<function_decl><type><specifier>static</specifier> <name>mp_result</name></type> <name>s_brmu</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>m</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Reduce a modulo m, using Barrett's algorithm. */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>s_reduce</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>mu</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>q1</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>q2</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Modular exponentiation, using Barrett reduction */</comment>
<function_decl><type><specifier>static</specifier> <name>mp_result</name></type> <name>s_embar</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>mu</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Unsigned magnitude division.  Assumes |a| &gt; |b|.  Allocates temporaries;
   overwrites a with quotient, b with remainder. */</comment>
<function_decl><type><specifier>static</specifier> <name>mp_result</name></type> <name>s_udiv_knuth</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>b</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Compute the number of digits in radix r required to represent the given
   value.  Does not account for sign flags, terminators, etc. */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>s_outlen</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>r</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Guess how many digits of precision will be needed to represent a radix r
   value of the specified number of digits.  Returns a value guaranteed to be
   no smaller than the actual number required. */</comment>
<function_decl><type><specifier>static</specifier> <name>mp_size</name></type> <name>s_inlen</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>r</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Convert a character to a digit value in radix r, or
   -1 if out of range */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>s_ch2val</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>r</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Convert a digit value to a character */</comment>
<function_decl><type><specifier>static</specifier> <name>char</name></type> <name>s_val2ch</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>caps</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Take 2's complement of a buffer in place */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>s_2comp</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Convert a value to binary, ignoring sign.  On input, *limpos is the bound on
   how many bytes should be written to buf; on output, *limpos is set to the
   number of bytes actually written. */</comment>
<function_decl><type><specifier>static</specifier> <name>mp_result</name></type> <name>s_tobin</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>limpos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pad</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Multiply X by Y into Z, ignoring signs.  Requires that Z have enough storage
   preallocated to hold the result. */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>UMUL</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>X</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>Y</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>Z</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>ua_</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>ub_</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>Y</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>o_</name> <init>= <expr><name>ua_</name> <operator>+</operator> <name>ub_</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ZERO</name><argument_list>(<argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>Z</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>o_</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>s_kmul</name><argument_list>(<argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>Y</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>Z</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ua_</name></expr></argument>, <argument><expr><name>ub_</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>Z</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <name>o_</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CLAMP</name><argument_list>(<argument><expr><name>Z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Square X into Z.  Requires that Z have enough storage to hold the result. */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>USQR</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>X</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>Z</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>ua_</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>o_</name> <init>= <expr><name>ua_</name> <operator>+</operator> <name>ua_</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ZERO</name><argument_list>(<argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>Z</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>o_</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>s_ksqr</name><argument_list>(<argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>Z</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ua_</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>Z</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <name>o_</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CLAMP</name><argument_list>(<argument><expr><name>Z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_init</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>z</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>MP_BADARG</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>single</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>digits</name></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>z</name><operator>-&gt;</operator><name>single</name></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>alloc</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>MP_ZPOS</name></expr>;</expr_stmt>

	<return>return <expr><name>MP_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>mp_int</name></type>
<name>mp_int_alloc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mp_int</name></type>		<name>out</name> <init>= <expr><call><name>px_alloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mpz_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>out</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>mp_int_init</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>out</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_init_size</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>prec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>z</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>prec</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>prec</name> <operator>=</operator> <name>default_precision</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>prec</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>mp_int_init</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>prec</name> <operator>=</operator> <call><name>s_round_prec</name><argument_list>(<argument><expr><name>prec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>digits</name></name> <operator>=</operator> <call><name>s_alloc</name><argument_list>(<argument><expr><name>prec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>MP_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>digits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>alloc</name></name> <operator>=</operator> <name>prec</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>MP_ZPOS</name></expr>;</expr_stmt>

	<return>return <expr><name>MP_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_init_copy</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>old</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>z</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>old</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>mp_size</name></type>		<name>uold</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>uold</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>mp_int_init</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>mp_size</name></type>		<name>target</name> <init>= <expr><call><name>MAX</name><argument_list>(<argument><expr><name>uold</name></expr></argument>, <argument><expr><name>default_precision</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>mp_result</name></type>	<name>res</name> <init>= <expr><call><name>mp_int_init_size</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <name>uold</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name><name>old</name><operator>-&gt;</operator><name>sign</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COPY</name><argument_list>(<argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>uold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>MP_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_init_value</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_small</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mpz_t</name></type>		<name>vtmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_digit</name></type>	<name><name>vbuf</name><index>[<expr><call><name>MP_VALUE_DIGITS</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>s_fake</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vtmp</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>vbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>mp_int_init_copy</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vtmp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_init_uvalue</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_usmall</name></type> <name>uvalue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mpz_t</name></type>		<name>vtmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_digit</name></type>	<name><name>vbuf</name><index>[<expr><call><name>MP_VALUE_DIGITS</name><argument_list>(<argument><expr><name>uvalue</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>s_ufake</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vtmp</name></expr></argument>, <argument><expr><name>uvalue</name></expr></argument>, <argument><expr><name>vbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>mp_int_init_copy</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vtmp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_set_value</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_small</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mpz_t</name></type>		<name>vtmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_digit</name></type>	<name><name>vbuf</name><index>[<expr><call><name>MP_VALUE_DIGITS</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>s_fake</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vtmp</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>vbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vtmp</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_set_uvalue</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_usmall</name></type> <name>uvalue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mpz_t</name></type>		<name>vtmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_digit</name></type>	<name><name>vbuf</name><index>[<expr><call><name>MP_VALUE_DIGITS</name><argument_list>(<argument><expr><name>uvalue</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>s_ufake</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vtmp</name></expr></argument>, <argument><expr><name>uvalue</name></expr></argument>, <argument><expr><name>vbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vtmp</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>mp_int_clear</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>z</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>&amp;</operator><operator>(</operator><name><name>z</name><operator>-&gt;</operator><name>single</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>s_free</name><argument_list>(<argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>digits</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>mp_int_free</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>z</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>mp_int_clear</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>px_free</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>					<comment type="block">/* note: NOT s_free() */</comment>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_copy</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>!=</operator> <name>c</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>mp_size</name></type>		<name>ua</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>da</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>dc</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_pad</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ua</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>MP_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>da</name> <operator>=</operator> <call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dc</name> <operator>=</operator> <call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COPY</name><argument_list>(<argument><expr><name>da</name></expr></argument>, <argument><expr><name>dc</name></expr></argument>, <argument><expr><name>ua</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <name>ua</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>sign</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>MP_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>mp_int_swap</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>!=</operator> <name>c</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>mpz_t</name></type>		<name>tmp</name> <init>= <expr><operator>*</operator><name>a</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><operator>*</operator><name>a</name> <operator>=</operator> <operator>*</operator><name>c</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>c</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>&amp;</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>single</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>digits</name></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>single</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>&amp;</operator><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>single</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>digits</name></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>single</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>mp_int_zero</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>z</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>digits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>MP_ZPOS</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_abs</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>mp_result</name></type>	<name>res</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_copy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>MP_ZPOS</name></expr>;</expr_stmt>
	<return>return <expr><name>MP_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_neg</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>mp_result</name></type>	<name>res</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_copy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CMPZ</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <literal type="number">1</literal> <operator>-</operator> <call><name>MP_SIGN</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>MP_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_add</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>mp_size</name></type>		<name>ua</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>ub</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>max</name> <init>= <expr><call><name>MAX</name><argument_list>(<argument><expr><name>ua</name></expr></argument>, <argument><expr><name>ub</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MP_SIGN</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Same sign -- add magnitudes, preserve sign of addends */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_pad</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>MP_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

		<decl_stmt><decl><type><name>mp_digit</name></type>	<name>carry</name> <init>= <expr><call><name>s_uadd</name><argument_list>(<argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ua</name></expr></argument>, <argument><expr><name>ub</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>mp_size</name></type>		<name>uc</name> <init>= <expr><name>max</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>carry</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_pad</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>max</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>MP_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>digits</name><index>[<expr><name>max</name></expr>]</index></name> <operator>=</operator> <name>carry</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>++</operator><name>uc</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <name>uc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>sign</name></name></expr>;</expr_stmt>

	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Different signs -- subtract magnitudes, preserve sign of greater */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name> <init>= <expr><call><name>s_ucmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="block">/* magnitude comparision, sign ignored */</comment>

		<comment type="block">/*
		 * Set x to max(a, b), y to min(a, b) to simplify later code. A
		 * special case yields zero for equal magnitudes.
		 */</comment>
		<decl_stmt><decl><type><name>mp_int</name></type>		<name>x</name></decl>,
					<decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>mp_int_zero</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>MP_OK</name></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>x</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>y</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>x</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>y</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_pad</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>MP_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Subtract smaller from larger */</comment>
		<expr_stmt><expr><call><name>s_usub</name><argument_list>(<argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>used</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CLAMP</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Give result the sign of the larger */</comment>
		<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>sign</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>MP_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_add_value</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_small</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mpz_t</name></type>		<name>vtmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_digit</name></type>	<name><name>vbuf</name><index>[<expr><call><name>MP_VALUE_DIGITS</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>s_fake</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vtmp</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>vbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>mp_int_add</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vtmp</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_sub</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>mp_size</name></type>		<name>ua</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>ub</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>max</name> <init>= <expr><call><name>MAX</name><argument_list>(<argument><expr><name>ua</name></expr></argument>, <argument><expr><name>ub</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>MP_SIGN</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Different signs -- add magnitudes and keep sign of a */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_pad</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>MP_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

		<decl_stmt><decl><type><name>mp_digit</name></type>	<name>carry</name> <init>= <expr><call><name>s_uadd</name><argument_list>(<argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ua</name></expr></argument>, <argument><expr><name>ub</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>mp_size</name></type>		<name>uc</name> <init>= <expr><name>max</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>carry</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_pad</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>max</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>MP_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>digits</name><index>[<expr><name>max</name></expr>]</index></name> <operator>=</operator> <name>carry</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>++</operator><name>uc</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <name>uc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>sign</name></name></expr>;</expr_stmt>

	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Same signs -- subtract magnitudes */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_pad</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>MP_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
		<decl_stmt><decl><type><name>mp_int</name></type>		<name>x</name></decl>,
					<decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>mp_sign</name></type>		<name>osign</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name> <init>= <expr><call><name>s_ucmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>x</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>y</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>osign</name> <operator>=</operator> <name>MP_ZPOS</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>x</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>y</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>osign</name> <operator>=</operator> <name>MP_NEG</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>MP_NEG</name> <operator>&amp;&amp;</operator> <name>cmp</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>osign</name> <operator>=</operator> <literal type="number">1</literal> <operator>-</operator> <name>osign</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>s_usub</name><argument_list>(<argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>used</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CLAMP</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>osign</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>MP_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_sub_value</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_small</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mpz_t</name></type>		<name>vtmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_digit</name></type>	<name><name>vbuf</name><index>[<expr><call><name>MP_VALUE_DIGITS</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>s_fake</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vtmp</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>vbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>mp_int_sub</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vtmp</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_mul</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If either input is zero, we can shortcut multiplication */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>mp_int_compare_zero</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>mp_int_compare_zero</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>mp_int_zero</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>MP_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Output is positive if inputs have same sign, otherwise negative */</comment>
	<decl_stmt><decl><type><name>mp_sign</name></type>		<name>osign</name> <init>= <expr><ternary><condition><expr><operator>(</operator><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>MP_SIGN</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><name>MP_ZPOS</name></expr> </then><else>: <expr><name>MP_NEG</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the output is not identical to any of the inputs, we'll write the
	 * results directly; otherwise, allocate a temporary space.
	 */</comment>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>ua</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>ub</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>osize</name> <init>= <expr><call><name>MAX</name><argument_list>(<argument><expr><name>ua</name></expr></argument>, <argument><expr><name>ub</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>osize</name> <operator>=</operator> <literal type="number">4</literal> <operator>*</operator> <operator>(</operator><operator>(</operator><name>osize</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>out</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>a</name> <operator>||</operator> <name>c</name> <operator>==</operator> <name>b</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><call><name>s_round_prec</name><argument_list>(<argument><expr><name>osize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>default_precision</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>out</name> <operator>=</operator> <call><name>s_alloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>MP_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_pad</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>osize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>MP_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>ZERO</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>osize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_kmul</name><argument_list>(<argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>out</name></expr></argument>, <argument><expr><name>ua</name></expr></argument>, <argument><expr><name>ub</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>MP_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we allocated a new buffer, get rid of whatever memory c was already
	 * using, and fix up its fields to reflect that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>out</name> <operator>!=</operator> <call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>s_free</name><argument_list>(<argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>digits</name></name> <operator>=</operator> <name>out</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>alloc</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <name>osize</name></expr>;</expr_stmt>			<comment type="block">/* might not be true, but we'll fix it ... */</comment>
	<expr_stmt><expr><call><name>CLAMP</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>					<comment type="block">/* ... right here */</comment>
	<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>osign</name></expr>;</expr_stmt>

	<return>return <expr><name>MP_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_mul_value</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_small</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mpz_t</name></type>		<name>vtmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_digit</name></type>	<name><name>vbuf</name><index>[<expr><call><name>MP_VALUE_DIGITS</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>s_fake</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vtmp</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>vbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>mp_int_mul</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vtmp</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_mul_pow2</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_small</name></type> <name>p2</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>p2</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>mp_result</name></type>	<name>res</name> <init>= <expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>s_qmul</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>(</operator><name>mp_size</name><operator>)</operator> <name>p2</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>MP_OK</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><name>MP_MEMORY</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_sqr</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get a temporary buffer big enough to hold the result */</comment>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>osize</name> <init>= <expr><operator>(</operator><name>mp_size</name><operator>)</operator> <literal type="number">4</literal> <operator>*</operator> <operator>(</operator><operator>(</operator><call><name>MP_USED</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>out</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>c</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>s_round_prec</name><argument_list>(<argument><expr><name>osize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>default_precision</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>out</name> <operator>=</operator> <call><name>s_alloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>MP_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_pad</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>osize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>MP_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>ZERO</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>osize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>s_ksqr</name><argument_list>(<argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>out</name></expr></argument>, <argument><expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get rid of whatever memory c was already using, and fix up its fields
	 * to reflect the new digit array it's using
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>out</name> <operator>!=</operator> <call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>s_free</name><argument_list>(<argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>digits</name></name> <operator>=</operator> <name>out</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>alloc</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <name>osize</name></expr>;</expr_stmt>			<comment type="block">/* might not be true, but we'll fix it ... */</comment>
	<expr_stmt><expr><call><name>CLAMP</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>					<comment type="block">/* ... right here */</comment>
	<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>MP_ZPOS</name></expr>;</expr_stmt>

	<return>return <expr><name>MP_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_div</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>q</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>r</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>q</name> <operator>!=</operator> <name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_result</name></type>	<name>res</name> <init>= <expr><name>MP_OK</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_int</name></type>		<name>qout</name></decl>,
				<decl><type ref="prev"/><name>rout</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_sign</name></type>		<name>sa</name> <init>= <expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_sign</name></type>		<name>sb</name> <init>= <expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CMPZ</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>MP_UNDEF</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><name>cmp</name> <operator>=</operator> <call><name>s_ucmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If |a| &lt; |b|, no division is required: q = 0, r = a
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_copy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>q</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>mp_int_zero</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><name>MP_OK</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If |a| = |b|, no division is required: q = 1 or -1, r = 0
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>mp_int_zero</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>q</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>mp_int_zero</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>q</name><operator>-&gt;</operator><name>digits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>sa</name> <operator>!=</operator> <name>sb</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>q</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>MP_NEG</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>MP_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * When |a| &gt; |b|, real division is required.  We need someplace to store
	 * quotient and remainder, but q and r are allowed to be NULL or to
	 * overlap with the inputs.
	 */</comment>
	<expr_stmt><expr><call><name>DECLARE_TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>lg</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>lg</name> <operator>=</operator> <call><name>s_isp2</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>q</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>!=</operator> <name>q</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>q</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>qout</name> <operator>=</operator> <name>q</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>qout</name> <operator>=</operator> <call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&amp;&amp;</operator> <name>a</name> <operator>!=</operator> <name>r</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rout</name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rout</name> <operator>=</operator> <call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>s_udiv_knuth</name><argument_list>(<argument><expr><name>qout</name></expr></argument>, <argument><expr><name>rout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>q</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>q</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>q</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>s_qdiv</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>(</operator><name>mp_size</name><operator>)</operator> <name>lg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>qout</name> <operator>=</operator> <name>q</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>s_qmod</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>(</operator><name>mp_size</name><operator>)</operator> <name>lg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>rout</name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Recompute signs for output */</comment>
	<if_stmt><if>if <condition>(<expr><name>rout</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>rout</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>sa</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>CMPZ</name><argument_list>(<argument><expr><name>rout</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>rout</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>MP_ZPOS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>qout</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>qout</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>sa</name> <operator>==</operator> <name>sb</name><operator>)</operator></expr> ?</condition><then> <expr><name>MP_ZPOS</name></expr> </then><else>: <expr><name>MP_NEG</name></expr></else></ternary></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>CMPZ</name><argument_list>(<argument><expr><name>qout</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>qout</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>MP_ZPOS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>q</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><name>qout</name></expr></argument>, <argument><expr><name>q</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><name>rout</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>CLEANUP_TEMP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_mod</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>DECLARE_TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>mp_int</name></type>		<name>out</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>m</name> <operator>==</operator> <name>c</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>c</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_div</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>CMPZ</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_add</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>CLEANUP_TEMP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>MP_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_div_value</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_small</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>q</name></decl></parameter>, <parameter><decl><type><name>mp_small</name> <modifier>*</modifier></type><name>r</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mpz_t</name></type>		<name>vtmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_digit</name></type>	<name><name>vbuf</name><index>[<expr><call><name>MP_VALUE_DIGITS</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>s_fake</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vtmp</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>vbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DECLARE_TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_div</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vtmp</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>mp_int_to_int</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* can't fail */</comment>

	<expr_stmt><expr><call><name>CLEANUP_TEMP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>MP_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_div_pow2</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_small</name></type> <name>p2</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>q</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>r</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>p2</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>q</name> <operator>!=</operator> <name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>mp_result</name></type>	<name>res</name> <init>= <expr><name>MP_OK</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>q</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_copy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>q</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>MP_OK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>s_qdiv</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>(</operator><name>mp_size</name><operator>)</operator> <name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>MP_OK</name> <operator>&amp;&amp;</operator> <name>r</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_copy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>MP_OK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>s_qmod</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>(</operator><name>mp_size</name><operator>)</operator> <name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_expt</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_small</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>c</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>b</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>MP_RANGE</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>DECLARE_TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>mp_int_set_value</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>v</name> <init>= <expr><call><name>labs</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>v</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>v</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_mul</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>v</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_sqr</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>CLEANUP_TEMP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>MP_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_expt_value</name><parameter_list>(<parameter><decl><type><name>mp_small</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_small</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>c</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>b</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>MP_RANGE</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>DECLARE_TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_set_value</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>mp_int_set_value</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>v</name> <init>= <expr><call><name>labs</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>v</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>v</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_mul</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>v</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_sqr</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>CLEANUP_TEMP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>MP_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_expt_full</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>MP_NEG</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>MP_RANGE</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>DECLARE_TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>mp_int_set_value</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>ix</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>ix</name> <operator>&lt;</operator> <call><name>MP_USED</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>ix</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>mp_digit</name></type>	<name>d</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>digits</name><index>[<expr><name>ix</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>jx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>jx</name> <operator>&lt;</operator> <name>MP_DIGIT_BIT</name></expr>;</condition> <incr><expr><operator>++</operator><name>jx</name></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>d</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_mul</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>d</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>d</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ix</name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <call><name>MP_USED</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_sqr</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>CLEANUP_TEMP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>MP_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>mp_int_compare</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>mp_sign</name></type>		<name>sa</name> <init>= <expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>sa</name> <operator>==</operator> <call><name>MP_SIGN</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name> <init>= <expr><call><name>s_ucmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If they're both zero or positive, the normal comparison applies; if
		 * both negative, the sense is reversed.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>sa</name> <operator>==</operator> <name>MP_ZPOS</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>cmp</name></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<return>return <expr><operator>-</operator><name>cmp</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>sa</name> <operator>==</operator> <name>MP_ZPOS</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>mp_int_compare_unsigned</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>s_ucmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>mp_int_compare_zero</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>z</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>z</name><operator>-&gt;</operator><name>digits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>MP_ZPOS</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>mp_int_compare_value</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_small</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>z</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>mp_sign</name></type>		<name>vsign</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>value</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>MP_NEG</name></expr> </then><else>: <expr><name>MP_ZPOS</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>vsign</name> <operator>==</operator> <call><name>MP_SIGN</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name> <init>= <expr><call><name>s_vcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<return>return <expr><ternary><condition><expr><operator>(</operator><name>vsign</name> <operator>==</operator> <name>MP_ZPOS</name><operator>)</operator></expr> ?</condition><then> <expr><name>cmp</name></expr> </then><else>: <expr><operator>-</operator><name>cmp</name></expr></else></ternary></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><ternary><condition><expr><operator>(</operator><name>value</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>mp_int_compare_uvalue</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_usmall</name></type> <name>uv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>z</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>MP_NEG</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><call><name>s_uvcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>uv</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_exptmod</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>m</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Zero moduli and negative exponents are not considered. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>CMPZ</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>MP_UNDEF</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>CMPZ</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>MP_RANGE</name></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>mp_size</name></type>		<name>um</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>DECLARE_TEMP</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>GROW</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <name>um</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>GROW</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <name>um</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>mp_int</name></type>		<name>s</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>b</name> <operator>||</operator> <name>c</name> <operator>==</operator> <name>m</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>GROW</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <name>um</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>s</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_mod</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>s_brmu</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>s_embar</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLEANUP_TEMP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>MP_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_exptmod_evalue</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_small</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mpz_t</name></type>		<name>vtmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_digit</name></type>	<name><name>vbuf</name><index>[<expr><call><name>MP_VALUE_DIGITS</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>s_fake</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vtmp</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>vbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>mp_int_exptmod</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vtmp</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_exptmod_bvalue</name><parameter_list>(<parameter><decl><type><name>mp_small</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mpz_t</name></type>		<name>vtmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_digit</name></type>	<name><name>vbuf</name><index>[<expr><call><name>MP_VALUE_DIGITS</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>s_fake</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vtmp</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>vbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>mp_int_exptmod</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vtmp</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_exptmod_known</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>mu</name></decl></parameter>,
					 <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>a</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>&amp;&amp;</operator> <name>m</name> <operator>&amp;&amp;</operator> <name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Zero moduli and negative exponents are not considered. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>CMPZ</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>MP_UNDEF</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>CMPZ</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>MP_RANGE</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>DECLARE_TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>um</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>GROW</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <name>um</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>mp_int</name></type>		<name>s</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>b</name> <operator>||</operator> <name>c</name> <operator>==</operator> <name>m</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>GROW</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <name>um</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>s</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_mod</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>s_embar</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>mu</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLEANUP_TEMP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>MP_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_redux_const</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>m</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>m</name> <operator>!=</operator> <name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>s_brmu</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_invmod</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>m</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CMPZ</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>CMPZ</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>MP_RANGE</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>DECLARE_TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_egcd</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>mp_int_compare_value</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><name>MP_UNDEF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* It is first necessary to constrain the value to the proper range */</comment>
	<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_mod</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now, if 'a' was originally negative, the value we have is actually the
	 * magnitude of the negative representative; to get the positive value we
	 * have to subtract from the modulus.  Otherwise, the value is okay as it
	 * stands.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>MP_NEG</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_sub</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>CLEANUP_TEMP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>MP_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Binary GCD algorithm due to Josef Stein, 1961 */</comment>
<function><type><name>mp_result</name></type>
<name>mp_int_gcd</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>ca</name> <init>= <expr><call><name>CMPZ</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cb</name> <init>= <expr><call><name>CMPZ</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>ca</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>cb</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>MP_UNDEF</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>ca</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>mp_int_abs</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>cb</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>mp_int_abs</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>DECLARE_TEMP</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>sign</name> <operator>=</operator> <name>MP_ZPOS</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>sign</name> <operator>=</operator> <name>MP_ZPOS</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<block>{<block_content>							<comment type="block">/* Divide out common factors of 2 from u and v */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>div2_u</name> <init>= <expr><call><name>s_dp2k</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>div2_v</name> <init>= <expr><call><name>s_dp2k</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name>div2_u</name></expr></argument>, <argument><expr><name>div2_v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>s_qdiv</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>mp_size</name><operator>)</operator> <name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>s_qdiv</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>mp_size</name><operator>)</operator> <name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><call><name>mp_int_is_odd</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_neg</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>s_qdiv</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>s_dp2k</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>CMPZ</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_neg</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_sub</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>CMPZ</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_abs</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_qmul</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>(</operator><name>mp_size</name><operator>)</operator> <name>k</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><name>MP_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>CLEANUP_TEMP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>MP_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This is the binary GCD algorithm again, but this time we keep track of the
   elementary matrix operations as we go, so we can get values x and y
   satisfying c = ax + by.
 */</comment>
<function><type><name>mp_result</name></type>
<name>mp_int_egcd</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>x</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name>y</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>mp_result</name></type>	<name>res</name> <init>= <expr><name>MP_OK</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ca</name> <init>= <expr><call><name>CMPZ</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cb</name> <init>= <expr><call><name>CMPZ</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>ca</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>cb</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>MP_UNDEF</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>ca</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_abs</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>mp_int_zero</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>mp_int_set_value</name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>MP_OK</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>cb</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_abs</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>mp_int_set_value</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>mp_int_zero</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>MP_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Initialize temporaries: A:0, B:1, C:2, D:3, u:4, v:5, ou:6, ov:7
	 */</comment>
	<expr_stmt><expr><call><name>DECLARE_TEMP</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_set_value</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_set_value</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We will work with absolute values here */</comment>
	<expr_stmt><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>sign</name> <operator>=</operator> <name>MP_ZPOS</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>sign</name> <operator>=</operator> <name>MP_ZPOS</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<block>{<block_content>							<comment type="block">/* Divide out common factors of 2 from u and v */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>div2_u</name> <init>= <expr><call><name>s_dp2k</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>,
					<decl><type ref="prev"/><name>div2_v</name> <init>= <expr><call><name>s_dp2k</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name>div2_u</name></expr></argument>, <argument><expr><name>div2_v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>s_qdiv</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>s_qdiv</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<while>while <condition>(<expr><call><name>mp_int_is_even</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>s_qdiv</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>mp_int_is_odd</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>mp_int_is_odd</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_add</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_sub</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>s_qdiv</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>s_qdiv</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>

		<while>while <condition>(<expr><call><name>mp_int_is_even</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>s_qdiv</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>mp_int_is_odd</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>mp_int_is_odd</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_add</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_sub</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>s_qdiv</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>s_qdiv</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>

		<if_stmt><if>if <condition>(<expr><call><name>mp_int_compare</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_sub</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_sub</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_sub</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_sub</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_sub</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_sub</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>CMPZ</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>x</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>y</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>c</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_qmul</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><name>MP_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>CLEANUP_TEMP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>MP_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_lcm</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since a * b = gcd(a, b) * lcm(a, b), we can compute lcm(a, b) = (a /
	 * gcd(a, b)) * b.
	 *
	 * This formulation insures everything works even if the input variables
	 * share space.
	 */</comment>
	<expr_stmt><expr><call><name>DECLARE_TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_gcd</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_div</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_mul</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLEANUP_TEMP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>MP_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>mp_int_divisible_value</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_small</name></type> <name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mp_small</name></type>	<name>rem</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>mp_int_div_value</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rem</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>MP_OK</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>rem</name> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>mp_int_is_pow2</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>z</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>s_isp2</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Implementation of Newton's root finding method, based loosely on a patch
   contributed by Hal Finkel &lt;half@halssoftware.com&gt;
   modified by M. J. Fromberger.
 */</comment>
<function><type><name>mp_result</name></type>
<name>mp_int_root</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_small</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>b</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>flips</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>MP_NEG</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>b</name> <operator>%</operator> <literal type="number">2</literal> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>MP_UNDEF</name></expr>;</return>	<comment type="block">/* root does not exist for negative a with
								 * even b */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>flips</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>DECLARE_TEMP</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>sign</name> <operator>=</operator> <name>MP_ZPOS</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>sign</name> <operator>=</operator> <name>MP_ZPOS</name></expr>;</expr_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_expt</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>mp_int_compare_unsigned</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_sub</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_expt</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>b</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_mul_value</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_div</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_sub</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>mp_int_compare_unsigned</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_sub_value</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If the original value of a was negative, flip the output sign. */</comment>
	<if_stmt><if>if <condition>(<expr><name>flips</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>mp_int_neg</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* cannot fail */</comment>

	<expr_stmt><expr><call><name>CLEANUP_TEMP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>MP_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_to_int</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_small</name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>z</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make sure the value is representable as a small integer */</comment>
	<decl_stmt><decl><type><name>mp_sign</name></type>		<name>sz</name> <init>= <expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>sz</name> <operator>==</operator> <name>MP_ZPOS</name> <operator>&amp;&amp;</operator> <call><name>mp_int_compare_value</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>MP_SMALL_MAX</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
		<call><name>mp_int_compare_value</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>MP_SMALL_MIN</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>MP_RANGE</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>mp_usmall</name></type>	<name>uz</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>dz</name> <init>= <expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>uz</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_small</name></type>	<name>uv</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>uz</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>uv</name> <operator>&lt;&lt;=</operator> <name>MP_DIGIT_BIT</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>uv</name> <operator>=</operator> <operator>(</operator><name>uv</name> <operator>&lt;&lt;</operator> <operator>(</operator><name>MP_DIGIT_BIT</name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator><operator>)</operator> <operator>|</operator> <operator>*</operator><name>dz</name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><operator>--</operator><name>uz</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>out</name> <operator>=</operator> <operator>(</operator><name>mp_small</name><operator>)</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>sz</name> <operator>==</operator> <name>MP_NEG</name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><name>uv</name></expr> </then><else>: <expr><name>uv</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>MP_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_to_uint</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_usmall</name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>z</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make sure the value is representable as an unsigned small integer */</comment>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>sz</name> <init>= <expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>sz</name> <operator>==</operator> <name>MP_NEG</name> <operator>||</operator> <call><name>mp_int_compare_uvalue</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>MP_USMALL_MAX</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>MP_RANGE</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>mp_size</name></type>		<name>uz</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>dz</name> <init>= <expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>uz</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_usmall</name></type>	<name>uv</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>uz</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>uv</name> <operator>&lt;&lt;=</operator> <name>MP_DIGIT_BIT</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>uv</name> <operator>=</operator> <operator>(</operator><name>uv</name> <operator>&lt;&lt;</operator> <operator>(</operator><name>MP_DIGIT_BIT</name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator><operator>)</operator> <operator>|</operator> <operator>*</operator><name>dz</name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><operator>--</operator><name>uz</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>out</name> <operator>=</operator> <name>uv</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>MP_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_to_string</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>radix</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>limit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>z</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>str</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>limit</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>radix</name> <operator>&gt;=</operator> <name>MP_MIN_RADIX</name> <operator>&amp;&amp;</operator> <name>radix</name> <operator>&lt;=</operator> <name>MP_MAX_RADIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CMPZ</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <call><name>s_val2ch</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>mp_result</name></type>	<name>res</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>mpz_t</name></type>		<name>tmp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>h</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>mp_int_init_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>MP_NEG</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>--</operator><name>limit</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>h</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>

		<comment type="block">/* Generate digits in reverse order until finished or limit reached */</comment>
		<for>for <control>( <comment type="block">/* */</comment> <init>;</init> <condition><expr><name>limit</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>limit</name></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>mp_digit</name></type>	<name>d</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>cmp</name> <operator>=</operator> <call><name>CMPZ</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>s_ddiv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><operator>(</operator><name>mp_digit</name><operator>)</operator> <name>radix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>str</name><operator>++</operator> <operator>=</operator> <call><name>s_val2ch</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name>t</name> <operator>=</operator> <name>str</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<comment type="block">/* Put digits back in correct output order */</comment>
		<while>while <condition>(<expr><name>h</name> <operator>&lt;</operator> <name>t</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name>tc</name> <init>= <expr><operator>*</operator><name>h</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><operator>*</operator><name>h</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>t</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>t</name><operator>--</operator> <operator>=</operator> <name>tc</name></expr>;</expr_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>mp_int_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>str</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>MP_OK</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><name>MP_TRUNC</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_string_len</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>radix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>z</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>radix</name> <operator>&gt;=</operator> <name>MP_MIN_RADIX</name> <operator>&amp;&amp;</operator> <name>radix</name> <operator>&lt;=</operator> <name>MP_MAX_RADIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>len</name> <init>= <expr><call><name>s_outlen</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>radix</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* for terminator */</comment>

	<comment type="block">/* Allow for sign marker on negatives */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>MP_NEG</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Read zero-terminated string into z */</comment>
<function><type><name>mp_result</name></type>
<name>mp_int_read_string</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>radix</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>mp_int_read_cstring</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>radix</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_read_cstring</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>radix</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>,
					<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>z</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>str</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>radix</name> <operator>&gt;=</operator> <name>MP_MIN_RADIX</name> <operator>&amp;&amp;</operator> <name>radix</name> <operator>&lt;=</operator> <name>MP_MAX_RADIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Skip leading whitespace */</comment>
	<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>++</operator><name>str</name></expr>;</expr_stmt></block_content></block></while>

	<comment type="block">/* Handle leading sign tag (+/-, positive default) */</comment>
	<switch>switch <condition>(<expr><operator>*</operator><name>str</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="char">'-'</literal></expr>:</case>
			<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>MP_NEG</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>++</operator><name>str</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'+'</literal></expr>:</case>
			<expr_stmt><expr><operator>++</operator><name>str</name></expr>;</expr_stmt>				<comment type="block">/* fallthrough */</comment>
		<default>default:</default>
			<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>MP_ZPOS</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Skip leading zeroes */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>ch</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>ch</name> <operator>=</operator> <call><name>s_ch2val</name><argument_list>(<argument><expr><operator>*</operator><name>str</name></expr></argument>, <argument><expr><name>radix</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>++</operator><name>str</name></expr>;</expr_stmt></block_content></block></while>

	<comment type="block">/* Make sure there is enough space for the value */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_pad</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><call><name>s_inlen</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>radix</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>MP_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>digits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>*</operator><name>str</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>ch</name> <operator>=</operator> <call><name>s_ch2val</name><argument_list>(<argument><expr><operator>*</operator><name>str</name></expr></argument>, <argument><expr><name>radix</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>s_dmul</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><operator>(</operator><name>mp_digit</name><operator>)</operator> <name>radix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>s_dadd</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><operator>(</operator><name>mp_digit</name><operator>)</operator> <name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>++</operator><name>str</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>CLAMP</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Override sign for zero, even if negative specified. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>CMPZ</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>MP_ZPOS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>end</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <call><name>unconstify</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Return a truncation error if the string has unprocessed characters
	 * remaining, so the caller can tell if the whole string was done
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>MP_TRUNC</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><name>MP_OK</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_count_bits</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>z</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>mp_size</name></type>		<name>uz</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>uz</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>z</name><operator>-&gt;</operator><name>digits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>--</operator><name>uz</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>nbits</name> <init>= <expr><name>uz</name> <operator>*</operator> <name>MP_DIGIT_BIT</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_digit</name></type>	<name>d</name> <init>= <expr><name><name>z</name><operator>-&gt;</operator><name>digits</name><index>[<expr><name>uz</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>d</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>d</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>++</operator><name>nbits</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>nbits</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_to_binary</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>limit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>PAD_FOR_2C</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>z</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>buf</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>limpos</name> <init>= <expr><name>limit</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_result</name></type>	<name>res</name> <init>= <expr><call><name>s_tobin</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>limpos</name></expr></argument>, <argument><expr><name>PAD_FOR_2C</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>MP_NEG</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>s_2comp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>limpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_read_binary</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>z</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>buf</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Figure out how many digits are needed to represent this value */</comment>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>need</name> <init>= <expr><operator>(</operator><operator>(</operator><name>len</name> <operator>*</operator> <name>CHAR_BIT</name><operator>)</operator> <operator>+</operator> <operator>(</operator><name>MP_DIGIT_BIT</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <name>MP_DIGIT_BIT</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_pad</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>need</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>MP_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>mp_int_zero</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the high-order bit is set, take the 2's complement before reading
	 * the value (it will be restored afterward)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <operator>(</operator><name>CHAR_BIT</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>MP_NEG</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>s_2comp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>dz</name> <init>= <expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>len</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr><operator>,</operator> <expr><operator>++</operator><name>tmp</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>s_qmul</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><operator>(</operator><name>mp_size</name><operator>)</operator> <name>CHAR_BIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>dz</name> <operator>|=</operator> <operator>*</operator><name>tmp</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Restore 2's complement if we took it before */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>MP_NEG</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>s_2comp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>MP_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_binary_len</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mp_result</name></type>	<name>res</name> <init>= <expr><call><name>mp_int_count_bits</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>bytes</name> <init>= <expr><call><name>mp_int_unsigned_len</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the highest-order bit falls exactly on a byte boundary, we need to
	 * pad with an extra byte so that the sign will be read correctly when
	 * reading it back in.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>bytes</name> <operator>*</operator> <name>CHAR_BIT</name> <operator>==</operator> <name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>++</operator><name>bytes</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>bytes</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_to_unsigned</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>limit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>NO_PADDING</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>z</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>buf</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>s_tobin</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>limit</name></expr></argument>, <argument><expr><name>NO_PADDING</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_read_unsigned</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>z</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>buf</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Figure out how many digits are needed to represent this value */</comment>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>need</name> <init>= <expr><operator>(</operator><operator>(</operator><name>len</name> <operator>*</operator> <name>CHAR_BIT</name><operator>)</operator> <operator>+</operator> <operator>(</operator><name>MP_DIGIT_BIT</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <name>MP_DIGIT_BIT</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_pad</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>need</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>MP_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>mp_int_zero</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>len</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr><operator>,</operator> <expr><operator>++</operator><name>tmp</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>s_qmul</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>CHAR_BIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>|=</operator> <operator>*</operator><name>tmp</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>MP_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>mp_result</name></type>
<name>mp_int_unsigned_len</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mp_result</name></type>	<name>res</name> <init>= <expr><call><name>mp_int_count_bits</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>bytes</name> <init>= <expr><operator>(</operator><name>res</name> <operator>+</operator> <operator>(</operator><name>CHAR_BIT</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <name>CHAR_BIT</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>bytes</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>mp_error_string</name><parameter_list>(<parameter><decl><type><name>mp_result</name></type> <name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>s_unknown_err</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <operator>-</operator><name>res</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ix</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>ix</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ix</name> <operator>&lt;</operator> <name>res</name> <operator>&amp;&amp;</operator> <name><name>s_error_msg</name><index>[<expr><name>ix</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><operator>++</operator><name>ix</name></expr></incr>)</control><block type="pseudo"><block_content>
		<empty_stmt>;</empty_stmt></block_content></block></for>

	<if_stmt><if>if <condition>(<expr><name><name>s_error_msg</name><index>[<expr><name>ix</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name><name>s_error_msg</name><index>[<expr><name>ix</name></expr>]</index></name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><name>s_unknown_err</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*------------------------------------------------------------------------*/</comment>
<comment type="block">/* Private functions for internal use.  These make assumptions.           */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>IMATH_DEBUG</name></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>mp_digit</name></type> <name>fill</name> <init>= <expr><operator>(</operator><name>mp_digit</name><operator>)</operator> <literal type="number">0xdeadbeefabad1dea</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>mp_digit</name> <modifier>*</modifier></type>
<name>s_alloc</name><parameter_list>(<parameter><decl><type><name>mp_size</name></type> <name>num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>out</name> <init>= <expr><call><name>px_alloc</name><argument_list>(<argument><expr><name>num</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>mp_digit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>out</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>IMATH_DEBUG</name></expr></cpp:if>
	<for>for <control>(<init><decl><type><name>mp_size</name></type> <name>ix</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>ix</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><operator>++</operator><name>ix</name></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>out</name><index>[<expr><name>ix</name></expr>]</index></name> <operator>=</operator> <name>fill</name></expr>;</expr_stmt></block_content></block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><name>out</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>mp_digit</name> <modifier>*</modifier></type>
<name>s_realloc</name><parameter_list>(<parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>old</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>osize</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>nsize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>IMATH_DEBUG</name></expr></cpp:if>
	<decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>new</name> <init>= <expr><call><name>s_alloc</name><argument_list>(<argument><expr><name>nsize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>new</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>mp_size</name></type> <name>ix</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>ix</name> <operator>&lt;</operator> <name>nsize</name></expr>;</condition> <incr><expr><operator>++</operator><name>ix</name></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>new</name><index>[<expr><name>ix</name></expr>]</index></name> <operator>=</operator> <name>fill</name></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new</name></expr></argument>, <argument><expr><name>old</name></expr></argument>, <argument><expr><name>osize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>mp_digit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>new</name> <init>= <expr><call><name>px_realloc</name><argument_list>(<argument><expr><name>old</name></expr></argument>, <argument><expr><name>nsize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>mp_digit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>new</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>new</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>s_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>px_free</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>s_pad</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>min</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>MP_ALLOC</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>min</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>mp_size</name></type>		<name>nsize</name> <init>= <expr><call><name>s_round_prec</name><argument_list>(<argument><expr><name>min</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>z</name><operator>-&gt;</operator><name>digits</name></name> <operator>==</operator> <operator>&amp;</operator><operator>(</operator><name><name>z</name><operator>-&gt;</operator><name>single</name></name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>tmp</name> <operator>=</operator> <call><name>s_alloc</name><argument_list>(<argument><expr><name>nsize</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>tmp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>z</name><operator>-&gt;</operator><name>single</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>(</operator><name>tmp</name> <operator>=</operator> <call><name>s_realloc</name><argument_list>(<argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>MP_ALLOC</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nsize</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>digits</name></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>alloc</name></name> <operator>=</operator> <name>nsize</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Note: This will not work correctly when value == MP_SMALL_MIN */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>s_fake</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_small</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name></type> <name><name>vbuf</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mp_usmall</name></type>	<name>uv</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>mp_usmall</name><operator>)</operator> <operator>(</operator><name>value</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><name>value</name></expr> </then><else>: <expr><name>value</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>s_ufake</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>uv</name></expr></argument>, <argument><expr><name>vbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>value</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>MP_NEG</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>s_ufake</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_usmall</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name></type> <name><name>vbuf</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>ndig</name> <init>= <expr><operator>(</operator><name>mp_size</name><operator>)</operator> <call><name>s_uvpack</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>vbuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <name>ndig</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>alloc</name></name> <operator>=</operator> <call><name>MP_VALUE_DIGITS</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>MP_ZPOS</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>digits</name></name> <operator>=</operator> <name>vbuf</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>s_cdig</name><parameter_list>(<parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>da</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>dat</name> <init>= <expr><name>da</name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>dbt</name> <init>= <expr><name>db</name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>( <comment type="block">/* */</comment> <init>;</init> <condition><expr><name>len</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>len</name></expr><operator>,</operator> <expr><operator>--</operator><name>dat</name></expr><operator>,</operator> <expr><operator>--</operator><name>dbt</name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>dat</name> <operator>&gt;</operator> <operator>*</operator><name>dbt</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>*</operator><name>dat</name> <operator>&lt;</operator> <operator>*</operator><name>dbt</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>s_uvpack</name><parameter_list>(<parameter><decl><type><name>mp_usmall</name></type> <name>uv</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name></type> <name><name>t</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndig</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>uv</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>t</name><index>[<expr><name>ndig</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<while>while <condition>(<expr><name>uv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>t</name><index>[<expr><name>ndig</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>mp_digit</name><operator>)</operator> <name>uv</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>uv</name> <operator>&gt;&gt;=</operator> <name>MP_DIGIT_BIT</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>uv</name> <operator>&gt;&gt;=</operator> <name>MP_DIGIT_BIT</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>ndig</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>s_ucmp</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>ua</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>,
				<decl><type ref="prev"/><name>ub</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>ua</name> <operator>&gt;</operator> <name>ub</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>ub</name> <operator>&gt;</operator> <name>ua</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><call><name>s_cdig</name><argument_list>(<argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ua</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>s_vcmp</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_small</name></type> <name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MSC_VER</name></cpp:ifdef>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>push</name><name>)</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>disable</name><name>:</name> <name>4146</name><name>)</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>mp_usmall</name></type>	<name>uv</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>v</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><operator>(</operator><name>mp_usmall</name><operator>)</operator> <name>v</name></expr> </then><else>: <expr><operator>(</operator><name>mp_usmall</name><operator>)</operator> <name>v</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MSC_VER</name></cpp:ifdef>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>pop</name><name>)</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><call><name>s_uvcmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>uv</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>s_uvcmp</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_usmall</name></type> <name>uv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mpz_t</name></type>		<name>vtmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_digit</name></type>	<name><name>vdig</name><index>[<expr><call><name>MP_VALUE_DIGITS</name><argument_list>(<argument><expr><name>uv</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>s_ufake</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vtmp</name></expr></argument>, <argument><expr><name>uv</name></expr></argument>, <argument><expr><name>vdig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>s_ucmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vtmp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>mp_digit</name></type>
<name>s_uadd</name><parameter_list>(<parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>da</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>dc</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>size_a</name></decl></parameter>,
	   <parameter><decl><type><name>mp_size</name></type> <name>size_b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>pos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_word</name></type>		<name>w</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Insure that da is the longer of the two to simplify later code */</comment>
	<if_stmt><if>if <condition>(<expr><name>size_b</name> <operator>&gt;</operator> <name>size_a</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SWAP</name><argument_list>(<argument><expr><name>mp_digit</name> <operator>*</operator></expr></argument>, <argument><expr><name>da</name></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SWAP</name><argument_list>(<argument><expr><name>mp_size</name></expr></argument>, <argument><expr><name>size_a</name></expr></argument>, <argument><expr><name>size_b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Add corresponding digits until the shorter number runs out */</comment>
	<for>for <control>(<init><expr><name>pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>pos</name> <operator>&lt;</operator> <name>size_b</name></expr>;</condition> <incr><expr><operator>++</operator><name>pos</name></expr><operator>,</operator> <expr><operator>++</operator><name>da</name></expr><operator>,</operator> <expr><operator>++</operator><name>db</name></expr><operator>,</operator> <expr><operator>++</operator><name>dc</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>w</name> <operator>=</operator> <name>w</name> <operator>+</operator> <operator>(</operator><name>mp_word</name><operator>)</operator> <operator>*</operator><name>da</name> <operator>+</operator> <operator>(</operator><name>mp_word</name><operator>)</operator> <operator>*</operator><name>db</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>dc</name> <operator>=</operator> <call><name>LOWER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>UPPER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Propagate carries as far as necessary */</comment>
	<for>for <control>( <comment type="block">/* */</comment> <init>;</init> <condition><expr><name>pos</name> <operator>&lt;</operator> <name>size_a</name></expr>;</condition> <incr><expr><operator>++</operator><name>pos</name></expr><operator>,</operator> <expr><operator>++</operator><name>da</name></expr><operator>,</operator> <expr><operator>++</operator><name>dc</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>w</name> <operator>=</operator> <name>w</name> <operator>+</operator> <operator>*</operator><name>da</name></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>dc</name> <operator>=</operator> <call><name>LOWER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>UPPER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Return carry out */</comment>
	<return>return <expr><operator>(</operator><name>mp_digit</name><operator>)</operator> <name>w</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>s_usub</name><parameter_list>(<parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>da</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>dc</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>size_a</name></decl></parameter>,
	   <parameter><decl><type><name>mp_size</name></type> <name>size_b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>pos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_word</name></type>		<name>w</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* We assume that |a| &gt;= |b| so this should definitely hold */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>size_a</name> <operator>&gt;=</operator> <name>size_b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Subtract corresponding digits and propagate borrow */</comment>
	<for>for <control>(<init><expr><name>pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>pos</name> <operator>&lt;</operator> <name>size_b</name></expr>;</condition> <incr><expr><operator>++</operator><name>pos</name></expr><operator>,</operator> <expr><operator>++</operator><name>da</name></expr><operator>,</operator> <expr><operator>++</operator><name>db</name></expr><operator>,</operator> <expr><operator>++</operator><name>dc</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>mp_word</name><operator>)</operator> <name>MP_DIGIT_MAX</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator>	<comment type="block">/* MP_RADIX */</comment>
			 <operator>(</operator><name>mp_word</name><operator>)</operator> <operator>*</operator><name>da</name><operator>)</operator> <operator>-</operator>
			<name>w</name> <operator>-</operator> <operator>(</operator><name>mp_word</name><operator>)</operator> <operator>*</operator><name>db</name></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>dc</name> <operator>=</operator> <call><name>LOWER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><call><name>UPPER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Finish the subtraction for remaining upper digits of da */</comment>
	<for>for <control>( <comment type="block">/* */</comment> <init>;</init> <condition><expr><name>pos</name> <operator>&lt;</operator> <name>size_a</name></expr>;</condition> <incr><expr><operator>++</operator><name>pos</name></expr><operator>,</operator> <expr><operator>++</operator><name>da</name></expr><operator>,</operator> <expr><operator>++</operator><name>dc</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>mp_word</name><operator>)</operator> <name>MP_DIGIT_MAX</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator>	<comment type="block">/* MP_RADIX */</comment>
			 <operator>(</operator><name>mp_word</name><operator>)</operator> <operator>*</operator><name>da</name><operator>)</operator> <operator>-</operator>
			<name>w</name></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>dc</name> <operator>=</operator> <call><name>LOWER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><call><name>UPPER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* If there is a borrow out at the end, it violates the precondition */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>w</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>s_kmul</name><parameter_list>(<parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>da</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>dc</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>size_a</name></decl></parameter>,
	   <parameter><decl><type><name>mp_size</name></type> <name>size_b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>bot_size</name></decl>;</decl_stmt>

	<comment type="block">/* Make sure b is the smaller of the two input values */</comment>
	<if_stmt><if>if <condition>(<expr><name>size_b</name> <operator>&gt;</operator> <name>size_a</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SWAP</name><argument_list>(<argument><expr><name>mp_digit</name> <operator>*</operator></expr></argument>, <argument><expr><name>da</name></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SWAP</name><argument_list>(<argument><expr><name>mp_size</name></expr></argument>, <argument><expr><name>size_a</name></expr></argument>, <argument><expr><name>size_b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Insure that the bottom is the larger half in an odd-length split; the
	 * code below relies on this being true.
	 */</comment>
	<expr_stmt><expr><name>bot_size</name> <operator>=</operator> <operator>(</operator><name>size_a</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the values are big enough to bother with recursion, use the
	 * Karatsuba algorithm to compute the product; otherwise use the normal
	 * multiplication algorithm
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>multiply_threshold</name> <operator>&amp;&amp;</operator> <name>size_a</name> <operator>&gt;=</operator> <name>multiply_threshold</name> <operator>&amp;&amp;</operator> <name>size_b</name> <operator>&gt;</operator> <name>bot_size</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>t1</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>t2</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>t3</name></decl>,
					<decl><type ref="prev"/><name>carry</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>a_top</name> <init>= <expr><name>da</name> <operator>+</operator> <name>bot_size</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>b_top</name> <init>= <expr><name>db</name> <operator>+</operator> <name>bot_size</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>mp_size</name></type>		<name>at_size</name> <init>= <expr><name>size_a</name> <operator>-</operator> <name>bot_size</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>mp_size</name></type>		<name>bt_size</name> <init>= <expr><name>size_b</name> <operator>-</operator> <name>bot_size</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>mp_size</name></type>		<name>buf_size</name> <init>= <expr><literal type="number">2</literal> <operator>*</operator> <name>bot_size</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Do a single allocation for all three temporary buffers needed; each
		 * buffer must be big enough to hold the product of two bottom halves,
		 * and one buffer needs space for the completed product; twice the
		 * space is plenty.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>t1</name> <operator>=</operator> <call><name>s_alloc</name><argument_list>(<argument><expr><literal type="number">4</literal> <operator>*</operator> <name>buf_size</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>t2</name> <operator>=</operator> <name>t1</name> <operator>+</operator> <name>buf_size</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>t3</name> <operator>=</operator> <name>t2</name> <operator>+</operator> <name>buf_size</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ZERO</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><literal type="number">4</literal> <operator>*</operator> <name>buf_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * t1 and t2 are initially used as temporaries to compute the inner
		 * product (a1 + a0)(b1 + b0) = a1b1 + a1b0 + a0b1 + a0b0
		 */</comment>
		<expr_stmt><expr><name>carry</name> <operator>=</operator> <call><name>s_uadd</name><argument_list>(<argument><expr><name>da</name></expr></argument>, <argument><expr><name>a_top</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>, <argument><expr><name>bot_size</name></expr></argument>, <argument><expr><name>at_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* t1 = a1 + a0 */</comment>
		<expr_stmt><expr><name><name>t1</name><index>[<expr><name>bot_size</name></expr>]</index></name> <operator>=</operator> <name>carry</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>carry</name> <operator>=</operator> <call><name>s_uadd</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>b_top</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><name>bot_size</name></expr></argument>, <argument><expr><name>bt_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* t2 = b1 + b0 */</comment>
		<expr_stmt><expr><name><name>t2</name><index>[<expr><name>bot_size</name></expr>]</index></name> <operator>=</operator> <name>carry</name></expr>;</expr_stmt>

		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>s_kmul</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>, <argument><expr><name>bot_size</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>bot_size</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* t3 = t1 * t2 */</comment>

		<comment type="block">/*
		 * Now we'll get t1 = a0b0 and t2 = a1b1, and subtract them out so
		 * that we're left with only the pieces we want:  t3 = a1b0 + a0b1
		 */</comment>
		<expr_stmt><expr><call><name>ZERO</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>buf_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ZERO</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name>buf_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>s_kmul</name><argument_list>(<argument><expr><name>da</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>, <argument><expr><name>bot_size</name></expr></argument>, <argument><expr><name>bot_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* t1 = a0 * b0 */</comment>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>s_kmul</name><argument_list>(<argument><expr><name>a_top</name></expr></argument>, <argument><expr><name>b_top</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><name>at_size</name></expr></argument>, <argument><expr><name>bt_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* t2 = a1 * b1 */</comment>

		<comment type="block">/* Subtract out t1 and t2 to get the inner product */</comment>
		<expr_stmt><expr><call><name>s_usub</name><argument_list>(<argument><expr><name>t3</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>, <argument><expr><name>buf_size</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>buf_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>s_usub</name><argument_list>(<argument><expr><name>t3</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>, <argument><expr><name>buf_size</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>buf_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Assemble the output value */</comment>
		<expr_stmt><expr><call><name>COPY</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>dc</name></expr></argument>, <argument><expr><name>buf_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>carry</name> <operator>=</operator> <call><name>s_uadd</name><argument_list>(<argument><expr><name>t3</name></expr></argument>, <argument><expr><name>dc</name> <operator>+</operator> <name>bot_size</name></expr></argument>, <argument><expr><name>dc</name> <operator>+</operator> <name>bot_size</name></expr></argument>, <argument><expr><name>buf_size</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>buf_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>carry</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>carry</name> <operator>=</operator>
			<call><name>s_uadd</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name>dc</name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>bot_size</name></expr></argument>, <argument><expr><name>dc</name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>bot_size</name></expr></argument>, <argument><expr><name>buf_size</name></expr></argument>, <argument><expr><name>buf_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>carry</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>s_free</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>				<comment type="block">/* note t2 and t3 are just internal pointers
								 * to t1 */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>s_umul</name><argument_list>(<argument><expr><name>da</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>dc</name></expr></argument>, <argument><expr><name>size_a</name></expr></argument>, <argument><expr><name>size_b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>s_umul</name><parameter_list>(<parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>da</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>dc</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>size_a</name></decl></parameter>,
	   <parameter><decl><type><name>mp_size</name></type> <name>size_b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>a</name></decl>,
				<decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_word</name></type>		<name>w</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>a</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>a</name> <operator>&lt;</operator> <name>size_a</name></expr>;</condition> <incr><expr><operator>++</operator><name>a</name></expr><operator>,</operator> <expr><operator>++</operator><name>dc</name></expr><operator>,</operator> <expr><operator>++</operator><name>da</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>dct</name> <init>= <expr><name>dc</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>dbt</name> <init>= <expr><name>db</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>da</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>w</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>b</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>b</name> <operator>&lt;</operator> <name>size_b</name></expr>;</condition> <incr><expr><operator>++</operator><name>b</name></expr><operator>,</operator> <expr><operator>++</operator><name>dbt</name></expr><operator>,</operator> <expr><operator>++</operator><name>dct</name></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>mp_word</name><operator>)</operator> <operator>*</operator><name>da</name> <operator>*</operator> <operator>(</operator><name>mp_word</name><operator>)</operator> <operator>*</operator><name>dbt</name> <operator>+</operator> <name>w</name> <operator>+</operator> <operator>(</operator><name>mp_word</name><operator>)</operator> <operator>*</operator><name>dct</name></expr>;</expr_stmt>

			<expr_stmt><expr><operator>*</operator><name>dct</name> <operator>=</operator> <call><name>LOWER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>UPPER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><operator>*</operator><name>dct</name> <operator>=</operator> <operator>(</operator><name>mp_digit</name><operator>)</operator> <name>w</name></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>s_ksqr</name><parameter_list>(<parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>da</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>dc</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>size_a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>multiply_threshold</name> <operator>&amp;&amp;</operator> <name>size_a</name> <operator>&gt;</operator> <name>multiply_threshold</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>mp_size</name></type>		<name>bot_size</name> <init>= <expr><operator>(</operator><name>size_a</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>a_top</name> <init>= <expr><name>da</name> <operator>+</operator> <name>bot_size</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>t1</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>t2</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>t3</name></decl>,
					<decl><type ref="prev"/><name>carry</name> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>mp_size</name></type>		<name>at_size</name> <init>= <expr><name>size_a</name> <operator>-</operator> <name>bot_size</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>mp_size</name></type>		<name>buf_size</name> <init>= <expr><literal type="number">2</literal> <operator>*</operator> <name>bot_size</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>t1</name> <operator>=</operator> <call><name>s_alloc</name><argument_list>(<argument><expr><literal type="number">4</literal> <operator>*</operator> <name>buf_size</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>t2</name> <operator>=</operator> <name>t1</name> <operator>+</operator> <name>buf_size</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>t3</name> <operator>=</operator> <name>t2</name> <operator>+</operator> <name>buf_size</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ZERO</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><literal type="number">4</literal> <operator>*</operator> <name>buf_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>s_ksqr</name><argument_list>(<argument><expr><name>da</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>, <argument><expr><name>bot_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* t1 = a0 ^ 2 */</comment>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>s_ksqr</name><argument_list>(<argument><expr><name>a_top</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><name>at_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* t2 = a1 ^ 2 */</comment>

		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>s_kmul</name><argument_list>(<argument><expr><name>da</name></expr></argument>, <argument><expr><name>a_top</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>, <argument><expr><name>bot_size</name></expr></argument>, <argument><expr><name>at_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* t3 = a0 * a1 */</comment>

		<comment type="block">/* Quick multiply t3 by 2, shifting left (can't overflow) */</comment>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
						<decl><type ref="prev"/><name>top</name> <init>= <expr><name>bot_size</name> <operator>+</operator> <name>at_size</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>mp_word</name></type>		<name>w</name></decl>,
						<decl><type ref="prev"/><name>save</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>top</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>t3</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>w</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>|</operator> <name>save</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>t3</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>LOWER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>save</name> <operator>=</operator> <call><name>UPPER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><name><name>t3</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>LOWER_HALF</name><argument_list>(<argument><expr><name>save</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/* Assemble the output value */</comment>
		<expr_stmt><expr><call><name>COPY</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>dc</name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <name>bot_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>carry</name> <operator>=</operator> <call><name>s_uadd</name><argument_list>(<argument><expr><name>t3</name></expr></argument>, <argument><expr><name>dc</name> <operator>+</operator> <name>bot_size</name></expr></argument>, <argument><expr><name>dc</name> <operator>+</operator> <name>bot_size</name></expr></argument>, <argument><expr><name>buf_size</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>buf_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>carry</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>carry</name> <operator>=</operator>
			<call><name>s_uadd</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name>dc</name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>bot_size</name></expr></argument>, <argument><expr><name>dc</name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>bot_size</name></expr></argument>, <argument><expr><name>buf_size</name></expr></argument>, <argument><expr><name>buf_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>carry</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>s_free</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>				<comment type="block">/* note that t2 and t2 are internal pointers
								 * only */</comment>

	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>s_usqr</name><argument_list>(<argument><expr><name>da</name></expr></argument>, <argument><expr><name>dc</name></expr></argument>, <argument><expr><name>size_a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>s_usqr</name><parameter_list>(<parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>da</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>dc</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>size_a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_word</name></type>		<name>w</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size_a</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr><operator>,</operator> <expr><name>dc</name> <operator>+=</operator> <literal type="number">2</literal></expr><operator>,</operator> <expr><operator>++</operator><name>da</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>dct</name> <init>= <expr><name>dc</name></expr></init></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>dat</name> <init>= <expr><name>da</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>da</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Take care of the first digit, no rollover */</comment>
		<expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>mp_word</name><operator>)</operator> <operator>*</operator><name>dat</name> <operator>*</operator> <operator>(</operator><name>mp_word</name><operator>)</operator> <operator>*</operator><name>dat</name> <operator>+</operator> <operator>(</operator><name>mp_word</name><operator>)</operator> <operator>*</operator><name>dct</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>dct</name> <operator>=</operator> <call><name>LOWER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>UPPER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>++</operator><name>dat</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>++</operator><name>dct</name></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>size_a</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr><operator>,</operator> <expr><operator>++</operator><name>dat</name></expr><operator>,</operator> <expr><operator>++</operator><name>dct</name></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>mp_word</name></type>		<name>t</name> <init>= <expr><operator>(</operator><name>mp_word</name><operator>)</operator> <operator>*</operator><name>da</name> <operator>*</operator> <operator>(</operator><name>mp_word</name><operator>)</operator> <operator>*</operator><name>dat</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>mp_word</name></type>		<name>u</name> <init>= <expr><name>w</name> <operator>+</operator> <operator>(</operator><name>mp_word</name><operator>)</operator> <operator>*</operator><name>dct</name></expr></init></decl>,
						<decl><type ref="prev"/><name>ov</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Check if doubling t will overflow a word */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>HIGH_BIT_SET</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ov</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>w</name> <operator>=</operator> <name>t</name> <operator>+</operator> <name>t</name></expr>;</expr_stmt>

			<comment type="block">/* Check if adding u to w will overflow a word */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>ADD_WILL_OVERFLOW</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ov</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>w</name> <operator>+=</operator> <name>u</name></expr>;</expr_stmt>

			<expr_stmt><expr><operator>*</operator><name>dct</name> <operator>=</operator> <call><name>LOWER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>UPPER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>ov</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>w</name> <operator>+=</operator> <name>MP_DIGIT_MAX</name></expr>;</expr_stmt>	<comment type="block">/* MP_RADIX */</comment>
				<expr_stmt><expr><operator>++</operator><name>w</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name>w</name> <operator>=</operator> <name>w</name> <operator>+</operator> <operator>*</operator><name>dct</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>dct</name> <operator>=</operator> <operator>(</operator><name>mp_digit</name><operator>)</operator> <name>w</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>w</name> <operator>=</operator> <call><name>UPPER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>++</operator><name>dct</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>w</name> <operator>=</operator> <name>w</name> <operator>+</operator> <operator>*</operator><name>dct</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>dct</name> <operator>=</operator> <call><name>LOWER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>w</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>s_dadd</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mp_word</name></type>		<name>w</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>da</name> <init>= <expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>ua</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>mp_word</name><operator>)</operator> <operator>*</operator><name>da</name> <operator>+</operator> <name>b</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>da</name><operator>++</operator> <operator>=</operator> <call><name>LOWER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>UPPER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>ua</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>ua</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>ua</name></expr><operator>,</operator> <expr><operator>++</operator><name>da</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>mp_word</name><operator>)</operator> <operator>*</operator><name>da</name> <operator>+</operator> <name>w</name></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>da</name> <operator>=</operator> <call><name>LOWER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>UPPER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>w</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>da</name> <operator>=</operator> <operator>(</operator><name>mp_digit</name><operator>)</operator> <name>w</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>used</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>s_dmul</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mp_word</name></type>		<name>w</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>da</name> <init>= <expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>ua</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>ua</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>mp_word</name><operator>)</operator> <operator>*</operator><name>da</name> <operator>*</operator> <name>b</name> <operator>+</operator> <name>w</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>da</name><operator>++</operator> <operator>=</operator> <call><name>LOWER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>UPPER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>--</operator><name>ua</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>w</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>da</name> <operator>=</operator> <operator>(</operator><name>mp_digit</name><operator>)</operator> <name>w</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>used</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>s_dbmul</name><parameter_list>(<parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>da</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name> <modifier>*</modifier></type><name>dc</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>size_a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mp_word</name></type>		<name>w</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>size_a</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>mp_word</name><operator>)</operator> <operator>*</operator><name>da</name><operator>++</operator> <operator>*</operator> <operator>(</operator><name>mp_word</name><operator>)</operator> <name>b</name> <operator>+</operator> <name>w</name></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>dc</name><operator>++</operator> <operator>=</operator> <call><name>LOWER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>UPPER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>--</operator><name>size_a</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>w</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>dc</name> <operator>=</operator> <call><name>LOWER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>mp_digit</name></type>
<name>s_ddiv</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_digit</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mp_word</name></type>		<name>w</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>qdigit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>ua</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>da</name> <init>= <expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>ua</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>( <comment type="block">/* */</comment> <init>;</init> <condition><expr><name>ua</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>ua</name></expr><operator>,</operator> <expr><operator>--</operator><name>da</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>w</name> <operator>&lt;&lt;</operator> <name>MP_DIGIT_BIT</name><operator>)</operator> <operator>|</operator> <operator>*</operator><name>da</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>w</name> <operator>&gt;=</operator> <name>b</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>qdigit</name> <operator>=</operator> <name>w</name> <operator>/</operator> <name>b</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>w</name> <operator>=</operator> <name>w</name> <operator>%</operator> <name>b</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>qdigit</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>da</name> <operator>=</operator> <operator>(</operator><name>mp_digit</name><operator>)</operator> <name>qdigit</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>CLAMP</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>mp_digit</name><operator>)</operator> <name>w</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>s_qdiv</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>p2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>ndig</name> <init>= <expr><name>p2</name> <operator>/</operator> <name>MP_DIGIT_BIT</name></expr></init></decl>,
				<decl><type ref="prev"/><name>nbits</name> <init>= <expr><name>p2</name> <operator>%</operator> <name>MP_DIGIT_BIT</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>uz</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>ndig</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>mp_size</name></type>		<name>mark</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>to</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>from</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>ndig</name> <operator>&gt;=</operator> <name>uz</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>mp_int_zero</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>to</name> <operator>=</operator> <call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>from</name> <operator>=</operator> <name>to</name> <operator>+</operator> <name>ndig</name></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>mark</name> <operator>=</operator> <name>ndig</name></expr>;</init> <condition><expr><name>mark</name> <operator>&lt;</operator> <name>uz</name></expr>;</condition> <incr><expr><operator>++</operator><name>mark</name></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>to</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>from</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <name>uz</name> <operator>-</operator> <name>ndig</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>nbits</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>mp_digit</name></type>	<name>d</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>dz</name></decl>,
					<decl><type ref="prev"/><name>save</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>mp_size</name></type>		<name>up</name> <init>= <expr><name>MP_DIGIT_BIT</name> <operator>-</operator> <name>nbits</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>uz</name> <operator>=</operator> <call><name>MP_USED</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dz</name> <operator>=</operator> <call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>uz</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<for>for <control>( <comment type="block">/* */</comment> <init>;</init> <condition><expr><name>uz</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>uz</name></expr><operator>,</operator> <expr><operator>--</operator><name>dz</name></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>save</name> <operator>=</operator> <operator>*</operator><name>dz</name></expr>;</expr_stmt>

			<expr_stmt><expr><operator>*</operator><name>dz</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>dz</name> <operator>&gt;&gt;</operator> <name>nbits</name><operator>)</operator> <operator>|</operator> <operator>(</operator><name>d</name> <operator>&lt;&lt;</operator> <name>up</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>d</name> <operator>=</operator> <name>save</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>CLAMP</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>z</name><operator>-&gt;</operator><name>digits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>MP_ZPOS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>s_qmod</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>p2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>start</name> <init>= <expr><name>p2</name> <operator>/</operator> <name>MP_DIGIT_BIT</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>rest</name> <init>= <expr><name>p2</name> <operator>%</operator> <name>MP_DIGIT_BIT</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>uz</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_digit</name></type>	<name>mask</name> <init>= <expr><operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <name>rest</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>start</name> <operator>&lt;=</operator> <name>uz</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>digits</name><index>[<expr><name>start</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&amp;=</operator> <name>mask</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CLAMP</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>s_qmul</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>p2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>uz</name></decl>,
				<decl><type ref="prev"/><name>need</name></decl>,
				<decl><type ref="prev"/><name>rest</name></decl>,
				<decl><type ref="prev"/><name>extra</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>from</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>to</name></decl>,
				<decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>p2</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>uz</name> <operator>=</operator> <call><name>MP_USED</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>need</name> <operator>=</operator> <name>p2</name> <operator>/</operator> <name>MP_DIGIT_BIT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rest</name> <operator>=</operator> <name>p2</name> <operator>%</operator> <name>MP_DIGIT_BIT</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Figure out if we need an extra digit at the top end; this occurs if the
	 * topmost `rest' bits of the high-order digit of z are not zero, meaning
	 * they will be shifted off the end if not preserved
	 */</comment>
	<expr_stmt><expr><name>extra</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rest</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>dz</name> <init>= <expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>uz</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>dz</name> <operator>&gt;&gt;</operator> <operator>(</operator><name>MP_DIGIT_BIT</name> <operator>-</operator> <name>rest</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>extra</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_pad</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>uz</name> <operator>+</operator> <name>need</name> <operator>+</operator> <name>extra</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we need to shift by whole digits, do that in one pass, then to back
	 * and shift by partial digits.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>need</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>from</name> <operator>=</operator> <call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>uz</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>to</name> <operator>=</operator> <name>from</name> <operator>+</operator> <name>need</name></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>uz</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>to</name><operator>--</operator> <operator>=</operator> <operator>*</operator><name>from</name><operator>--</operator></expr>;</expr_stmt></block_content></block></for>

		<expr_stmt><expr><call><name>ZERO</name><argument_list>(<argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>need</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>uz</name> <operator>+=</operator> <name>need</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>rest</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>d</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>need</name></expr><operator>,</operator> <expr><name>from</name> <operator>=</operator> <call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>need</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>uz</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr><operator>,</operator> <expr><operator>++</operator><name>from</name></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>mp_digit</name></type>	<name>save</name> <init>= <expr><operator>*</operator><name>from</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><operator>*</operator><name>from</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>from</name> <operator>&lt;&lt;</operator> <name>rest</name><operator>)</operator> <operator>|</operator> <operator>(</operator><name>d</name> <operator>&gt;&gt;</operator> <operator>(</operator><name>MP_DIGIT_BIT</name> <operator>-</operator> <name>rest</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>d</name> <operator>=</operator> <name>save</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name>d</name> <operator>&gt;&gt;=</operator> <operator>(</operator><name>MP_DIGIT_BIT</name> <operator>-</operator> <name>rest</name><operator>)</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>d</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>from</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>uz</name> <operator>+=</operator> <name>extra</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <name>uz</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CLAMP</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Compute z = 2^p2 - |z|; requires that 2^p2 &gt;= |z|
   The sign of the result is always zero/positive.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>s_qsub</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>p2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mp_digit</name></type>	<name>hi</name> <init>= <expr><operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>p2</name> <operator>%</operator> <name>MP_DIGIT_BIT</name><operator>)</operator><operator>)</operator></expr></init></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>zp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>tdig</name> <init>= <expr><operator>(</operator><name>p2</name> <operator>/</operator> <name>MP_DIGIT_BIT</name><operator>)</operator></expr></init></decl>,
				<decl><type ref="prev"/><name>pos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_word</name></type>		<name>w</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_pad</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>tdig</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>pos</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>zp</name> <operator>=</operator> <call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>pos</name> <operator>&lt;</operator> <name>tdig</name></expr>;</condition> <incr><expr><operator>++</operator><name>pos</name></expr><operator>,</operator> <expr><operator>++</operator><name>zp</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>mp_word</name><operator>)</operator> <name>MP_DIGIT_MAX</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>-</operator> <name>w</name> <operator>-</operator> <operator>(</operator><name>mp_word</name><operator>)</operator> <operator>*</operator><name>zp</name></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>zp</name> <operator>=</operator> <call><name>LOWER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>w</name> <operator>=</operator> <ternary><condition><expr><call><name>UPPER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>mp_word</name><operator>)</operator> <name>MP_DIGIT_MAX</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>hi</name><operator>)</operator> <operator>-</operator> <name>w</name> <operator>-</operator> <operator>(</operator><name>mp_word</name><operator>)</operator> <operator>*</operator><name>zp</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>zp</name> <operator>=</operator> <call><name>LOWER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>UPPER_HALF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* no borrow out should be possible */</comment>

	<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>MP_ZPOS</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CLAMP</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>s_dp2k</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>dp</name> <init>= <expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></init></decl>,
				<decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>dp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><operator>*</operator><name>dp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>k</name> <operator>+=</operator> <name>MP_DIGIT_BIT</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>++</operator><name>dp</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><name>d</name> <operator>=</operator> <operator>*</operator><name>dp</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>d</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>d</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>++</operator><name>k</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>k</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>s_isp2</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>uz</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></init></decl>,
				<decl><type ref="prev"/><name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>dz</name> <init>= <expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></init></decl>,
				<decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>uz</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>dz</name><operator>++</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>k</name> <operator>+=</operator> <name>MP_DIGIT_BIT</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>--</operator><name>uz</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><name>d</name> <operator>=</operator> <operator>*</operator><name>dz</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>d</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>d</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>++</operator><name>k</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>d</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><operator>(</operator><name>int</name><operator>)</operator> <name>k</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>s_2expt</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_small</name></type> <name>k</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>ndig</name></decl>,
				<decl><type ref="prev"/><name>rest</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>dz</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ndig</name> <operator>=</operator> <operator>(</operator><name>k</name> <operator>+</operator> <name>MP_DIGIT_BIT</name><operator>)</operator> <operator>/</operator> <name>MP_DIGIT_BIT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rest</name> <operator>=</operator> <name>k</name> <operator>%</operator> <name>MP_DIGIT_BIT</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_pad</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>ndig</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>dz</name> <operator>=</operator> <call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ZERO</name><argument_list>(<argument><expr><name>dz</name></expr></argument>, <argument><expr><name>ndig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><operator>(</operator><name>dz</name> <operator>+</operator> <name>ndig</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>=</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <name>rest</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <name>ndig</name></expr>;</expr_stmt>

	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>s_norm</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mp_digit</name></type>	<name>d</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>digits</name><index>[<expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>d</name> <operator>&lt;</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>mp_digit</name><operator>)</operator> <operator>(</operator><name>MP_DIGIT_BIT</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>)</condition>
	<block>{<block_content>							<comment type="block">/* d &lt; (MP_RADIX / 2) */</comment>
		<expr_stmt><expr><name>d</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>++</operator><name>k</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* These multiplications can't fail */</comment>
	<if_stmt><if>if <condition>(<expr><name>k</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>s_qmul</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>(</operator><name>mp_size</name><operator>)</operator> <name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>s_qmul</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><operator>(</operator><name>mp_size</name><operator>)</operator> <name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>k</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>mp_result</name></type>
<name>s_brmu</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>m</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>um</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_pad</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>um</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>MP_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>s_2expt</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>MP_DIGIT_BIT</name> <operator>*</operator> <name>um</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>mp_int_div</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>s_reduce</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>mu</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>q1</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>q2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>um</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></init></decl>,
				<decl><type ref="prev"/><name>umb_p1</name></decl>,
				<decl><type ref="prev"/><name>umb_m1</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>umb_p1</name> <operator>=</operator> <operator>(</operator><name>um</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>MP_DIGIT_BIT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>umb_m1</name> <operator>=</operator> <operator>(</operator><name>um</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>MP_DIGIT_BIT</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>q1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>MP_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Compute q2 = floor((floor(x / b^(k-1)) * mu) / b^(k+1)) */</comment>
	<expr_stmt><expr><call><name>s_qdiv</name><argument_list>(<argument><expr><name>q1</name></expr></argument>, <argument><expr><name>umb_m1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UMUL</name><argument_list>(<argument><expr><name>q1</name></expr></argument>, <argument><expr><name>mu</name></expr></argument>, <argument><expr><name>q2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>s_qdiv</name><argument_list>(<argument><expr><name>q2</name></expr></argument>, <argument><expr><name>umb_p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set x = x mod b^(k+1) */</comment>
	<expr_stmt><expr><call><name>s_qmod</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>umb_p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now, q is a guess for the quotient a / m. Compute x - q * m mod
	 * b^(k+1), replacing x.  This may be off by a factor of 2m, but no more
	 * than that.
	 */</comment>
	<expr_stmt><expr><call><name>UMUL</name><argument_list>(<argument><expr><name>q2</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>q1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>s_qmod</name><argument_list>(<argument><expr><name>q1</name></expr></argument>, <argument><expr><name>umb_p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>mp_int_sub</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>q1</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* can't fail */</comment>

	<comment type="block">/*
	 * The result may be &lt; 0; if it is, add b^(k+1) to pin it in the proper
	 * range.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>CMPZ</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>s_qsub</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>umb_p1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If x &gt; m, we need to back it off until it is in range.  This will be
	 * required at most twice.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>mp_int_compare</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>mp_int_sub</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>mp_int_compare</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>mp_int_sub</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* At this point, x has been properly reduced. */</comment>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Perform modular exponentiation using Barrett's method, where mu is the
   reduction constant for m.  Assumes a &lt; m, b &gt; 0. */</comment>
<function><type><specifier>static</specifier> <name>mp_result</name></type>
<name>s_embar</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>mu</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mp_digit</name></type>	<name>umu</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>mu</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>dbt</name> <init>= <expr><name>db</name> <operator>+</operator> <call><name>MP_USED</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>DECLARE_TEMP</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>GROW</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">4</literal> <operator>*</operator> <name>umu</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>GROW</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">4</literal> <operator>*</operator> <name>umu</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>GROW</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">4</literal> <operator>*</operator> <name>umu</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ZERO</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>digits</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ZERO</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>digits</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ZERO</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>digits</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>mp_int_set_value</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Take care of low-order digits */</comment>
	<while>while <condition>(<expr><name>db</name> <operator>&lt;</operator> <name>dbt</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>mp_digit</name></type>	<name>d</name> <init>= <expr><operator>*</operator><name>db</name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>MP_DIGIT_BIT</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr><operator>,</operator> <expr><name>d</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>d</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* The use of a second temporary avoids allocation */</comment>
				<expr_stmt><expr><call><name>UMUL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_reduce</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>mu</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><name>MP_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>USQR</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>MP_ZPOS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_reduce</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>mu</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><name>MP_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>MP_SIGN</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>MP_ZPOS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><operator>++</operator><name>db</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Take care of highest-order digit */</comment>
	<decl_stmt><decl><type><name>mp_digit</name></type>	<name>d</name> <init>= <expr><operator>*</operator><name>dbt</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>d</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>UMUL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_reduce</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>mu</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><name>MP_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>d</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>d</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>USQR</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_reduce</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>mu</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><name>MP_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>mp_int_copy</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>CLEANUP_TEMP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>MP_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Division of nonnegative integers

   This function implements division algorithm for unsigned multi-precision
   integers. The algorithm is based on Algorithm D from Knuth's "The Art of
   Computer Programming", 3rd ed. 1998, pg 272-273.

   We diverge from Knuth's algorithm in that we do not perform the subtraction
   from the remainder until we have determined that we have the correct
   quotient digit. This makes our algorithm less efficient that Knuth because
   we might have to perform multiple multiplication and comparison steps before
   the subtraction. The advantage is that it is easy to implement and ensure
   correctness without worrying about underflow from the subtraction.

   inputs: u   a n+m digit integer in base b (b is 2^MP_DIGIT_BIT)
		   v   a n   digit integer in base b (b is 2^MP_DIGIT_BIT)
		   n &gt;= 1
		   m &gt;= 0
  outputs: u / v stored in u
		   u % v stored in v
 */</comment>
<function><type><specifier>static</specifier> <name>mp_result</name></type>
<name>s_udiv_knuth</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>u</name></decl></parameter>, <parameter><decl><type><name>mp_int</name></type> <name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Force signs to positive */</comment>
	<expr_stmt><expr><name><name>u</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>MP_ZPOS</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>MP_ZPOS</name></expr>;</expr_stmt>

	<comment type="block">/* Use simple division algorithm when v is only one digit long */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>mp_digit</name></type>	<name>d</name></decl>,
					<decl><type ref="prev"/><name>rem</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>d</name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>digits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rem</name> <operator>=</operator> <call><name>s_ddiv</name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>mp_int_set_value</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>rem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>MP_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Algorithm D
	 *
	 * The n and m variables are defined as used by Knuth. u is an n digit
	 * number with digits u_{n-1}..u_0. v is an n+m digit number with digits
	 * from v_{m+n-1}..v_0. We require that n &gt; 1 and m &gt;= 0
	 */</comment>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>n</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>m</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>n</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>&gt;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* assert(m &gt;= 0) follows because m is unsigned. */</comment>

	<comment type="block">/*
	 * D1: Normalize. The normalization step provides the necessary condition
	 * for Theorem B, which states that the quotient estimate for q_j, call it
	 * qhat
	 *
	 * qhat = u_{j+n}u_{j+n-1} / v_{n-1}
	 *
	 * is bounded by
	 *
	 * qhat - 2 &lt;= q_j &lt;= qhat.
	 *
	 * That is, qhat is always greater than the actual quotient digit q, and
	 * it is never more than two larger than the actual quotient digit.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>k</name> <init>= <expr><call><name>s_norm</name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Extend size of u by one if needed.
	 *
	 * The algorithm begins with a value of u that has one more digit of
	 * input. The normalization step sets u_{m+n}..u_0 = 2^k * u_{m+n-1}..u_0.
	 * If the multiplication did not increase the number of digits of u, we
	 * need to add a leading zero here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>MP_USED</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>m</name> <operator>+</operator> <name>n</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_pad</name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr><name>m</name> <operator>+</operator> <name>n</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>MP_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>u</name><operator>-&gt;</operator><name>digits</name><index>[<expr><name>m</name> <operator>+</operator> <name>n</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>u</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <name>m</name> <operator>+</operator> <name>n</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Add a leading 0 to v.
	 *
	 * The multiplication in step D4 multiplies qhat * 0v_{n-1}..v_0.  We need
	 * to add the leading zero to v here to ensure that the multiplication
	 * will produce the full n+1 digit result.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>s_pad</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>MP_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>digits</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize temporary variables q and t. q allocates space for m+1
	 * digits to store the quotient digits t allocates space for n+1 digits to
	 * hold the result of q_j*v
	 */</comment>
	<expr_stmt><expr><call><name>DECLARE_TEMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>GROW</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>m</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>GROW</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* D2: Initialize j */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name> <init>= <expr><name>m</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mpz_t</name></type>		<name>r</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>r</name><operator>.</operator><name>digits</name></name> <operator>=</operator> <call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>j</name></expr>;</expr_stmt>	<comment type="block">/* The contents of r are shared with u */</comment>
	<expr_stmt><expr><name><name>r</name><operator>.</operator><name>used</name></name> <operator>=</operator> <name>n</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>r</name><operator>.</operator><name>sign</name></name> <operator>=</operator> <name>MP_ZPOS</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>r</name><operator>.</operator><name>alloc</name></name> <operator>=</operator> <call><name>MP_ALLOC</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ZERO</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>digits</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Calculate the m+1 digits of the quotient result */</comment>
	<for>for <control>(<init>;</init> <condition><expr><name>j</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* D3: Calculate q' */</comment>
		<comment type="block">/* r-&gt;digits is aligned to position j of the number u */</comment>
		<decl_stmt><decl><type><name>mp_word</name></type>		<name>pfx</name></decl>,
					<decl><type ref="prev"/><name>qhat</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>pfx</name> <operator>=</operator> <name><name>r</name><operator>.</operator><name>digits</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pfx</name> <operator>&lt;&lt;=</operator> <name>MP_DIGIT_BIT</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>pfx</name> <operator>&lt;&lt;=</operator> <name>MP_DIGIT_BIT</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>pfx</name> <operator>|=</operator> <name><name>r</name><operator>.</operator><name>digits</name><index>[<expr><name>n</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt> <comment type="block">/* pfx = u_{j+n}{j+n-1} */</comment>

		<expr_stmt><expr><name>qhat</name> <operator>=</operator> <name>pfx</name> <operator>/</operator> <name><name>v</name><operator>-&gt;</operator><name>digits</name><index>[<expr><name>n</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check to see if qhat &gt; b, and decrease qhat if so. Theorem B
		 * guarantess that qhat is at most 2 larger than the actual value, so
		 * it is possible that qhat is greater than the maximum value that
		 * will fit in a digit
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>qhat</name> <operator>&gt;</operator> <name>MP_DIGIT_MAX</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>qhat</name> <operator>=</operator> <name>MP_DIGIT_MAX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * D4,D5,D6: Multiply qhat * v and test for a correct value of q
		 *
		 * We proceed a bit different than the way described by Knuth. This
		 * way is simpler but less efficent. Instead of doing the multiply and
		 * subtract then checking for underflow, we first do the multiply of
		 * qhat * v and see if it is larger than the current remainder r. If
		 * it is larger, we decrease qhat by one and try again. We may need to
		 * decrease qhat one more time before we get a value that is smaller
		 * than r.
		 *
		 * This way is less efficent than Knuth becuase we do more multiplies,
		 * but we do not need to worry about underflow this way.
		 */</comment>
		<comment type="block">/* t = qhat * v */</comment>
		<expr_stmt><expr><call><name>s_dbmul</name><argument_list>(<argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>mp_digit</name><operator>)</operator> <name>qhat</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>digits</name></expr></argument>, <argument><expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>used</name> <operator>=</operator> <name>n</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CLAMP</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Clamp r for the comparison. Comparisons do not like leading zeros. */</comment>
		<expr_stmt><expr><call><name>CLAMP</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>s_ucmp</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>						<comment type="block">/* would the remainder be negative? */</comment>
			<expr_stmt><expr><name>qhat</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>			<comment type="block">/* try a smaller q */</comment>
			<expr_stmt><expr><call><name>s_dbmul</name><argument_list>(<argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>mp_digit</name><operator>)</operator> <name>qhat</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>digits</name></expr></argument>, <argument><expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>used</name> <operator>=</operator> <name>n</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CLAMP</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>s_ucmp</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>					<comment type="block">/* would the remainder be negative? */</comment>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>qhat</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>qhat</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>		<comment type="block">/* try a smaller q */</comment>
				<expr_stmt><expr><call><name>s_dbmul</name><argument_list>(<argument><expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>mp_digit</name><operator>)</operator> <name>qhat</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>digits</name></expr></argument>, <argument><expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>used</name> <operator>=</operator> <name>n</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>CLAMP</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>s_ucmp</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <literal type="string">"The mathematics failed us."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Unclamp r. The D algorithm expects r = u_{j+n}..u_j to always be
		 * n+1 digits long.
		 */</comment>
		<expr_stmt><expr><name><name>r</name><operator>.</operator><name>used</name></name> <operator>=</operator> <name>n</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * D4: Multiply and subtract
		 *
		 * Note: The multiply was completed above so we only need to subtract
		 * here.
		 */</comment>
		<expr_stmt><expr><call><name>s_usub</name><argument_list>(<argument><expr><name><name>r</name><operator>.</operator><name>digits</name></name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>digits</name></expr></argument>, <argument><expr><name><name>r</name><operator>.</operator><name>digits</name></name></expr></argument>, <argument><expr><name><name>r</name><operator>.</operator><name>used</name></name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * D5: Test remainder
		 *
		 * Note: Not needed because we always check that qhat is the correct
		 * value before performing the subtract.  Value cast to mp_digit to
		 * prevent warning, qhat has been clamped to MP_DIGIT_MAX
		 */</comment>
		<expr_stmt><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>digits</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>mp_digit</name><operator>)</operator> <name>qhat</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * D6: Add back Note: Not needed because we always check that qhat is
		 * the correct value before performing the subtract.
		 */</comment>

		<comment type="block">/* D7: Loop on j */</comment>
		<expr_stmt><expr><name><name>r</name><operator>.</operator><name>digits</name></name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ZERO</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>digits</name></expr></argument>, <argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Get rid of leading zeros in q */</comment>
	<expr_stmt><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>used</name> <operator>=</operator> <name>m</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CLAMP</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Denormalize the remainder */</comment>
	<expr_stmt><expr><call><name>CLAMP</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>					<comment type="block">/* use u here because the r.digits pointer is
								 * off-by-one */</comment>
	<if_stmt><if>if <condition>(<expr><name>k</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>s_qdiv</name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>			<comment type="block">/* ok:  0 &lt;= r &lt; v */</comment>
	<expr_stmt><expr><call><name>mp_int_copy</name><argument_list>(<argument><expr><call><name>TEMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* ok:  q &lt;= u     */</comment>

	<expr_stmt><expr><call><name>CLEANUP_TEMP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>MP_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>s_outlen</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>r</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>r</name> <operator>&gt;=</operator> <name>MP_MIN_RADIX</name> <operator>&amp;&amp;</operator> <name>r</name> <operator>&lt;=</operator> <name>MP_MAX_RADIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>mp_result</name></type>	<name>bits</name> <init>= <expr><call><name>mp_int_count_bits</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>raw</name> <init>= <expr><operator>(</operator><name>double</name><operator>)</operator> <name>bits</name> <operator>*</operator> <name><name>s_log2</name><index>[<expr><name>r</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<return>return <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>raw</name> <operator>+</operator> <literal type="number">0.999999</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>mp_size</name></type>
<name>s_inlen</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>mp_size</name></type> <name>r</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>raw</name> <init>= <expr><operator>(</operator><name>double</name><operator>)</operator> <name>len</name> <operator>/</operator> <name><name>s_log2</name><index>[<expr><name>r</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>bits</name> <init>= <expr><operator>(</operator><name>mp_size</name><operator>)</operator> <operator>(</operator><name>raw</name> <operator>+</operator> <literal type="number">0.5</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

	<return>return <expr><operator>(</operator><name>mp_size</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>bits</name> <operator>+</operator> <operator>(</operator><name>MP_DIGIT_BIT</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <name>MP_DIGIT_BIT</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>s_ch2val</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>r</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>out</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * In some locales, isalpha() accepts characters outside the range A-Z,
	 * producing out&lt;0 or out&gt;=36.  The "out &gt;= r" check will always catch
	 * out&gt;=36.  Though nothing explicitly catches out&lt;0, our caller reacts
	 * the same way to every negative return value.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>out</name> <operator>=</operator> <name>c</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>r</name> <operator>&gt;</operator> <literal type="number">10</literal> <operator>&amp;&amp;</operator> <call><name>isalpha</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>toupper</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="char">'A'</literal> <operator>+</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>

	<return>return <expr><ternary><condition><expr><operator>(</operator><name>out</name> <operator>&gt;=</operator> <name>r</name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><name>out</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name></type>
<name>s_val2ch</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>caps</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>v</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>v</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>v</name> <operator>+</operator> <literal type="char">'0'</literal></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name>out</name> <init>= <expr><operator>(</operator><name>v</name> <operator>-</operator> <literal type="number">10</literal><operator>)</operator> <operator>+</operator> <literal type="char">'a'</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>caps</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><call><name>toupper</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>out</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<return>return <expr><name>out</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>s_2comp</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>s</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name> <init>= <expr><operator>~</operator><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>s</name> <operator>=</operator> <name>c</name> <operator>+</operator> <name>s</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>c</name> <operator>=</operator> <name>s</name> <operator>&amp;</operator> <name>UCHAR_MAX</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>s</name> <operator>&gt;&gt;=</operator> <name>CHAR_BIT</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* last carry out is ignored */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>mp_result</name></type>
<name>s_tobin</name><parameter_list>(<parameter><decl><type><name>mp_int</name></type> <name>z</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>limpos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pad</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>limit</name> <init>= <expr><operator>*</operator><name>limpos</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_size</name></type>		<name>uz</name> <init>= <expr><call><name>MP_USED</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mp_digit</name>   <modifier>*</modifier></type><name>dz</name> <init>= <expr><call><name>MP_DIGITS</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>uz</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pos</name> <operator>&lt;</operator> <name>limit</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>mp_digit</name></type>	<name>d</name> <init>= <expr><operator>*</operator><name>dz</name><operator>++</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>mp_digit</name></expr></argument>)</argument_list></sizeof></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pos</name> <operator>&lt;</operator> <name>limit</name></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>buf</name><index>[<expr><name>pos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>d</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>d</name> <operator>&gt;&gt;=</operator> <name>CHAR_BIT</name></expr>;</expr_stmt>

			<comment type="block">/* Don't write leading zeroes */</comment>
			<if_stmt><if>if <condition>(<expr><name>d</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>uz</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>			<comment type="block">/* exit loop without signaling truncation */</comment>
		</block_content>}</block></for>

		<comment type="block">/* Detect truncation (loop exited with pos &gt;= limit) */</comment>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><operator>--</operator><name>uz</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>pad</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>buf</name><index>[<expr><name>pos</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <operator>(</operator><name>CHAR_BIT</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name>limit</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>buf</name><index>[<expr><name>pos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>uz</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Digits are in reverse order, fix that */</comment>
	<expr_stmt><expr><call><name>REV</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Return the number of bytes actually written */</comment>
	<expr_stmt><expr><operator>*</operator><name>limpos</name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>

	<return>return <expr><ternary><condition><expr><operator>(</operator><name>uz</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>MP_OK</name></expr> </then><else>: <expr><name>MP_TRUNC</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Here there be dragons */</comment>
</unit>
