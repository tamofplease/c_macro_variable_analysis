<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/pl/tcl/pltcl.c"><comment type="block" format="doxygen">/**********************************************************************
 * pltcl.c		- PostgreSQL support for Tcl as
 *				  procedural language (PL)
 *
 *	  src/pl/tcl/pltcl.c
 *
 **********************************************************************/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;tcl.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/objectaccess.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/event_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/spi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_func.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/regproc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>


<expr_stmt><expr><name>PG_MODULE_MAGIC</name></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_TCL_VERSION</name><parameter_list>(<parameter><type><name>maj</name></type></parameter>,<parameter><type><name>min</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((TCL_MAJOR_VERSION &gt; maj) || \
	 (TCL_MAJOR_VERSION == maj &amp;&amp; TCL_MINOR_VERSION &gt;= min))</cpp:value></cpp:define>

<comment type="block">/* Insist on Tcl &gt;= 8.4 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>HAVE_TCL_VERSION</name><argument_list>(<argument><expr><literal type="number">8</literal><operator>,</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> PostgreSQL only supports Tcl 8.4 or later.</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Hack to deal with Tcl 8.6 const-ification without losing compatibility */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>CONST86</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONST86</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* define our text domain for translations */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TEXTDOMAIN</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEXTDOMAIN</name></cpp:macro> <cpp:value>PG_TEXTDOMAIN("pltcl")</cpp:value></cpp:define>


<comment type="block">/*
 * Support for converting between UTF8 (which is what all strings going into
 * or out of Tcl should be) and the database encoding.
 *
 * If you just use utf_u2e() or utf_e2u() directly, they will leak some
 * palloc'd space when doing a conversion.  This is not worth worrying about
 * if it only happens, say, once per PL/Tcl function call.  If it does seem
 * worth worrying about, use the wrapper macros.
 */</comment>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>char</name> <modifier>*</modifier></type>
<name>utf_u2e</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>pg_any_to_server</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PG_UTF8</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>char</name> <modifier>*</modifier></type>
<name>utf_e2u</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>pg_server_to_any</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PG_UTF8</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UTF_BEGIN</name></cpp:macro> \
	<cpp:value>do { \
		const char *_pltcl_utf_src = NULL; \
		char *_pltcl_utf_dst = NULL</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UTF_END</name></cpp:macro> \
	<cpp:value>if (_pltcl_utf_src != (const char *) _pltcl_utf_dst) \
			pfree(_pltcl_utf_dst); \
	} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UTF_U2E</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(_pltcl_utf_dst = utf_u2e(_pltcl_utf_src = (x)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UTF_E2U</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(_pltcl_utf_dst = utf_e2u(_pltcl_utf_src = (x)))</cpp:value></cpp:define>


<comment type="block" format="doxygen">/**********************************************************************
 * Information associated with a Tcl interpreter.  We have one interpreter
 * that is used for all pltclu (untrusted) functions.  For pltcl (trusted)
 * functions, there is a separate interpreter for each effective SQL userid.
 * (This is needed to ensure that an unprivileged user can't inject Tcl code
 * that'll be executed with the privileges of some other SQL user.)
 *
 * The pltcl_interp_desc structs are kept in a Postgres hash table indexed
 * by userid OID, with OID 0 used for the single untrusted interpreter.
 **********************************************************************/</comment>
<typedef>typedef <type><struct>struct <name>pltcl_interp_desc</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>user_id</name></decl>;</decl_stmt>		<comment type="block">/* Hash key (must be first!) */</comment>
	<decl_stmt><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl>;</decl_stmt>			<comment type="block">/* The interpreter */</comment>
	<decl_stmt><decl><type><name>Tcl_HashTable</name></type> <name>query_hash</name></decl>;</decl_stmt>	<comment type="block">/* pltcl_query_desc structs */</comment>
}</block></struct></type> <name>pltcl_interp_desc</name>;</typedef>


<comment type="block" format="doxygen">/**********************************************************************
 * The information we cache about loaded procedures
 *
 * The pltcl_proc_desc struct itself, as well as all subsidiary data,
 * is stored in the memory context identified by the fn_cxt field.
 * We can reclaim all the data by deleting that context, and should do so
 * when the fn_refcount goes to zero.  (But note that we do not bother
 * trying to clean up Tcl's copy of the procedure definition: it's Tcl's
 * problem to manage its memory when we replace a proc definition.  We do
 * not clean up pltcl_proc_descs when a pg_proc row is deleted, only when
 * it is updated, and the same policy applies to Tcl's copy as well.)
 *
 * Note that the data in this struct is shared across all active calls;
 * nothing except the fn_refcount should be changed by a call instance.
 **********************************************************************/</comment>
<typedef>typedef <type><struct>struct <name>pltcl_proc_desc</name>
<block>{
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>user_proname</name></decl>;</decl_stmt>	<comment type="block">/* user's name (from pg_proc.proname) */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>internal_proname</name></decl>;</decl_stmt>	<comment type="block">/* Tcl name (based on function OID) */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>fn_cxt</name></decl>;</decl_stmt>		<comment type="block">/* memory context for this procedure */</comment>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>fn_refcount</name></decl>;</decl_stmt>	<comment type="block">/* number of active references */</comment>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>fn_xmin</name></decl>;</decl_stmt>		<comment type="block">/* xmin of pg_proc row */</comment>
	<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>fn_tid</name></decl>;</decl_stmt>		<comment type="block">/* TID of pg_proc row */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>fn_readonly</name></decl>;</decl_stmt>	<comment type="block">/* is function readonly? */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>lanpltrusted</name></decl>;</decl_stmt>	<comment type="block">/* is it pltcl (vs. pltclu)? */</comment>
	<decl_stmt><decl><type><name>pltcl_interp_desc</name> <modifier>*</modifier></type><name>interp_desc</name></decl>;</decl_stmt> <comment type="block">/* interpreter to use */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>result_typid</name></decl>;</decl_stmt>	<comment type="block">/* OID of fn's result type */</comment>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>result_in_func</name></decl>;</decl_stmt> <comment type="block">/* input function for fn's result type */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>result_typioparam</name></decl>;</decl_stmt>	<comment type="block">/* param to pass to same */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>fn_retisset</name></decl>;</decl_stmt>	<comment type="block">/* true if function returns a set */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>fn_retistuple</name></decl>;</decl_stmt>	<comment type="block">/* true if function returns composite */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>fn_retisdomain</name></decl>;</decl_stmt> <comment type="block">/* true if function returns domain */</comment>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>domain_info</name></decl>;</decl_stmt>	<comment type="block">/* opaque cache for domain checks */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name></decl>;</decl_stmt>			<comment type="block">/* number of arguments */</comment>
	<comment type="block">/* these arrays have nargs entries: */</comment>
	<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>arg_out_func</name></decl>;</decl_stmt>	<comment type="block">/* output fns for arg types */</comment>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>arg_is_rowtype</name></decl>;</decl_stmt> <comment type="block">/* is each arg composite? */</comment>
}</block></struct></type> <name>pltcl_proc_desc</name>;</typedef>


<comment type="block" format="doxygen">/**********************************************************************
 * The information we cache about prepared and saved plans
 **********************************************************************/</comment>
<typedef>typedef <type><struct>struct <name>pltcl_query_desc</name>
<block>{
	<decl_stmt><decl><type><name>char</name></type>		<name><name>qname</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SPIPlanPtr</name></type>	<name>plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>argtypes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>arginfuncs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>argtypioparams</name></decl>;</decl_stmt>
}</block></struct></type> <name>pltcl_query_desc</name>;</typedef>


<comment type="block" format="doxygen">/**********************************************************************
 * For speedy lookup, we maintain a hash table mapping from
 * function OID + trigger flag + user OID to pltcl_proc_desc pointers.
 * The reason the pltcl_proc_desc struct isn't directly part of the hash
 * entry is to simplify recovery from errors during compile_pltcl_function.
 *
 * Note: if the same function is called by multiple userIDs within a session,
 * there will be a separate pltcl_proc_desc entry for each userID in the case
 * of pltcl functions, but only one entry for pltclu functions, because we
 * set user_id = 0 for that case.
 **********************************************************************/</comment>
<typedef>typedef <type><struct>struct <name>pltcl_proc_key</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>proc_id</name></decl>;</decl_stmt>		<comment type="block">/* Function OID */</comment>

	<comment type="block">/*
	 * is_trigger is really a bool, but declare as Oid to ensure this struct
	 * contains no padding
	 */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>is_trigger</name></decl>;</decl_stmt>		<comment type="block">/* is it a trigger function? */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>user_id</name></decl>;</decl_stmt>		<comment type="block">/* User calling the function, or 0 */</comment>
}</block></struct></type> <name>pltcl_proc_key</name>;</typedef>

<typedef>typedef <type><struct>struct <name>pltcl_proc_ptr</name>
<block>{
	<decl_stmt><decl><type><name>pltcl_proc_key</name></type> <name>proc_key</name></decl>;</decl_stmt>	<comment type="block">/* Hash key (must be first!) */</comment>
	<decl_stmt><decl><type><name>pltcl_proc_desc</name> <modifier>*</modifier></type><name>proc_ptr</name></decl>;</decl_stmt>
}</block></struct></type> <name>pltcl_proc_ptr</name>;</typedef>


<comment type="block" format="doxygen">/**********************************************************************
 * Per-call state
 **********************************************************************/</comment>
<typedef>typedef <type><struct>struct <name>pltcl_call_state</name>
<block>{
	<comment type="block">/* Call info struct, or NULL in a trigger */</comment>
	<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl>;</decl_stmt>

	<comment type="block">/* Trigger data, if we're in a normal (not event) trigger; else NULL */</comment>
	<decl_stmt><decl><type><name>TriggerData</name> <modifier>*</modifier></type><name>trigdata</name></decl>;</decl_stmt>

	<comment type="block">/* Function we're executing (NULL if not yet identified) */</comment>
	<decl_stmt><decl><type><name>pltcl_proc_desc</name> <modifier>*</modifier></type><name>prodesc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Information for SRFs and functions returning composite types.
	 * ret_tupdesc and attinmeta are set up if either fn_retistuple or
	 * fn_retisset, since even a scalar-returning SRF needs a tuplestore.
	 */</comment>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>ret_tupdesc</name></decl>;</decl_stmt>	<comment type="block">/* return rowtype, if retistuple or retisset */</comment>
	<decl_stmt><decl><type><name>AttInMetadata</name> <modifier>*</modifier></type><name>attinmeta</name></decl>;</decl_stmt>	<comment type="block">/* metadata for building tuples of that type */</comment>

	<decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsi</name></decl>;</decl_stmt>			<comment type="block">/* passed-in ReturnSetInfo, if any */</comment>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tuple_store</name></decl>;</decl_stmt>	<comment type="block">/* SRFs accumulate result here */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>tuple_store_cxt</name></decl>;</decl_stmt>	<comment type="block">/* context and resowner for tuplestore */</comment>
	<decl_stmt><decl><type><name>ResourceOwner</name></type> <name>tuple_store_owner</name></decl>;</decl_stmt>
}</block></struct></type> <name>pltcl_call_state</name>;</typedef>


<comment type="block" format="doxygen">/**********************************************************************
 * Global data
 **********************************************************************/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>pltcl_start_proc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>pltclu_start_proc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>pltcl_pm_init_done</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Tcl_Interp</name> <modifier>*</modifier></type><name>pltcl_hold_interp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>pltcl_interp_htab</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>pltcl_proc_htab</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* this is saved and restored by pltcl_handler */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>pltcl_call_state</name> <modifier>*</modifier></type><name>pltcl_current_call_state</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block" format="doxygen">/**********************************************************************
 * Lookup table for SQLSTATE condition names
 **********************************************************************/</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>label</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sqlerrstate</name></decl>;</decl_stmt>
}</block></struct></type> <name>TclExceptionNameMap</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TclExceptionNameMap</name></type> <name><name>exception_name_map</name><index>[]</index></name> <init>= <expr><block>{
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pltclerrcodes.h"</cpp:file></cpp:include>		<comment type="block">/* pgrminclude ignore */</comment>
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block" format="doxygen">/**********************************************************************
 * Forward declarations
 **********************************************************************/</comment>
<function_decl><type><name>void</name></type>		<name>_PG_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pltcl_init_interp</name><parameter_list>(<parameter><decl><type><name>pltcl_interp_desc</name> <modifier>*</modifier></type><name>interp_desc</name></decl></parameter>,
							  <parameter><decl><type><name>Oid</name></type> <name>prolang</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>pltrusted</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>pltcl_interp_desc</name> <modifier>*</modifier></type><name>pltcl_fetch_interp</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>prolang</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>pltrusted</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>call_pltcl_start_proc</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>prolang</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>pltrusted</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>start_proc_error_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>pltcl_handler</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>pltrusted</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>pltcl_func_handler</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>, <parameter><decl><type><name>pltcl_call_state</name> <modifier>*</modifier></type><name>call_state</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>pltrusted</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HeapTuple</name></type> <name>pltcl_trigger_handler</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>, <parameter><decl><type><name>pltcl_call_state</name> <modifier>*</modifier></type><name>call_state</name></decl></parameter>,
									   <parameter><decl><type><name>bool</name></type> <name>pltrusted</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pltcl_event_trigger_handler</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>, <parameter><decl><type><name>pltcl_call_state</name> <modifier>*</modifier></type><name>call_state</name></decl></parameter>,
										<parameter><decl><type><name>bool</name></type> <name>pltrusted</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>throw_tcl_error</name><parameter_list>(<parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>proname</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>pltcl_proc_desc</name> <modifier>*</modifier></type><name>compile_pltcl_function</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>fn_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>tgreloid</name></decl></parameter>,
											   <parameter><decl><type><name>bool</name></type> <name>is_event_trigger</name></decl></parameter>,
											   <parameter><decl><type><name>bool</name></type> <name>pltrusted</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>pltcl_elog</name><parameter_list>(<parameter><decl><type><name>ClientData</name></type> <name>cdata</name></decl></parameter>, <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>, <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>objv</name><index>[]</index></name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pltcl_construct_errorCode</name><parameter_list>(<parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>, <parameter><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pltcl_get_condition_name</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sqlstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>pltcl_quote</name><parameter_list>(<parameter><decl><type><name>ClientData</name></type> <name>cdata</name></decl></parameter>, <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>, <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>objv</name><index>[]</index></name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>pltcl_argisnull</name><parameter_list>(<parameter><decl><type><name>ClientData</name></type> <name>cdata</name></decl></parameter>, <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
							<parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>, <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>objv</name><index>[]</index></name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>pltcl_returnnull</name><parameter_list>(<parameter><decl><type><name>ClientData</name></type> <name>cdata</name></decl></parameter>, <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>, <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>objv</name><index>[]</index></name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>pltcl_returnnext</name><parameter_list>(<parameter><decl><type><name>ClientData</name></type> <name>cdata</name></decl></parameter>, <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>, <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>objv</name><index>[]</index></name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>pltcl_SPI_execute</name><parameter_list>(<parameter><decl><type><name>ClientData</name></type> <name>cdata</name></decl></parameter>, <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
							  <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>, <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>objv</name><index>[]</index></name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>pltcl_process_SPI_result</name><parameter_list>(<parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
									 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arrayname</name></decl></parameter>,
									 <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier></type><name>loop_body</name></decl></parameter>,
									 <parameter><decl><type><name>int</name></type> <name>spi_rc</name></decl></parameter>,
									 <parameter><decl><type><name>SPITupleTable</name> <modifier>*</modifier></type><name>tuptable</name></decl></parameter>,
									 <parameter><decl><type><name>uint64</name></type> <name>ntuples</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>pltcl_SPI_prepare</name><parameter_list>(<parameter><decl><type><name>ClientData</name></type> <name>cdata</name></decl></parameter>, <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
							  <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>, <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>objv</name><index>[]</index></name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>pltcl_SPI_execute_plan</name><parameter_list>(<parameter><decl><type><name>ClientData</name></type> <name>cdata</name></decl></parameter>, <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
								   <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>, <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>objv</name><index>[]</index></name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>pltcl_subtransaction</name><parameter_list>(<parameter><decl><type><name>ClientData</name></type> <name>cdata</name></decl></parameter>, <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
								 <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>, <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>objv</name><index>[]</index></name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>pltcl_commit</name><parameter_list>(<parameter><decl><type><name>ClientData</name></type> <name>cdata</name></decl></parameter>, <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>, <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>objv</name><index>[]</index></name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>pltcl_rollback</name><parameter_list>(<parameter><decl><type><name>ClientData</name></type> <name>cdata</name></decl></parameter>, <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>, <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>objv</name><index>[]</index></name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pltcl_subtrans_begin</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl></parameter>,
								 <parameter><decl><type><name>ResourceOwner</name></type> <name>oldowner</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pltcl_subtrans_commit</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl></parameter>,
								  <parameter><decl><type><name>ResourceOwner</name></type> <name>oldowner</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pltcl_subtrans_abort</name><parameter_list>(<parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
								 <parameter><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl></parameter>,
								 <parameter><decl><type><name>ResourceOwner</name></type> <name>oldowner</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pltcl_set_tuple_values</name><parameter_list>(<parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arrayname</name></decl></parameter>,
								   <parameter><decl><type><name>uint64</name></type> <name>tupno</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Tcl_Obj</name> <modifier>*</modifier></type><name>pltcl_build_tuple_argument</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>include_generated</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HeapTuple</name></type> <name>pltcl_build_tuple_result</name><parameter_list>(<parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
										  <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><modifier>*</modifier></type><name>kvObjv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kvObjc</name></decl></parameter>,
										  <parameter><decl><type><name>pltcl_call_state</name> <modifier>*</modifier></type><name>call_state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pltcl_init_tuple_store</name><parameter_list>(<parameter><decl><type><name>pltcl_call_state</name> <modifier>*</modifier></type><name>call_state</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Hack to override Tcl's builtin Notifier subsystem.  This prevents the
 * backend from becoming multithreaded, which breaks all sorts of things.
 * That happens in the default version of Tcl_InitNotifier if the TCL library
 * has been compiled with multithreading support (i.e. when TCL_THREADS is
 * defined under Unix, and in all cases under Windows).
 * It's okay to disable the notifier because we never enter the Tcl event loop
 * from Postgres, so the notifier capabilities are initialized, but never
 * used.  Only InitNotifier and DeleteFileHandler ever seem to get called
 * within Postgres, but we implement all the functions for completeness.
 */</comment>
<function><type><specifier>static</specifier> <name>ClientData</name></type>
<name>pltcl_InitNotifier</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>fakeThreadKey</name></decl>;</decl_stmt>	<comment type="block">/* To give valid address for ClientData */</comment>

	<return>return <expr><operator>(</operator><name>ClientData</name><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name>fakeThreadKey</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pltcl_FinalizeNotifier</name><parameter_list>(<parameter><decl><type><name>ClientData</name></type> <name>clientData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pltcl_SetTimer</name><parameter_list>(<parameter><decl><type><name>CONST86</name> <name>Tcl_Time</name> <modifier>*</modifier></type><name>timePtr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pltcl_AlertNotifier</name><parameter_list>(<parameter><decl><type><name>ClientData</name></type> <name>clientData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pltcl_CreateFileHandler</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mask</name></decl></parameter>,
						<parameter><decl><type><name>Tcl_FileProc</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>, <parameter><decl><type><name>ClientData</name></type> <name>clientData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pltcl_DeleteFileHandler</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pltcl_ServiceModeHook</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pltcl_WaitForEvent</name><parameter_list>(<parameter><decl><type><name>CONST86</name> <name>Tcl_Time</name> <modifier>*</modifier></type><name>timePtr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * _PG_init()			- library load-time initialization
 *
 * DO NOT make this static nor change its name!
 *
 * The work done here must be safe to do in the postmaster process,
 * in case the pltcl library is preloaded in the postmaster.
 */</comment>
<function><type><name>void</name></type>
<name>_PG_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Tcl_NotifierProcs</name></type> <name>notifier</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>hash_ctl</name></decl>;</decl_stmt>

	<comment type="block">/* Be sure we do initialization only once (should be redundant now) */</comment>
	<if_stmt><if>if <condition>(<expr><name>pltcl_pm_init_done</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pg_bindtextdomain</name><argument_list>(<argument><expr><name>TEXTDOMAIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<comment type="block">/* Required on win32 to prevent error loading init.tcl */</comment>
	<expr_stmt><expr><call><name>Tcl_FindExecutable</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Override the functions in the Notifier subsystem.  See comments above.
	 */</comment>
	<expr_stmt><expr><name><name>notifier</name><operator>.</operator><name>setTimerProc</name></name> <operator>=</operator> <name>pltcl_SetTimer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>notifier</name><operator>.</operator><name>waitForEventProc</name></name> <operator>=</operator> <name>pltcl_WaitForEvent</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>notifier</name><operator>.</operator><name>createFileHandlerProc</name></name> <operator>=</operator> <name>pltcl_CreateFileHandler</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>notifier</name><operator>.</operator><name>deleteFileHandlerProc</name></name> <operator>=</operator> <name>pltcl_DeleteFileHandler</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>notifier</name><operator>.</operator><name>initNotifierProc</name></name> <operator>=</operator> <name>pltcl_InitNotifier</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>notifier</name><operator>.</operator><name>finalizeNotifierProc</name></name> <operator>=</operator> <name>pltcl_FinalizeNotifier</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>notifier</name><operator>.</operator><name>alertNotifierProc</name></name> <operator>=</operator> <name>pltcl_AlertNotifier</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>notifier</name><operator>.</operator><name>serviceModeHookProc</name></name> <operator>=</operator> <name>pltcl_ServiceModeHook</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Tcl_SetNotifier</name><argument_list>(<argument><expr><operator>&amp;</operator><name>notifier</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * Create the dummy hold interpreter to prevent close of
	 * stdout and stderr on DeleteInterp
	 ************************************************************/</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>pltcl_hold_interp</name> <operator>=</operator> <call><name>Tcl_CreateInterp</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not create master Tcl interpreter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>Tcl_Init</name><argument_list>(<argument><expr><name>pltcl_hold_interp</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TCL_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not initialize master Tcl interpreter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * Create the hash table for working interpreters
	 ************************************************************/</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pltcl_interp_desc</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>pltcl_interp_htab</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"PL/Tcl interpreters"</literal></expr></argument>,
									<argument><expr><literal type="number">8</literal></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
									<argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * Create the hash table for function lookup
	 ************************************************************/</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pltcl_proc_key</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pltcl_proc_ptr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>pltcl_proc_htab</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"PL/Tcl functions"</literal></expr></argument>,
								  <argument><expr><literal type="number">100</literal></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
								  <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * Define PL/Tcl's custom GUCs
	 ************************************************************/</comment>
	<expr_stmt><expr><call><name>DefineCustomStringVariable</name><argument_list>(<argument><expr><literal type="string">"pltcl.start_proc"</literal></expr></argument>,
							   <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"PL/Tcl function to call once when pltcl is first used."</literal></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>pltcl_start_proc</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><name>PGC_SUSET</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DefineCustomStringVariable</name><argument_list>(<argument><expr><literal type="string">"pltclu.start_proc"</literal></expr></argument>,
							   <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"PL/TclU function to call once when pltclu is first used."</literal></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>pltclu_start_proc</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><name>PGC_SUSET</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pltcl_pm_init_done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************
 * pltcl_init_interp() - initialize a new Tcl interpreter
 **********************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pltcl_init_interp</name><parameter_list>(<parameter><decl><type><name>pltcl_interp_desc</name> <modifier>*</modifier></type><name>interp_desc</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>prolang</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>pltrusted</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>interpname</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * Create the Tcl interpreter as a slave of pltcl_hold_interp.
	 * Note: Tcl automatically does Tcl_Init in the untrusted case,
	 * and it's not wanted in the trusted case.
	 ************************************************************/</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>interpname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>interpname</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"slave_%u"</literal></expr></argument>, <argument><expr><name><name>interp_desc</name><operator>-&gt;</operator><name>user_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>interp</name> <operator>=</operator> <call><name>Tcl_CreateSlave</name><argument_list>(<argument><expr><name>pltcl_hold_interp</name></expr></argument>, <argument><expr><name>interpname</name></expr></argument>,
								  <argument><expr><ternary><condition><expr><name>pltrusted</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not create slave Tcl interpreter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * Initialize the query hash table associated with interpreter
	 ************************************************************/</comment>
	<expr_stmt><expr><call><name>Tcl_InitHashTable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>interp_desc</name><operator>-&gt;</operator><name>query_hash</name></name></expr></argument>, <argument><expr><name>TCL_STRING_KEYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * Install the commands for SPI support in the interpreter
	 ************************************************************/</comment>
	<expr_stmt><expr><call><name>Tcl_CreateObjCommand</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="string">"elog"</literal></expr></argument>,
						 <argument><expr><name>pltcl_elog</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Tcl_CreateObjCommand</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="string">"quote"</literal></expr></argument>,
						 <argument><expr><name>pltcl_quote</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Tcl_CreateObjCommand</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="string">"argisnull"</literal></expr></argument>,
						 <argument><expr><name>pltcl_argisnull</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Tcl_CreateObjCommand</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="string">"return_null"</literal></expr></argument>,
						 <argument><expr><name>pltcl_returnnull</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Tcl_CreateObjCommand</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="string">"return_next"</literal></expr></argument>,
						 <argument><expr><name>pltcl_returnnext</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Tcl_CreateObjCommand</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="string">"spi_exec"</literal></expr></argument>,
						 <argument><expr><name>pltcl_SPI_execute</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Tcl_CreateObjCommand</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="string">"spi_prepare"</literal></expr></argument>,
						 <argument><expr><name>pltcl_SPI_prepare</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Tcl_CreateObjCommand</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="string">"spi_execp"</literal></expr></argument>,
						 <argument><expr><name>pltcl_SPI_execute_plan</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Tcl_CreateObjCommand</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="string">"subtransaction"</literal></expr></argument>,
						 <argument><expr><name>pltcl_subtransaction</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Tcl_CreateObjCommand</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="string">"commit"</literal></expr></argument>,
						 <argument><expr><name>pltcl_commit</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Tcl_CreateObjCommand</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="string">"rollback"</literal></expr></argument>,
						 <argument><expr><name>pltcl_rollback</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * Call the appropriate start_proc, if there is one.
	 *
	 * We must set interp_desc-&gt;interp before the call, else the start_proc
	 * won't find the interpreter it's supposed to use.  But, if the
	 * start_proc fails, we want to abandon use of the interpreter.
	 ************************************************************/</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name><name>interp_desc</name><operator>-&gt;</operator><name>interp</name></name> <operator>=</operator> <name>interp</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>call_pltcl_start_proc</name><argument_list>(<argument><expr><name>prolang</name></expr></argument>, <argument><expr><name>pltrusted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name><name>interp_desc</name><operator>-&gt;</operator><name>interp</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Tcl_DeleteInterp</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************
 * pltcl_fetch_interp() - fetch the Tcl interpreter to use for a function
 *
 * This also takes care of any on-first-use initialization required.
 **********************************************************************/</comment>
<function><type><specifier>static</specifier> <name>pltcl_interp_desc</name> <modifier>*</modifier></type>
<name>pltcl_fetch_interp</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>prolang</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>pltrusted</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>user_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pltcl_interp_desc</name> <modifier>*</modifier></type><name>interp_desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<comment type="block">/* Find or create the interpreter hashtable entry for this userid */</comment>
	<if_stmt><if>if <condition>(<expr><name>pltrusted</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>user_id</name> <operator>=</operator> <call><name>GetUserId</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>user_id</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>interp_desc</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>pltcl_interp_htab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>user_id</name></expr></argument>,
							  <argument><expr><name>HASH_ENTER</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>interp_desc</name><operator>-&gt;</operator><name>interp</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* If we haven't yet successfully made an interpreter, try to do that */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>interp_desc</name><operator>-&gt;</operator><name>interp</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pltcl_init_interp</name><argument_list>(<argument><expr><name>interp_desc</name></expr></argument>, <argument><expr><name>prolang</name></expr></argument>, <argument><expr><name>pltrusted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>interp_desc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**********************************************************************
 * call_pltcl_start_proc()	 - Call user-defined initialization proc, if any
 **********************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>call_pltcl_start_proc</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>prolang</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>pltrusted</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>start_proc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gucname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>errcallback</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>namelist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>procOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>procTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procStruct</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>finfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PgStat_FunctionCallUsage</name></type> <name>fcusage</name></decl>;</decl_stmt>

	<comment type="block">/* select appropriate GUC */</comment>
	<expr_stmt><expr><name>start_proc</name> <operator>=</operator> <ternary><condition><expr><name>pltrusted</name></expr> ?</condition><then> <expr><name>pltcl_start_proc</name></expr> </then><else>: <expr><name>pltclu_start_proc</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>gucname</name> <operator>=</operator> <ternary><condition><expr><name>pltrusted</name></expr> ?</condition><then> <expr><literal type="string">"pltcl.start_proc"</literal></expr> </then><else>: <expr><literal type="string">"pltclu.start_proc"</literal></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* Nothing to do if it's empty or unset */</comment>
	<if_stmt><if>if <condition>(<expr><name>start_proc</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>start_proc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Set up errcontext callback to make errors more helpful */</comment>
	<expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>start_proc_error_callback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <call><name>unconstify</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>, <argument><expr><name>gucname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>errcallback</name></expr>;</expr_stmt>

	<comment type="block">/* Parse possibly-qualified identifier and look up the function */</comment>
	<expr_stmt><expr><name>namelist</name> <operator>=</operator> <call><name>stringToQualifiedNameList</name><argument_list>(<argument><expr><name>start_proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>procOid</name> <operator>=</operator> <call><name>LookupFuncName</name><argument_list>(<argument><expr><name>namelist</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Current user must have permission to call function */</comment>
	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_proc_aclcheck</name><argument_list>(<argument><expr><name>procOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_FUNCTION</name></expr></argument>, <argument><expr><name>start_proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Get the function's pg_proc entry */</comment>
	<expr_stmt><expr><name>procTup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>procOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>procTup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>procOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>procStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>procTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* It must be same language as the function we're currently calling */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>procStruct</name><operator>-&gt;</operator><name>prolang</name></name> <operator>!=</operator> <name>prolang</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function \"%s\" is in the wrong language"</literal></expr></argument>,
						<argument><expr><name>start_proc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * It must not be SECURITY DEFINER, either.  This together with the
	 * language match check ensures that the function will execute in the same
	 * Tcl interpreter we just finished initializing.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>procStruct</name><operator>-&gt;</operator><name>prosecdef</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function \"%s\" must not be SECURITY DEFINER"</literal></expr></argument>,
						<argument><expr><name>start_proc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* A-OK */</comment>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>procTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Call the function using the normal SQL function call mechanism.  We
	 * could perhaps cheat and jump directly to pltcl_handler(), but it seems
	 * better to do it this way so that the call is exposed to, eg, call
	 * statistics collection.
	 */</comment>
	<expr_stmt><expr><call><name>InvokeFunctionExecuteHook</name><argument_list>(<argument><expr><name>procOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>procOid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>finfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>finfo</name></expr></argument>,
							 <argument><expr><literal type="number">0</literal></expr></argument>,
							 <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_init_function_usage</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fcusage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_end_function_usage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fcusage</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Pop the error context stack */</comment>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>errcallback</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Error context callback for errors occurring during start_proc processing.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>start_proc_error_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gucname</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* translator: %s is "pltcl.start_proc" or "pltclu.start_proc" */</comment>
	<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"processing %s parameter"</literal></expr></argument>, <argument><expr><name>gucname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**********************************************************************
 * pltcl_call_handler		- This is the only visible function
 *				  of the PL interpreter. The PostgreSQL
 *				  function manager and trigger manager
 *				  call this function for execution of
 *				  PL/Tcl procedures.
 **********************************************************************/</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>pltcl_call_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* keep non-static */</comment>
<function><type><name>Datum</name></type>
<name>pltcl_call_handler</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>pltcl_handler</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Alternative handler for unsafe functions
 */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>pltclu_call_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* keep non-static */</comment>
<function><type><name>Datum</name></type>
<name>pltclu_call_handler</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>pltcl_handler</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**********************************************************************
 * pltcl_handler()		- Handler for function and trigger calls, for
 *						  both trusted and untrusted interpreters.
 **********************************************************************/</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>pltcl_handler</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>pltrusted</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>retval</name> <init>= <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pltcl_call_state</name></type> <name>current_call_state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pltcl_call_state</name> <modifier>*</modifier></type><name>save_call_state</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Initialize current_call_state to nulls/zeroes; in particular, set its
	 * prodesc pointer to null.  Anything that sets it non-null should
	 * increase the prodesc's fn_refcount at the same time.  We'll decrease
	 * the refcount, and then delete the prodesc if it's no longer referenced,
	 * on the way out of this function.  This ensures that prodescs live as
	 * long as needed even if somebody replaces the originating pg_proc row
	 * while they're executing.
	 */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>current_call_state</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>current_call_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Ensure that static pointer is saved/restored properly
	 */</comment>
	<expr_stmt><expr><name>save_call_state</name> <operator>=</operator> <name>pltcl_current_call_state</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>pltcl_current_call_state</name> <operator>=</operator> <operator>&amp;</operator><name>current_call_state</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/*
		 * Determine if called as function or trigger and call appropriate
		 * subhandler
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>CALLED_AS_TRIGGER</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* invoke the trigger handler */</comment>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>pltcl_trigger_handler</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>,
														   <argument><expr><operator>&amp;</operator><name>current_call_state</name></expr></argument>,
														   <argument><expr><name>pltrusted</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>CALLED_AS_EVENT_TRIGGER</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* invoke the event trigger handler */</comment>
			<expr_stmt><expr><call><name>pltcl_event_trigger_handler</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>current_call_state</name></expr></argument>, <argument><expr><name>pltrusted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* invoke the regular function handler */</comment>
			<expr_stmt><expr><name><name>current_call_state</name><operator>.</operator><name>fcinfo</name></name> <operator>=</operator> <name>fcinfo</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>pltcl_func_handler</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>current_call_state</name></expr></argument>, <argument><expr><name>pltrusted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_FINALLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/* Restore static pointer, then clean up the prodesc refcount if any */</comment>
		<comment type="block">/*
		 * (We're being paranoid in case an error is thrown in context
		 * deletion)
		 */</comment>
		<expr_stmt><expr><name>pltcl_current_call_state</name> <operator>=</operator> <name>save_call_state</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>current_call_state</name><operator>.</operator><name>prodesc</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>current_call_state</name><operator>.</operator><name>prodesc</name><operator>-&gt;</operator><name>fn_refcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>--</operator><name><name>current_call_state</name><operator>.</operator><name>prodesc</name><operator>-&gt;</operator><name>fn_refcount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>current_call_state</name><operator>.</operator><name>prodesc</name><operator>-&gt;</operator><name>fn_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**********************************************************************
 * pltcl_func_handler()		- Handler for regular function calls
 **********************************************************************/</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>pltcl_func_handler</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>, <parameter><decl><type><name>pltcl_call_state</name> <modifier>*</modifier></type><name>call_state</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>pltrusted</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>nonatomic</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pltcl_proc_desc</name> <modifier>*</modifier></type><name>prodesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tcl_Interp</name> <modifier>*</modifier><specifier>volatile</specifier></type> <name>interp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tcl_Obj</name>    <modifier>*</modifier></type><name>tcl_cmd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tcl_rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>retval</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>nonatomic</name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name> <operator>&amp;&amp;</operator>
		<call><name>IsA</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>CallContext</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>castNode</name><argument_list>(<argument><expr><name>CallContext</name></expr></argument>, <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atomic</name></expr>;</expr_stmt>

	<comment type="block">/* Connect to SPI manager */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SPI_connect_ext</name><argument_list>(<argument><expr><ternary><condition><expr><name>nonatomic</name></expr> ?</condition><then> <expr><name>SPI_OPT_NONATOMIC</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SPI_OK_CONNECT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not connect to SPI manager"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Find or compile the function */</comment>
	<expr_stmt><expr><name>prodesc</name> <operator>=</operator> <call><name>compile_pltcl_function</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
									 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>pltrusted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>call_state</name><operator>-&gt;</operator><name>prodesc</name></name> <operator>=</operator> <name>prodesc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>fn_refcount</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>interp</name> <operator>=</operator> <name><name>prodesc</name><operator>-&gt;</operator><name>interp_desc</name><operator>-&gt;</operator><name>interp</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we're a SRF, check caller can handle materialize mode, and save
	 * relevant info into call_state.  We must ensure that the returned
	 * tuplestore is owned by the caller's context, even if we first create it
	 * inside a subtransaction.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>prodesc</name><operator>-&gt;</operator><name>fn_retisset</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsi</name> <init>= <expr><operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rsi</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsi</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<operator>(</operator><name><name>rsi</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>call_state</name><operator>-&gt;</operator><name>rsi</name></name> <operator>=</operator> <name>rsi</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>call_state</name><operator>-&gt;</operator><name>tuple_store_cxt</name></name> <operator>=</operator> <name><name>rsi</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>call_state</name><operator>-&gt;</operator><name>tuple_store_owner</name></name> <operator>=</operator> <name>CurrentResourceOwner</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * Create the tcl command to call the internal
	 * proc in the Tcl interpreter
	 ************************************************************/</comment>
	<expr_stmt><expr><name>tcl_cmd</name> <operator>=</operator> <call><name>Tcl_NewObj</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tcl_cmd</name></expr></argument>,
							 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><name><name>prodesc</name><operator>-&gt;</operator><name>internal_proname</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We hold a refcount on tcl_cmd just to be sure it stays around */</comment>
	<expr_stmt><expr><call><name>Tcl_IncrRefCount</name><argument_list>(<argument><expr><name>tcl_cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * Add all call arguments to the command
	 ************************************************************/</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>prodesc</name><operator>-&gt;</operator><name>nargs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>prodesc</name><operator>-&gt;</operator><name>arg_is_rowtype</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block" format="doxygen">/**************************************************
				 * For tuple values, add a list for 'array set ...'
				 **************************************************/</comment>
				<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tcl_cmd</name></expr></argument>, <argument><expr><call><name>Tcl_NewObj</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>td</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>tupType</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int32</name></type>		<name>tupTypmod</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>tmptup</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Tcl_Obj</name>    <modifier>*</modifier></type><name>list_tmp</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>td</name> <operator>=</operator> <call><name>DatumGetHeapTupleHeader</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* Extract rowtype info and find a tupdesc */</comment>
					<expr_stmt><expr><name>tupType</name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypeId</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>tupTypmod</name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypMod</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc</name><argument_list>(<argument><expr><name>tupType</name></expr></argument>, <argument><expr><name>tupTypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* Build a temporary HeapTuple control structure */</comment>
					<expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetDatumLength</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <name>td</name></expr>;</expr_stmt>

					<expr_stmt><expr><name>list_tmp</name> <operator>=</operator> <call><name>pltcl_build_tuple_argument</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmptup</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tcl_cmd</name></expr></argument>, <argument><expr><name>list_tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block" format="doxygen">/**************************************************
				 * Single values are added as string element
				 * of their external representation
				 **************************************************/</comment>
				<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tcl_cmd</name></expr></argument>, <argument><expr><call><name>Tcl_NewObj</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>OutputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>prodesc</name><operator>-&gt;</operator><name>arg_out_func</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
											 <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>UTF_BEGIN</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tcl_cmd</name></expr></argument>,
											 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><call><name>UTF_E2U</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>UTF_END</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/* Release refcount to free tcl_cmd */</comment>
		<expr_stmt><expr><call><name>Tcl_DecrRefCount</name><argument_list>(<argument><expr><name>tcl_cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * Call the Tcl function
	 *
	 * We assume no PG error can be thrown directly from this call.
	 ************************************************************/</comment>
	<expr_stmt><expr><name>tcl_rc</name> <operator>=</operator> <call><name>Tcl_EvalObjEx</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>tcl_cmd</name></expr></argument>, <argument><expr><operator>(</operator><name>TCL_EVAL_DIRECT</name> <operator>|</operator> <name>TCL_EVAL_GLOBAL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Release refcount to free tcl_cmd (and all subsidiary objects) */</comment>
	<expr_stmt><expr><call><name>Tcl_DecrRefCount</name><argument_list>(<argument><expr><name>tcl_cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * Check for errors reported by Tcl.
	 ************************************************************/</comment>
	<if_stmt><if>if <condition>(<expr><name>tcl_rc</name> <operator>!=</operator> <name>TCL_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>throw_tcl_error</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>prodesc</name><operator>-&gt;</operator><name>user_proname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * Disconnect from SPI manager and then create the return
	 * value datum (if the input function does a palloc for it
	 * this must not be allocated in the SPI memory context
	 * because SPI_finish would free it).  But don't try to call
	 * the result_in_func if we've been told to return a NULL;
	 * the Tcl result may not be a valid value of the result type
	 * in that case.
	 ************************************************************/</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SPI_finish</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SPI_OK_FINISH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_finish() failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>prodesc</name><operator>-&gt;</operator><name>fn_retisset</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsi</name> <init>= <expr><name><name>call_state</name><operator>-&gt;</operator><name>rsi</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* We already checked this is OK */</comment>
		<expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>

		<comment type="block">/* If we produced any tuples, send back the result */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>call_state</name><operator>-&gt;</operator><name>tuple_store</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>setResult</name></name> <operator>=</operator> <name><name>call_state</name><operator>-&gt;</operator><name>tuple_store</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>call_state</name><operator>-&gt;</operator><name>ret_tupdesc</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>call_state</name><operator>-&gt;</operator><name>tuple_store_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>setDesc</name></name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name><name>call_state</name><operator>-&gt;</operator><name>ret_tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>InputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>prodesc</name><operator>-&gt;</operator><name>result_in_func</name></name></expr></argument>,
								   <argument><expr><name>NULL</name></expr></argument>,
								   <argument><expr><name><name>prodesc</name><operator>-&gt;</operator><name>result_typioparam</name></name></expr></argument>,
								   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>prodesc</name><operator>-&gt;</operator><name>fn_retistuple</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>td</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Tcl_Obj</name>    <modifier>*</modifier></type><name>resultObj</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Tcl_Obj</name>   <modifier>*</modifier><modifier>*</modifier></type><name>resultObjv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>resultObjc</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Set up data about result type.  XXX it's tempting to consider
		 * caching this in the prodesc, in the common case where the rowtype
		 * is determined by the function not the calling query.  But we'd have
		 * to be able to deal with ADD/DROP/ALTER COLUMN events when the
		 * result type is a named composite type, so it's not exactly trivial.
		 * Maybe worth improving someday.
		 */</comment>
		<switch>switch <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>td</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>TYPEFUNC_COMPOSITE</name></expr>:</case>
				<comment type="block">/* success */</comment>
				<break>break;</break>
			<case>case <expr><name>TYPEFUNC_COMPOSITE_DOMAIN</name></expr>:</case>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>prodesc</name><operator>-&gt;</operator><name>fn_retisdomain</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>TYPEFUNC_RECORD</name></expr>:</case>
				<comment type="block">/* failed to determine actual type of RECORD */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function returning record called in context "</literal>
								<literal type="string">"that cannot accept type record"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<comment type="block">/* result type isn't composite? */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"return type must be a row type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>call_state</name><operator>-&gt;</operator><name>ret_tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>call_state</name><operator>-&gt;</operator><name>attinmeta</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>call_state</name><operator>-&gt;</operator><name>ret_tupdesc</name></name> <operator>=</operator> <name>td</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>call_state</name><operator>-&gt;</operator><name>attinmeta</name></name> <operator>=</operator> <call><name>TupleDescGetAttInMetadata</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Convert function result to tuple */</comment>
		<expr_stmt><expr><name>resultObj</name> <operator>=</operator> <call><name>Tcl_GetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>Tcl_ListObjGetElements</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>resultObj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>resultObjc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>resultObjv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TCL_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>throw_tcl_error</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>prodesc</name><operator>-&gt;</operator><name>user_proname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>pltcl_build_tuple_result</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>resultObjv</name></expr></argument>, <argument><expr><name>resultObjc</name></expr></argument>,
									   <argument><expr><name>call_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>InputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>prodesc</name><operator>-&gt;</operator><name>result_in_func</name></name></expr></argument>,
								   <argument><expr><call><name>utf_u2e</name><argument_list>(<argument><expr><call><name>Tcl_GetStringResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name><name>prodesc</name><operator>-&gt;</operator><name>result_typioparam</name></name></expr></argument>,
								   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**********************************************************************
 * pltcl_trigger_handler()	- Handler for trigger calls
 **********************************************************************/</comment>
<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>pltcl_trigger_handler</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>, <parameter><decl><type><name>pltcl_call_state</name> <modifier>*</modifier></type><name>call_state</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>pltrusted</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pltcl_proc_desc</name> <modifier>*</modifier></type><name>prodesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tcl_Interp</name> <modifier>*</modifier><specifier>volatile</specifier></type> <name>interp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TriggerData</name> <modifier>*</modifier></type><name>trigdata</name> <init>= <expr><operator>(</operator><name>TriggerData</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>stroid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>HeapTuple</name></type> <name>rettup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tcl_Obj</name>    <modifier>*</modifier></type><name>tcl_cmd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tcl_Obj</name>    <modifier>*</modifier></type><name>tcl_trigtup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tcl_rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>result_Objc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tcl_Obj</name>   <modifier>*</modifier><modifier>*</modifier></type><name>result_Objv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>			<name>rc</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>call_state</name><operator>-&gt;</operator><name>trigdata</name></name> <operator>=</operator> <name>trigdata</name></expr>;</expr_stmt>

	<comment type="block">/* Connect to SPI manager */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SPI_connect</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SPI_OK_CONNECT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not connect to SPI manager"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Make transition tables visible to this SPI connection */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SPI_register_trigger_data</name><argument_list>(<argument><expr><name>trigdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rc</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Find or compile the function */</comment>
	<expr_stmt><expr><name>prodesc</name> <operator>=</operator> <call><name>compile_pltcl_function</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>,
									 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_relation</name></name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name>false</name></expr></argument>, <comment type="block">/* not an event trigger */</comment>
									 <argument><expr><name>pltrusted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>call_state</name><operator>-&gt;</operator><name>prodesc</name></name> <operator>=</operator> <name>prodesc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>fn_refcount</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>interp</name> <operator>=</operator> <name><name>prodesc</name><operator>-&gt;</operator><name>interp_desc</name><operator>-&gt;</operator><name>interp</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_relation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * Create the tcl command to call the internal
	 * proc in the interpreter
	 ************************************************************/</comment>
	<expr_stmt><expr><name>tcl_cmd</name> <operator>=</operator> <call><name>Tcl_NewObj</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Tcl_IncrRefCount</name><argument_list>(<argument><expr><name>tcl_cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/* The procedure name (note this is all ASCII, so no utf_e2u) */</comment>
		<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tcl_cmd</name></expr></argument>,
								 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><name><name>prodesc</name><operator>-&gt;</operator><name>internal_proname</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* The trigger name for argument TG_name */</comment>
		<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tcl_cmd</name></expr></argument>,
								 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><call><name>utf_e2u</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigger</name><operator>-&gt;</operator><name>tgname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* The oid of the trigger relation for argument TG_relid */</comment>
		<comment type="block">/* Consider not converting to a string for more performance? */</comment>
		<expr_stmt><expr><name>stroid</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>oidout</name></expr></argument>,
													 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_relation</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tcl_cmd</name></expr></argument>,
								 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><name>stroid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>stroid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* The name of the table the trigger is acting on: TG_table_name */</comment>
		<expr_stmt><expr><name>stroid</name> <operator>=</operator> <call><name>SPI_getrelname</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_relation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tcl_cmd</name></expr></argument>,
								 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><call><name>utf_e2u</name><argument_list>(<argument><expr><name>stroid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>stroid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* The schema of the table the trigger is acting on: TG_table_schema */</comment>
		<expr_stmt><expr><name>stroid</name> <operator>=</operator> <call><name>SPI_getnspname</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_relation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tcl_cmd</name></expr></argument>,
								 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><call><name>utf_e2u</name><argument_list>(<argument><expr><name>stroid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>stroid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* A list of attribute names for argument TG_relatts */</comment>
		<expr_stmt><expr><name>tcl_trigtup</name> <operator>=</operator> <call><name>Tcl_NewObj</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tcl_trigtup</name></expr></argument>, <argument><expr><call><name>Tcl_NewObj</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tcl_trigtup</name></expr></argument>, <argument><expr><call><name>Tcl_NewObj</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tcl_trigtup</name></expr></argument>,
										 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><call><name>utf_e2u</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tcl_cmd</name></expr></argument>, <argument><expr><name>tcl_trigtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* The when part of the event for TG_when */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FIRED_BEFORE</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tcl_cmd</name></expr></argument>,
									 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"BEFORE"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_AFTER</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tcl_cmd</name></expr></argument>,
									 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"AFTER"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_INSTEAD</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tcl_cmd</name></expr></argument>,
									 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"INSTEAD OF"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized WHEN tg_event: %u"</literal></expr></argument>, <argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* The level part of the event for TG_level */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FIRED_FOR_ROW</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tcl_cmd</name></expr></argument>,
									 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"ROW"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Now the command part of the event for TG_op and data for NEW
			 * and OLD
			 *
			 * Note: In BEFORE trigger, stored generated columns are not
			 * computed yet, so don't make them accessible in NEW row.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FIRED_BY_INSERT</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tcl_cmd</name></expr></argument>,
										 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"INSERT"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tcl_cmd</name></expr></argument>,
										 <argument><expr><call><name>pltcl_build_tuple_argument</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigtuple</name></name></expr></argument>,
																	<argument><expr><name>tupdesc</name></expr></argument>,
																	<argument><expr><operator>!</operator><call><name>TRIGGER_FIRED_BEFORE</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tcl_cmd</name></expr></argument>, <argument><expr><call><name>Tcl_NewObj</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>rettup</name> <operator>=</operator> <name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigtuple</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_BY_DELETE</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tcl_cmd</name></expr></argument>,
										 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"DELETE"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tcl_cmd</name></expr></argument>, <argument><expr><call><name>Tcl_NewObj</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tcl_cmd</name></expr></argument>,
										 <argument><expr><call><name>pltcl_build_tuple_argument</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigtuple</name></name></expr></argument>,
																	<argument><expr><name>tupdesc</name></expr></argument>,
																	<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>rettup</name> <operator>=</operator> <name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigtuple</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_BY_UPDATE</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tcl_cmd</name></expr></argument>,
										 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"UPDATE"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tcl_cmd</name></expr></argument>,
										 <argument><expr><call><name>pltcl_build_tuple_argument</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_newtuple</name></name></expr></argument>,
																	<argument><expr><name>tupdesc</name></expr></argument>,
																	<argument><expr><operator>!</operator><call><name>TRIGGER_FIRED_BEFORE</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tcl_cmd</name></expr></argument>,
										 <argument><expr><call><name>pltcl_build_tuple_argument</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigtuple</name></name></expr></argument>,
																	<argument><expr><name>tupdesc</name></expr></argument>,
																	<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>rettup</name> <operator>=</operator> <name><name>trigdata</name><operator>-&gt;</operator><name>tg_newtuple</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized OP tg_event: %u"</literal></expr></argument>, <argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_FOR_STATEMENT</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tcl_cmd</name></expr></argument>,
									 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"STATEMENT"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FIRED_BY_INSERT</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tcl_cmd</name></expr></argument>,
										 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"INSERT"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_BY_DELETE</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tcl_cmd</name></expr></argument>,
										 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"DELETE"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_BY_UPDATE</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tcl_cmd</name></expr></argument>,
										 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"UPDATE"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_BY_TRUNCATE</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tcl_cmd</name></expr></argument>,
										 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"TRUNCATE"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized OP tg_event: %u"</literal></expr></argument>, <argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tcl_cmd</name></expr></argument>, <argument><expr><call><name>Tcl_NewObj</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tcl_cmd</name></expr></argument>, <argument><expr><call><name>Tcl_NewObj</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>rettup</name> <operator>=</operator> <operator>(</operator><name>HeapTuple</name><operator>)</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized LEVEL tg_event: %u"</literal></expr></argument>, <argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Finally append the arguments from CREATE TRIGGER */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigger</name><operator>-&gt;</operator><name>tgnargs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tcl_cmd</name></expr></argument>,
									 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><call><name>utf_e2u</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigger</name><operator>-&gt;</operator><name>tgargs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Tcl_DecrRefCount</name><argument_list>(<argument><expr><name>tcl_cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * Call the Tcl function
	 *
	 * We assume no PG error can be thrown directly from this call.
	 ************************************************************/</comment>
	<expr_stmt><expr><name>tcl_rc</name> <operator>=</operator> <call><name>Tcl_EvalObjEx</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>tcl_cmd</name></expr></argument>, <argument><expr><operator>(</operator><name>TCL_EVAL_DIRECT</name> <operator>|</operator> <name>TCL_EVAL_GLOBAL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Release refcount to free tcl_cmd (and all subsidiary objects) */</comment>
	<expr_stmt><expr><call><name>Tcl_DecrRefCount</name><argument_list>(<argument><expr><name>tcl_cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * Check for errors reported by Tcl.
	 ************************************************************/</comment>
	<if_stmt><if>if <condition>(<expr><name>tcl_rc</name> <operator>!=</operator> <name>TCL_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>throw_tcl_error</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>prodesc</name><operator>-&gt;</operator><name>user_proname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * Exit SPI environment.
	 ************************************************************/</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SPI_finish</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SPI_OK_FINISH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_finish() failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * The return value from the procedure might be one of
	 * the magic strings OK or SKIP, or a list from array get.
	 * We can check for OK or SKIP without worrying about encoding.
	 ************************************************************/</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>Tcl_GetStringResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"OK"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>rettup</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"SKIP"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>HeapTuple</name><operator>)</operator> <name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * Otherwise, the return value should be a column name/value list
	 * specifying the modified tuple to return.
	 ************************************************************/</comment>
	<if_stmt><if>if <condition>(<expr><call><name>Tcl_ListObjGetElements</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_GetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>result_Objc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result_Objv</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TCL_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not split return value from trigger: %s"</literal></expr></argument>,
						<argument><expr><call><name>utf_u2e</name><argument_list>(<argument><expr><call><name>Tcl_GetStringResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Convert function result to tuple */</comment>
	<expr_stmt><expr><name>rettup</name> <operator>=</operator> <call><name>pltcl_build_tuple_result</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>result_Objv</name></expr></argument>, <argument><expr><name>result_Objc</name></expr></argument>,
									  <argument><expr><name>call_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rettup</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************
 * pltcl_event_trigger_handler()	- Handler for event trigger calls
 **********************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pltcl_event_trigger_handler</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>, <parameter><decl><type><name>pltcl_call_state</name> <modifier>*</modifier></type><name>call_state</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>pltrusted</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pltcl_proc_desc</name> <modifier>*</modifier></type><name>prodesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tcl_Interp</name> <modifier>*</modifier><specifier>volatile</specifier></type> <name>interp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EventTriggerData</name> <modifier>*</modifier></type><name>tdata</name> <init>= <expr><operator>(</operator><name>EventTriggerData</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tcl_Obj</name>    <modifier>*</modifier></type><name>tcl_cmd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tcl_rc</name></decl>;</decl_stmt>

	<comment type="block">/* Connect to SPI manager */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SPI_connect</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SPI_OK_CONNECT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not connect to SPI manager"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Find or compile the function */</comment>
	<expr_stmt><expr><name>prodesc</name> <operator>=</operator> <call><name>compile_pltcl_function</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>,
									 <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>pltrusted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>call_state</name><operator>-&gt;</operator><name>prodesc</name></name> <operator>=</operator> <name>prodesc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>fn_refcount</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>interp</name> <operator>=</operator> <name><name>prodesc</name><operator>-&gt;</operator><name>interp_desc</name><operator>-&gt;</operator><name>interp</name></name></expr>;</expr_stmt>

	<comment type="block">/* Create the tcl command and call the internal proc */</comment>
	<expr_stmt><expr><name>tcl_cmd</name> <operator>=</operator> <call><name>Tcl_NewObj</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Tcl_IncrRefCount</name><argument_list>(<argument><expr><name>tcl_cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tcl_cmd</name></expr></argument>,
							 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><name><name>prodesc</name><operator>-&gt;</operator><name>internal_proname</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tcl_cmd</name></expr></argument>,
							 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><call><name>utf_e2u</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>event</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tcl_cmd</name></expr></argument>,
							 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><call><name>utf_e2u</name><argument_list>(<argument><expr><call><name>GetCommandTagName</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tcl_rc</name> <operator>=</operator> <call><name>Tcl_EvalObjEx</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>tcl_cmd</name></expr></argument>, <argument><expr><operator>(</operator><name>TCL_EVAL_DIRECT</name> <operator>|</operator> <name>TCL_EVAL_GLOBAL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Release refcount to free tcl_cmd (and all subsidiary objects) */</comment>
	<expr_stmt><expr><call><name>Tcl_DecrRefCount</name><argument_list>(<argument><expr><name>tcl_cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check for errors reported by Tcl. */</comment>
	<if_stmt><if>if <condition>(<expr><name>tcl_rc</name> <operator>!=</operator> <name>TCL_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>throw_tcl_error</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>prodesc</name><operator>-&gt;</operator><name>user_proname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SPI_finish</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SPI_OK_FINISH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_finish() failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**********************************************************************
 * throw_tcl_error	- ereport an error returned from the Tcl interpreter
 **********************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>throw_tcl_error</name><parameter_list>(<parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>proname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Caution is needed here because Tcl_GetVar could overwrite the
	 * interpreter result (even though it's not really supposed to), and we
	 * can't control the order of evaluation of ereport arguments. Hence, make
	 * real sure we have our own copy of the result string before invoking
	 * Tcl_GetVar.
	 */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>emsg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>emsg</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>utf_u2e</name><argument_list>(<argument><expr><call><name>Tcl_GetStringResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>utf_u2e</name><argument_list>(<argument><expr><call><name>Tcl_GetVar</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="string">"errorInfo"</literal></expr></argument>, <argument><expr><name>TCL_GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_EXTERNAL_ROUTINE_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>emsg</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"%s\nin PL/Tcl function \"%s\""</literal></expr></argument>,
						<argument><expr><name>econtext</name></expr></argument>, <argument><expr><name>proname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**********************************************************************
 * compile_pltcl_function	- compile (or hopefully just look up) function
 *
 * tgreloid is the OID of the relation when compiling a trigger, or zero
 * (InvalidOid) when compiling a plain function.
 **********************************************************************/</comment>
<function><type><specifier>static</specifier> <name>pltcl_proc_desc</name> <modifier>*</modifier></type>
<name>compile_pltcl_function</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>fn_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>tgreloid</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>is_event_trigger</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>pltrusted</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>procTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procStruct</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pltcl_proc_key</name></type> <name>proc_key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pltcl_proc_ptr</name> <modifier>*</modifier></type><name>proc_ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pltcl_proc_desc</name> <modifier>*</modifier></type><name>prodesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pltcl_proc_desc</name> <modifier>*</modifier></type><name>old_prodesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>MemoryContext</name></type> <name>proc_cxt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tcl_DString</name></type> <name>proc_internal_def</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tcl_DString</name></type> <name>proc_internal_body</name></decl>;</decl_stmt>

	<comment type="block">/* We'll need the pg_proc tuple in any case... */</comment>
	<expr_stmt><expr><name>procTup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>fn_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>procTup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>fn_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>procStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>procTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Look up function in pltcl_proc_htab; if it's not there, create an entry
	 * and set the entry's proc_ptr to NULL.
	 */</comment>
	<expr_stmt><expr><name><name>proc_key</name><operator>.</operator><name>proc_id</name></name> <operator>=</operator> <name>fn_oid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proc_key</name><operator>.</operator><name>is_trigger</name></name> <operator>=</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>tgreloid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proc_key</name><operator>.</operator><name>user_id</name></name> <operator>=</operator> <ternary><condition><expr><name>pltrusted</name></expr> ?</condition><then> <expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><name>InvalidOid</name></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><name>proc_ptr</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>pltcl_proc_htab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>proc_key</name></expr></argument>,
						   <argument><expr><name>HASH_ENTER</name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>proc_ptr</name><operator>-&gt;</operator><name>proc_ptr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>prodesc</name> <operator>=</operator> <name><name>proc_ptr</name><operator>-&gt;</operator><name>proc_ptr</name></name></expr>;</expr_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * If it's present, must check whether it's still up to date.
	 * This is needed because CREATE OR REPLACE FUNCTION can modify the
	 * function's pg_proc entry without changing its OID.
	 ************************************************************/</comment>
	<if_stmt><if>if <condition>(<expr><name>prodesc</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<name><name>prodesc</name><operator>-&gt;</operator><name>fn_xmin</name></name> <operator>==</operator> <call><name>HeapTupleHeaderGetRawXmin</name><argument_list>(<argument><expr><name><name>procTup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>ItemPointerEquals</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>prodesc</name><operator>-&gt;</operator><name>fn_tid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>procTup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* It's still up-to-date, so we can use it */</comment>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>procTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>prodesc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * If we haven't found it in the hashtable, we analyze
	 * the functions arguments and returntype and store
	 * the in-/out-functions in the prodesc block and create
	 * a new hashtable entry for it.
	 *
	 * Then we load the procedure into the Tcl interpreter.
	 ************************************************************/</comment>
	<expr_stmt><expr><call><name>Tcl_DStringInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>proc_internal_def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Tcl_DStringInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>proc_internal_body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>is_trigger</name> <init>= <expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>tgreloid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>internal_proname</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>typeTup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typeStruct</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>proc_internal_args</name><index>[<expr><literal type="number">33</literal> <operator>*</operator> <name>FUNC_MAX_ARGS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>prosrcdatum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>proc_source</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><literal type="number">48</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>tcl_rc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

		<comment type="block" format="doxygen">/************************************************************
		 * Build our internal proc name from the function's Oid.  Append
		 * "_trigger" when appropriate to ensure the normal and trigger
		 * cases are kept separate.  Note name must be all-ASCII.
		 ************************************************************/</comment>
		<if_stmt><if>if <condition>(<expr><name>is_event_trigger</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>internal_proname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>internal_proname</name></expr></argument>)</argument_list></sizeof></expr></argument>,
					 <argument><expr><literal type="string">"__PLTcl_proc_%u_evttrigger"</literal></expr></argument>, <argument><expr><name>fn_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>is_trigger</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>internal_proname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>internal_proname</name></expr></argument>)</argument_list></sizeof></expr></argument>,
					 <argument><expr><literal type="string">"__PLTcl_proc_%u_trigger"</literal></expr></argument>, <argument><expr><name>fn_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>internal_proname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>internal_proname</name></expr></argument>)</argument_list></sizeof></expr></argument>,
					 <argument><expr><literal type="string">"__PLTcl_proc_%u"</literal></expr></argument>, <argument><expr><name>fn_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block" format="doxygen">/************************************************************
		 * Allocate a context that will hold all PG data for the procedure.
		 ************************************************************/</comment>
		<expr_stmt><expr><name>proc_cxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
										 <argument><expr><literal type="string">"PL/Tcl function"</literal></expr></argument>,
										 <argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block" format="doxygen">/************************************************************
		 * Allocate and fill a new procedure description block.
		 * struct prodesc and subsidiary data must all live in proc_cxt.
		 ************************************************************/</comment>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>proc_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>prodesc</name> <operator>=</operator> <operator>(</operator><name>pltcl_proc_desc</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pltcl_proc_desc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>user_proname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>procStruct</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSetIdentifier</name><argument_list>(<argument><expr><name>proc_cxt</name></expr></argument>, <argument><expr><name><name>prodesc</name><operator>-&gt;</operator><name>user_proname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>internal_proname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>internal_proname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>fn_cxt</name></name> <operator>=</operator> <name>proc_cxt</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>fn_refcount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>fn_xmin</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetRawXmin</name><argument_list>(<argument><expr><name><name>procTup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>fn_tid</name></name> <operator>=</operator> <name><name>procTup</name><operator>-&gt;</operator><name>t_self</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>nargs</name></name> <operator>=</operator> <name><name>procStruct</name><operator>-&gt;</operator><name>pronargs</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>arg_out_func</name></name> <operator>=</operator> <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>prodesc</name><operator>-&gt;</operator><name>nargs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>arg_is_rowtype</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>prodesc</name><operator>-&gt;</operator><name>nargs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Remember if function is STABLE/IMMUTABLE */</comment>
		<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>fn_readonly</name></name> <operator>=</operator>
			<operator>(</operator><name><name>procStruct</name><operator>-&gt;</operator><name>provolatile</name></name> <operator>!=</operator> <name>PROVOLATILE_VOLATILE</name><operator>)</operator></expr>;</expr_stmt>
		<comment type="block">/* And whether it is trusted */</comment>
		<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>lanpltrusted</name></name> <operator>=</operator> <name>pltrusted</name></expr>;</expr_stmt>

		<comment type="block" format="doxygen">/************************************************************
		 * Identify the interpreter to use for the function
		 ************************************************************/</comment>
		<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>interp_desc</name></name> <operator>=</operator> <call><name>pltcl_fetch_interp</name><argument_list>(<argument><expr><name><name>procStruct</name><operator>-&gt;</operator><name>prolang</name></name></expr></argument>,
												  <argument><expr><name><name>prodesc</name><operator>-&gt;</operator><name>lanpltrusted</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>interp</name> <operator>=</operator> <name><name>prodesc</name><operator>-&gt;</operator><name>interp_desc</name><operator>-&gt;</operator><name>interp</name></name></expr>;</expr_stmt>

		<comment type="block" format="doxygen">/************************************************************
		 * Get the required information for input conversion of the
		 * return value.
		 ************************************************************/</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_trigger</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_event_trigger</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>rettype</name> <init>= <expr><name><name>procStruct</name><operator>-&gt;</operator><name>prorettype</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>typeTup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>typeTup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>typeStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typeTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Disallow pseudotype result, except VOID and RECORD */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>typeStruct</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_PSEUDO</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>rettype</name> <operator>==</operator> <name>VOIDOID</name> <operator>||</operator>
					<name>rettype</name> <operator>==</operator> <name>RECORDOID</name></expr>)</condition><block type="pseudo"><block_content>
					 <comment type="block">/* okay */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>rettype</name> <operator>==</operator> <name>TRIGGEROID</name> <operator>||</operator>
						 <name>rettype</name> <operator>==</operator> <name>EVTTRIGGEROID</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"trigger functions can only be called as triggers"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PL/Tcl functions cannot return type %s"</literal></expr></argument>,
									<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>result_typid</name></name> <operator>=</operator> <name>rettype</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><name><name>typeStruct</name><operator>-&gt;</operator><name>typinput</name></name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>prodesc</name><operator>-&gt;</operator><name>result_in_func</name></name><operator>)</operator></expr></argument>,
						  <argument><expr><name>proc_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>result_typioparam</name></name> <operator>=</operator> <call><name>getTypeIOParam</name><argument_list>(<argument><expr><name>typeTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>fn_retisset</name></name> <operator>=</operator> <name><name>procStruct</name><operator>-&gt;</operator><name>proretset</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>fn_retistuple</name></name> <operator>=</operator> <call><name>type_is_rowtype</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>fn_retisdomain</name></name> <operator>=</operator> <operator>(</operator><name><name>typeStruct</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_DOMAIN</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>domain_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typeTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block" format="doxygen">/************************************************************
		 * Get the required information for output conversion
		 * of all procedure arguments, and set up argument naming info.
		 ************************************************************/</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_trigger</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_event_trigger</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>proc_internal_args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>prodesc</name><operator>-&gt;</operator><name>nargs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>argtype</name> <init>= <expr><name><name>procStruct</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>typeTup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>argtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>typeTup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>argtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>typeStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typeTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Disallow pseudotype argument, except RECORD */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>typeStruct</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_PSEUDO</name> <operator>&amp;&amp;</operator>
					<name>argtype</name> <operator>!=</operator> <name>RECORDOID</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PL/Tcl functions cannot accept type %s"</literal></expr></argument>,
									<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>argtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>type_is_rowtype</name><argument_list>(<argument><expr><name>argtype</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>arg_is_rowtype</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"__PLTcl_Tup_%d"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>arg_is_rowtype</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><name><name>typeStruct</name><operator>-&gt;</operator><name>typoutput</name></name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>prodesc</name><operator>-&gt;</operator><name>arg_out_func</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>,
								  <argument><expr><name>proc_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>proc_internal_args</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>proc_internal_args</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typeTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>is_trigger</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* trigger procedure has fixed args */</comment>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>proc_internal_args</name></expr></argument>,
				   <argument><expr><literal type="string">"TG_name TG_relid TG_table_name TG_table_schema TG_relatts TG_when TG_level TG_op __PLTcl_Tup_NEW __PLTcl_Tup_OLD args"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>is_event_trigger</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* event trigger procedure has fixed args */</comment>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>proc_internal_args</name></expr></argument>, <argument><expr><literal type="string">"TG_event TG_tag"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block" format="doxygen">/************************************************************
		 * Create the tcl command to define the internal
		 * procedure
		 *
		 * Leave this code as DString - performance is not critical here,
		 * and we don't want to duplicate the knowledge of the Tcl quoting
		 * rules that's embedded in Tcl_DStringAppendElement.
		 ************************************************************/</comment>
		<expr_stmt><expr><call><name>Tcl_DStringAppendElement</name><argument_list>(<argument><expr><operator>&amp;</operator><name>proc_internal_def</name></expr></argument>, <argument><expr><literal type="string">"proc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Tcl_DStringAppendElement</name><argument_list>(<argument><expr><operator>&amp;</operator><name>proc_internal_def</name></expr></argument>, <argument><expr><name>internal_proname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Tcl_DStringAppendElement</name><argument_list>(<argument><expr><operator>&amp;</operator><name>proc_internal_def</name></expr></argument>, <argument><expr><name>proc_internal_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block" format="doxygen">/************************************************************
		 * prefix procedure body with
		 * upvar #0 &lt;internal_proname&gt; GD
		 * and with appropriate setting of arguments
		 ************************************************************/</comment>
		<expr_stmt><expr><call><name>Tcl_DStringAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>proc_internal_body</name></expr></argument>, <argument><expr><literal type="string">"upvar #0 "</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Tcl_DStringAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>proc_internal_body</name></expr></argument>, <argument><expr><name>internal_proname</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Tcl_DStringAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>proc_internal_body</name></expr></argument>, <argument><expr><literal type="string">" GD\n"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>is_trigger</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Tcl_DStringAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>proc_internal_body</name></expr></argument>,
							  <argument><expr><literal type="string">"array set NEW $__PLTcl_Tup_NEW\n"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Tcl_DStringAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>proc_internal_body</name></expr></argument>,
							  <argument><expr><literal type="string">"array set OLD $__PLTcl_Tup_OLD\n"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Tcl_DStringAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>proc_internal_body</name></expr></argument>,
							  <argument><expr><literal type="string">"set i 0\n"</literal>
							  <literal type="string">"set v 0\n"</literal>
							  <literal type="string">"foreach v $args {\n"</literal>
							  <literal type="string">"  incr i\n"</literal>
							  <literal type="string">"  set $i $v\n"</literal>
							  <literal type="string">"}\n"</literal>
							  <literal type="string">"unset i v\n\n"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>is_event_trigger</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* no argument support for event triggers */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>prodesc</name><operator>-&gt;</operator><name>nargs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>prodesc</name><operator>-&gt;</operator><name>arg_is_rowtype</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
							 <argument><expr><literal type="string">"array set %d $__PLTcl_Tup_%d\n"</literal></expr></argument>,
							 <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Tcl_DStringAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>proc_internal_body</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></else></if_stmt>

		<comment type="block" format="doxygen">/************************************************************
		 * Add user's function definition to proc body
		 ************************************************************/</comment>
		<expr_stmt><expr><name>prosrcdatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>procTup</name></expr></argument>,
									  <argument><expr><name>Anum_pg_proc_prosrc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null prosrc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>proc_source</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>prosrcdatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>UTF_BEGIN</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Tcl_DStringAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>proc_internal_body</name></expr></argument>, <argument><expr><call><name>UTF_E2U</name><argument_list>(<argument><expr><name>proc_source</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>UTF_END</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>proc_source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Tcl_DStringAppendElement</name><argument_list>(<argument><expr><operator>&amp;</operator><name>proc_internal_def</name></expr></argument>,
								 <argument><expr><call><name>Tcl_DStringValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>proc_internal_body</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block" format="doxygen">/************************************************************
		 * Create the procedure in the interpreter
		 ************************************************************/</comment>
		<expr_stmt><expr><name>tcl_rc</name> <operator>=</operator> <call><name>Tcl_EvalEx</name><argument_list>(<argument><expr><name>interp</name></expr></argument>,
							<argument><expr><call><name>Tcl_DStringValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>proc_internal_def</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>Tcl_DStringLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name>proc_internal_def</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>TCL_EVAL_GLOBAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tcl_rc</name> <operator>!=</operator> <name>TCL_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_EXTERNAL_ROUTINE_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create internal procedure \"%s\": %s"</literal></expr></argument>,
							<argument><expr><name>internal_proname</name></expr></argument>,
							<argument><expr><call><name>utf_u2e</name><argument_list>(<argument><expr><call><name>Tcl_GetStringResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/*
		 * If we failed anywhere above, clean up whatever got allocated.  It
		 * should all be in the proc_cxt, except for the DStrings.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>proc_cxt</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>proc_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>Tcl_DStringFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>proc_internal_def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Tcl_DStringFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>proc_internal_body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Install the new proc description block in the hashtable, incrementing
	 * its refcount (the hashtable link counts as a reference).  Then, if
	 * there was a previous definition of the function, decrement that one's
	 * refcount, and delete it if no longer referenced.  The order of
	 * operations here is important: if something goes wrong during the
	 * MemoryContextDelete, leaking some memory for the old definition is OK,
	 * but we don't want to corrupt the live hashtable entry.  (Likewise,
	 * freeing the DStrings is pretty low priority if that happens.)
	 */</comment>
	<expr_stmt><expr><name>old_prodesc</name> <operator>=</operator> <name><name>proc_ptr</name><operator>-&gt;</operator><name>proc_ptr</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>proc_ptr</name><operator>-&gt;</operator><name>proc_ptr</name></name> <operator>=</operator> <name>prodesc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>fn_refcount</name></name><operator>++</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>old_prodesc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>old_prodesc</name><operator>-&gt;</operator><name>fn_refcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>--</operator><name><name>old_prodesc</name><operator>-&gt;</operator><name>fn_refcount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>old_prodesc</name><operator>-&gt;</operator><name>fn_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Tcl_DStringFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>proc_internal_def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Tcl_DStringFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>proc_internal_body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>procTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>prodesc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**********************************************************************
 * pltcl_elog()		- elog() support for PLTcl
 **********************************************************************/</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pltcl_elog</name><parameter_list>(<parameter><decl><type><name>ClientData</name></type> <name>cdata</name></decl></parameter>, <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
		   <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>, <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>objv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>level</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>priIndex</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>logpriorities</name><index>[]</index></name> <init>= <expr><block>{
		<expr><literal type="string">"DEBUG"</literal></expr>, <expr><literal type="string">"LOG"</literal></expr>, <expr><literal type="string">"INFO"</literal></expr>, <expr><literal type="string">"NOTICE"</literal></expr>,
		<expr><literal type="string">"WARNING"</literal></expr>, <expr><literal type="string">"ERROR"</literal></expr>, <expr><literal type="string">"FATAL"</literal></expr>, <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>loglevels</name><index>[]</index></name> <init>= <expr><block>{
		<expr><name>DEBUG2</name></expr>, <expr><name>LOG</name></expr>, <expr><name>INFO</name></expr>, <expr><name>NOTICE</name></expr>,
		<expr><name>WARNING</name></expr>, <expr><name>ERROR</name></expr>, <expr><name>FATAL</name></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>objc</name> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr><literal type="string">"level msg"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>TCL_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>Tcl_GetIndexFromObj</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>logpriorities</name></expr></argument>, <argument><expr><literal type="string">"priority"</literal></expr></argument>,
							<argument><expr><name>TCL_EXACT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>priIndex</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TCL_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>TCL_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>level</name> <operator>=</operator> <name><name>loglevels</name><index>[<expr><name>priIndex</name></expr>]</index></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>level</name> <operator>==</operator> <name>ERROR</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We just pass the error back to Tcl.  If it's not caught, it'll
		 * eventually get converted to a PG error when we reach the call
		 * handler.
		 */</comment>
		<expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>TCL_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * For non-error messages, just pass 'em to ereport().  We do not expect
	 * that this will fail, but just on the off chance it does, report the
	 * error back to Tcl.  Note we are assuming that ereport() can't have any
	 * internal failures that are so bad as to require a transaction abort.
	 *
	 * This path is also used for FATAL errors, which aren't going to come
	 * back to us at all.
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>UTF_BEGIN</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>level</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_EXTERNAL_ROUTINE_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>UTF_U2E</name><argument_list>(<argument><expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>UTF_END</name></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name></decl>;</decl_stmt>

		<comment type="block">/* Must reset elog.c's state */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>edata</name> <operator>=</operator> <call><name>CopyErrorData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Pass the error data to Tcl */</comment>
		<expr_stmt><expr><call><name>pltcl_construct_errorCode</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>UTF_BEGIN</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><call><name>UTF_E2U</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>UTF_END</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FreeErrorData</name><argument_list>(<argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>TCL_ERROR</name></expr>;</return>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>TCL_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**********************************************************************
 * pltcl_construct_errorCode()		- construct a Tcl errorCode
 *		list with detailed information from the PostgreSQL server
 **********************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pltcl_construct_errorCode</name><parameter_list>(<parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>, <parameter><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Tcl_Obj</name>    <modifier>*</modifier></type><name>obj</name> <init>= <expr><call><name>Tcl_NewObj</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>,
							 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"POSTGRES"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>,
							 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><name>PG_VERSION</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>,
							 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"SQLSTATE"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>,
							 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><call><name>unpack_sql_state</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>,
							 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"condition"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>,
							 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><call><name>pltcl_get_condition_name</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>,
							 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"message"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>UTF_BEGIN</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>,
							 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><call><name>UTF_E2U</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>UTF_END</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>detail</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>,
								 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"detail"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>UTF_BEGIN</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>,
								 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><call><name>UTF_E2U</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>detail</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>UTF_END</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>hint</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>,
								 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"hint"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>UTF_BEGIN</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>,
								 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><call><name>UTF_E2U</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>hint</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>UTF_END</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>context</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>,
								 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"context"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>UTF_BEGIN</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>,
								 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><call><name>UTF_E2U</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>UTF_END</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>schema_name</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>,
								 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"schema"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>UTF_BEGIN</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>,
								 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><call><name>UTF_E2U</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>UTF_END</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>table_name</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>,
								 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"table"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>UTF_BEGIN</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>,
								 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><call><name>UTF_E2U</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>UTF_END</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>column_name</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>,
								 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"column"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>UTF_BEGIN</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>,
								 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><call><name>UTF_E2U</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>column_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>UTF_END</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>datatype_name</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>,
								 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"datatype"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>UTF_BEGIN</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>,
								 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><call><name>UTF_E2U</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>datatype_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>UTF_END</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>constraint_name</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>,
								 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"constraint"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>UTF_BEGIN</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>,
								 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><call><name>UTF_E2U</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>constraint_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>UTF_END</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* cursorpos is never interesting here; report internal query/pos */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>internalquery</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>,
								 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"statement"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>UTF_BEGIN</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>,
								 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><call><name>UTF_E2U</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>internalquery</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>UTF_END</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>internalpos</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>,
								 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"cursor_position"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>,
								 <argument><expr><call><name>Tcl_NewIntObj</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>internalpos</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>filename</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>,
								 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"filename"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>UTF_BEGIN</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>,
								 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><call><name>UTF_E2U</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>UTF_END</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>lineno</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>,
								 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"lineno"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>,
								 <argument><expr><call><name>Tcl_NewIntObj</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>lineno</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>funcname</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>,
								 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"funcname"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>UTF_BEGIN</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>,
								 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><call><name>UTF_E2U</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>UTF_END</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Tcl_SetObjErrorCode</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**********************************************************************
 * pltcl_get_condition_name()	- find name for SQLSTATE
 **********************************************************************/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>pltcl_get_condition_name</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sqlstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>exception_name_map</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>label</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>exception_name_map</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sqlerrstate</name> <operator>==</operator> <name>sqlstate</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>exception_name_map</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>label</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><literal type="string">"unrecognized_sqlstate"</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**********************************************************************
 * pltcl_quote()	- quote literal strings that are to
 *			  be used in SPI_execute query strings
 **********************************************************************/</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pltcl_quote</name><parameter_list>(<parameter><decl><type><name>ClientData</name></type> <name>cdata</name></decl></parameter>, <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
			<parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>, <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>objv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cp1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cp2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>length</name></decl>;</decl_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * Check call syntax
	 ************************************************************/</comment>
	<if_stmt><if>if <condition>(<expr><name>objc</name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr><literal type="string">"string"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>TCL_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * Allocate space for the maximum the string can
	 * grow to and initialize pointers
	 ************************************************************/</comment>
	<expr_stmt><expr><name>cp1</name> <operator>=</operator> <call><name>Tcl_GetStringFromObj</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>length</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cp2</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * Walk through string and double every quote and backslash
	 ************************************************************/</comment>
	<while>while <condition>(<expr><operator>*</operator><name>cp1</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp1</name> <operator>==</operator> <literal type="char">'\''</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>cp2</name><operator>++</operator> <operator>=</operator> <literal type="char">'\''</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp1</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>cp2</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>cp2</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>cp1</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block" format="doxygen">/************************************************************
	 * Terminate the string and set it as result
	 ************************************************************/</comment>
	<expr_stmt><expr><operator>*</operator><name>cp2</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>TCL_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**********************************************************************
 * pltcl_argisnull()	- determine if a specific argument is NULL
 **********************************************************************/</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pltcl_argisnull</name><parameter_list>(<parameter><decl><type><name>ClientData</name></type> <name>cdata</name></decl></parameter>, <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>, <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>objv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>argno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name> <init>= <expr><name><name>pltcl_current_call_state</name><operator>-&gt;</operator><name>fcinfo</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * Check call syntax
	 ************************************************************/</comment>
	<if_stmt><if>if <condition>(<expr><name>objc</name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr><literal type="string">"argno"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>TCL_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * Check that we're called as a normal function
	 ************************************************************/</comment>
	<if_stmt><if>if <condition>(<expr><name>fcinfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>,
						 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"argisnull cannot be used in triggers"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>TCL_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * Get the argument number
	 ************************************************************/</comment>
	<if_stmt><if>if <condition>(<expr><call><name>Tcl_GetIntFromObj</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argno</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TCL_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>TCL_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * Check that the argno is valid
	 ************************************************************/</comment>
	<expr_stmt><expr><name>argno</name><operator>--</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>argno</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>argno</name> <operator>&gt;=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>nargs</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>,
						 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"argno out of range"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>TCL_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * Get the requested NULL state
	 ************************************************************/</comment>
	<expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_NewBooleanObj</name><argument_list>(<argument><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><name>argno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>TCL_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**********************************************************************
 * pltcl_returnnull()	- Cause a NULL return from the current function
 **********************************************************************/</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pltcl_returnnull</name><parameter_list>(<parameter><decl><type><name>ClientData</name></type> <name>cdata</name></decl></parameter>, <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
				 <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>, <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>objv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name> <init>= <expr><name><name>pltcl_current_call_state</name><operator>-&gt;</operator><name>fcinfo</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * Check call syntax
	 ************************************************************/</comment>
	<if_stmt><if>if <condition>(<expr><name>objc</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>TCL_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * Check that we're called as a normal function
	 ************************************************************/</comment>
	<if_stmt><if>if <condition>(<expr><name>fcinfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>,
						 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"return_null cannot be used in triggers"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>TCL_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * Set the NULL return flag and cause Tcl to return from the
	 * procedure.
	 ************************************************************/</comment>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<return>return <expr><name>TCL_RETURN</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**********************************************************************
 * pltcl_returnnext()	- Add a row to the result tuplestore in a SRF.
 **********************************************************************/</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pltcl_returnnext</name><parameter_list>(<parameter><decl><type><name>ClientData</name></type> <name>cdata</name></decl></parameter>, <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
				 <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>, <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>objv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pltcl_call_state</name> <modifier>*</modifier></type><name>call_state</name> <init>= <expr><name>pltcl_current_call_state</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name> <init>= <expr><name><name>call_state</name><operator>-&gt;</operator><name>fcinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pltcl_proc_desc</name> <modifier>*</modifier></type><name>prodesc</name> <init>= <expr><name><name>call_state</name><operator>-&gt;</operator><name>prodesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResourceOwner</name></type> <name>oldowner</name> <init>= <expr><name>CurrentResourceOwner</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>result</name> <init>= <expr><name>TCL_OK</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check that we're called as a set-returning function
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>fcinfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>,
						 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"return_next cannot be used in triggers"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>TCL_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>prodesc</name><operator>-&gt;</operator><name>fn_retisset</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>,
						 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"return_next cannot be used in non-set-returning functions"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>TCL_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check call syntax
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>objc</name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr><literal type="string">"result"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>TCL_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The rest might throw elog(ERROR), so must run in a subtransaction.
	 *
	 * A small advantage of using a subtransaction is that it provides a
	 * short-lived memory context for free, so we needn't worry about leaking
	 * memory here.  To use that context, call BeginInternalSubTransaction
	 * directly instead of going through pltcl_subtrans_begin.
	 */</comment>
	<expr_stmt><expr><call><name>BeginInternalSubTransaction</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/* Set up tuple store if first output row */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>call_state</name><operator>-&gt;</operator><name>tuple_store</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pltcl_init_tuple_store</name><argument_list>(<argument><expr><name>call_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>prodesc</name><operator>-&gt;</operator><name>fn_retistuple</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Tcl_Obj</name>   <modifier>*</modifier><modifier>*</modifier></type><name>rowObjv</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>rowObjc</name></decl>;</decl_stmt>

			<comment type="block">/* result should be a list, so break it down */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>Tcl_ListObjGetElements</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rowObjc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rowObjv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TCL_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>TCL_ERROR</name></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>pltcl_build_tuple_result</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>rowObjv</name></expr></argument>, <argument><expr><name>rowObjc</name></expr></argument>,
												 <argument><expr><name>call_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>tuplestore_puttuple</name><argument_list>(<argument><expr><name><name>call_state</name><operator>-&gt;</operator><name>tuple_store</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>retval</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* for paranoia's sake, check that tupdesc has exactly one column */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>call_state</name><operator>-&gt;</operator><name>ret_tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"wrong result type supplied in return_next"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>InputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>prodesc</name><operator>-&gt;</operator><name>result_in_func</name></name></expr></argument>,
									   <argument><expr><call><name>utf_u2e</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><name><name>prodesc</name><operator>-&gt;</operator><name>result_typioparam</name></name></expr></argument>,
									   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name><name>call_state</name><operator>-&gt;</operator><name>tuple_store</name></name></expr></argument>, <argument><expr><name><name>call_state</name><operator>-&gt;</operator><name>ret_tupdesc</name></name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>retval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>pltcl_subtrans_commit</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>, <argument><expr><name>oldowner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pltcl_subtrans_abort</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>oldcontext</name></expr></argument>, <argument><expr><name>oldowner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>TCL_ERROR</name></expr>;</return>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*----------
 * Support for running SPI operations inside subtransactions
 *
 * Intended usage pattern is:
 *
 *	MemoryContext oldcontext = CurrentMemoryContext;
 *	ResourceOwner oldowner = CurrentResourceOwner;
 *
 *	...
 *	pltcl_subtrans_begin(oldcontext, oldowner);
 *	PG_TRY();
 *	{
 *		do something risky;
 *		pltcl_subtrans_commit(oldcontext, oldowner);
 *	}
 *	PG_CATCH();
 *	{
 *		pltcl_subtrans_abort(interp, oldcontext, oldowner);
 *		return TCL_ERROR;
 *	}
 *	PG_END_TRY();
 *	return TCL_OK;
 *----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pltcl_subtrans_begin</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl></parameter>, <parameter><decl><type><name>ResourceOwner</name></type> <name>oldowner</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>BeginInternalSubTransaction</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Want to run inside function's memory context */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pltcl_subtrans_commit</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl></parameter>, <parameter><decl><type><name>ResourceOwner</name></type> <name>oldowner</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Commit the inner transaction, return to outer xact context */</comment>
	<expr_stmt><expr><call><name>ReleaseCurrentSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>oldowner</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pltcl_subtrans_abort</name><parameter_list>(<parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
					 <parameter><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl></parameter>, <parameter><decl><type><name>ResourceOwner</name></type> <name>oldowner</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name></decl>;</decl_stmt>

	<comment type="block">/* Save error info */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>edata</name> <operator>=</operator> <call><name>CopyErrorData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Abort the inner transaction */</comment>
	<expr_stmt><expr><call><name>RollbackAndReleaseCurrentSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>oldowner</name></expr>;</expr_stmt>

	<comment type="block">/* Pass the error data to Tcl */</comment>
	<expr_stmt><expr><call><name>pltcl_construct_errorCode</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>UTF_BEGIN</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><call><name>UTF_E2U</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>UTF_END</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FreeErrorData</name><argument_list>(<argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**********************************************************************
 * pltcl_SPI_execute()		- The builtin SPI_execute command
 *				  for the Tcl interpreter
 **********************************************************************/</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pltcl_SPI_execute</name><parameter_list>(<parameter><decl><type><name>ClientData</name></type> <name>cdata</name></decl></parameter>, <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>, <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>objv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>my_rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>spi_rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>query_idx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>optIndex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>volatile</specifier></type> <name>arrayname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tcl_Obj</name>    <modifier>*</modifier><specifier>volatile</specifier></type> <name>loop_body</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResourceOwner</name></type> <name>oldowner</name> <init>= <expr><name>CurrentResourceOwner</name></expr></init></decl>;</decl_stmt>

	<enum>enum <name>options</name>
	<block>{
		<decl><name>OPT_ARRAY</name></decl>, <decl><name>OPT_COUNT</name></decl>
	}</block>;</enum>

	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>options</name><index>[]</index></name> <init>= <expr><block>{
		<expr><literal type="string">"-array"</literal></expr>, <expr><literal type="string">"-count"</literal></expr>, <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * Check the call syntax and get the options
	 ************************************************************/</comment>
	<if_stmt><if>if <condition>(<expr><name>objc</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objv</name></expr></argument>,
						 <argument><expr><literal type="string">"?-count n? ?-array name? query ?loop body?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>TCL_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>objc</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>Tcl_GetIndexFromObj</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								<argument><expr><name>TCL_EXACT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>optIndex</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TCL_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>++</operator><name>i</name> <operator>&gt;=</operator> <name>objc</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>,
							 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"missing argument to -count or -array"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>TCL_ERROR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<switch>switch <condition>(<expr><operator>(</operator>enum <name>options</name><operator>)</operator> <name>optIndex</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>OPT_ARRAY</name></expr>:</case>
				<expr_stmt><expr><name>arrayname</name> <operator>=</operator> <call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>OPT_COUNT</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>Tcl_GetIntFromObj</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>count</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TCL_OK</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>TCL_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></while>

	<expr_stmt><expr><name>query_idx</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>query_idx</name> <operator>&gt;=</operator> <name>objc</name> <operator>||</operator> <name>query_idx</name> <operator>+</operator> <literal type="number">2</literal> <operator>&lt;</operator> <name>objc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>query_idx</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr><literal type="string">"query ?loop body?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>TCL_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>query_idx</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>objc</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>loop_body</name> <operator>=</operator> <name><name>objv</name><index>[<expr><name>query_idx</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * Execute the query inside a sub-transaction, so we can cope with
	 * errors sanely
	 ************************************************************/</comment>

	<expr_stmt><expr><call><name>pltcl_subtrans_begin</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>, <argument><expr><name>oldowner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>UTF_BEGIN</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>spi_rc</name> <operator>=</operator> <call><name>SPI_execute</name><argument_list>(<argument><expr><call><name>UTF_U2E</name><argument_list>(<argument><expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><name>query_idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name><name>pltcl_current_call_state</name><operator>-&gt;</operator><name>prodesc</name><operator>-&gt;</operator><name>fn_readonly</name></name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>UTF_END</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>my_rc</name> <operator>=</operator> <call><name>pltcl_process_SPI_result</name><argument_list>(<argument><expr><name>interp</name></expr></argument>,
										 <argument><expr><name>arrayname</name></expr></argument>,
										 <argument><expr><name>loop_body</name></expr></argument>,
										 <argument><expr><name>spi_rc</name></expr></argument>,
										 <argument><expr><name>SPI_tuptable</name></expr></argument>,
										 <argument><expr><name>SPI_processed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pltcl_subtrans_commit</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>, <argument><expr><name>oldowner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pltcl_subtrans_abort</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>oldcontext</name></expr></argument>, <argument><expr><name>oldowner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>TCL_ERROR</name></expr>;</return>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>my_rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Process the result from SPI_execute or SPI_execute_plan
 *
 * Shared code between pltcl_SPI_execute and pltcl_SPI_execute_plan
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pltcl_process_SPI_result</name><parameter_list>(<parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
						 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arrayname</name></decl></parameter>,
						 <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier></type><name>loop_body</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>spi_rc</name></decl></parameter>,
						 <parameter><decl><type><name>SPITupleTable</name> <modifier>*</modifier></type><name>tuptable</name></decl></parameter>,
						 <parameter><decl><type><name>uint64</name></type> <name>ntuples</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>my_rc</name> <init>= <expr><name>TCL_OK</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>loop_rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name>  <modifier>*</modifier></type><name>tuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>spi_rc</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>SPI_OK_SELINTO</name></expr>:</case>
		<case>case <expr><name>SPI_OK_INSERT</name></expr>:</case>
		<case>case <expr><name>SPI_OK_DELETE</name></expr>:</case>
		<case>case <expr><name>SPI_OK_UPDATE</name></expr>:</case>
			<expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_NewWideIntObj</name><argument_list>(<argument><expr><name>ntuples</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>SPI_OK_UTILITY</name></expr>:</case>
		<case>case <expr><name>SPI_OK_REWRITTEN</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>tuptable</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_NewIntObj</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* fall through for utility returning tuples */</comment>
			<comment type="block">/* FALLTHROUGH */</comment>

		<case>case <expr><name>SPI_OK_SELECT</name></expr>:</case>
		<case>case <expr><name>SPI_OK_INSERT_RETURNING</name></expr>:</case>
		<case>case <expr><name>SPI_OK_DELETE_RETURNING</name></expr>:</case>
		<case>case <expr><name>SPI_OK_UPDATE_RETURNING</name></expr>:</case>

			<comment type="block">/*
			 * Process the tuples we got
			 */</comment>
			<expr_stmt><expr><name>tuples</name> <operator>=</operator> <name><name>tuptable</name><operator>-&gt;</operator><name>vals</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <name><name>tuptable</name><operator>-&gt;</operator><name>tupdesc</name></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>loop_body</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * If there is no loop body given, just set the variables from
				 * the first tuple (if any)
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>ntuples</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>pltcl_set_tuple_values</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>arrayname</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
										   <argument><expr><name><name>tuples</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * There is a loop body - process all tuples and evaluate the
				 * body on each
				 */</comment>
				<decl_stmt><decl><type><name>uint64</name></type>		<name>i</name></decl>;</decl_stmt>

				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntuples</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<expr_stmt><expr><call><name>pltcl_set_tuple_values</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>arrayname</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
										   <argument><expr><name><name>tuples</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>loop_rc</name> <operator>=</operator> <call><name>Tcl_EvalObjEx</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>loop_body</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>loop_rc</name> <operator>==</operator> <name>TCL_OK</name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name>loop_rc</name> <operator>==</operator> <name>TCL_CONTINUE</name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name>loop_rc</name> <operator>==</operator> <name>TCL_RETURN</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>my_rc</name> <operator>=</operator> <name>TCL_RETURN</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name>loop_rc</name> <operator>==</operator> <name>TCL_BREAK</name></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>my_rc</name> <operator>=</operator> <name>TCL_ERROR</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></for>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>my_rc</name> <operator>==</operator> <name>TCL_OK</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_NewWideIntObj</name><argument_list>(<argument><expr><name>ntuples</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="string">"pltcl: SPI_execute failed: "</literal></expr></argument>,
							 <argument><expr><call><name>SPI_result_code_string</name><argument_list>(<argument><expr><name>spi_rc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>my_rc</name> <operator>=</operator> <name>TCL_ERROR</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>SPI_freetuptable</name><argument_list>(<argument><expr><name>tuptable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>my_rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**********************************************************************
 * pltcl_SPI_prepare()		- Builtin support for prepared plans
 *				  The Tcl command SPI_prepare
 *				  always saves the plan using
 *				  SPI_keepplan and returns a key for
 *				  access. There is no chance to prepare
 *				  and not save the plan currently.
 **********************************************************************/</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pltcl_SPI_prepare</name><parameter_list>(<parameter><decl><type><name>ClientData</name></type> <name>cdata</name></decl></parameter>, <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>, <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>objv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>MemoryContext</name></type> <name>plan_cxt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tcl_Obj</name>   <modifier>*</modifier><modifier>*</modifier></type><name>argsObj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pltcl_query_desc</name> <modifier>*</modifier></type><name>qdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tcl_HashEntry</name> <modifier>*</modifier></type><name>hashent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>hashnew</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tcl_HashTable</name> <modifier>*</modifier></type><name>query_hash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResourceOwner</name></type> <name>oldowner</name> <init>= <expr><name>CurrentResourceOwner</name></expr></init></decl>;</decl_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * Check the call syntax
	 ************************************************************/</comment>
	<if_stmt><if>if <condition>(<expr><name>objc</name> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr><literal type="string">"query argtypes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>TCL_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * Split the argument type list
	 ************************************************************/</comment>
	<if_stmt><if>if <condition>(<expr><call><name>Tcl_ListObjGetElements</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nargs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argsObj</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TCL_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>TCL_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * Allocate the new querydesc structure
	 *
	 * struct qdesc and subsidiary data all live in plan_cxt.  Note that if the
	 * function is recompiled for whatever reason, permanent memory leaks
	 * occur.  FIXME someday.
	 ************************************************************/</comment>
	<expr_stmt><expr><name>plan_cxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
									 <argument><expr><literal type="string">"PL/Tcl spi_prepare query"</literal></expr></argument>,
									 <argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>plan_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>qdesc</name> <operator>=</operator> <operator>(</operator><name>pltcl_query_desc</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pltcl_query_desc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>qdesc</name><operator>-&gt;</operator><name>qname</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>qdesc</name><operator>-&gt;</operator><name>qname</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%p"</literal></expr></argument>, <argument><expr><name>qdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qdesc</name><operator>-&gt;</operator><name>nargs</name></name> <operator>=</operator> <name>nargs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qdesc</name><operator>-&gt;</operator><name>argtypes</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qdesc</name><operator>-&gt;</operator><name>arginfuncs</name></name> <operator>=</operator> <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qdesc</name><operator>-&gt;</operator><name>argtypioparams</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * Execute the prepare inside a sub-transaction, so we can cope with
	 * errors sanely
	 ************************************************************/</comment>

	<expr_stmt><expr><call><name>pltcl_subtrans_begin</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>, <argument><expr><name>oldowner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block" format="doxygen">/************************************************************
		 * Resolve argument type names and then look them up by oid
		 * in the system cache, and remember the required information
		 * for input conversion.
		 ************************************************************/</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>typId</name></decl>,
						<decl><type ref="prev"/><name>typInput</name></decl>,
						<decl><type ref="prev"/><name>typIOParam</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>parseTypeString</name><argument_list>(<argument><expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>argsObj</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>typId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typmod</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>getTypeInputInfo</name><argument_list>(<argument><expr><name>typId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typInput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typIOParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>qdesc</name><operator>-&gt;</operator><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>typId</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><name>typInput</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>qdesc</name><operator>-&gt;</operator><name>arginfuncs</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><name>plan_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>qdesc</name><operator>-&gt;</operator><name>argtypioparams</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>typIOParam</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block" format="doxygen">/************************************************************
		 * Prepare the plan and check for errors
		 ************************************************************/</comment>
		<expr_stmt><expr><name>UTF_BEGIN</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qdesc</name><operator>-&gt;</operator><name>plan</name></name> <operator>=</operator> <call><name>SPI_prepare</name><argument_list>(<argument><expr><call><name>UTF_U2E</name><argument_list>(<argument><expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name><name>qdesc</name><operator>-&gt;</operator><name>argtypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>UTF_END</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>qdesc</name><operator>-&gt;</operator><name>plan</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_prepare() failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block" format="doxygen">/************************************************************
		 * Save the plan into permanent memory (right now it's in the
		 * SPI procCxt, which will go away at function end).
		 ************************************************************/</comment>
		<if_stmt><if>if <condition>(<expr><call><name>SPI_keepplan</name><argument_list>(<argument><expr><name><name>qdesc</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_keepplan() failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>pltcl_subtrans_commit</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>, <argument><expr><name>oldowner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pltcl_subtrans_abort</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>oldcontext</name></expr></argument>, <argument><expr><name>oldowner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>plan_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>TCL_ERROR</name></expr>;</return>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * Insert a hashtable entry for the plan and return
	 * the key to the caller
	 ************************************************************/</comment>
	<expr_stmt><expr><name>query_hash</name> <operator>=</operator> <operator>&amp;</operator><name><name>pltcl_current_call_state</name><operator>-&gt;</operator><name>prodesc</name><operator>-&gt;</operator><name>interp_desc</name><operator>-&gt;</operator><name>query_hash</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>hashent</name> <operator>=</operator> <call><name>Tcl_CreateHashEntry</name><argument_list>(<argument><expr><name>query_hash</name></expr></argument>, <argument><expr><name><name>qdesc</name><operator>-&gt;</operator><name>qname</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hashnew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Tcl_SetHashValue</name><argument_list>(<argument><expr><name>hashent</name></expr></argument>, <argument><expr><operator>(</operator><name>ClientData</name><operator>)</operator> <name>qdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* qname is ASCII, so no need for encoding conversion */</comment>
	<expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><name><name>qdesc</name><operator>-&gt;</operator><name>qname</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>TCL_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**********************************************************************
 * pltcl_SPI_execute_plan()		- Execute a prepared plan
 **********************************************************************/</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pltcl_SPI_execute_plan</name><parameter_list>(<parameter><decl><type><name>ClientData</name></type> <name>cdata</name></decl></parameter>, <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>, <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>objv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>my_rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>spi_rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>optIndex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tcl_HashEntry</name> <modifier>*</modifier></type><name>hashent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pltcl_query_desc</name> <modifier>*</modifier></type><name>qdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nulls</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arrayname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tcl_Obj</name>    <modifier>*</modifier></type><name>loop_body</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>callObjc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tcl_Obj</name>   <modifier>*</modifier><modifier>*</modifier></type><name>callObjv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>argvalues</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResourceOwner</name></type> <name>oldowner</name> <init>= <expr><name>CurrentResourceOwner</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tcl_HashTable</name> <modifier>*</modifier></type><name>query_hash</name></decl>;</decl_stmt>

	<enum>enum <name>options</name>
	<block>{
		<decl><name>OPT_ARRAY</name></decl>, <decl><name>OPT_COUNT</name></decl>, <decl><name>OPT_NULLS</name></decl>
	}</block>;</enum>

	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>options</name><index>[]</index></name> <init>= <expr><block>{
		<expr><literal type="string">"-array"</literal></expr>, <expr><literal type="string">"-count"</literal></expr>, <expr><literal type="string">"-nulls"</literal></expr>, <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * Get the options and check syntax
	 ************************************************************/</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>objc</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>Tcl_GetIndexFromObj</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								<argument><expr><name>TCL_EXACT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>optIndex</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TCL_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>++</operator><name>i</name> <operator>&gt;=</operator> <name>objc</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>,
							 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"missing argument to -array, -count or -nulls"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>TCL_ERROR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<switch>switch <condition>(<expr><operator>(</operator>enum <name>options</name><operator>)</operator> <name>optIndex</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>OPT_ARRAY</name></expr>:</case>
				<expr_stmt><expr><name>arrayname</name> <operator>=</operator> <call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>OPT_COUNT</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>Tcl_GetIntFromObj</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>count</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TCL_OK</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>TCL_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><name>OPT_NULLS</name></expr>:</case>
				<expr_stmt><expr><name>nulls</name> <operator>=</operator> <call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></while>

	<comment type="block" format="doxygen">/************************************************************
	 * Get the prepared plan descriptor by its key
	 ************************************************************/</comment>
	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>objc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>,
						 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"missing argument to -count or -array"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>TCL_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>query_hash</name> <operator>=</operator> <operator>&amp;</operator><name><name>pltcl_current_call_state</name><operator>-&gt;</operator><name>prodesc</name><operator>-&gt;</operator><name>interp_desc</name><operator>-&gt;</operator><name>query_hash</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>hashent</name> <operator>=</operator> <call><name>Tcl_FindHashEntry</name><argument_list>(<argument><expr><name>query_hash</name></expr></argument>, <argument><expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>hashent</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="string">"invalid queryid '"</literal></expr></argument>, <argument><expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"'"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>TCL_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>qdesc</name> <operator>=</operator> <operator>(</operator><name>pltcl_query_desc</name> <operator>*</operator><operator>)</operator> <call><name>Tcl_GetHashValue</name><argument_list>(<argument><expr><name>hashent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * If a nulls string is given, check for correct length
	 ************************************************************/</comment>
	<if_stmt><if>if <condition>(<expr><name>nulls</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>qdesc</name><operator>-&gt;</operator><name>nargs</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>,
							 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"length of nulls string doesn't match number of arguments"</literal></expr></argument>,
											  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>TCL_ERROR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * If there was an argtype list on preparation, we need
	 * an argument value list now
	 ************************************************************/</comment>
	<if_stmt><if>if <condition>(<expr><name><name>qdesc</name><operator>-&gt;</operator><name>nargs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>objc</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>,
							 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"argument list length doesn't match number of arguments for query"</literal></expr></argument>,
											  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>TCL_ERROR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block" format="doxygen">/************************************************************
		 * Split the argument values
		 ************************************************************/</comment>
		<if_stmt><if>if <condition>(<expr><call><name>Tcl_ListObjGetElements</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>callObjc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>callObjv</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TCL_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>TCL_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block" format="doxygen">/************************************************************
		 * Check that the number of arguments matches
		 ************************************************************/</comment>
		<if_stmt><if>if <condition>(<expr><name>callObjc</name> <operator>!=</operator> <name><name>qdesc</name><operator>-&gt;</operator><name>nargs</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>,
							 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><literal type="string">"argument list length doesn't match number of arguments for query"</literal></expr></argument>,
											  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>TCL_ERROR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>callObjc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * Get loop body if present
	 ************************************************************/</comment>
	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>objc</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>loop_body</name> <operator>=</operator> <name><name>objv</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <name>objc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objv</name></expr></argument>,
						 <argument><expr><literal type="string">"?-count n? ?-array name? ?-nulls string? "</literal>
						 <literal type="string">"query ?args? ?loop body?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>TCL_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * Execute the plan inside a sub-transaction, so we can cope with
	 * errors sanely
	 ************************************************************/</comment>

	<expr_stmt><expr><call><name>pltcl_subtrans_begin</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>, <argument><expr><name>oldowner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block" format="doxygen">/************************************************************
		 * Setup the value array for SPI_execute_plan() using
		 * the type specific input functions
		 ************************************************************/</comment>
		<expr_stmt><expr><name>argvalues</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>callObjc</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>callObjc</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>nulls</name> <operator>&amp;&amp;</operator> <name><name>nulls</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <literal type="char">'n'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>argvalues</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>InputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>qdesc</name><operator>-&gt;</operator><name>arginfuncs</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
												 <argument><expr><name>NULL</name></expr></argument>,
												 <argument><expr><name><name>qdesc</name><operator>-&gt;</operator><name>argtypioparams</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
												 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>UTF_BEGIN</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>argvalues</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>InputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>qdesc</name><operator>-&gt;</operator><name>arginfuncs</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
												 <argument><expr><call><name>UTF_U2E</name><argument_list>(<argument><expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>callObjv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><name><name>qdesc</name><operator>-&gt;</operator><name>argtypioparams</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
												 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>UTF_END</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>

		<comment type="block" format="doxygen">/************************************************************
		 * Execute the plan
		 ************************************************************/</comment>
		<expr_stmt><expr><name>spi_rc</name> <operator>=</operator> <call><name>SPI_execute_plan</name><argument_list>(<argument><expr><name><name>qdesc</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><name>argvalues</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>,
								  <argument><expr><name><name>pltcl_current_call_state</name><operator>-&gt;</operator><name>prodesc</name><operator>-&gt;</operator><name>fn_readonly</name></name></expr></argument>,
								  <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>my_rc</name> <operator>=</operator> <call><name>pltcl_process_SPI_result</name><argument_list>(<argument><expr><name>interp</name></expr></argument>,
										 <argument><expr><name>arrayname</name></expr></argument>,
										 <argument><expr><name>loop_body</name></expr></argument>,
										 <argument><expr><name>spi_rc</name></expr></argument>,
										 <argument><expr><name>SPI_tuptable</name></expr></argument>,
										 <argument><expr><name>SPI_processed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pltcl_subtrans_commit</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>, <argument><expr><name>oldowner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pltcl_subtrans_abort</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>oldcontext</name></expr></argument>, <argument><expr><name>oldowner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>TCL_ERROR</name></expr>;</return>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>my_rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**********************************************************************
 * pltcl_subtransaction()	- Execute some Tcl code in a subtransaction
 *
 * The subtransaction is aborted if the Tcl code fragment returns TCL_ERROR,
 * otherwise it's subcommitted.
 **********************************************************************/</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pltcl_subtransaction</name><parameter_list>(<parameter><decl><type><name>ClientData</name></type> <name>cdata</name></decl></parameter>, <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>, <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>objv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResourceOwner</name></type> <name>oldowner</name> <init>= <expr><name>CurrentResourceOwner</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>retcode</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>objc</name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr><literal type="string">"command"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>TCL_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Note: we don't use pltcl_subtrans_begin and friends here because we
	 * don't want the error handling in pltcl_subtrans_abort.  But otherwise
	 * the processing should be about the same as in those functions.
	 */</comment>
	<expr_stmt><expr><call><name>BeginInternalSubTransaction</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>retcode</name> <operator>=</operator> <call><name>Tcl_EvalObjEx</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>retcode</name> <operator>==</operator> <name>TCL_ERROR</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Rollback the subtransaction */</comment>
		<expr_stmt><expr><call><name>RollbackAndReleaseCurrentSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Commit the subtransaction */</comment>
		<expr_stmt><expr><call><name>ReleaseCurrentSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* In either case, restore previous memory context and resource owner */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>oldowner</name></expr>;</expr_stmt>

	<return>return <expr><name>retcode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**********************************************************************
 * pltcl_commit()
 *
 * Commit the transaction and start a new one.
 **********************************************************************/</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pltcl_commit</name><parameter_list>(<parameter><decl><type><name>ClientData</name></type> <name>cdata</name></decl></parameter>, <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
			 <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>, <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>objv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SPI_commit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name></decl>;</decl_stmt>

		<comment type="block">/* Save error info */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>edata</name> <operator>=</operator> <call><name>CopyErrorData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Pass the error data to Tcl */</comment>
		<expr_stmt><expr><call><name>pltcl_construct_errorCode</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>UTF_BEGIN</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><call><name>UTF_E2U</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>UTF_END</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FreeErrorData</name><argument_list>(<argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>TCL_ERROR</name></expr>;</return>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>TCL_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**********************************************************************
 * pltcl_rollback()
 *
 * Abort the transaction and start a new one.
 **********************************************************************/</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pltcl_rollback</name><parameter_list>(<parameter><decl><type><name>ClientData</name></type> <name>cdata</name></decl></parameter>, <parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>,
			   <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>, <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>objv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SPI_rollback</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name></decl>;</decl_stmt>

		<comment type="block">/* Save error info */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>edata</name> <operator>=</operator> <call><name>CopyErrorData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Pass the error data to Tcl */</comment>
		<expr_stmt><expr><call><name>pltcl_construct_errorCode</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>UTF_BEGIN</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><call><name>UTF_E2U</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>UTF_END</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FreeErrorData</name><argument_list>(<argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>TCL_ERROR</name></expr>;</return>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>TCL_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**********************************************************************
 * pltcl_set_tuple_values() - Set variables for all attributes
 *				  of a given tuple
 *
 * Note: arrayname is presumed to be UTF8; it usually came from Tcl
 **********************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pltcl_set_tuple_values</name><parameter_list>(<parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arrayname</name></decl></parameter>,
					   <parameter><decl><type><name>uint64</name></type> <name>tupno</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>outputstr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>attr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typoutput</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typisvarlena</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>arrptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nameptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nullname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * Prepare pointers for Tcl_SetVar2Ex() below
	 ************************************************************/</comment>
	<if_stmt><if>if <condition>(<expr><name>arrayname</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>arrptr</name> <operator>=</operator> <operator>&amp;</operator><name>attname</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nameptr</name> <operator>=</operator> <operator>&amp;</operator><name>nullname</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>arrptr</name> <operator>=</operator> <operator>&amp;</operator><name>arrayname</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nameptr</name> <operator>=</operator> <operator>&amp;</operator><name>attname</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * When outputting to an array, fill the ".tupno" element with the
		 * current tuple number.  This will be overridden below if ".tupno" is
		 * in use as an actual field name in the rowtype.
		 */</comment>
		<expr_stmt><expr><call><name>Tcl_SetVar2Ex</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>arrayname</name></expr></argument>, <argument><expr><literal type="string">".tupno"</literal></expr></argument>, <argument><expr><call><name>Tcl_NewWideIntObj</name><argument_list>(<argument><expr><name>tupno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* ignore dropped attributes */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block" format="doxygen">/************************************************************
		 * Get the attribute name
		 ************************************************************/</comment>
		<expr_stmt><expr><name>UTF_BEGIN</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>UTF_E2U</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>UTF_END</name></expr>;</expr_stmt>

		<comment type="block" format="doxygen">/************************************************************
		 * Get the attributes value
		 ************************************************************/</comment>
		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block" format="doxygen">/************************************************************
		 * If there is a value, set the variable
		 * If not, unset it
		 *
		 * Hmmm - Null attributes will cause functions to
		 *		  crash if they don't expect them - need something
		 *		  smarter here.
		 ************************************************************/</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typoutput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typisvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>outputstr</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>typoutput</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>UTF_BEGIN</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Tcl_SetVar2Ex</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><operator>*</operator><name>arrptr</name></expr></argument>, <argument><expr><operator>*</operator><name>nameptr</name></expr></argument>,
						  <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><call><name>UTF_E2U</name><argument_list>(<argument><expr><name>outputstr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>UTF_END</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>outputstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>Tcl_UnsetVar2</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><operator>*</operator><name>arrptr</name></expr></argument>, <argument><expr><operator>*</operator><name>nameptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>unconstify</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>, <argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**********************************************************************
 * pltcl_build_tuple_argument() - Build a list object usable for 'array set'
 *				  from all attributes of a given tuple
 **********************************************************************/</comment>
<function><type><specifier>static</specifier> <name>Tcl_Obj</name> <modifier>*</modifier></type>
<name>pltcl_build_tuple_argument</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>include_generated</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Tcl_Obj</name>    <modifier>*</modifier></type><name>retobj</name> <init>= <expr><call><name>Tcl_NewObj</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>outputstr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>attr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typoutput</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typisvarlena</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* ignore dropped attributes */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attgenerated</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* don't include unless requested */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>include_generated</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block" format="doxygen">/************************************************************
		 * Get the attribute name
		 ************************************************************/</comment>
		<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block" format="doxygen">/************************************************************
		 * Get the attributes value
		 ************************************************************/</comment>
		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block" format="doxygen">/************************************************************
		 * If there is a value, append the attribute name and the
		 * value to the list
		 *
		 * Hmmm - Null attributes will cause functions to
		 *		  crash if they don't expect them - need something
		 *		  smarter here.
		 ************************************************************/</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>typoutput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typisvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>outputstr</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>typoutput</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>UTF_BEGIN</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>retobj</name></expr></argument>,
									 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><call><name>UTF_E2U</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>UTF_END</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>UTF_BEGIN</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>retobj</name></expr></argument>,
									 <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><call><name>UTF_E2U</name><argument_list>(<argument><expr><name>outputstr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>UTF_END</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>outputstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>retobj</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************
 * pltcl_build_tuple_result() - Build a tuple of function's result rowtype
 *				  from a Tcl list of column names and values
 *
 * In a trigger function, we build a tuple of the trigger table's rowtype.
 *
 * Note: this function leaks memory.  Even if we made it clean up its own
 * mess, there's no way to prevent the datatype input functions it calls
 * from leaking.  Run it in a short-lived context, unless we're about to
 * exit the procedure anyway.
 **********************************************************************/</comment>
<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>pltcl_build_tuple_result</name><parameter_list>(<parameter><decl><type><name>Tcl_Interp</name> <modifier>*</modifier></type><name>interp</name></decl></parameter>, <parameter><decl><type><name>Tcl_Obj</name> <modifier>*</modifier><modifier>*</modifier></type><name>kvObjv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kvObjc</name></decl></parameter>,
						 <parameter><decl><type><name>pltcl_call_state</name> <modifier>*</modifier></type><name>call_state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttInMetadata</name> <modifier>*</modifier></type><name>attinmeta</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>call_state</name><operator>-&gt;</operator><name>ret_tupdesc</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <name><name>call_state</name><operator>-&gt;</operator><name>ret_tupdesc</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>attinmeta</name> <operator>=</operator> <name><name>call_state</name><operator>-&gt;</operator><name>attinmeta</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>call_state</name><operator>-&gt;</operator><name>trigdata</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>call_state</name><operator>-&gt;</operator><name>trigdata</name><operator>-&gt;</operator><name>tg_relation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attinmeta</name> <operator>=</operator> <call><name>TupleDescGetAttInMetadata</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"PL/Tcl function does not return a tuple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>			<comment type="block">/* keep compiler quiet */</comment>
		<expr_stmt><expr><name>attinmeta</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>kvObjc</name> <operator>%</operator> <literal type="number">2</literal> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column name/value list must have even number of elements"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>kvObjc</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fieldName</name> <init>= <expr><call><name>utf_u2e</name><argument_list>(<argument><expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>kvObjv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>attn</name> <init>= <expr><call><name>SPI_fnumber</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * We silently ignore ".tupno", if it's present but doesn't match any
		 * actual output column.  This allows direct use of a row returned by
		 * pltcl_set_tuple_values().
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>attn</name> <operator>==</operator> <name>SPI_ERROR_NOATTRIBUTE</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>fieldName</name></expr></argument>, <argument><expr><literal type="string">".tupno"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column name/value list contains nonexistent column name \"%s\""</literal></expr></argument>,
							<argument><expr><name>fieldName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>attn</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot set system attribute \"%s\""</literal></expr></argument>,
							<argument><expr><name>fieldName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>attn</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attgenerated</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot set generated column \"%s\""</literal></expr></argument>,
							<argument><expr><name>fieldName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><name>attn</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>utf_u2e</name><argument_list>(<argument><expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>kvObjv</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>BuildTupleFromCStrings</name><argument_list>(<argument><expr><name>attinmeta</name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* if result type is domain-over-composite, check domain constraints */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>call_state</name><operator>-&gt;</operator><name>prodesc</name><operator>-&gt;</operator><name>fn_retisdomain</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>domain_check</name><argument_list>(<argument><expr><call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>,
					 <argument><expr><name><name>call_state</name><operator>-&gt;</operator><name>prodesc</name><operator>-&gt;</operator><name>result_typid</name></name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name><name>call_state</name><operator>-&gt;</operator><name>prodesc</name><operator>-&gt;</operator><name>domain_info</name></name></expr></argument>,
					 <argument><expr><name><name>call_state</name><operator>-&gt;</operator><name>prodesc</name><operator>-&gt;</operator><name>fn_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************
 * pltcl_init_tuple_store() - Initialize the result tuplestore for a SRF
 **********************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pltcl_init_tuple_store</name><parameter_list>(<parameter><decl><type><name>pltcl_call_state</name> <modifier>*</modifier></type><name>call_state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsi</name> <init>= <expr><name><name>call_state</name><operator>-&gt;</operator><name>rsi</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResourceOwner</name></type> <name>oldowner</name></decl>;</decl_stmt>

	<comment type="block">/* Should be in a SRF */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Should be first time through */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>call_state</name><operator>-&gt;</operator><name>tuple_store</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>call_state</name><operator>-&gt;</operator><name>attinmeta</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We expect caller to provide an appropriate result tupdesc */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>expectedDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>call_state</name><operator>-&gt;</operator><name>ret_tupdesc</name></name> <operator>=</operator> <name><name>rsi</name><operator>-&gt;</operator><name>expectedDesc</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Switch to the right memory context and resource owner for storing the
	 * tuplestore. If we're within a subtransaction opened for an exception
	 * block, for example, we must still create the tuplestore in the resource
	 * owner that was active when this function was entered, and not in the
	 * subtransaction's resource owner.
	 */</comment>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>call_state</name><operator>-&gt;</operator><name>tuple_store_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldowner</name> <operator>=</operator> <name>CurrentResourceOwner</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name><name>call_state</name><operator>-&gt;</operator><name>tuple_store_owner</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>call_state</name><operator>-&gt;</operator><name>tuple_store</name></name> <operator>=</operator>
		<call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize_Random</name></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build attinmeta in this context, too */</comment>
	<expr_stmt><expr><name><name>call_state</name><operator>-&gt;</operator><name>attinmeta</name></name> <operator>=</operator> <call><name>TupleDescGetAttInMetadata</name><argument_list>(<argument><expr><name><name>call_state</name><operator>-&gt;</operator><name>ret_tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>oldowner</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
