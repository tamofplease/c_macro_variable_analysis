<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/pl/plpgsql/src/pl_exec.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * pl_exec.c		- Executor for the PL/pgSQL
 *			  procedural language
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/pl/plpgsql/src/pl_exec.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/detoast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tupconvert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execExpr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/spi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/spi_priv.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/stringinfo_mb.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/scansup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"plpgsql.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/cmdtag.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/pquery.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name></decl>;</decl_stmt>			<comment type="block">/* number of arguments */</comment>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>			<comment type="block">/* types of arguments */</comment>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>			<comment type="block">/* evaluated argument values */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>			<comment type="block">/* null markers (' '/'n' style) */</comment>
}</block></struct></type> <name>PreparedParamsData</name>;</typedef>

<comment type="block">/*
 * All plpgsql function executions within a single transaction share the same
 * executor EState for evaluating "simple" expressions.  Each function call
 * creates its own "eval_econtext" ExprContext within this estate for
 * per-evaluation workspace.  eval_econtext is freed at normal function exit,
 * and the EState is freed at transaction end (in case of error, we assume
 * that the abort mechanisms clean it all up).  Furthermore, any exception
 * block within a function has to have its own eval_econtext separate from
 * the containing function's, so that we can clean up ExprContext callbacks
 * properly at subtransaction exit.  We maintain a stack that tracks the
 * individual econtexts so that we can clean up correctly at subxact exit.
 *
 * This arrangement is a bit tedious to maintain, but it's worth the trouble
 * so that we don't have to re-prepare simple expressions on each trip through
 * a function.  (We assume the case to optimize is many repetitions of a
 * function within a transaction.)
 *
 * However, there's no value in trying to amortize simple expression setup
 * across multiple executions of a DO block (inline code block), since there
 * can never be any.  If we use the shared EState for a DO block, the expr
 * state trees are effectively leaked till end of transaction, and that can
 * add up if the user keeps on submitting DO blocks.  Therefore, each DO block
 * has its own simple-expression EState, which is cleaned up at exit from
 * plpgsql_inline_handler().  DO blocks still use the simple_econtext_stack,
 * though, so that subxact abort cleanup does the right thing.
 *
 * (However, if a DO block executes COMMIT or ROLLBACK, then exec_stmt_commit
 * or exec_stmt_rollback will unlink it from the DO's simple-expression EState
 * and create a new shared EState that will be used thenceforth.  The original
 * EState will be cleaned up when we get back to plpgsql_inline_handler.  This
 * is a bit ugly, but it isn't worth doing better, since scenarios like this
 * can't result in indefinite accumulation of state trees.)
 */</comment>
<typedef>typedef <type><struct>struct <name>SimpleEcontextStackEntry</name>
<block>{
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>stack_econtext</name></decl>;</decl_stmt>	<comment type="block">/* a stacked econtext */</comment>
	<decl_stmt><decl><type><name>SubTransactionId</name></type> <name>xact_subxid</name></decl>;</decl_stmt>	<comment type="block">/* ID for current subxact */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>SimpleEcontextStackEntry</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>	<comment type="block">/* next stack entry up */</comment>
}</block></struct></type> <name>SimpleEcontextStackEntry</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>EState</name> <modifier>*</modifier></type><name>shared_simple_eval_estate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SimpleEcontextStackEntry</name> <modifier>*</modifier></type><name>simple_econtext_stack</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * In addition to the shared simple-eval EState, we have a shared resource
 * owner that holds refcounts on the CachedPlans for any "simple" expressions
 * we have evaluated in the current transaction.  This allows us to avoid
 * continually grabbing and releasing a plan refcount when a simple expression
 * is used over and over.  (DO blocks use their own resowner, in exactly the
 * same way described above for shared_simple_eval_estate.)
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>ResourceOwner</name></type> <name>shared_simple_eval_resowner</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Memory management within a plpgsql function generally works with three
 * contexts:
 *
 * 1. Function-call-lifespan data, such as variable values, is kept in the
 * "main" context, a/k/a the "SPI Proc" context established by SPI_connect().
 * This is usually the CurrentMemoryContext while running code in this module
 * (which is not good, because careless coding can easily cause
 * function-lifespan memory leaks, but we live with it for now).
 *
 * 2. Some statement-execution routines need statement-lifespan workspace.
 * A suitable context is created on-demand by get_stmt_mcontext(), and must
 * be reset at the end of the requesting routine.  Error recovery will clean
 * it up automatically.  Nested statements requiring statement-lifespan
 * workspace will result in a stack of such contexts, see push_stmt_mcontext().
 *
 * 3. We use the eval_econtext's per-tuple memory context for expression
 * evaluation, and as a general-purpose workspace for short-lived allocations.
 * Such allocations usually aren't explicitly freed, but are left to be
 * cleaned up by a context reset, typically done by exec_eval_cleanup().
 *
 * These macros are for use in making short-lived allocations:
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>get_eval_mcontext</name><parameter_list>(<parameter><type><name>estate</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((estate)-&gt;eval_econtext-&gt;ecxt_per_tuple_memory)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>eval_mcontext_alloc</name><parameter_list>(<parameter><type><name>estate</name></type></parameter>, <parameter><type><name>sz</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>MemoryContextAlloc(get_eval_mcontext(estate), sz)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>eval_mcontext_alloc0</name><parameter_list>(<parameter><type><name>estate</name></type></parameter>, <parameter><type><name>sz</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>MemoryContextAllocZero(get_eval_mcontext(estate), sz)</cpp:value></cpp:define>

<comment type="block">/*
 * We use a session-wide hash table for caching cast information.
 *
 * Once built, the compiled expression trees (cast_expr fields) survive for
 * the life of the session.  At some point it might be worth invalidating
 * those after pg_cast changes, but for the moment we don't bother.
 *
 * The evaluation state trees (cast_exprstate) are managed in the same way as
 * simple expressions (i.e., we assume cast expressions are always simple).
 *
 * As with simple expressions, DO blocks don't use the shared hash table but
 * must have their own.  This isn't ideal, but we don't want to deal with
 * multiple simple_eval_estates within a DO block.
 */</comment>
<typedef>typedef <type><struct>struct					<comment type="block">/* lookup key for cast info */</comment>
<block>{
	<comment type="block">/* NB: we assume this struct contains no padding bytes */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>srctype</name></decl>;</decl_stmt>		<comment type="block">/* source type for cast */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>dsttype</name></decl>;</decl_stmt>		<comment type="block">/* destination type for cast */</comment>
	<decl_stmt><decl><type><name>int32</name></type>		<name>srctypmod</name></decl>;</decl_stmt>		<comment type="block">/* source typmod for cast */</comment>
	<decl_stmt><decl><type><name>int32</name></type>		<name>dsttypmod</name></decl>;</decl_stmt>		<comment type="block">/* destination typmod for cast */</comment>
}</block></struct></type> <name>plpgsql_CastHashKey</name>;</typedef>

<typedef>typedef <type><struct>struct					<comment type="block">/* cast_hash table entry */</comment>
<block>{
	<decl_stmt><decl><type><name>plpgsql_CastHashKey</name></type> <name>key</name></decl>;</decl_stmt>	<comment type="block">/* hash key --- MUST BE FIRST */</comment>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>cast_expr</name></decl>;</decl_stmt>		<comment type="block">/* cast expression, or NULL if no-op cast */</comment>
	<decl_stmt><decl><type><name>CachedExpression</name> <modifier>*</modifier></type><name>cast_cexpr</name></decl>;</decl_stmt>	<comment type="block">/* cached expression backing the above */</comment>
	<comment type="block">/* ExprState is valid only when cast_lxid matches current LXID */</comment>
	<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>cast_exprstate</name></decl>;</decl_stmt> <comment type="block">/* expression's eval tree */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>cast_in_use</name></decl>;</decl_stmt>	<comment type="block">/* true while we're executing eval tree */</comment>
	<decl_stmt><decl><type><name>LocalTransactionId</name></type> <name>cast_lxid</name></decl>;</decl_stmt>
}</block></struct></type> <name>plpgsql_CastHashEntry</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>shared_cast_context</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>shared_cast_hash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * LOOP_RC_PROCESSING encapsulates common logic for looping statements to
 * handle return/exit/continue result codes from the loop body statement(s).
 * It's meant to be used like this:
 *
 *		int rc = PLPGSQL_RC_OK;
 *		for (...)
 *		{
 *			...
 *			rc = exec_stmts(estate, stmt-&gt;body);
 *			LOOP_RC_PROCESSING(stmt-&gt;label, break);
 *			...
 *		}
 *		return rc;
 *
 * If execution of the loop should terminate, LOOP_RC_PROCESSING will execute
 * "exit_action" (typically a "break" or "goto"), after updating "rc" to the
 * value the current statement should return.  If execution should continue,
 * LOOP_RC_PROCESSING will do nothing except reset "rc" to PLPGSQL_RC_OK.
 *
 * estate and rc are implicit arguments to the macro.
 * estate-&gt;exitlabel is examined and possibly updated.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOOP_RC_PROCESSING</name><parameter_list>(<parameter><type><name>looplabel</name></type></parameter>, <parameter><type><name>exit_action</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>if (rc == PLPGSQL_RC_RETURN) \
	{ \
		<comment type="block">/* RETURN, so propagate RC_RETURN out */</comment> \
		exit_action; \
	} \
	else if (rc == PLPGSQL_RC_EXIT) \
	{ \
		if (estate-&gt;exitlabel == NULL) \
		{ \
			<comment type="block">/* unlabeled EXIT terminates this loop */</comment> \
			rc = PLPGSQL_RC_OK; \
			exit_action; \
		} \
		else if ((looplabel) != NULL &amp;&amp; \
				 strcmp(looplabel, estate-&gt;exitlabel) == 0) \
		{ \
			<comment type="block">/* labeled EXIT matching this loop, so terminate loop */</comment> \
			estate-&gt;exitlabel = NULL; \
			rc = PLPGSQL_RC_OK; \
			exit_action; \
		} \
		else \
		{ \
			<comment type="block">/* non-matching labeled EXIT, propagate RC_EXIT out */</comment> \
			exit_action; \
		} \
	} \
	else if (rc == PLPGSQL_RC_CONTINUE) \
	{ \
		if (estate-&gt;exitlabel == NULL) \
		{ \
			<comment type="block">/* unlabeled CONTINUE matches this loop, so continue in loop */</comment> \
			rc = PLPGSQL_RC_OK; \
		} \
		else if ((looplabel) != NULL &amp;&amp; \
				 strcmp(looplabel, estate-&gt;exitlabel) == 0) \
		{ \
			<comment type="block">/* labeled CONTINUE matching this loop, so continue in loop */</comment> \
			estate-&gt;exitlabel = NULL; \
			rc = PLPGSQL_RC_OK; \
		} \
		else \
		{ \
			<comment type="block">/* non-matching labeled CONTINUE, propagate RC_CONTINUE out */</comment> \
			exit_action; \
		} \
	} \
	else \
		Assert(rc == PLPGSQL_RC_OK)</cpp:value></cpp:define>

<comment type="block" format="doxygen">/************************************************************
 * Local function forward declarations
 ************************************************************/</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>coerce_function_result_tuple</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
										 <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>plpgsql_exec_error_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>copy_plpgsql_datums</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
								<parameter><decl><type><name>PLpgSQL_function</name> <modifier>*</modifier></type><name>func</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>plpgsql_fulfill_promise</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
									<parameter><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>get_stmt_mcontext</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>push_stmt_mcontext</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pop_stmt_mcontext</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>exec_stmt_block</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
							<parameter><decl><type><name>PLpgSQL_stmt_block</name> <modifier>*</modifier></type><name>block</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>exec_stmts</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>stmts</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>exec_stmt</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
					  <parameter><decl><type><name>PLpgSQL_stmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>exec_stmt_assign</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
							 <parameter><decl><type><name>PLpgSQL_stmt_assign</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>exec_stmt_perform</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
							  <parameter><decl><type><name>PLpgSQL_stmt_perform</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>exec_stmt_call</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
						   <parameter><decl><type><name>PLpgSQL_stmt_call</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>exec_stmt_getdiag</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
							  <parameter><decl><type><name>PLpgSQL_stmt_getdiag</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>exec_stmt_if</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
						 <parameter><decl><type><name>PLpgSQL_stmt_if</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>exec_stmt_case</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
						   <parameter><decl><type><name>PLpgSQL_stmt_case</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>exec_stmt_loop</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
						   <parameter><decl><type><name>PLpgSQL_stmt_loop</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>exec_stmt_while</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
							<parameter><decl><type><name>PLpgSQL_stmt_while</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>exec_stmt_fori</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
						   <parameter><decl><type><name>PLpgSQL_stmt_fori</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>exec_stmt_fors</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
						   <parameter><decl><type><name>PLpgSQL_stmt_fors</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>exec_stmt_forc</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
						   <parameter><decl><type><name>PLpgSQL_stmt_forc</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>exec_stmt_foreach_a</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
								<parameter><decl><type><name>PLpgSQL_stmt_foreach_a</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>exec_stmt_open</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
						   <parameter><decl><type><name>PLpgSQL_stmt_open</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>exec_stmt_fetch</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
							<parameter><decl><type><name>PLpgSQL_stmt_fetch</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>exec_stmt_close</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
							<parameter><decl><type><name>PLpgSQL_stmt_close</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>exec_stmt_exit</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
						   <parameter><decl><type><name>PLpgSQL_stmt_exit</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>exec_stmt_return</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
							 <parameter><decl><type><name>PLpgSQL_stmt_return</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>exec_stmt_return_next</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
								  <parameter><decl><type><name>PLpgSQL_stmt_return_next</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>exec_stmt_return_query</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
								   <parameter><decl><type><name>PLpgSQL_stmt_return_query</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>exec_stmt_raise</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
							<parameter><decl><type><name>PLpgSQL_stmt_raise</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>exec_stmt_assert</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
							 <parameter><decl><type><name>PLpgSQL_stmt_assert</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>exec_stmt_execsql</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
							  <parameter><decl><type><name>PLpgSQL_stmt_execsql</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>exec_stmt_dynexecute</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
								 <parameter><decl><type><name>PLpgSQL_stmt_dynexecute</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>exec_stmt_dynfors</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
							  <parameter><decl><type><name>PLpgSQL_stmt_dynfors</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>exec_stmt_commit</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
							 <parameter><decl><type><name>PLpgSQL_stmt_commit</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>exec_stmt_rollback</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
							   <parameter><decl><type><name>PLpgSQL_stmt_rollback</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>exec_stmt_set</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
						  <parameter><decl><type><name>PLpgSQL_stmt_set</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>plpgsql_estate_setup</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
								 <parameter><decl><type><name>PLpgSQL_function</name> <modifier>*</modifier></type><name>func</name></decl></parameter>,
								 <parameter><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsi</name></decl></parameter>,
								 <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>simple_eval_estate</name></decl></parameter>,
								 <parameter><decl><type><name>ResourceOwner</name></type> <name>simple_eval_resowner</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>exec_eval_cleanup</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>exec_prepare_plan</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
							  <parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cursorOptions</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name></type> <name>keepplan</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>exec_simple_check_plan</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>exec_save_simple_expr</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>CachedPlan</name> <modifier>*</modifier></type><name>cplan</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>exec_check_rw_parameter</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>target_dno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>contains_target_param</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>target_dno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>exec_eval_simple_expr</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
								  <parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
								  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>result</name></decl></parameter>,
								  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>,
								  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>rettype</name></decl></parameter>,
								  <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>rettypmod</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>exec_assign_expr</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
							 <parameter><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
							 <parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>exec_assign_c_string</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
								 <parameter><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
								 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>exec_assign_value</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
							  <parameter><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
							  <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isNull</name></decl></parameter>,
							  <parameter><decl><type><name>Oid</name></type> <name>valtype</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>valtypmod</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>exec_eval_datum</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
							<parameter><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>datum</name></decl></parameter>,
							<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>typeid</name></decl></parameter>,
							<parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>typetypmod</name></decl></parameter>,
							<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>value</name></decl></parameter>,
							<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>exec_eval_integer</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
							  <parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>exec_eval_boolean</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
							  <parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>exec_eval_expr</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
							<parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
							<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>,
							<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>rettype</name></decl></parameter>,
							<parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>rettypmod</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>exec_run_select</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
							<parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>maxtuples</name></decl></parameter>, <parameter><decl><type><name>Portal</name> <modifier>*</modifier></type><name>portalP</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>exec_for_query</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_forq</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>,
						   <parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>prefetch_ok</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ParamListInfo</name></type> <name>setup_param_list</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
									  <parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ParamExternData</name> <modifier>*</modifier></type><name>plpgsql_param_fetch</name><parameter_list>(<parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
											<parameter><decl><type><name>int</name></type> <name>paramid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>speculative</name></decl></parameter>,
											<parameter><decl><type><name>ParamExternData</name> <modifier>*</modifier></type><name>workspace</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>plpgsql_param_compile</name><parameter_list>(<parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>, <parameter><decl><type><name>Param</name> <modifier>*</modifier></type><name>param</name></decl></parameter>,
								  <parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
								  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>resv</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>resnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>plpgsql_param_eval_var</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>,
								   <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>plpgsql_param_eval_var_ro</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>,
									  <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>plpgsql_param_eval_recfield</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>,
										<parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>plpgsql_param_eval_generic</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>,
									   <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>plpgsql_param_eval_generic_ro</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>,
										  <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>exec_move_row</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
						  <parameter><decl><type><name>PLpgSQL_variable</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
						  <parameter><decl><type><name>HeapTuple</name></type> <name>tup</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>revalidate_rectypeid</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>make_expanded_record_for_rec</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
														  <parameter><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name></decl></parameter>,
														  <parameter><decl><type><name>TupleDesc</name></type> <name>srctupdesc</name></decl></parameter>,
														  <parameter><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>srcerh</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>exec_move_row_from_fields</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
									  <parameter><decl><type><name>PLpgSQL_variable</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
									  <parameter><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>newerh</name></decl></parameter>,
									  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>,
									  <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>compatible_tupdescs</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>src_tupdesc</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>dst_tupdesc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HeapTuple</name></type> <name>make_tuple_from_row</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
									 <parameter><decl><type><name>PLpgSQL_row</name> <modifier>*</modifier></type><name>row</name></decl></parameter>,
									 <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleDesc</name></type> <name>deconstruct_composite_datum</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>,
											 <parameter><decl><type><name>HeapTupleData</name> <modifier>*</modifier></type><name>tmptup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>exec_move_row_from_datum</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
									 <parameter><decl><type><name>PLpgSQL_variable</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
									 <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>instantiate_empty_record_variable</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
											  <parameter><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>convert_value_to_string</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
									 <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>valtype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>exec_cast_value</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
							 <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name></type> <name>valtype</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>valtypmod</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name></type> <name>reqtype</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>reqtypmod</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>plpgsql_CastHashEntry</name> <modifier>*</modifier></type><name>get_cast_hashentry</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
												 <parameter><decl><type><name>Oid</name></type> <name>srctype</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>srctypmod</name></decl></parameter>,
												 <parameter><decl><type><name>Oid</name></type> <name>dsttype</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>dsttypmod</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>exec_init_tuple_store</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>exec_set_found</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>plpgsql_create_econtext</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>plpgsql_destroy_econtext</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_simple_var</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>,
							  <parameter><decl><type><name>Datum</name></type> <name>newvalue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>freeable</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_text_var</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_record_var</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name></decl></parameter>,
							  <parameter><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>erh</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PreparedParamsData</name> <modifier>*</modifier></type><name>exec_eval_using_params</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
												  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>params</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Portal</name></type> <name>exec_dynquery_with_params</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
										<parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>dynquery</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>params</name></decl></parameter>,
										<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>portalname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cursorOptions</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>format_expr_params</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
								<parameter><decl><type><specifier>const</specifier> <name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>format_preparedparamsdata</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
									   <parameter><decl><type><specifier>const</specifier> <name>PreparedParamsData</name> <modifier>*</modifier></type><name>ppd</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* ----------
 * plpgsql_exec_function	Called by the call handler for
 *				function execution.
 *
 * This is also used to execute inline code blocks (DO blocks).  The only
 * difference that this code is aware of is that for a DO block, we want
 * to use a private simple_eval_estate and a private simple_eval_resowner,
 * which are created and passed in by the caller.  For regular functions,
 * pass NULL, which implies using shared_simple_eval_estate and
 * shared_simple_eval_resowner.  (When using a private simple_eval_estate,
 * we must also use a private cast hashtable, but that's taken care of
 * within plpgsql_estate_setup.)
 * ----------
 */</comment>
<function><type><name>Datum</name></type>
<name>plpgsql_exec_function</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_function</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>,
					  <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>simple_eval_estate</name></decl></parameter>,
					  <parameter><decl><type><name>ResourceOwner</name></type> <name>simple_eval_resowner</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>atomic</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PLpgSQL_execstate</name></type> <name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>plerrcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Setup the execution state
	 */</comment>
	<expr_stmt><expr><call><name>plpgsql_estate_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></argument>,
						 <argument><expr><name>simple_eval_estate</name></expr></argument>, <argument><expr><name>simple_eval_resowner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>.</operator><name>atomic</name></name> <operator>=</operator> <name>atomic</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Setup error traceback support for ereport()
	 */</comment>
	<expr_stmt><expr><name><name>plerrcontext</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>plpgsql_exec_error_callback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plerrcontext</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <operator>&amp;</operator><name>estate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plerrcontext</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>plerrcontext</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make local execution copies of all the datums
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_text</name></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"during initialization of execution state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>copy_plpgsql_datums</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Store the actual call argument values into the appropriate variables
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_text</name></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"while storing call arguments into local variables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>func</name><operator>-&gt;</operator><name>fn_nargs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>n</name> <init>= <expr><name><name>func</name><operator>-&gt;</operator><name>fn_argvarnos</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>estate</name><operator>.</operator><name>datums</name><index>[<expr><name>n</name></expr>]</index></name><operator>-&gt;</operator><name>dtype</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>PLPGSQL_DTYPE_VAR</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name><name>estate</name><operator>.</operator><name>datums</name><index>[<expr><name>n</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>assign_simple_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
									  <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>,
									  <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name></expr></argument>,
									  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * Force any array-valued parameter to be stored in
					 * expanded form in our local variable, in hopes of
					 * improving efficiency of uses of the variable.  (This is
					 * a hack, really: why only arrays? Need more thought
					 * about which cases are likely to win.  See also
					 * typisarray-specific heuristic in exec_assign_value.)
					 *
					 * Special cases: If passed a R/W expanded pointer, assume
					 * we can commandeer the object rather than having to copy
					 * it.  If passed a R/O expanded pointer, just keep it as
					 * the value of the variable for the moment.  (We'll force
					 * it to R/W if the variable gets modified, but that may
					 * very well never happen.)
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>var</name><operator>-&gt;</operator><name>isnull</name></name> <operator>&amp;&amp;</operator> <name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typisarray</name></name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_EXPANDED_RW</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* take ownership of R/W object */</comment>
							<expr_stmt><expr><call><name>assign_simple_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
											  <argument><expr><call><name>TransferExpandedObject</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr></argument>,
																	 <argument><expr><name><name>estate</name><operator>.</operator><name>datum_context</name></name></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><name>false</name></expr></argument>,
											  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if>
						<if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_EXPANDED_RO</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* R/O pointer, keep it as-is until assigned to */</comment>
						</block_content>}</block></if>
						<else>else
						<block>{<block_content>
							<comment type="block">/* flat array, so force to expanded form */</comment>
							<expr_stmt><expr><call><name>assign_simple_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
											  <argument><expr><call><name>expand_array</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr></argument>,
														   <argument><expr><name><name>estate</name><operator>.</operator><name>datum_context</name></name></expr></argument>,
														   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><name>false</name></expr></argument>,
											  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></else></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><name>PLPGSQL_DTYPE_REC</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name> <init>= <expr><operator>(</operator><name>PLpgSQL_rec</name> <operator>*</operator><operator>)</operator> <name><name>estate</name><operator>.</operator><name>datums</name><index>[<expr><name>n</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* Assign row value from composite datum */</comment>
						<expr_stmt><expr><call><name>exec_move_row_from_datum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>,
												 <argument><expr><operator>(</operator><name>PLpgSQL_variable</name> <operator>*</operator><operator>)</operator> <name>rec</name></expr></argument>,
												 <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* If arg is null, set variable to null */</comment>
						<expr_stmt><expr><call><name>exec_move_row</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_variable</name> <operator>*</operator><operator>)</operator> <name>rec</name></expr></argument>,
									  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					<comment type="block">/* clean up after exec_move_row() */</comment>
					<expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>

			<default>default:</default>
				<comment type="block">/* Anything else should not be an argument variable */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized dtype: %d"</literal></expr></argument>, <argument><expr><name><name>func</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>dtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_text</name></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"during function entry"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set the magic variable FOUND to false
	 */</comment>
	<expr_stmt><expr><call><name>exec_set_found</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Let the instrumentation plugin peek at this function
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>plpgsql_plugin_ptr</name> <operator>&amp;&amp;</operator> <name><operator>(</operator><operator>*</operator><name>plpgsql_plugin_ptr</name><operator>)</operator><operator>-&gt;</operator><name>func_beg</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name><operator>(</operator><operator>*</operator><name>plpgsql_plugin_ptr</name><operator>)</operator><operator>-&gt;</operator><name>func_beg</name></name><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>estate</name><operator>,</operator> <name>func</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Now call the toplevel block of statements
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_text</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_stmt</name></name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_stmt</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>func</name><operator>-&gt;</operator><name>action</name></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt</name> <operator>*</operator><operator>)</operator> <name><name>func</name><operator>-&gt;</operator><name>action</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>PLPGSQL_RC_RETURN</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_stmt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_text</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_S_R_E_FUNCTION_EXECUTED_NO_RETURN_STATEMENT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"control reached end of function without RETURN"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We got a return value - process it
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_stmt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_text</name></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"while casting return value to function's return type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name><name>estate</name><operator>.</operator><name>retisnull</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>.</operator><name>retisset</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsi</name> <init>= <expr><name><name>estate</name><operator>.</operator><name>rsi</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Check caller can handle a set result */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rsi</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsi</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<operator>(</operator><name><name>rsi</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>

		<comment type="block">/* If we produced any tuples, send back the result */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>.</operator><name>tuple_store</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>setResult</name></name> <operator>=</operator> <name><name>estate</name><operator>.</operator><name>tuple_store</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>.</operator><name>tuple_store_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>setDesc</name></name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name><name>estate</name><operator>.</operator><name>tuple_store_desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>.</operator><name>retval</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>estate</name><operator>.</operator><name>retisnull</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Cast result value to function's declared result type, and copy it
		 * out to the upper executor memory context.  We must treat tuple
		 * results specially in order to deal with cases like rowtypes
		 * involving dropped columns.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>.</operator><name>retistuple</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Don't need coercion if rowtype is known to match */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>func</name><operator>-&gt;</operator><name>fn_rettype</name></name> <operator>==</operator> <name><name>estate</name><operator>.</operator><name>rettype</name></name> <operator>&amp;&amp;</operator>
				<name><name>func</name><operator>-&gt;</operator><name>fn_rettype</name></name> <operator>!=</operator> <name>RECORDOID</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Copy the tuple result into upper executor memory context.
				 * However, if we have a R/W expanded datum, we can just
				 * transfer its ownership out to the upper context.
				 */</comment>
				<expr_stmt><expr><name><name>estate</name><operator>.</operator><name>retval</name></name> <operator>=</operator> <call><name>SPI_datumTransfer</name><argument_list>(<argument><expr><name><name>estate</name><operator>.</operator><name>retval</name></name></expr></argument>,
												  <argument><expr><name>false</name></expr></argument>,
												  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Need to look up the expected result type.  XXX would be
				 * better to cache the tupdesc instead of repeating
				 * get_call_result_type(), but the only easy place to save it
				 * is in the PLpgSQL_function struct, and that's too
				 * long-lived: composite types could change during the
				 * existence of a PLpgSQL_function.
				 */</comment>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>resultTypeId</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>

				<switch>switch <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>resultTypeId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>TYPEFUNC_COMPOSITE</name></expr>:</case>
						<comment type="block">/* got the expected result rowtype, now coerce it */</comment>
						<expr_stmt><expr><call><name>coerce_function_result_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>TYPEFUNC_COMPOSITE_DOMAIN</name></expr>:</case>
						<comment type="block">/* got the expected result rowtype, now coerce it */</comment>
						<expr_stmt><expr><call><name>coerce_function_result_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<comment type="block">/* and check domain constraints */</comment>
						<comment type="block">/* XXX allowing caching here would be good, too */</comment>
						<expr_stmt><expr><call><name>domain_check</name><argument_list>(<argument><expr><name><name>estate</name><operator>.</operator><name>retval</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>resultTypeId</name></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>TYPEFUNC_RECORD</name></expr>:</case>

						<comment type="block">/*
						 * Failed to determine actual type of RECORD.  We
						 * could raise an error here, but what this means in
						 * practice is that the caller is expecting any old
						 * generic rowtype, so we don't really need to be
						 * restrictive.  Pass back the generated result as-is.
						 */</comment>
						<expr_stmt><expr><name><name>estate</name><operator>.</operator><name>retval</name></name> <operator>=</operator> <call><name>SPI_datumTransfer</name><argument_list>(<argument><expr><name><name>estate</name><operator>.</operator><name>retval</name></name></expr></argument>,
														  <argument><expr><name>false</name></expr></argument>,
														  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<default>default:</default>
						<comment type="block">/* shouldn't get here if retistuple is true ... */</comment>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"return type must be a row type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Scalar case: use exec_cast_value */</comment>
			<expr_stmt><expr><name><name>estate</name><operator>.</operator><name>retval</name></name> <operator>=</operator> <call><name>exec_cast_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>,
											<argument><expr><name><name>estate</name><operator>.</operator><name>retval</name></name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr></argument>,
											<argument><expr><name><name>estate</name><operator>.</operator><name>rettype</name></name></expr></argument>,
											<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
											<argument><expr><name><name>func</name><operator>-&gt;</operator><name>fn_rettype</name></name></expr></argument>,
											<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If the function's return type isn't by value, copy the value
			 * into upper executor memory context.  However, if we have a R/W
			 * expanded datum, we can just transfer its ownership out to the
			 * upper executor context.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>func</name><operator>-&gt;</operator><name>fn_retbyval</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>estate</name><operator>.</operator><name>retval</name></name> <operator>=</operator> <call><name>SPI_datumTransfer</name><argument_list>(<argument><expr><name><name>estate</name><operator>.</operator><name>retval</name></name></expr></argument>,
												  <argument><expr><name>false</name></expr></argument>,
												  <argument><expr><name><name>func</name><operator>-&gt;</operator><name>fn_rettyplen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * We're returning a NULL, which normally requires no conversion work
		 * regardless of datatypes.  But, if we are casting it to a domain
		 * return type, we'd better check that the domain's constraints pass.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>func</name><operator>-&gt;</operator><name>fn_retisdomain</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>estate</name><operator>.</operator><name>retval</name></name> <operator>=</operator> <call><name>exec_cast_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>,
											<argument><expr><name><name>estate</name><operator>.</operator><name>retval</name></name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr></argument>,
											<argument><expr><name><name>estate</name><operator>.</operator><name>rettype</name></name></expr></argument>,
											<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
											<argument><expr><name><name>func</name><operator>-&gt;</operator><name>fn_rettype</name></name></expr></argument>,
											<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_text</name></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"during function exit"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Let the instrumentation plugin peek at this function
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>plpgsql_plugin_ptr</name> <operator>&amp;&amp;</operator> <name><operator>(</operator><operator>*</operator><name>plpgsql_plugin_ptr</name><operator>)</operator><operator>-&gt;</operator><name>func_end</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name><operator>(</operator><operator>*</operator><name>plpgsql_plugin_ptr</name><operator>)</operator><operator>-&gt;</operator><name>func_end</name></name><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>estate</name><operator>,</operator> <name>func</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Clean up any leftover temporary memory */</comment>
	<expr_stmt><expr><call><name>plpgsql_destroy_econtext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* stmt_mcontext will be destroyed when function's main context is */</comment>

	<comment type="block">/*
	 * Pop the error context stack
	 */</comment>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>plerrcontext</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Return the function's result
	 */</comment>
	<return>return <expr><name><name>estate</name><operator>.</operator><name>retval</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper for plpgsql_exec_function: coerce composite result to the specified
 * tuple descriptor, and copy it out to upper executor memory.  This is split
 * out mostly for cosmetic reasons --- the logic would be very deeply nested
 * otherwise.
 *
 * estate-&gt;retval is updated in-place.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>coerce_function_result_tuple</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>rettup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>retdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>tupmap</name></decl>;</decl_stmt>

	<comment type="block">/* We assume exec_stmt_return verified that result is composite */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>type_is_rowtype</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>rettype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We can special-case expanded records for speed */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_EXPANDED</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>retval</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>erh</name> <init>= <expr><operator>(</operator><name>ExpandedRecordHeader</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetEOHP</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>retval</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>erh</name><operator>-&gt;</operator><name>er_magic</name></name> <operator>==</operator> <name>ER_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Extract record's TupleDesc */</comment>
		<expr_stmt><expr><name>retdesc</name> <operator>=</operator> <call><name>expanded_record_get_tupdesc</name><argument_list>(<argument><expr><name>erh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* check rowtype compatibility */</comment>
		<expr_stmt><expr><name>tupmap</name> <operator>=</operator> <call><name>convert_tuples_by_position</name><argument_list>(<argument><expr><name>retdesc</name></expr></argument>,
											<argument><expr><name>tupdesc</name></expr></argument>,
											<argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"returned record type does not match expected record type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* it might need conversion */</comment>
		<if_stmt><if>if <condition>(<expr><name>tupmap</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>rettup</name> <operator>=</operator> <call><name>expanded_record_get_tuple</name><argument_list>(<argument><expr><name>erh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rettup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rettup</name> <operator>=</operator> <call><name>execute_attr_map_tuple</name><argument_list>(<argument><expr><name>rettup</name></expr></argument>, <argument><expr><name>tupmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Copy tuple to upper executor memory, as a tuple Datum.  Make
			 * sure it is labeled with the caller-supplied tuple type.
			 */</comment>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>retval</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>SPI_returntuple</name><argument_list>(<argument><expr><name>rettup</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* no need to free map, we're about to return anyway */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypeid</name></name> <operator>==</operator> <name><name>erh</name><operator>-&gt;</operator><name>er_decltypeid</name></name> <operator>||</operator>
				   <operator>(</operator><name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypeid</name></name> <operator>==</operator> <name>RECORDOID</name> <operator>&amp;&amp;</operator>
					<operator>!</operator><call><name>ExpandedRecordIsDomain</name><argument_list>(<argument><expr><name>erh</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The expanded record has the right physical tupdesc, but the
			 * wrong type ID.  (Typically, the expanded record is RECORDOID
			 * but the function is declared to return a named composite type.
			 * As in exec_move_row_from_datum, we don't allow returning a
			 * composite-domain record from a function declared to return
			 * RECORD.)  So we must flatten the record to a tuple datum and
			 * overwrite its type fields with the right thing.  spi.c doesn't
			 * provide any easy way to deal with this case, so we end up
			 * duplicating the guts of datumCopy() :-(
			 */</comment>
			<decl_stmt><decl><type><name>Size</name></type>		<name>resultsize</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>tuphdr</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>resultsize</name> <operator>=</operator> <call><name>EOH_get_flat_size</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>erh</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tuphdr</name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>SPI_palloc</name><argument_list>(<argument><expr><name>resultsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>EOH_flatten_into</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>erh</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>tuphdr</name></expr></argument>, <argument><expr><name>resultsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>HeapTupleHeaderSetTypeId</name><argument_list>(<argument><expr><name>tuphdr</name></expr></argument>, <argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypeid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>HeapTupleHeaderSetTypMod</name><argument_list>(<argument><expr><name>tuphdr</name></expr></argument>, <argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>retval</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>tuphdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * We need only copy result into upper executor memory context.
			 * However, if we have a R/W expanded datum, we can just transfer
			 * its ownership out to the upper executor context.
			 */</comment>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>retval</name></name> <operator>=</operator> <call><name>SPI_datumTransfer</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>retval</name></name></expr></argument>,
											   <argument><expr><name>false</name></expr></argument>,
											   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Convert composite datum to a HeapTuple and TupleDesc */</comment>
		<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>tmptup</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>retdesc</name> <operator>=</operator> <call><name>deconstruct_composite_datum</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>retval</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmptup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rettup</name> <operator>=</operator> <operator>&amp;</operator><name>tmptup</name></expr>;</expr_stmt>

		<comment type="block">/* check rowtype compatibility */</comment>
		<expr_stmt><expr><name>tupmap</name> <operator>=</operator> <call><name>convert_tuples_by_position</name><argument_list>(<argument><expr><name>retdesc</name></expr></argument>,
											<argument><expr><name>tupdesc</name></expr></argument>,
											<argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"returned record type does not match expected record type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* it might need conversion */</comment>
		<if_stmt><if>if <condition>(<expr><name>tupmap</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>rettup</name> <operator>=</operator> <call><name>execute_attr_map_tuple</name><argument_list>(<argument><expr><name>rettup</name></expr></argument>, <argument><expr><name>tupmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Copy tuple to upper executor memory, as a tuple Datum.  Make sure
		 * it is labeled with the caller-supplied tuple type.
		 */</comment>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>retval</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>SPI_returntuple</name><argument_list>(<argument><expr><name>rettup</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* no need to free map, we're about to return anyway */</comment>

		<expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name>retdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * plpgsql_exec_trigger		Called by the call handler for
 *				trigger execution.
 * ----------
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>plpgsql_exec_trigger</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_function</name> <modifier>*</modifier></type><name>func</name></decl></parameter>,
					 <parameter><decl><type><name>TriggerData</name> <modifier>*</modifier></type><name>trigdata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PLpgSQL_execstate</name></type> <name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>plerrcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec_new</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>rec_old</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>rettup</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Setup the execution state
	 */</comment>
	<expr_stmt><expr><call><name>plpgsql_estate_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>.</operator><name>trigdata</name></name> <operator>=</operator> <name>trigdata</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Setup error traceback support for ereport()
	 */</comment>
	<expr_stmt><expr><name><name>plerrcontext</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>plpgsql_exec_error_callback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plerrcontext</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <operator>&amp;</operator><name>estate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plerrcontext</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>plerrcontext</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make local execution copies of all the datums
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_text</name></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"during initialization of execution state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>copy_plpgsql_datums</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Put the OLD and NEW tuples into record variables
	 *
	 * We set up expanded records for both variables even though only one may
	 * have a value.  This allows record references to succeed in functions
	 * that are used for multiple trigger types.  For example, we might have a
	 * test like "if (TG_OP = 'INSERT' and NEW.foo = 'xyz')", which should
	 * work regardless of the current trigger type.  If a value is actually
	 * fetched from an unsupplied tuple, it will read as NULL.
	 */</comment>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_relation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rec_new</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_rec</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>.</operator><name>datums</name><index>[<expr><name><name>func</name><operator>-&gt;</operator><name>new_varno</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>rec_old</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_rec</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>.</operator><name>datums</name><index>[<expr><name><name>func</name><operator>-&gt;</operator><name>old_varno</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rec_new</name><operator>-&gt;</operator><name>erh</name></name> <operator>=</operator> <call><name>make_expanded_record_from_tupdesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>,
													 <argument><expr><name><name>estate</name><operator>.</operator><name>datum_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rec_old</name><operator>-&gt;</operator><name>erh</name></name> <operator>=</operator> <call><name>make_expanded_record_from_exprecord</name><argument_list>(<argument><expr><name><name>rec_new</name><operator>-&gt;</operator><name>erh</name></name></expr></argument>,
													   <argument><expr><name><name>estate</name><operator>.</operator><name>datum_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TRIGGER_FIRED_FOR_ROW</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Per-statement triggers don't use OLD/NEW variables
		 */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_BY_INSERT</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>expanded_record_set_tuple</name><argument_list>(<argument><expr><name><name>rec_new</name><operator>-&gt;</operator><name>erh</name></name></expr></argument>, <argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigtuple</name></name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_BY_UPDATE</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>expanded_record_set_tuple</name><argument_list>(<argument><expr><name><name>rec_new</name><operator>-&gt;</operator><name>erh</name></name></expr></argument>, <argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_newtuple</name></name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>expanded_record_set_tuple</name><argument_list>(<argument><expr><name><name>rec_old</name><operator>-&gt;</operator><name>erh</name></name></expr></argument>, <argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigtuple</name></name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * In BEFORE trigger, stored generated columns are not computed yet,
		 * so make them null in the NEW row.  (Only needed in UPDATE branch;
		 * in the INSERT case, they are already null, but in UPDATE, the field
		 * still contains the old value.)  Alternatively, we could construct a
		 * whole new row structure without the generated columns, but this way
		 * seems more efficient and potentially less confusing.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tupdesc</name><operator>-&gt;</operator><name>constr</name></name> <operator>&amp;&amp;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>has_generated_stored</name></name> <operator>&amp;&amp;</operator>
			<call><name>TRIGGER_FIRED_BEFORE</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<if_stmt><if>if <condition>(<expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attgenerated</name> <operator>==</operator> <name>ATTRIBUTE_GENERATED_STORED</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>expanded_record_set_field_internal</name><argument_list>(<argument><expr><name><name>rec_new</name><operator>-&gt;</operator><name>erh</name></name></expr></argument>,
													   <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
													   <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>,
													   <argument><expr><name>true</name></expr></argument>,	<comment type="block">/* isnull */</comment>
													   <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_BY_DELETE</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>expanded_record_set_tuple</name><argument_list>(<argument><expr><name><name>rec_old</name><operator>-&gt;</operator><name>erh</name></name></expr></argument>, <argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigtuple</name></name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized trigger action: not INSERT, DELETE, or UPDATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Make transition tables visible to this SPI connection */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SPI_register_trigger_data</name><argument_list>(<argument><expr><name>trigdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rc</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_text</name></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"during function entry"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set the magic variable FOUND to false
	 */</comment>
	<expr_stmt><expr><call><name>exec_set_found</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Let the instrumentation plugin peek at this function
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>plpgsql_plugin_ptr</name> <operator>&amp;&amp;</operator> <name><operator>(</operator><operator>*</operator><name>plpgsql_plugin_ptr</name><operator>)</operator><operator>-&gt;</operator><name>func_beg</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name><operator>(</operator><operator>*</operator><name>plpgsql_plugin_ptr</name><operator>)</operator><operator>-&gt;</operator><name>func_beg</name></name><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>estate</name><operator>,</operator> <name>func</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Now call the toplevel block of statements
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_text</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_stmt</name></name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_stmt</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>func</name><operator>-&gt;</operator><name>action</name></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt</name> <operator>*</operator><operator>)</operator> <name><name>func</name><operator>-&gt;</operator><name>action</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>PLPGSQL_RC_RETURN</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_stmt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_text</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_S_R_E_FUNCTION_EXECUTED_NO_RETURN_STATEMENT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"control reached end of trigger procedure without RETURN"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_stmt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_text</name></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"during function exit"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>.</operator><name>retisset</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"trigger procedure cannot return a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check that the returned tuple structure has the same attributes, the
	 * relation that fired the trigger has. A per-statement trigger always
	 * needs to return NULL, so we ignore any return value the function itself
	 * produces (XXX: is this a good idea?)
	 *
	 * XXX This way it is possible, that the trigger returns a tuple where
	 * attributes don't have the correct atttypmod's length. It's up to the
	 * trigger's programmer to ensure that this doesn't happen. Jan
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>.</operator><name>retisnull</name></name> <operator>||</operator> <operator>!</operator><call><name>TRIGGER_FIRED_FOR_ROW</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>rettup</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>retdesc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>tupmap</name></decl>;</decl_stmt>

		<comment type="block">/* We assume exec_stmt_return verified that result is composite */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>type_is_rowtype</name><argument_list>(<argument><expr><name><name>estate</name><operator>.</operator><name>rettype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* We can special-case expanded records for speed */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_EXPANDED</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>estate</name><operator>.</operator><name>retval</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>erh</name> <init>= <expr><operator>(</operator><name>ExpandedRecordHeader</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetEOHP</name><argument_list>(<argument><expr><name><name>estate</name><operator>.</operator><name>retval</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>erh</name><operator>-&gt;</operator><name>er_magic</name></name> <operator>==</operator> <name>ER_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Extract HeapTuple and TupleDesc */</comment>
			<expr_stmt><expr><name>rettup</name> <operator>=</operator> <call><name>expanded_record_get_tuple</name><argument_list>(<argument><expr><name>erh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rettup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>retdesc</name> <operator>=</operator> <call><name>expanded_record_get_tupdesc</name><argument_list>(<argument><expr><name>erh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>retdesc</name> <operator>!=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_relation</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* check rowtype compatibility */</comment>
				<expr_stmt><expr><name>tupmap</name> <operator>=</operator> <call><name>convert_tuples_by_position</name><argument_list>(<argument><expr><name>retdesc</name></expr></argument>,
													<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_relation</name></name></expr></argument>)</argument_list></call></expr></argument>,
													<argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"returned row structure does not match the structure of the triggering table"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* it might need conversion */</comment>
				<if_stmt><if>if <condition>(<expr><name>tupmap</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>rettup</name> <operator>=</operator> <call><name>execute_attr_map_tuple</name><argument_list>(<argument><expr><name>rettup</name></expr></argument>, <argument><expr><name>tupmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<comment type="block">/* no need to free map, we're about to return anyway */</comment>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Copy tuple to upper executor memory.  But if user just did
			 * "return new" or "return old" without changing anything, there's
			 * no need to copy; we can return the original tuple (which will
			 * save a few cycles in trigger.c as well as here).
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>rettup</name> <operator>!=</operator> <name><name>trigdata</name><operator>-&gt;</operator><name>tg_newtuple</name></name> <operator>&amp;&amp;</operator>
				<name>rettup</name> <operator>!=</operator> <name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigtuple</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>rettup</name> <operator>=</operator> <call><name>SPI_copytuple</name><argument_list>(<argument><expr><name>rettup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Convert composite datum to a HeapTuple and TupleDesc */</comment>
			<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>tmptup</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>retdesc</name> <operator>=</operator> <call><name>deconstruct_composite_datum</name><argument_list>(<argument><expr><name><name>estate</name><operator>.</operator><name>retval</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmptup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rettup</name> <operator>=</operator> <operator>&amp;</operator><name>tmptup</name></expr>;</expr_stmt>

			<comment type="block">/* check rowtype compatibility */</comment>
			<expr_stmt><expr><name>tupmap</name> <operator>=</operator> <call><name>convert_tuples_by_position</name><argument_list>(<argument><expr><name>retdesc</name></expr></argument>,
												<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_relation</name></name></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"returned row structure does not match the structure of the triggering table"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* it might need conversion */</comment>
			<if_stmt><if>if <condition>(<expr><name>tupmap</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>rettup</name> <operator>=</operator> <call><name>execute_attr_map_tuple</name><argument_list>(<argument><expr><name>rettup</name></expr></argument>, <argument><expr><name>tupmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name>retdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* no need to free map, we're about to return anyway */</comment>

			<comment type="block">/* Copy tuple to upper executor memory */</comment>
			<expr_stmt><expr><name>rettup</name> <operator>=</operator> <call><name>SPI_copytuple</name><argument_list>(<argument><expr><name>rettup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Let the instrumentation plugin peek at this function
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>plpgsql_plugin_ptr</name> <operator>&amp;&amp;</operator> <name><operator>(</operator><operator>*</operator><name>plpgsql_plugin_ptr</name><operator>)</operator><operator>-&gt;</operator><name>func_end</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name><operator>(</operator><operator>*</operator><name>plpgsql_plugin_ptr</name><operator>)</operator><operator>-&gt;</operator><name>func_end</name></name><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>estate</name><operator>,</operator> <name>func</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Clean up any leftover temporary memory */</comment>
	<expr_stmt><expr><call><name>plpgsql_destroy_econtext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* stmt_mcontext will be destroyed when function's main context is */</comment>

	<comment type="block">/*
	 * Pop the error context stack
	 */</comment>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>plerrcontext</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Return the trigger's result
	 */</comment>
	<return>return <expr><name>rettup</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * plpgsql_exec_event_trigger		Called by the call handler for
 *				event trigger execution.
 * ----------
 */</comment>
<function><type><name>void</name></type>
<name>plpgsql_exec_event_trigger</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_function</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><name>EventTriggerData</name> <modifier>*</modifier></type><name>trigdata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PLpgSQL_execstate</name></type> <name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>plerrcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Setup the execution state
	 */</comment>
	<expr_stmt><expr><call><name>plpgsql_estate_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>.</operator><name>evtrigdata</name></name> <operator>=</operator> <name>trigdata</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Setup error traceback support for ereport()
	 */</comment>
	<expr_stmt><expr><name><name>plerrcontext</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>plpgsql_exec_error_callback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plerrcontext</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <operator>&amp;</operator><name>estate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plerrcontext</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>plerrcontext</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make local execution copies of all the datums
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_text</name></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"during initialization of execution state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>copy_plpgsql_datums</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Let the instrumentation plugin peek at this function
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>plpgsql_plugin_ptr</name> <operator>&amp;&amp;</operator> <name><operator>(</operator><operator>*</operator><name>plpgsql_plugin_ptr</name><operator>)</operator><operator>-&gt;</operator><name>func_beg</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name><operator>(</operator><operator>*</operator><name>plpgsql_plugin_ptr</name><operator>)</operator><operator>-&gt;</operator><name>func_beg</name></name><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>estate</name><operator>,</operator> <name>func</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Now call the toplevel block of statements
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_text</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_stmt</name></name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_stmt</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>func</name><operator>-&gt;</operator><name>action</name></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt</name> <operator>*</operator><operator>)</operator> <name><name>func</name><operator>-&gt;</operator><name>action</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>PLPGSQL_RC_RETURN</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_stmt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_text</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_S_R_E_FUNCTION_EXECUTED_NO_RETURN_STATEMENT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"control reached end of trigger procedure without RETURN"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_stmt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>.</operator><name>err_text</name></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"during function exit"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Let the instrumentation plugin peek at this function
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>plpgsql_plugin_ptr</name> <operator>&amp;&amp;</operator> <name><operator>(</operator><operator>*</operator><name>plpgsql_plugin_ptr</name><operator>)</operator><operator>-&gt;</operator><name>func_end</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name><operator>(</operator><operator>*</operator><name>plpgsql_plugin_ptr</name><operator>)</operator><operator>-&gt;</operator><name>func_end</name></name><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>estate</name><operator>,</operator> <name>func</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Clean up any leftover temporary memory */</comment>
	<expr_stmt><expr><call><name>plpgsql_destroy_econtext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* stmt_mcontext will be destroyed when function's main context is */</comment>

	<comment type="block">/*
	 * Pop the error context stack
	 */</comment>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>plerrcontext</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * error context callback to let us supply a call-stack traceback
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>plpgsql_exec_error_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name> <init>= <expr><operator>(</operator><name>PLpgSQL_execstate</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>err_text</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We don't expend the cycles to run gettext() on err_text unless we
		 * actually need it.  Therefore, places that set up err_text should
		 * use gettext_noop() to ensure the strings get recorded in the
		 * message dictionary.
		 *
		 * If both err_text and err_stmt are set, use the err_text as
		 * description, but report the err_stmt's line number.  When err_stmt
		 * is not set, we're in function entry/exit, or some such place not
		 * attached to a specific line number.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>err_stmt</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * translator: last %s is a phrase such as "during statement block
			 * local variable initialization"
			 */</comment>
			<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"PL/pgSQL function %s line %d %s"</literal></expr></argument>,
					   <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>fn_signature</name></name></expr></argument>,
					   <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>err_stmt</name><operator>-&gt;</operator><name>lineno</name></name></expr></argument>,
					   <argument><expr><call><name>_</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>err_text</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * translator: last %s is a phrase such as "while storing call
			 * arguments into local variables"
			 */</comment>
			<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"PL/pgSQL function %s %s"</literal></expr></argument>,
					   <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>fn_signature</name></name></expr></argument>,
					   <argument><expr><call><name>_</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>err_text</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>err_stmt</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* translator: last %s is a plpgsql statement type name */</comment>
		<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"PL/pgSQL function %s line %d at %s"</literal></expr></argument>,
				   <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>fn_signature</name></name></expr></argument>,
				   <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>err_stmt</name><operator>-&gt;</operator><name>lineno</name></name></expr></argument>,
				   <argument><expr><call><name>plpgsql_stmt_typename</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>err_stmt</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"PL/pgSQL function %s"</literal></expr></argument>,
				   <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>fn_signature</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * Support function for initializing local execution variables
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>copy_plpgsql_datums</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
					<parameter><decl><type><name>PLpgSQL_function</name> <modifier>*</modifier></type><name>func</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndatums</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>ndatums</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier><modifier>*</modifier></type><name>indatums</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier><modifier>*</modifier></type><name>outdatums</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>workspace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ws_next</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Allocate local datum-pointer array */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>datums</name></name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_datum</name> <operator>*</operator><operator>*</operator><operator>)</operator>
		<call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PLpgSQL_datum</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ndatums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * To reduce palloc overhead, we make a single palloc request for all the
	 * space needed for locally-instantiated datums.
	 */</comment>
	<expr_stmt><expr><name>workspace</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>func</name><operator>-&gt;</operator><name>copiable_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ws_next</name> <operator>=</operator> <name>workspace</name></expr>;</expr_stmt>

	<comment type="block">/* Fill datum-pointer array, copying datums into workspace as needed */</comment>
	<expr_stmt><expr><name>indatums</name> <operator>=</operator> <name><name>func</name><operator>-&gt;</operator><name>datums</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>outdatums</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>datums</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndatums</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>indatum</name> <init>= <expr><name><name>indatums</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>outdatum</name></decl>;</decl_stmt>

		<comment type="block">/* This must agree with plpgsql_finish_datums on what is copiable */</comment>
		<switch>switch <condition>(<expr><name><name>indatum</name><operator>-&gt;</operator><name>dtype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>PLPGSQL_DTYPE_VAR</name></expr>:</case>
			<case>case <expr><name>PLPGSQL_DTYPE_PROMISE</name></expr>:</case>
				<expr_stmt><expr><name>outdatum</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_datum</name> <operator>*</operator><operator>)</operator> <name>ws_next</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>outdatum</name></expr></argument>, <argument><expr><name>indatum</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PLpgSQL_var</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ws_next</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PLpgSQL_var</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>PLPGSQL_DTYPE_REC</name></expr>:</case>
				<expr_stmt><expr><name>outdatum</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_datum</name> <operator>*</operator><operator>)</operator> <name>ws_next</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>outdatum</name></expr></argument>, <argument><expr><name>indatum</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PLpgSQL_rec</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ws_next</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PLpgSQL_rec</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>PLPGSQL_DTYPE_ROW</name></expr>:</case>
			<case>case <expr><name>PLPGSQL_DTYPE_RECFIELD</name></expr>:</case>
			<case>case <expr><name>PLPGSQL_DTYPE_ARRAYELEM</name></expr>:</case>

				<comment type="block">/*
				 * These datum records are read-only at runtime, so no need to
				 * copy them (well, RECFIELD and ARRAYELEM contain cached
				 * data, but we'd just as soon centralize the caching anyway).
				 */</comment>
				<expr_stmt><expr><name>outdatum</name> <operator>=</operator> <name>indatum</name></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized dtype: %d"</literal></expr></argument>, <argument><expr><name><name>indatum</name><operator>-&gt;</operator><name>dtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>outdatum</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
				<break>break;</break>
		</block_content>}</block></switch>

		<expr_stmt><expr><name><name>outdatums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>outdatum</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ws_next</name> <operator>==</operator> <name>workspace</name> <operator>+</operator> <name><name>func</name><operator>-&gt;</operator><name>copiable_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * If the variable has an armed "promise", compute the promised value
 * and assign it to the variable.
 * The assignment automatically disarms the promise.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>plpgsql_fulfill_promise</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
						<parameter><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>promise</name></name> <operator>==</operator> <name>PLPGSQL_PROMISE_NONE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* nothing to do */</comment>

	<comment type="block">/*
	 * This will typically be invoked in a short-lived context such as the
	 * mcontext.  We must create variable values in the estate's datum
	 * context.  This quick-and-dirty solution risks leaking some additional
	 * cruft there, but since any one promise is honored at most once per
	 * function call, it's probably not worth being more careful.
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>datum_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>promise</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PLPGSQL_PROMISE_TG_NAME</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>trigdata</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"trigger promise is not in a trigger function"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>assign_simple_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
							  <argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>namein</name></expr></argument>,
												  <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>trigdata</name><operator>-&gt;</operator><name>tg_trigger</name><operator>-&gt;</operator><name>tgname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PLPGSQL_PROMISE_TG_WHEN</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>trigdata</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"trigger promise is not in a trigger function"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FIRED_BEFORE</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>assign_text_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="string">"BEFORE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_AFTER</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>assign_text_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="string">"AFTER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_INSTEAD</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>assign_text_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="string">"INSTEAD OF"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized trigger execution time: not BEFORE, AFTER, or INSTEAD OF"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>

		<case>case <expr><name>PLPGSQL_PROMISE_TG_LEVEL</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>trigdata</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"trigger promise is not in a trigger function"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FIRED_FOR_ROW</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>assign_text_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="string">"ROW"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_FOR_STATEMENT</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>assign_text_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="string">"STATEMENT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized trigger event type: not ROW or STATEMENT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>

		<case>case <expr><name>PLPGSQL_PROMISE_TG_OP</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>trigdata</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"trigger promise is not in a trigger function"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FIRED_BY_INSERT</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>assign_text_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="string">"INSERT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_BY_UPDATE</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>assign_text_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="string">"UPDATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_BY_DELETE</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>assign_text_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="string">"DELETE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_BY_TRUNCATE</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>assign_text_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="string">"TRUNCATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized trigger action: not INSERT, DELETE, UPDATE, or TRUNCATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>

		<case>case <expr><name>PLPGSQL_PROMISE_TG_RELID</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>trigdata</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"trigger promise is not in a trigger function"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>assign_simple_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
							  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>trigdata</name><operator>-&gt;</operator><name>tg_relation</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PLPGSQL_PROMISE_TG_TABLE_NAME</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>trigdata</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"trigger promise is not in a trigger function"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>assign_simple_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
							  <argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>namein</name></expr></argument>,
												  <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>trigdata</name><operator>-&gt;</operator><name>tg_relation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PLPGSQL_PROMISE_TG_TABLE_SCHEMA</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>trigdata</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"trigger promise is not in a trigger function"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>assign_simple_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
							  <argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>namein</name></expr></argument>,
												  <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>trigdata</name><operator>-&gt;</operator><name>tg_relation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PLPGSQL_PROMISE_TG_NARGS</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>trigdata</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"trigger promise is not in a trigger function"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>assign_simple_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
							  <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>trigdata</name><operator>-&gt;</operator><name>tg_trigger</name><operator>-&gt;</operator><name>tgnargs</name></name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PLPGSQL_PROMISE_TG_ARGV</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>trigdata</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"trigger promise is not in a trigger function"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>trigdata</name><operator>-&gt;</operator><name>tg_trigger</name><operator>-&gt;</operator><name>tgnargs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * For historical reasons, tg_argv[] subscripts start at zero
				 * not one.  So we can't use construct_array().
				 */</comment>
				<decl_stmt><decl><type><name>int</name></type>			<name>nelems</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>trigdata</name><operator>-&gt;</operator><name>tg_trigger</name><operator>-&gt;</operator><name>tgnargs</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>elems</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name><name>dims</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name><name>lbs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>elems</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nelems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nelems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>elems</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>trigdata</name><operator>-&gt;</operator><name>tg_trigger</name><operator>-&gt;</operator><name>tgargs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
				<expr_stmt><expr><name><name>dims</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>nelems</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>lbs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>assign_simple_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
								  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>construct_md_array</name><argument_list>(<argument><expr><name>elems</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
																	 <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>dims</name></expr></argument>, <argument><expr><name>lbs</name></expr></argument>,
																	 <argument><expr><name>TEXTOID</name></expr></argument>,
																	 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>TYPALIGN_INT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>assign_simple_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>

		<case>case <expr><name>PLPGSQL_PROMISE_TG_EVENT</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>evtrigdata</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"event trigger promise is not in an event trigger function"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>assign_text_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>evtrigdata</name><operator>-&gt;</operator><name>event</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PLPGSQL_PROMISE_TG_TAG</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>evtrigdata</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"event trigger promise is not in an event trigger function"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>assign_text_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><call><name>GetCommandTagName</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>evtrigdata</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized promise type: %d"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>promise</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create a memory context for statement-lifespan variables, if we don't
 * have one already.  It will be a child of stmt_mcontext_parent, which is
 * either the function's main context or a pushed-down outer stmt_mcontext.
 */</comment>
<function><type><specifier>static</specifier> <name>MemoryContext</name></type>
<name>get_stmt_mcontext</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>stmt_mcontext</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>stmt_mcontext</name></name> <operator>=</operator>
			<call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>stmt_mcontext_parent</name></name></expr></argument>,
								  <argument><expr><literal type="string">"PLpgSQL per-statement data"</literal></expr></argument>,
								  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name><name>estate</name><operator>-&gt;</operator><name>stmt_mcontext</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Push down the current stmt_mcontext so that called statements won't use it.
 * This is needed by statements that have statement-lifespan data and need to
 * preserve it across some inner statements.  The caller should eventually do
 * pop_stmt_mcontext().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>push_stmt_mcontext</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Should have done get_stmt_mcontext() first */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>stmt_mcontext</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Assert we've not messed up the stack linkage */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>MemoryContextGetParent</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>stmt_mcontext</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>estate</name><operator>-&gt;</operator><name>stmt_mcontext_parent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Push it down to become the parent of any nested stmt mcontext */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>stmt_mcontext_parent</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>stmt_mcontext</name></name></expr>;</expr_stmt>
	<comment type="block">/* And make it not available for use directly */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>stmt_mcontext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Undo push_stmt_mcontext().  We assume this is done just before or after
 * resetting the caller's stmt_mcontext; since that action will also delete
 * any child contexts, there's no need to explicitly delete whatever context
 * might currently be estate-&gt;stmt_mcontext.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pop_stmt_mcontext</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* We need only pop the stack */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>stmt_mcontext</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>stmt_mcontext_parent</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>stmt_mcontext_parent</name></name> <operator>=</operator> <call><name>MemoryContextGetParent</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>stmt_mcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Subroutine for exec_stmt_block: does any condition in the condition list
 * match the current exception?
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>exception_matches_conditions</name><parameter_list>(<parameter><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_condition</name> <modifier>*</modifier></type><name>cond</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<for>for <control>(<init>;</init> <condition><expr><name>cond</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>cond</name> <operator>=</operator> <name><name>cond</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>sqlerrstate</name> <init>= <expr><name><name>cond</name><operator>-&gt;</operator><name>sqlerrstate</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * OTHERS matches everything *except* query-canceled and
		 * assert-failure.  If you're foolish enough, you can match those
		 * explicitly.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>sqlerrstate</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name> <operator>!=</operator> <name>ERRCODE_QUERY_CANCELED</name> <operator>&amp;&amp;</operator>
				<name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name> <operator>!=</operator> <name>ERRCODE_ASSERT_FAILURE</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<comment type="block">/* Exact match? */</comment>
		<if type="elseif">else if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name> <operator>==</operator> <name>sqlerrstate</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
		<comment type="block">/* Category match? */</comment>
		<if type="elseif">else if <condition>(<expr><call><name>ERRCODE_IS_CATEGORY</name><argument_list>(<argument><expr><name>sqlerrstate</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				 <call><name>ERRCODE_TO_CATEGORY</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>sqlerrstate</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_stmt_block			Execute a block of statements
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_block</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_block</name> <modifier>*</modifier></type><name>block</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>rc</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * First initialize all variables declared in this block
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>err_text</name></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"during statement block local variable initialization"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>block</name><operator>-&gt;</operator><name>n_initvars</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>n</name> <init>= <expr><name><name>block</name><operator>-&gt;</operator><name>initvarnos</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>datum</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>n</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * The set of dtypes handled here must match plpgsql_add_initdatums().
		 *
		 * Note that we currently don't support promise datums within blocks,
		 * only at a function's outermost scope, so we needn't handle those
		 * here.
		 */</comment>
		<switch>switch <condition>(<expr><name><name>datum</name><operator>-&gt;</operator><name>dtype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>PLPGSQL_DTYPE_VAR</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name>datum</name></expr></init></decl>;</decl_stmt>

					<comment type="block">/*
					 * Free any old value, in case re-entering block, and
					 * initialize to NULL
					 */</comment>
					<expr_stmt><expr><call><name>assign_simple_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>default_val</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * If needed, give the datatype a chance to reject
						 * NULLs, by assigning a NULL to the variable.  We
						 * claim the value is of type UNKNOWN, not the var's
						 * datatype, else coercion will be skipped.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_DOMAIN</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>exec_assign_value</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
											  <argument><expr><operator>(</operator><name>PLpgSQL_datum</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>,
											  <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>,
											  <argument><expr><name>true</name></expr></argument>,
											  <argument><expr><name>UNKNOWNOID</name></expr></argument>,
											  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<comment type="block">/* parser should have rejected NOT NULL */</comment>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>var</name><operator>-&gt;</operator><name>notnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><call><name>exec_assign_expr</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_datum</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>,
										 <argument><expr><name><name>var</name><operator>-&gt;</operator><name>default_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><name>PLPGSQL_DTYPE_REC</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name> <init>= <expr><operator>(</operator><name>PLpgSQL_rec</name> <operator>*</operator><operator>)</operator> <name>datum</name></expr></init></decl>;</decl_stmt>

					<comment type="block">/*
					 * Deletion of any existing object will be handled during
					 * the assignments below, and in some cases it's more
					 * efficient for us not to get rid of it beforehand.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>default_val</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * If needed, give the datatype a chance to reject
						 * NULLs, by assigning a NULL to the variable.
						 */</comment>
						<expr_stmt><expr><call><name>exec_move_row</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_variable</name> <operator>*</operator><operator>)</operator> <name>rec</name></expr></argument>,
									  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/* parser should have rejected NOT NULL */</comment>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>rec</name><operator>-&gt;</operator><name>notnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><call><name>exec_assign_expr</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_datum</name> <operator>*</operator><operator>)</operator> <name>rec</name></expr></argument>,
										 <argument><expr><name><name>rec</name><operator>-&gt;</operator><name>default_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized dtype: %d"</literal></expr></argument>, <argument><expr><name><name>datum</name><operator>-&gt;</operator><name>dtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name><name>block</name><operator>-&gt;</operator><name>exceptions</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Execute the statements in the block's body inside a sub-transaction
		 */</comment>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ResourceOwner</name></type> <name>oldowner</name> <init>= <expr><name>CurrentResourceOwner</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>old_eval_econtext</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>eval_econtext</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>save_cur_error</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>cur_error</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>stmt_mcontext</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>err_text</name></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"during statement block entry"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We will need a stmt_mcontext to hold the error data if an error
		 * occurs.  It seems best to force it to exist before entering the
		 * subtransaction, so that we reduce the risk of out-of-memory during
		 * error recovery, and because this greatly simplifies restoring the
		 * stmt_mcontext stack to the correct state after an error.  We can
		 * ameliorate the cost of this by allowing the called statements to
		 * use this mcontext too; so we don't push it down here.
		 */</comment>
		<expr_stmt><expr><name>stmt_mcontext</name> <operator>=</operator> <call><name>get_stmt_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>BeginInternalSubTransaction</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Want to run statements inside function's memory context */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<comment type="block">/*
			 * We need to run the block's statements with a new eval_econtext
			 * that belongs to the current subtransaction; if we try to use
			 * the outer econtext then ExprContext shutdown callbacks will be
			 * called at the wrong times.
			 */</comment>
			<expr_stmt><expr><call><name>plpgsql_create_econtext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>err_text</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

			<comment type="block">/* Run the block's statements */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmts</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>block</name><operator>-&gt;</operator><name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>err_text</name></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"during statement block exit"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If the block ended with RETURN, we may need to copy the return
			 * value out of the subtransaction eval_context.  We can avoid a
			 * physical copy if the value happens to be a R/W expanded object.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <name>PLPGSQL_RC_RETURN</name> <operator>&amp;&amp;</operator>
				<operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>retisset</name></name> <operator>&amp;&amp;</operator>
				<operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>retisnull</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int16</name></type>		<name>resTypLen</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>resTypByVal</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>get_typlenbyval</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>rettype</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>resTypLen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>resTypByVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>retval</name></name> <operator>=</operator> <call><name>datumTransfer</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>retval</name></name></expr></argument>,
											   <argument><expr><name>resTypByVal</name></expr></argument>, <argument><expr><name>resTypLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Commit the inner transaction, return to outer xact context */</comment>
			<expr_stmt><expr><call><name>ReleaseCurrentSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>oldowner</name></expr>;</expr_stmt>

			<comment type="block">/* Assert that the stmt_mcontext stack is unchanged */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>stmt_mcontext</name> <operator>==</operator> <name><name>estate</name><operator>-&gt;</operator><name>stmt_mcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Revert to outer eval_econtext.  (The inner one was
			 * automatically cleaned up during subxact exit.)
			 */</comment>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_econtext</name></name> <operator>=</operator> <name>old_eval_econtext</name></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>err_text</name></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"during exception cleanup"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Save error info in our stmt_mcontext */</comment>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>edata</name> <operator>=</operator> <call><name>CopyErrorData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Abort the inner transaction */</comment>
			<expr_stmt><expr><call><name>RollbackAndReleaseCurrentSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>oldowner</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Set up the stmt_mcontext stack as though we had restored our
			 * previous state and then done push_stmt_mcontext().  The push is
			 * needed so that statements in the exception handler won't
			 * clobber the error data that's in our stmt_mcontext.
			 */</comment>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>stmt_mcontext_parent</name></name> <operator>=</operator> <name>stmt_mcontext</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>stmt_mcontext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Now we can delete any nested stmt_mcontexts that might have
			 * been created as children of ours.  (Note: we do not immediately
			 * release any statement-lifespan data that might have been left
			 * behind in stmt_mcontext itself.  We could attempt that by doing
			 * a MemoryContextReset on it before collecting the error data
			 * above, but it seems too risky to do any significant amount of
			 * work before collecting the error.)
			 */</comment>
			<expr_stmt><expr><call><name>MemoryContextDeleteChildren</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Revert to outer eval_econtext */</comment>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_econtext</name></name> <operator>=</operator> <name>old_eval_econtext</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Must clean up the econtext too.  However, any tuple table made
			 * in the subxact will have been thrown away by SPI during subxact
			 * abort, so we don't need to (and mustn't try to) free the
			 * eval_tuptable.
			 */</comment>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_tuptable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Look for a matching exception handler */</comment>
			<macro><name>foreach</name><argument_list>(<argument>e</argument>, <argument>block-&gt;exceptions-&gt;exc_list</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PLpgSQL_exception</name> <modifier>*</modifier></type><name>exception</name> <init>= <expr><operator>(</operator><name>PLpgSQL_exception</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>exception_matches_conditions</name><argument_list>(<argument><expr><name>edata</name></expr></argument>, <argument><expr><name><name>exception</name><operator>-&gt;</operator><name>conditions</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Initialize the magic SQLSTATE and SQLERRM variables for
					 * the exception block; this also frees values from any
					 * prior use of the same exception. We needn't do this
					 * until we have found a matching exception.
					 */</comment>
					<decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>state_var</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>errm_var</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>state_var</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator>
						<name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>block</name><operator>-&gt;</operator><name>exceptions</name><operator>-&gt;</operator><name>sqlstate_varno</name></name></expr>]</index></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>errm_var</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator>
						<name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>block</name><operator>-&gt;</operator><name>exceptions</name><operator>-&gt;</operator><name>sqlerrm_varno</name></name></expr>]</index></name></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>assign_text_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>state_var</name></expr></argument>,
									<argument><expr><call><name>unpack_sql_state</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>assign_text_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>errm_var</name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * Also set up cur_error so the error data is accessible
					 * inside the handler.
					 */</comment>
					<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>cur_error</name></name> <operator>=</operator> <name>edata</name></expr>;</expr_stmt>

					<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>err_text</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

					<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmts</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>exception</name><operator>-&gt;</operator><name>action</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>

			<comment type="block">/*
			 * Restore previous state of cur_error, whether or not we executed
			 * a handler.  This is needed in case an error got thrown from
			 * some inner block's exception handler.
			 */</comment>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>cur_error</name></name> <operator>=</operator> <name>save_cur_error</name></expr>;</expr_stmt>

			<comment type="block">/* If no match found, re-throw the error */</comment>
			<if_stmt><if>if <condition>(<expr><name>e</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ReThrowError</name><argument_list>(<argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Restore stmt_mcontext stack and release the error data */</comment>
			<expr_stmt><expr><call><name>pop_stmt_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>save_cur_error</name> <operator>==</operator> <name><name>estate</name><operator>-&gt;</operator><name>cur_error</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Just execute the statements in the block's body
		 */</comment>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>err_text</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmts</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>block</name><operator>-&gt;</operator><name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>err_text</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Handle the return code.  This is intentionally different from
	 * LOOP_RC_PROCESSING(): CONTINUE never matches a block, and EXIT matches
	 * a block only if there is a label match.
	 */</comment>
	<switch>switch <condition>(<expr><name>rc</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PLPGSQL_RC_OK</name></expr>:</case>
		<case>case <expr><name>PLPGSQL_RC_RETURN</name></expr>:</case>
		<case>case <expr><name>PLPGSQL_RC_CONTINUE</name></expr>:</case>
			<return>return <expr><name>rc</name></expr>;</return>

		<case>case <expr><name>PLPGSQL_RC_EXIT</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>exitlabel</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>PLPGSQL_RC_EXIT</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>block</name><operator>-&gt;</operator><name>label</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>PLPGSQL_RC_EXIT</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>label</name></name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>exitlabel</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>PLPGSQL_RC_EXIT</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>exitlabel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized rc: %d"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_stmts			Iterate over a list of statements
 *				as long as their return code is OK
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmts</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>stmts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>stmts</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Ensure we do a CHECK_FOR_INTERRUPTS() even though there is no
		 * statement.  This prevents hangup in a tight loop if, for instance,
		 * there is a LOOP construct with an empty body.
		 */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>s</argument>, <argument>stmts</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PLpgSQL_stmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>PLpgSQL_stmt</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>rc</name> <init>= <expr><call><name>exec_stmt</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>PLPGSQL_RC_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_stmt			Distribute one statement to the statements
 *				type specific execution function.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PLpgSQL_stmt</name> <modifier>*</modifier></type><name>save_estmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rc</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>save_estmt</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>err_stmt</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>err_stmt</name></name> <operator>=</operator> <name>stmt</name></expr>;</expr_stmt>

	<comment type="block">/* Let the plugin know that we are about to execute this statement */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>plpgsql_plugin_ptr</name> <operator>&amp;&amp;</operator> <name><operator>(</operator><operator>*</operator><name>plpgsql_plugin_ptr</name><operator>)</operator><operator>-&gt;</operator><name>stmt_beg</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name><operator>(</operator><operator>*</operator><name>plpgsql_plugin_ptr</name><operator>)</operator><operator>-&gt;</operator><name>stmt_beg</name></name><operator>)</operator> <operator>(</operator><name>estate</name><operator>,</operator> <name>stmt</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>cmd_type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PLPGSQL_STMT_BLOCK</name></expr>:</case>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_block</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_block</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PLPGSQL_STMT_ASSIGN</name></expr>:</case>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_assign</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_assign</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PLPGSQL_STMT_PERFORM</name></expr>:</case>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_perform</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_perform</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PLPGSQL_STMT_CALL</name></expr>:</case>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_call</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_call</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PLPGSQL_STMT_GETDIAG</name></expr>:</case>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_getdiag</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_getdiag</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PLPGSQL_STMT_IF</name></expr>:</case>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_if</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_if</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PLPGSQL_STMT_CASE</name></expr>:</case>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_case</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_case</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PLPGSQL_STMT_LOOP</name></expr>:</case>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_loop</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_loop</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PLPGSQL_STMT_WHILE</name></expr>:</case>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_while</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_while</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PLPGSQL_STMT_FORI</name></expr>:</case>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_fori</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_fori</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PLPGSQL_STMT_FORS</name></expr>:</case>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_fors</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_fors</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PLPGSQL_STMT_FORC</name></expr>:</case>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_forc</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_forc</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PLPGSQL_STMT_FOREACH_A</name></expr>:</case>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_foreach_a</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_foreach_a</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PLPGSQL_STMT_EXIT</name></expr>:</case>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_exit</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_exit</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PLPGSQL_STMT_RETURN</name></expr>:</case>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_return</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_return</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PLPGSQL_STMT_RETURN_NEXT</name></expr>:</case>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_return_next</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_return_next</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PLPGSQL_STMT_RETURN_QUERY</name></expr>:</case>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_return_query</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_return_query</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PLPGSQL_STMT_RAISE</name></expr>:</case>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_raise</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_raise</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PLPGSQL_STMT_ASSERT</name></expr>:</case>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_assert</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_assert</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PLPGSQL_STMT_EXECSQL</name></expr>:</case>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_execsql</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_execsql</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PLPGSQL_STMT_DYNEXECUTE</name></expr>:</case>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_dynexecute</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_dynexecute</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PLPGSQL_STMT_DYNFORS</name></expr>:</case>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_dynfors</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_dynfors</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PLPGSQL_STMT_OPEN</name></expr>:</case>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_open</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_open</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PLPGSQL_STMT_FETCH</name></expr>:</case>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_fetch</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_fetch</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PLPGSQL_STMT_CLOSE</name></expr>:</case>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_close</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_close</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PLPGSQL_STMT_COMMIT</name></expr>:</case>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_commit</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_commit</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PLPGSQL_STMT_ROLLBACK</name></expr>:</case>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_rollback</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_rollback</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PLPGSQL_STMT_SET</name></expr>:</case>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmt_set</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_set</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>err_stmt</name></name> <operator>=</operator> <name>save_estmt</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized cmd_type: %d"</literal></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>cmd_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<comment type="block">/* Let the plugin know that we have finished executing this statement */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>plpgsql_plugin_ptr</name> <operator>&amp;&amp;</operator> <name><operator>(</operator><operator>*</operator><name>plpgsql_plugin_ptr</name><operator>)</operator><operator>-&gt;</operator><name>stmt_end</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name><operator>(</operator><operator>*</operator><name>plpgsql_plugin_ptr</name><operator>)</operator><operator>-&gt;</operator><name>stmt_end</name></name><operator>)</operator> <operator>(</operator><name>estate</name><operator>,</operator> <name>stmt</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>err_stmt</name></name> <operator>=</operator> <name>save_estmt</name></expr>;</expr_stmt>

	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_stmt_assign			Evaluate an expression and
 *					put the result into a variable.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_assign</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_assign</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>varno</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>exec_assign_expr</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>stmt</name><operator>-&gt;</operator><name>varno</name></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * exec_stmt_perform		Evaluate query and discard result (but set
 *							FOUND depending on whether at least one row
 *							was returned).
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_perform</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_perform</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>exec_run_select</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>exec_set_found</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>eval_processed</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * exec_stmt_call
 *
 * NOTE: this is used for both CALL and DO statements.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_call</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_call</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SPIPlanPtr</name></type>	<name>orig_plan</name> <init>= <expr><name><name>expr</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>local_plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PLpgSQL_variable</name> <modifier>*</modifier><specifier>volatile</specifier></type> <name>cur_target</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>target</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>LocalTransactionId</name></type> <name>before_lxid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LocalTransactionId</name></type> <name>after_lxid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>rc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If not in atomic context, we make a local plan that we'll just use for
	 * this invocation, and will free at the end.  Otherwise, transaction ends
	 * would cause errors about plancache leaks.
	 *
	 * XXX This would be fixable with some plancache/resowner surgery
	 * elsewhere, but for now we'll just work around this here.
	 */</comment>
	<expr_stmt><expr><name>local_plan</name> <operator>=</operator> <operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>atomic</name></name></expr>;</expr_stmt>

	<comment type="block">/* PG_TRY to ensure we clear the plan link, if needed, on failure */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SPIPlanPtr</name></type>	<name>plan</name> <init>= <expr><name><name>expr</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramLI</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Make a plan if we don't have one, or if we need a local one.  Note
		 * that we'll overwrite expr-&gt;plan either way; the PG_TRY block will
		 * ensure we undo that on the way out, if the plan is local.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>plan</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>local_plan</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Force target to be recalculated whenever the plan changes, in
			 * case the procedure's argument list has changed.
			 */</comment>
			<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>target</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>cur_target</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

			<comment type="block">/* Don't let SPI save the plan if it's going to be local */</comment>
			<expr_stmt><expr><call><name>exec_prepare_plan</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>!</operator><name>local_plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>plan</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * A CALL or DO can never be a simple expression.  (If it could be,
		 * we'd have to worry about saving/restoring the previous values of
		 * the related expr fields, not just expr-&gt;plan.)
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Tell SPI to allow non-atomic execution.  (The field name is a
		 * legacy choice.)
		 */</comment>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>no_snapshots</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * We construct a DTYPE_ROW datum representing the plpgsql variables
		 * associated with the procedure's output arguments.  Then we can use
		 * exec_move_row() to do the assignments.
		 *
		 * If we're using a local plan, also make a local target; otherwise,
		 * since the above code will force a new plan each time through, we'd
		 * repeatedly leak the memory for the target.  (Note: we also leak the
		 * target when a plan change is forced, but that isn't so likely to
		 * cause excessive memory leaks.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>is_call</name></name> <operator>&amp;&amp;</operator> <name>cur_target</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>funcexpr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>func_tuple</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>funcargs</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>argtypes</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>argnames</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>argmodes</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PLpgSQL_row</name> <modifier>*</modifier></type><name>row</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>nfields</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

			<comment type="block">/* Use stmt_mcontext for any cruft accumulated here */</comment>
			<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_stmt_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Get the parsed CallStmt, and look up the called procedure
			 */</comment>
			<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>Query</name></expr></argument>,
								 <argument><expr><operator>(</operator><operator>(</operator><name>CachedPlanSource</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>plancache_list</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>query_list</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>utilityStmt</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CallStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"query for CALL statement is not a CallStmt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>funcexpr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>CallStmt</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>funcexpr</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>func_tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>,
										 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>funcexpr</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>func_tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>,
					 <argument><expr><name><name>funcexpr</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Extract function arguments, and expand any named-arg notation
			 */</comment>
			<expr_stmt><expr><name>funcargs</name> <operator>=</operator> <call><name>expand_function_arguments</name><argument_list>(<argument><expr><name><name>funcexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
												 <argument><expr><name><name>funcexpr</name><operator>-&gt;</operator><name>funcresulttype</name></name></expr></argument>,
												 <argument><expr><name>func_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Get the argument names and modes, too
			 */</comment>
			<expr_stmt><expr><call><name>get_func_arg_info</name><argument_list>(<argument><expr><name>func_tuple</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argtypes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argnames</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argmodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>func_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Begin constructing row Datum; keep it in fn_cxt if it's to be
			 * long-lived.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>local_plan</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>fn_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>row</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_row</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PLpgSQL_row</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>row</name><operator>-&gt;</operator><name>dtype</name></name> <operator>=</operator> <name>PLPGSQL_DTYPE_ROW</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>row</name><operator>-&gt;</operator><name>refname</name></name> <operator>=</operator> <literal type="string">"(unnamed row)"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>row</name><operator>-&gt;</operator><name>lineno</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>row</name><operator>-&gt;</operator><name>varnos</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>funcargs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>local_plan</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_stmt_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Examine procedure's argument list.  Each output arg position
			 * should be an unadorned plpgsql variable (Datum), which we can
			 * insert into the row Datum.
			 */</comment>
			<expr_stmt><expr><name>nfields</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>funcargs</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>argmodes</name> <operator>&amp;&amp;</operator>
					<operator>(</operator><name><name>argmodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>PROARGMODE_INOUT</name> <operator>||</operator>
					 <name><name>argmodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>PROARGMODE_OUT</name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Param</name>	   <modifier>*</modifier></type><name>param</name> <init>= <expr><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>n</name></expr></init></decl>;</decl_stmt>

						<comment type="block">/* paramid is offset by 1 (see make_datum_param()) */</comment>
						<expr_stmt><expr><name><name>row</name><operator>-&gt;</operator><name>varnos</name><index>[<expr><name>nfields</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>paramid</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* report error using parameter name, if available */</comment>
						<if_stmt><if>if <condition>(<expr><name>argnames</name> <operator>&amp;&amp;</operator> <name><name>argnames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>argnames</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"procedure parameter \"%s\" is an output parameter but corresponding argument is not writable"</literal></expr></argument>,
											<argument><expr><name><name>argnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"procedure parameter %d is an output parameter but corresponding argument is not writable"</literal></expr></argument>,
											<argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block>

			<expr_stmt><expr><name><name>row</name><operator>-&gt;</operator><name>nfields</name></name> <operator>=</operator> <name>nfields</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>cur_target</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_variable</name> <operator>*</operator><operator>)</operator> <name>row</name></expr>;</expr_stmt>

			<comment type="block">/* We can save and re-use the target datum, if it's not local */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>local_plan</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>target</name></name> <operator>=</operator> <name>cur_target</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>paramLI</name> <operator>=</operator> <call><name>setup_param_list</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>before_lxid</name> <operator>=</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>lxid</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SPI_execute_plan_with_paramlist</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><name>paramLI</name></expr></argument>,
											 <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>readonly_func</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/*
		 * If we are using a local plan, restore the old plan link.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>local_plan</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>plan</name></name> <operator>=</operator> <name>orig_plan</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we are using a local plan, restore the old plan link; then free the
	 * local plan to avoid memory leaks.  (Note that the error exit path above
	 * just clears the link without risking calling SPI_freeplan; we expect
	 * that xact cleanup will take care of the mess in that case.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>local_plan</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SPIPlanPtr</name></type>	<name>plan</name> <init>= <expr><name><name>expr</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>plan</name></name> <operator>=</operator> <name>orig_plan</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SPI_freeplan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_execute_plan_with_paramlist failed executing query \"%s\": %s"</literal></expr></argument>,
			 <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>query</name></name></expr></argument>, <argument><expr><call><name>SPI_result_code_string</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>after_lxid</name> <operator>=</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>lxid</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>before_lxid</name> <operator>!=</operator> <name>after_lxid</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we are in a new transaction after the call, we need to build new
		 * simple-expression infrastructure.
		 */</comment>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>simple_eval_estate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>simple_eval_resowner</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>plpgsql_create_econtext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check result rowcount; if there's one row, assign procedure's output
	 * values back to the appropriate variables.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>SPI_processed</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SPITupleTable</name> <modifier>*</modifier></type><name>tuptab</name> <init>= <expr><name>SPI_tuptable</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cur_target</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"DO statement returned a row"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>exec_move_row</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>cur_target</name></expr></argument>, <argument><expr><name><name>tuptab</name><operator>-&gt;</operator><name>vals</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>tuptab</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>SPI_processed</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"procedure call returned more than one row"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SPI_freetuptable</name><argument_list>(<argument><expr><name>SPI_tuptable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * exec_stmt_getdiag					Put internal PG information into
 *										specified variables.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_getdiag</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_getdiag</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * GET STACKED DIAGNOSTICS is only valid inside an exception handler.
	 *
	 * Note: we trust the grammar to have disallowed the relevant item kinds
	 * if not is_stacked, otherwise we'd dump core below.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>is_stacked</name></name> <operator>&amp;&amp;</operator> <name><name>estate</name><operator>-&gt;</operator><name>cur_error</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_STACKED_DIAGNOSTICS_ACCESSED_WITHOUT_ACTIVE_HANDLER</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"GET STACKED DIAGNOSTICS cannot be used outside an exception handler"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmt-&gt;diag_items</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PLpgSQL_diag_item</name> <modifier>*</modifier></type><name>diag_item</name> <init>= <expr><operator>(</operator><name>PLpgSQL_diag_item</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>diag_item</name><operator>-&gt;</operator><name>target</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>diag_item</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>PLPGSQL_GETDIAG_ROW_COUNT</name></expr>:</case>
				<expr_stmt><expr><call><name>exec_assign_value</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
								  <argument><expr><call><name>UInt64GetDatum</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_processed</name></name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>PLPGSQL_GETDIAG_ERROR_CONTEXT</name></expr>:</case>
				<expr_stmt><expr><call><name>exec_assign_c_string</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
									 <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>cur_error</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>PLPGSQL_GETDIAG_ERROR_DETAIL</name></expr>:</case>
				<expr_stmt><expr><call><name>exec_assign_c_string</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
									 <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>cur_error</name><operator>-&gt;</operator><name>detail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>PLPGSQL_GETDIAG_ERROR_HINT</name></expr>:</case>
				<expr_stmt><expr><call><name>exec_assign_c_string</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
									 <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>cur_error</name><operator>-&gt;</operator><name>hint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>PLPGSQL_GETDIAG_RETURNED_SQLSTATE</name></expr>:</case>
				<expr_stmt><expr><call><name>exec_assign_c_string</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
									 <argument><expr><call><name>unpack_sql_state</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>cur_error</name><operator>-&gt;</operator><name>sqlerrcode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>PLPGSQL_GETDIAG_COLUMN_NAME</name></expr>:</case>
				<expr_stmt><expr><call><name>exec_assign_c_string</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
									 <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>cur_error</name><operator>-&gt;</operator><name>column_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>PLPGSQL_GETDIAG_CONSTRAINT_NAME</name></expr>:</case>
				<expr_stmt><expr><call><name>exec_assign_c_string</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
									 <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>cur_error</name><operator>-&gt;</operator><name>constraint_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>PLPGSQL_GETDIAG_DATATYPE_NAME</name></expr>:</case>
				<expr_stmt><expr><call><name>exec_assign_c_string</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
									 <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>cur_error</name><operator>-&gt;</operator><name>datatype_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>PLPGSQL_GETDIAG_MESSAGE_TEXT</name></expr>:</case>
				<expr_stmt><expr><call><name>exec_assign_c_string</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
									 <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>cur_error</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>PLPGSQL_GETDIAG_TABLE_NAME</name></expr>:</case>
				<expr_stmt><expr><call><name>exec_assign_c_string</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
									 <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>cur_error</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>PLPGSQL_GETDIAG_SCHEMA_NAME</name></expr>:</case>
				<expr_stmt><expr><call><name>exec_assign_c_string</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
									 <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>cur_error</name><operator>-&gt;</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>PLPGSQL_GETDIAG_CONTEXT</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>contextstackstr</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

					<comment type="block">/* Use eval_mcontext for short-lived string */</comment>
					<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>contextstackstr</name> <operator>=</operator> <call><name>GetErrorContextStack</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>exec_assign_c_string</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>contextstackstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized diagnostic item kind: %d"</literal></expr></argument>,
					 <argument><expr><name><name>diag_item</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block>

	<expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * exec_stmt_if				Evaluate a bool expression and
 *					execute the true or false body
 *					conditionally.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_if</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_if</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>exec_eval_boolean</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>cond</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name> <operator>&amp;&amp;</operator> <name>value</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>exec_stmts</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>then_body</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmt-&gt;elsif_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PLpgSQL_if_elsif</name> <modifier>*</modifier></type><name>elif</name> <init>= <expr><operator>(</operator><name>PLpgSQL_if_elsif</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>exec_eval_boolean</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>elif</name><operator>-&gt;</operator><name>cond</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name> <operator>&amp;&amp;</operator> <name>value</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>exec_stmts</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>elif</name><operator>-&gt;</operator><name>stmts</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><call><name>exec_stmts</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>else_body</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*-----------
 * exec_stmt_case
 *-----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_case</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_case</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>t_var</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>t_expr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* simple case */</comment>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>t_val</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>t_typoid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>t_typmod</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>t_val</name> <operator>=</operator> <call><name>exec_eval_expr</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>t_expr</name></name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t_typoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t_typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>t_var</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>stmt</name><operator>-&gt;</operator><name>t_varno</name></name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * When expected datatype is different from real, change it. Note that
		 * what we're modifying here is an execution copy of the datum, so
		 * this doesn't affect the originally stored function parse tree. (In
		 * theory, if the expression datatype keeps changing during execution,
		 * this could cause a function-lifespan memory leak.  Doesn't seem
		 * worth worrying about though.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>t_var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typoid</name></name> <operator>!=</operator> <name>t_typoid</name> <operator>||</operator>
			<name><name>t_var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>atttypmod</name></name> <operator>!=</operator> <name>t_typmod</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>t_var</name><operator>-&gt;</operator><name>datatype</name></name> <operator>=</operator> <call><name>plpgsql_build_datatype</name><argument_list>(<argument><expr><name>t_typoid</name></expr></argument>,
													 <argument><expr><name>t_typmod</name></expr></argument>,
													 <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>fn_input_collation</name></name></expr></argument>,
													 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* now we can assign to the variable */</comment>
		<expr_stmt><expr><call><name>exec_assign_value</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
						  <argument><expr><operator>(</operator><name>PLpgSQL_datum</name> <operator>*</operator><operator>)</operator> <name>t_var</name></expr></argument>,
						  <argument><expr><name>t_val</name></expr></argument>,
						  <argument><expr><name>isnull</name></expr></argument>,
						  <argument><expr><name>t_typoid</name></expr></argument>,
						  <argument><expr><name>t_typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Now search for a successful WHEN clause */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>stmt-&gt;case_when_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PLpgSQL_case_when</name> <modifier>*</modifier></type><name>cwt</name> <init>= <expr><operator>(</operator><name>PLpgSQL_case_when</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>value</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>exec_eval_boolean</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>cwt</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name> <operator>&amp;&amp;</operator> <name>value</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Found it */</comment>

			<comment type="block">/* We can now discard any value we had for the temp variable */</comment>
			<if_stmt><if>if <condition>(<expr><name>t_var</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>assign_simple_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>t_var</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Evaluate the statement(s), and we're done */</comment>
			<return>return <expr><call><name>exec_stmts</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>cwt</name><operator>-&gt;</operator><name>stmts</name></name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* We can now discard any value we had for the temp variable */</comment>
	<if_stmt><if>if <condition>(<expr><name>t_var</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>assign_simple_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>t_var</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* SQL2003 mandates this error if there was no ELSE clause */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>have_else</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CASE_NOT_FOUND</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"case not found"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"CASE statement is missing ELSE part."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Evaluate the ELSE statements, and we're done */</comment>
	<return>return <expr><call><name>exec_stmts</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>else_stmts</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_stmt_loop			Loop over statements until
 *					an exit occurs.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_loop</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_loop</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>rc</name> <init>= <expr><name>PLPGSQL_RC_OK</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmts</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>LOOP_RC_PROCESSING</name><argument_list>(<argument>stmt-&gt;label</argument>, <argument>break</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_stmt_while			Loop over statements as long
 *					as an expression evaluates to
 *					true or an exit occurs.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_while</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_while</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>rc</name> <init>= <expr><name>PLPGSQL_RC_OK</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>value</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>exec_eval_boolean</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>cond</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>isnull</name> <operator>||</operator> <operator>!</operator><name>value</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmts</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>LOOP_RC_PROCESSING</name><argument_list>(<argument>stmt-&gt;label</argument>, <argument>break</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_stmt_fori			Iterate an integer variable
 *					from a lower to an upper value
 *					incrementing or decrementing by the BY value
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_fori</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_fori</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>valtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>valtypmod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>loop_value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>end_value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>step_value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rc</name> <init>= <expr><name>PLPGSQL_RC_OK</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>stmt</name><operator>-&gt;</operator><name>var</name><operator>-&gt;</operator><name>dno</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get the value of the lower bound
	 */</comment>
	<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>exec_eval_expr</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>lower</name></name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>valtype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>valtypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>exec_cast_value</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>,
							<argument><expr><name>valtype</name></expr></argument>, <argument><expr><name>valtypmod</name></expr></argument>,
							<argument><expr><name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typoid</name></name></expr></argument>,
							<argument><expr><name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"lower bound of FOR loop cannot be null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>loop_value</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get the value of the upper bound
	 */</comment>
	<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>exec_eval_expr</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>upper</name></name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>valtype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>valtypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>exec_cast_value</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>,
							<argument><expr><name>valtype</name></expr></argument>, <argument><expr><name>valtypmod</name></expr></argument>,
							<argument><expr><name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typoid</name></name></expr></argument>,
							<argument><expr><name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"upper bound of FOR loop cannot be null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>end_value</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get the step value
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>step</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>exec_eval_expr</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>step</name></name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>valtype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>valtypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>exec_cast_value</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>,
								<argument><expr><name>valtype</name></expr></argument>, <argument><expr><name>valtypmod</name></expr></argument>,
								<argument><expr><name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typoid</name></name></expr></argument>,
								<argument><expr><name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"BY value of FOR loop cannot be null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>step_value</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>step_value</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"BY value of FOR loop must be greater than zero"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>step_value</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Now do the loop
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * Check against upper bound
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>reverse</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>loop_value</name> <operator>&lt;</operator> <name>end_value</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>loop_value</name> <operator>&gt;</operator> <name>end_value</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>			<comment type="block">/* looped at least once */</comment>

		<comment type="block">/*
		 * Assign current value to loop var
		 */</comment>
		<expr_stmt><expr><call><name>assign_simple_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>loop_value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Execute the statements
		 */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmts</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>LOOP_RC_PROCESSING</name><argument_list>(<argument>stmt-&gt;label</argument>, <argument>break</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

		<comment type="block">/*
		 * Increase/decrease loop value, unless it would overflow, in which
		 * case exit the loop.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>reverse</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>loop_value</name> <operator>&lt;</operator> <operator>(</operator><name>PG_INT32_MIN</name> <operator>+</operator> <name>step_value</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>loop_value</name> <operator>-=</operator> <name>step_value</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>loop_value</name> <operator>&gt;</operator> <operator>(</operator><name>PG_INT32_MAX</name> <operator>-</operator> <name>step_value</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>loop_value</name> <operator>+=</operator> <name>step_value</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Set the FOUND variable to indicate the result of executing the loop
	 * (namely, whether we looped one or more times). This must be set here so
	 * that it does not interfere with the value of the FOUND variable inside
	 * the loop processing itself.
	 */</comment>
	<expr_stmt><expr><call><name>exec_set_found</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_stmt_fors			Execute a query, assign each
 *					tuple to a record or row and
 *					execute a group of statements
 *					for it.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_fors</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_fors</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Portal</name></type>		<name>portal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Open the implicit cursor for the statement using exec_run_select
	 */</comment>
	<expr_stmt><expr><call><name>exec_run_select</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Execute the loop
	 */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_for_query</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_forq</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>, <argument><expr><name>portal</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Close the implicit cursor
	 */</comment>
	<expr_stmt><expr><call><name>SPI_cursor_close</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_stmt_forc			Execute a loop for each row from a cursor.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_forc</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_forc</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>curvar</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>stmt_mcontext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>curname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramLI</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Portal</name></type>		<name>portal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>

	<comment type="block">/* ----------
	 * Get the cursor variable and if it has an assigned name, check
	 * that it's not in use currently.
	 * ----------
	 */</comment>
	<expr_stmt><expr><name>curvar</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>stmt</name><operator>-&gt;</operator><name>curvar</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>curvar</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

		<comment type="block">/* We only need stmt_mcontext to hold the cursor name string */</comment>
		<expr_stmt><expr><name>stmt_mcontext</name> <operator>=</operator> <call><name>get_stmt_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>curname</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name><name>curvar</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>SPI_cursor_find</name><argument_list>(<argument><expr><name>curname</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_CURSOR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cursor \"%s\" already in use"</literal></expr></argument>, <argument><expr><name>curname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* ----------
	 * Open the cursor just like an OPEN command
	 *
	 * Note: parser should already have checked that statement supplies
	 * args iff cursor needs them, but we check again to be safe.
	 * ----------
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>argquery</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* ----------
		 * OPEN CURSOR with args.  We fake a SELECT ... INTO ...
		 * statement to evaluate the args and put 'em into the
		 * internal row.
		 * ----------
		 */</comment>
		<decl_stmt><decl><type><name>PLpgSQL_stmt_execsql</name></type> <name>set_args</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>curvar</name><operator>-&gt;</operator><name>cursor_explicit_argrow</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"arguments given for cursor without arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>set_args</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>set_args</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>set_args</name><operator>.</operator><name>cmd_type</name></name> <operator>=</operator> <name>PLPGSQL_STMT_EXECSQL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>set_args</name><operator>.</operator><name>lineno</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>lineno</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>set_args</name><operator>.</operator><name>sqlstmt</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>argquery</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>set_args</name><operator>.</operator><name>into</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<comment type="block">/* XXX historically this has not been STRICT */</comment>
		<expr_stmt><expr><name><name>set_args</name><operator>.</operator><name>target</name></name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_variable</name> <operator>*</operator><operator>)</operator>
			<operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>curvar</name><operator>-&gt;</operator><name>cursor_explicit_argrow</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>exec_stmt_execsql</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>set_args</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PLPGSQL_RC_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"open cursor failed during argument processing"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>curvar</name><operator>-&gt;</operator><name>cursor_explicit_argrow</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"arguments required for cursor"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <name><name>curvar</name><operator>-&gt;</operator><name>cursor_explicit_expr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>plan</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>exec_prepare_plan</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name><name>curvar</name><operator>-&gt;</operator><name>cursor_options</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Set up ParamListInfo for this query
	 */</comment>
	<expr_stmt><expr><name>paramLI</name> <operator>=</operator> <call><name>setup_param_list</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Open the cursor (the paramlist will get copied into the portal)
	 */</comment>
	<expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>SPI_cursor_open_with_paramlist</name><argument_list>(<argument><expr><name>curname</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>,
											<argument><expr><name>paramLI</name></expr></argument>,
											<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>readonly_func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>portal</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not open cursor: %s"</literal></expr></argument>,
			 <argument><expr><call><name>SPI_result_code_string</name><argument_list>(<argument><expr><name>SPI_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If cursor variable was NULL, store the generated portal name in it
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>curname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>assign_text_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>curvar</name></expr></argument>, <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Clean up before entering exec_for_query
	 */</comment>
	<expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>stmt_mcontext</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Execute the loop.  We can't prefetch because the cursor is accessible
	 * to the user, for instance via UPDATE WHERE CURRENT OF within the loop.
	 */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_for_query</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_forq</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>, <argument><expr><name>portal</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* ----------
	 * Close portal, and restore cursor variable if it was initially NULL.
	 * ----------
	 */</comment>
	<expr_stmt><expr><call><name>SPI_cursor_close</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>curname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>assign_simple_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>curvar</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_stmt_foreach_a			Loop over elements or slices of an array
 *
 * When looping over elements, the loop variable is the same type that the
 * array stores (eg: integer), when looping through slices, the loop variable
 * is an array of size and dimensions to match the size of the slice.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_foreach_a</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_foreach_a</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>arrtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>arrtypmod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>loop_var</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>loop_var_elem_type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rc</name> <init>= <expr><name>PLPGSQL_RC_OK</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>stmt_mcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayIterator</name></type> <name>array_iterator</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>iterator_result_type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>iterator_result_typmod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

	<comment type="block">/* get the value of the array expression */</comment>
	<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>exec_eval_expr</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arrtype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arrtypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"FOREACH expression must not be null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Do as much as possible of the code below in stmt_mcontext, to avoid any
	 * leaks from called subroutines.  We need a private stmt_mcontext since
	 * we'll be calling arbitrary statement code.
	 */</comment>
	<expr_stmt><expr><name>stmt_mcontext</name> <operator>=</operator> <call><name>get_stmt_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>push_stmt_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* check the type of the expression - must be an array */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>get_element_type</name><argument_list>(<argument><expr><name>arrtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"FOREACH expression must yield an array, not type %s"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>arrtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We must copy the array into stmt_mcontext, else it will disappear in
	 * exec_eval_cleanup.  This is annoying, but cleanup will certainly happen
	 * while running the loop body, so we have little choice.
	 */</comment>
	<expr_stmt><expr><name>arr</name> <operator>=</operator> <call><name>DatumGetArrayTypePCopy</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Clean up any leftover temporary memory */</comment>
	<expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Slice dimension must be less than or equal to array dimension */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>slice</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>stmt</name><operator>-&gt;</operator><name>slice</name></name> <operator>&gt;</operator> <call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_SUBSCRIPT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"slice dimension (%d) is out of the valid range 0..%d"</literal></expr></argument>,
						<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>slice</name></name></expr></argument>, <argument><expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Set up the loop variable and see if it is of an array type */</comment>
	<expr_stmt><expr><name>loop_var</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>stmt</name><operator>-&gt;</operator><name>varno</name></name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>loop_var</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_REC</name> <operator>||</operator>
		<name><name>loop_var</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_ROW</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Record/row variable is certainly not of array type, and might not
		 * be initialized at all yet, so don't try to get its type
		 */</comment>
		<expr_stmt><expr><name>loop_var_elem_type</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>loop_var_elem_type</name> <operator>=</operator> <call><name>get_element_type</name><argument_list>(<argument><expr><call><name>plpgsql_exec_get_datum_type</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
																		  <argument><expr><name>loop_var</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Sanity-check the loop variable type.  We don't try very hard here, and
	 * should not be too picky since it's possible that exec_assign_value can
	 * coerce values of different types.  But it seems worthwhile to complain
	 * if the array-ness of the loop variable is not right.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>slice</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>loop_var_elem_type</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"FOREACH ... SLICE loop variable must be of an array type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>slice</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>loop_var_elem_type</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"FOREACH loop variable must not be of an array type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Create an iterator to step through the array */</comment>
	<expr_stmt><expr><name>array_iterator</name> <operator>=</operator> <call><name>array_create_iterator</name><argument_list>(<argument><expr><name>arr</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>slice</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Identify iterator result type */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>slice</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* When slicing, nominal type of result is same as array type */</comment>
		<expr_stmt><expr><name>iterator_result_type</name> <operator>=</operator> <name>arrtype</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>iterator_result_typmod</name> <operator>=</operator> <name>arrtypmod</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Without slicing, results are individual array elements */</comment>
		<expr_stmt><expr><name>iterator_result_type</name> <operator>=</operator> <call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>iterator_result_typmod</name> <operator>=</operator> <name>arrtypmod</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Iterate over the array elements or slices */</comment>
	<while>while <condition>(<expr><call><name>array_iterate</name><argument_list>(<argument><expr><name>array_iterator</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>			<comment type="block">/* looped at least once */</comment>

		<comment type="block">/* exec_assign_value and exec_stmts must run in the main context */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Assign current element/slice to the loop variable */</comment>
		<expr_stmt><expr><call><name>exec_assign_value</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>loop_var</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>,
						  <argument><expr><name>iterator_result_type</name></expr></argument>, <argument><expr><name>iterator_result_typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* In slice case, value is temporary; must free it to avoid leakage */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>slice</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Execute the statements
		 */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmts</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>LOOP_RC_PROCESSING</name><argument_list>(<argument>stmt-&gt;label</argument>, <argument>break</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Restore memory context state */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pop_stmt_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Release temporary memory, including the array value */</comment>
	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set the FOUND variable to indicate the result of executing the loop
	 * (namely, whether we looped one or more times). This must be set here so
	 * that it does not interfere with the value of the FOUND variable inside
	 * the loop processing itself.
	 */</comment>
	<expr_stmt><expr><call><name>exec_set_found</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_stmt_exit			Implements EXIT and CONTINUE
 *
 * This begins the process of exiting / restarting a loop.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_exit</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_exit</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If the exit / continue has a condition, evaluate it
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>cond</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>value</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>exec_eval_boolean</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>cond</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isnull</name> <operator>||</operator> <name>value</name> <operator>==</operator> <name>false</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>exitlabel</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>label</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>is_exit</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>PLPGSQL_RC_EXIT</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>PLPGSQL_RC_CONTINUE</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_stmt_return			Evaluate an expression and start
 *					returning from the function.
 *
 * Note: The result may be in the eval_mcontext.  Therefore, we must not
 * do exec_eval_cleanup while unwinding the control stack.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_return</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_return</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If processing a set-returning PL/pgSQL function, the final RETURN
	 * indicates that the function is finished producing tuples.  The rest of
	 * the work will be done at the top level.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>retisset</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>PLPGSQL_RC_RETURN</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* initialize for null result */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>retval</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>retisnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>rettype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Special case path when the RETURN expression is a simple variable
	 * reference; in particular, this path is always taken in functions with
	 * one or more OUT parameters.
	 *
	 * This special case is especially efficient for returning variables that
	 * have R/W expanded values: we can put the R/W pointer directly into
	 * estate-&gt;retval, leading to transferring the value to the caller's
	 * context cheaply.  If we went through exec_eval_expr we'd end up with a
	 * R/O pointer.  It's okay to skip MakeExpandedObjectReadOnly here since
	 * we know we won't need the variable's value within the function anymore.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>retvarno</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>retvar</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>stmt</name><operator>-&gt;</operator><name>retvarno</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>retvar</name><operator>-&gt;</operator><name>dtype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>PLPGSQL_DTYPE_PROMISE</name></expr>:</case>
				<comment type="block">/* fulfill promise if needed, then handle like regular var */</comment>
				<expr_stmt><expr><call><name>plpgsql_fulfill_promise</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name>retvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* FALL THRU */</comment>

			<case>case <expr><name>PLPGSQL_DTYPE_VAR</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name>retvar</name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>retval</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>retisnull</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>rettype</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typoid</name></name></expr>;</expr_stmt>

					<comment type="block">/*
					 * A PLpgSQL_var could not be of composite type, so
					 * conversion must fail if retistuple.  We throw a custom
					 * error mainly for consistency with historical behavior.
					 * For the same reason, we don't throw error if the result
					 * is NULL.  (Note that plpgsql_exec_trigger assumes that
					 * any non-null result has been verified to be composite.)
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>retistuple</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>retisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot return non-composite value from function returning composite type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><name>PLPGSQL_DTYPE_REC</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name> <init>= <expr><operator>(</operator><name>PLpgSQL_rec</name> <operator>*</operator><operator>)</operator> <name>retvar</name></expr></init></decl>;</decl_stmt>

					<comment type="block">/* If record is empty, we return NULL not a row of nulls */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>erh</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ExpandedRecordIsEmpty</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>erh</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>retval</name></name> <operator>=</operator> <call><name>ExpandedRecordGetDatum</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>erh</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>retisnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>rettype</name></name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>rectypeid</name></name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><name>PLPGSQL_DTYPE_ROW</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>PLpgSQL_row</name> <modifier>*</modifier></type><name>row</name> <init>= <expr><operator>(</operator><name>PLpgSQL_row</name> <operator>*</operator><operator>)</operator> <name>retvar</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int32</name></type>		<name>rettypmod</name></decl>;</decl_stmt>

					<comment type="block">/* We get here if there are multiple OUT parameters */</comment>
					<expr_stmt><expr><call><name>exec_eval_datum</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
									<argument><expr><operator>(</operator><name>PLpgSQL_datum</name> <operator>*</operator><operator>)</operator> <name>row</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>estate</name><operator>-&gt;</operator><name>rettype</name></name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>rettypmod</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>estate</name><operator>-&gt;</operator><name>retval</name></name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>estate</name><operator>-&gt;</operator><name>retisnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized dtype: %d"</literal></expr></argument>, <argument><expr><name><name>retvar</name><operator>-&gt;</operator><name>dtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>

		<return>return <expr><name>PLPGSQL_RC_RETURN</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>expr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int32</name></type>		<name>rettypmod</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>retval</name></name> <operator>=</operator> <call><name>exec_eval_expr</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
										<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>retisnull</name></name><operator>)</operator></expr></argument>,
										<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>rettype</name></name><operator>)</operator></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>rettypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * As in the DTYPE_VAR case above, throw a custom error if a non-null,
		 * non-composite value is returned in a function returning tuple.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>retistuple</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>retisnull</name></name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>type_is_rowtype</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>rettype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot return non-composite value from function returning composite type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><name>PLPGSQL_RC_RETURN</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Special hack for function returning VOID: instead of NULL, return a
	 * non-null VOID value.  This is of dubious importance but is kept for
	 * backwards compatibility.  We don't do it for procedures, though.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>fn_rettype</name></name> <operator>==</operator> <name>VOIDOID</name> <operator>&amp;&amp;</operator>
		<name><name>estate</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>fn_prokind</name></name> <operator>!=</operator> <name>PROKIND_PROCEDURE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>retval</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>retisnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>rettype</name></name> <operator>=</operator> <name>VOIDOID</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>PLPGSQL_RC_RETURN</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * exec_stmt_return_next		Evaluate an expression and add it to the
 *								list of tuples returned by the current
 *								SRF.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_return_next</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
					  <parameter><decl><type><name>PLpgSQL_stmt_return_next</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>natts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>retisset</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use RETURN NEXT in a non-SETOF function"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>tuple_store</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>exec_init_tuple_store</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* tuple_store_desc will be filled by exec_init_tuple_store */</comment>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>tuple_store_desc</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>natts</name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Special case path when the RETURN NEXT expression is a simple variable
	 * reference; in particular, this path is always taken in functions with
	 * one or more OUT parameters.
	 *
	 * Unlike exec_stmt_return, there's no special win here for R/W expanded
	 * values, since they'll have to get flattened to go into the tuplestore.
	 * Indeed, we'd better make them R/O to avoid any risk of the casting step
	 * changing them in-place.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>retvarno</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>retvar</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>stmt</name><operator>-&gt;</operator><name>retvarno</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>retvar</name><operator>-&gt;</operator><name>dtype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>PLPGSQL_DTYPE_PROMISE</name></expr>:</case>
				<comment type="block">/* fulfill promise if needed, then handle like regular var */</comment>
				<expr_stmt><expr><call><name>plpgsql_fulfill_promise</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name>retvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* FALL THRU */</comment>

			<case>case <expr><name>PLPGSQL_DTYPE_VAR</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name>retvar</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Datum</name></type>		<name>retval</name> <init>= <expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name> <init>= <expr><name><name>var</name><operator>-&gt;</operator><name>isnull</name></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>natts</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"wrong result type supplied in RETURN NEXT"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/* let's be very paranoid about the cast step */</comment>
					<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>MakeExpandedObjectReadOnly</name><argument_list>(<argument><expr><name>retval</name></expr></argument>,
														<argument><expr><name>isNull</name></expr></argument>,
														<argument><expr><name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* coerce type if needed */</comment>
					<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>exec_cast_value</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
											 <argument><expr><name>retval</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>,
											 <argument><expr><name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typoid</name></name></expr></argument>,
											 <argument><expr><name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>,
											 <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
											 <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>tuple_store</name></name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>retval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><name>PLPGSQL_DTYPE_REC</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name> <init>= <expr><operator>(</operator><name>PLpgSQL_rec</name> <operator>*</operator><operator>)</operator> <name>retvar</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>rec_tupdesc</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>tupmap</name></decl>;</decl_stmt>

					<comment type="block">/* If rec is null, try to convert it to a row of nulls */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>erh</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>instantiate_empty_record_variable</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>ExpandedRecordIsEmpty</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>erh</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>deconstruct_expanded_record</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>erh</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/* Use eval_mcontext for tuple conversion work */</comment>
					<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>rec_tupdesc</name> <operator>=</operator> <call><name>expanded_record_get_tupdesc</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>erh</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>tupmap</name> <operator>=</operator> <call><name>convert_tuples_by_position</name><argument_list>(<argument><expr><name>rec_tupdesc</name></expr></argument>,
														<argument><expr><name>tupdesc</name></expr></argument>,
														<argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"wrong record type supplied in RETURN NEXT"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>expanded_record_get_tuple</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>erh</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>tupmap</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>execute_attr_map_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>tupmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>tuplestore_puttuple</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>tuple_store</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><name>PLPGSQL_DTYPE_ROW</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>PLpgSQL_row</name> <modifier>*</modifier></type><name>row</name> <init>= <expr><operator>(</operator><name>PLpgSQL_row</name> <operator>*</operator><operator>)</operator> <name>retvar</name></expr></init></decl>;</decl_stmt>

					<comment type="block">/* We get here if there are multiple OUT parameters */</comment>

					<comment type="block">/* Use eval_mcontext for tuple conversion work */</comment>
					<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>make_tuple_from_row</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>tuple</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* should not happen */</comment>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"wrong record type supplied in RETURN NEXT"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>tuplestore_puttuple</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>tuple_store</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized dtype: %d"</literal></expr></argument>, <argument><expr><name><name>retvar</name><operator>-&gt;</operator><name>dtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>expr</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>retval</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>rettype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>rettypmod</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>exec_eval_expr</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
								<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>rettype</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>rettypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>retistuple</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Expression should be of RECORD or composite type */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>tmptup</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>retvaldesc</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>tupmap</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>type_is_rowtype</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot return non-composite value from function returning composite type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* Use eval_mcontext for tuple conversion work */</comment>
				<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>retvaldesc</name> <operator>=</operator> <call><name>deconstruct_composite_datum</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmptup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>tuple</name> <operator>=</operator> <operator>&amp;</operator><name>tmptup</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>tupmap</name> <operator>=</operator> <call><name>convert_tuples_by_position</name><argument_list>(<argument><expr><name>retvaldesc</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>,
													<argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"returned record type does not match expected record type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>tupmap</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>execute_attr_map_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>tupmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>tuplestore_puttuple</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>tuple_store</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name>retvaldesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Composite NULL --- store a row of nulls */</comment>
				<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>nulldatums</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nullflags</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>nulldatums</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator>
					<call><name>eval_mcontext_alloc0</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>nullflags</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator>
					<call><name>eval_mcontext_alloc</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nullflags</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>tuple_store</name></name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>,
									 <argument><expr><name>nulldatums</name></expr></argument>, <argument><expr><name>nullflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Simple scalar result */</comment>
			<if_stmt><if>if <condition>(<expr><name>natts</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"wrong result type supplied in RETURN NEXT"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* coerce type if needed */</comment>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>exec_cast_value</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
									 <argument><expr><name>retval</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>,
									 <argument><expr><name>rettype</name></expr></argument>,
									 <argument><expr><name>rettypmod</name></expr></argument>,
									 <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
									 <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>tuple_store</name></name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>retval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"RETURN NEXT must have a parameter"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * exec_stmt_return_query		Evaluate a query and add it to the
 *								list of tuples returned by the current
 *								SRF.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_return_query</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
					   <parameter><decl><type><name>PLpgSQL_stmt_return_query</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Portal</name></type>		<name>portal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>processed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>tupmap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>retisset</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use RETURN QUERY in a non-SETOF function"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>tuple_store</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>exec_init_tuple_store</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* static query */</comment>
		<expr_stmt><expr><call><name>exec_run_select</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* RETURN QUERY EXECUTE */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>dynquery</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>exec_dynquery_with_params</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>dynquery</name></name></expr></argument>,
										   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>params</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
										   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Use eval_mcontext for tuple conversion work */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tupmap</name> <operator>=</operator> <call><name>convert_tuples_by_position</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>tupDesc</name></name></expr></argument>,
										<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>tuple_store_desc</name></name></expr></argument>,
										<argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"structure of query does not match function result type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>SPI_cursor_fetch</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">50</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* SPI will have changed CurrentMemoryContext */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>SPI_processed</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SPI_processed</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name> <init>= <expr><name><name>SPI_tuptable</name><operator>-&gt;</operator><name>vals</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>tupmap</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>execute_attr_map_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>tupmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>tuplestore_puttuple</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>tuple_store</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>tupmap</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>processed</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>SPI_freetuptable</name><argument_list>(<argument><expr><name>SPI_tuptable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>SPI_freetuptable</name><argument_list>(<argument><expr><name>SPI_tuptable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SPI_cursor_close</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_processed</name></name> <operator>=</operator> <name>processed</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>exec_set_found</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>processed</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_init_tuple_store</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsi</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>rsi</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResourceOwner</name></type> <name>oldowner</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check caller can handle a set result in the way we want
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rsi</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsi</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>(</operator><name><name>rsi</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<name><name>rsi</name><operator>-&gt;</operator><name>expectedDesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Switch to the right memory context and resource owner for storing the
	 * tuplestore for return set. If we're within a subtransaction opened for
	 * an exception-block, for example, we must still create the tuplestore in
	 * the resource owner that was active when this function was entered, and
	 * not in the subtransaction resource owner.
	 */</comment>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>tuple_store_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldowner</name> <operator>=</operator> <name>CurrentResourceOwner</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>tuple_store_owner</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>tuple_store</name></name> <operator>=</operator>
		<call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize_Random</name></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>oldowner</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>tuple_store_desc</name></name> <operator>=</operator> <name><name>rsi</name><operator>-&gt;</operator><name>expectedDesc</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_RAISE_OPTION_TEXT</name><parameter_list>(<parameter><type><name>opt</name></type></parameter>, <parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do { \
	if (opt) \
		ereport(ERROR, \
				(errcode(ERRCODE_SYNTAX_ERROR), \
				 errmsg("RAISE option already specified: %s", \
						name))); \
	opt = MemoryContextStrdup(stmt_mcontext, extval); \
} while (0)</cpp:value></cpp:define>

<comment type="block">/* ----------
 * exec_stmt_raise			Build a message and throw it with elog()
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_raise</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_raise</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>err_code</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>condname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>err_message</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>err_detail</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>err_hint</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>err_column</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>err_constraint</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>err_datatype</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>err_table</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>err_schema</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>stmt_mcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* RAISE with no parameters: re-throw current exception */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>condname</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>message</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<name><name>stmt</name><operator>-&gt;</operator><name>options</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>cur_error</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ReThrowError</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>cur_error</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* oops, we're not inside a handler */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_STACKED_DIAGNOSTICS_ACCESSED_WITHOUT_ACTIVE_HANDLER</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"RAISE without parameters cannot be used outside an exception handler"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We'll need to accumulate the various strings in stmt_mcontext */</comment>
	<expr_stmt><expr><name>stmt_mcontext</name> <operator>=</operator> <call><name>get_stmt_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>condname</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>err_code</name> <operator>=</operator> <call><name>plpgsql_recognize_err_condition</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>condname</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>condname</name> <operator>=</operator> <call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>condname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>message</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>ds</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>current_param</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

		<comment type="block">/* build string in stmt_mcontext */</comment>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>current_param</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>params</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>cp</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>message</name></name></expr>;</init> <condition><expr><operator>*</operator><name>cp</name></expr>;</condition> <incr><expr><name>cp</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/*
			 * Occurrences of a single % are replaced by the next parameter's
			 * external representation. Double %'s are converted to one %.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>cp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'%'</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>paramtypeid</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int32</name></type>		<name>paramtypmod</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Datum</name></type>		<name>paramvalue</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>paramisnull</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>extval</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>cp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'%'</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ds</name></expr></argument>, <argument><expr><literal type="char">'%'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* should have been checked at compile time */</comment>
				<if_stmt><if>if <condition>(<expr><name>current_param</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected RAISE parameter list length"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>paramvalue</name> <operator>=</operator> <call><name>exec_eval_expr</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
											<argument><expr><operator>(</operator><name>PLpgSQL_expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>current_param</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>paramisnull</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>paramtypeid</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>paramtypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>paramisnull</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>extval</name> <operator>=</operator> <literal type="string">"&lt;NULL&gt;"</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>extval</name> <operator>=</operator> <call><name>convert_value_to_string</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
													 <argument><expr><name>paramvalue</name></expr></argument>,
													 <argument><expr><name>paramtypeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ds</name></expr></argument>, <argument><expr><name>extval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>current_param</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>params</name></name></expr></argument>, <argument><expr><name>current_param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ds</name></expr></argument>, <argument><expr><name><name>cp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* should have been checked at compile time */</comment>
		<if_stmt><if>if <condition>(<expr><name>current_param</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected RAISE parameter list length"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>err_message</name> <operator>=</operator> <name><name>ds</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmt-&gt;options</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PLpgSQL_raise_option</name> <modifier>*</modifier></type><name>opt</name> <init>= <expr><operator>(</operator><name>PLpgSQL_raise_option</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>optionvalue</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>optionisnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>optiontypeid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>optiontypmod</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>extval</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>optionvalue</name> <operator>=</operator> <call><name>exec_eval_expr</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>optionisnull</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>optiontypeid</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>optiontypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>optionisnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"RAISE statement option cannot be null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>extval</name> <operator>=</operator> <call><name>convert_value_to_string</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>optionvalue</name></expr></argument>, <argument><expr><name>optiontypeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>opt_type</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>PLPGSQL_RAISEOPTION_ERRCODE</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>err_code</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"RAISE option already specified: %s"</literal></expr></argument>,
									<argument><expr><literal type="string">"ERRCODE"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>err_code</name> <operator>=</operator> <call><name>plpgsql_recognize_err_condition</name><argument_list>(<argument><expr><name>extval</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>condname</name> <operator>=</operator> <call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>, <argument><expr><name>extval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>PLPGSQL_RAISEOPTION_MESSAGE</name></expr>:</case>
				<expr_stmt><expr><call><name>SET_RAISE_OPTION_TEXT</name><argument_list>(<argument><expr><name>err_message</name></expr></argument>, <argument><expr><literal type="string">"MESSAGE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>PLPGSQL_RAISEOPTION_DETAIL</name></expr>:</case>
				<expr_stmt><expr><call><name>SET_RAISE_OPTION_TEXT</name><argument_list>(<argument><expr><name>err_detail</name></expr></argument>, <argument><expr><literal type="string">"DETAIL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>PLPGSQL_RAISEOPTION_HINT</name></expr>:</case>
				<expr_stmt><expr><call><name>SET_RAISE_OPTION_TEXT</name><argument_list>(<argument><expr><name>err_hint</name></expr></argument>, <argument><expr><literal type="string">"HINT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>PLPGSQL_RAISEOPTION_COLUMN</name></expr>:</case>
				<expr_stmt><expr><call><name>SET_RAISE_OPTION_TEXT</name><argument_list>(<argument><expr><name>err_column</name></expr></argument>, <argument><expr><literal type="string">"COLUMN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>PLPGSQL_RAISEOPTION_CONSTRAINT</name></expr>:</case>
				<expr_stmt><expr><call><name>SET_RAISE_OPTION_TEXT</name><argument_list>(<argument><expr><name>err_constraint</name></expr></argument>, <argument><expr><literal type="string">"CONSTRAINT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>PLPGSQL_RAISEOPTION_DATATYPE</name></expr>:</case>
				<expr_stmt><expr><call><name>SET_RAISE_OPTION_TEXT</name><argument_list>(<argument><expr><name>err_datatype</name></expr></argument>, <argument><expr><literal type="string">"DATATYPE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>PLPGSQL_RAISEOPTION_TABLE</name></expr>:</case>
				<expr_stmt><expr><call><name>SET_RAISE_OPTION_TEXT</name><argument_list>(<argument><expr><name>err_table</name></expr></argument>, <argument><expr><literal type="string">"TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>PLPGSQL_RAISEOPTION_SCHEMA</name></expr>:</case>
				<expr_stmt><expr><call><name>SET_RAISE_OPTION_TEXT</name><argument_list>(<argument><expr><name>err_schema</name></expr></argument>, <argument><expr><literal type="string">"SCHEMA"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized raise option: %d"</literal></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>opt_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>

		<expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Default code if nothing specified */</comment>
	<if_stmt><if>if <condition>(<expr><name>err_code</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>elog_level</name></name> <operator>&gt;=</operator> <name>ERROR</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>err_code</name> <operator>=</operator> <name>ERRCODE_RAISE_EXCEPTION</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Default error message if nothing specified */</comment>
	<if_stmt><if>if <condition>(<expr><name>err_message</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>condname</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>err_message</name> <operator>=</operator> <name>condname</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>condname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>err_message</name> <operator>=</operator> <call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>,
											  <argument><expr><call><name>unpack_sql_state</name><argument_list>(<argument><expr><name>err_code</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Throw the error (may or may not come back)
	 */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>elog_level</name></name></expr></argument>,
			<argument><expr><operator>(</operator><ternary><condition><expr><name>err_code</name></expr> ?</condition><then> <expr><call><name>errcode</name><argument_list>(<argument><expr><name>err_code</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
			 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>err_message</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <ternary><condition><expr><operator>(</operator><name>err_detail</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>err_detail</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
			 <ternary><condition><expr><operator>(</operator><name>err_hint</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>err_hint</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
			 <ternary><condition><expr><operator>(</operator><name>err_column</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then>
			 <expr><call><name>err_generic_string</name><argument_list>(<argument><expr><name>PG_DIAG_COLUMN_NAME</name></expr></argument>, <argument><expr><name>err_column</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
			 <ternary><condition><expr><operator>(</operator><name>err_constraint</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then>
			 <expr><call><name>err_generic_string</name><argument_list>(<argument><expr><name>PG_DIAG_CONSTRAINT_NAME</name></expr></argument>, <argument><expr><name>err_constraint</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
			 <ternary><condition><expr><operator>(</operator><name>err_datatype</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then>
			 <expr><call><name>err_generic_string</name><argument_list>(<argument><expr><name>PG_DIAG_DATATYPE_NAME</name></expr></argument>, <argument><expr><name>err_datatype</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
			 <ternary><condition><expr><operator>(</operator><name>err_table</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then>
			 <expr><call><name>err_generic_string</name><argument_list>(<argument><expr><name>PG_DIAG_TABLE_NAME</name></expr></argument>, <argument><expr><name>err_table</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
			 <ternary><condition><expr><operator>(</operator><name>err_schema</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then>
			 <expr><call><name>err_generic_string</name><argument_list>(<argument><expr><name>PG_DIAG_SCHEMA_NAME</name></expr></argument>, <argument><expr><name>err_schema</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Clean up transient strings */</comment>
	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * exec_stmt_assert			Assert statement
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_assert</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_assert</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

	<comment type="block">/* do nothing when asserts are not enabled */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>plpgsql_check_asserts</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>exec_eval_boolean</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>cond</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>isnull</name> <operator>||</operator> <operator>!</operator><name>value</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>message</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>message</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>val</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>typeid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>exec_eval_expr</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>message</name></name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typeid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>message</name> <operator>=</operator> <call><name>convert_value_to_string</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* we mustn't do exec_eval_cleanup here */</comment>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ASSERT_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <ternary><condition><expr><name>message</name></expr> ?</condition><then> <expr><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr> </then><else>:
				 <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"assertion failed"</literal></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * Initialize a mostly empty execution state
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>plpgsql_estate_setup</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
					 <parameter><decl><type><name>PLpgSQL_function</name> <modifier>*</modifier></type><name>func</name></decl></parameter>,
					 <parameter><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsi</name></decl></parameter>,
					 <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>simple_eval_estate</name></decl></parameter>,
					 <parameter><decl><type><name>ResourceOwner</name></type> <name>simple_eval_resowner</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>ctl</name></decl>;</decl_stmt>

	<comment type="block">/* this link will be restored at exit from plpgsql_call_handler */</comment>
	<expr_stmt><expr><name><name>func</name><operator>-&gt;</operator><name>cur_estate</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>func</name></name> <operator>=</operator> <name>func</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>trigdata</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>evtrigdata</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>retval</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>retisnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>rettype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>fn_rettype</name></name> <operator>=</operator> <name><name>func</name><operator>-&gt;</operator><name>fn_rettype</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>retistuple</name></name> <operator>=</operator> <name><name>func</name><operator>-&gt;</operator><name>fn_retistuple</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>retisset</name></name> <operator>=</operator> <name><name>func</name><operator>-&gt;</operator><name>fn_retset</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>readonly_func</name></name> <operator>=</operator> <name><name>func</name><operator>-&gt;</operator><name>fn_readonly</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>atomic</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>exitlabel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>cur_error</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>tuple_store</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>tuple_store_desc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rsi</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>tuple_store_cxt</name></name> <operator>=</operator> <name><name>rsi</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>tuple_store_owner</name></name> <operator>=</operator> <name>CurrentResourceOwner</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>tuple_store_cxt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>tuple_store_owner</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>rsi</name></name> <operator>=</operator> <name>rsi</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>found_varno</name></name> <operator>=</operator> <name><name>func</name><operator>-&gt;</operator><name>found_varno</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>=</operator> <name><name>func</name><operator>-&gt;</operator><name>ndatums</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>datums</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<comment type="block">/* the datums array will be filled by copy_plpgsql_datums() */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>datum_context</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>

	<comment type="block">/* initialize our ParamListInfo with appropriate hook functions */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>paramLI</name></name> <operator>=</operator> <call><name>makeParamList</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>paramLI</name><operator>-&gt;</operator><name>paramFetch</name></name> <operator>=</operator> <name>plpgsql_param_fetch</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>paramLI</name><operator>-&gt;</operator><name>paramFetchArg</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>estate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>paramLI</name><operator>-&gt;</operator><name>paramCompile</name></name> <operator>=</operator> <name>plpgsql_param_compile</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>paramLI</name><operator>-&gt;</operator><name>paramCompileArg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* not needed */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>paramLI</name><operator>-&gt;</operator><name>parserSetup</name></name> <operator>=</operator> <operator>(</operator><name>ParserSetupHook</name><operator>)</operator> <name>plpgsql_parser_setup</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>paramLI</name><operator>-&gt;</operator><name>parserSetupArg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* filled during use */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>paramLI</name><operator>-&gt;</operator><name>numParams</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>ndatums</name></name></expr>;</expr_stmt>

	<comment type="block">/* set up for use of appropriate simple-expression EState and cast hash */</comment>
	<if_stmt><if>if <condition>(<expr><name>simple_eval_estate</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>simple_eval_estate</name></name> <operator>=</operator> <name>simple_eval_estate</name></expr>;</expr_stmt>
		<comment type="block">/* Private cast hash just lives in function's main context */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>plpgsql_CastHashKey</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>plpgsql_CastHashEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>cast_hash</name></name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"PLpgSQL private cast cache"</literal></expr></argument>,
										<argument><expr><literal type="number">16</literal></expr></argument>, <comment type="block">/* start small and extend */</comment>
										<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>,
										<argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>cast_hash_context</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>simple_eval_estate</name></name> <operator>=</operator> <name>shared_simple_eval_estate</name></expr>;</expr_stmt>
		<comment type="block">/* Create the session-wide cast-info hash table if we didn't already */</comment>
		<if_stmt><if>if <condition>(<expr><name>shared_cast_hash</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>shared_cast_context</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
														<argument><expr><literal type="string">"PLpgSQL cast info"</literal></expr></argument>,
														<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>plpgsql_CastHashKey</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>plpgsql_CastHashEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>shared_cast_context</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>shared_cast_hash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"PLpgSQL cast cache"</literal></expr></argument>,
										   <argument><expr><literal type="number">16</literal></expr></argument>,	<comment type="block">/* start small and extend */</comment>
										   <argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>,
										   <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>cast_hash</name></name> <operator>=</operator> <name>shared_cast_hash</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>cast_hash_context</name></name> <operator>=</operator> <name>shared_cast_context</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* likewise for the simple-expression resource owner */</comment>
	<if_stmt><if>if <condition>(<expr><name>simple_eval_resowner</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>simple_eval_resowner</name></name> <operator>=</operator> <name>simple_eval_resowner</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>simple_eval_resowner</name></name> <operator>=</operator> <name>shared_simple_eval_resowner</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * We start with no stmt_mcontext; one will be created only if needed.
	 * That context will be a direct child of the function's main execution
	 * context.  Additional stmt_mcontexts might be created as children of it.
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>stmt_mcontext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>stmt_mcontext_parent</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_tuptable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_processed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_econtext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>err_stmt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>err_text</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>plugin_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create an EState and ExprContext for evaluation of simple expressions.
	 */</comment>
	<expr_stmt><expr><call><name>plpgsql_create_econtext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Let the plugin see this function before we initialize any local
	 * PL/pgSQL variables - note that we also give the plugin a few function
	 * pointers so it can call back into PL/pgSQL for doing things like
	 * variable assignments and stack traces
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>plpgsql_plugin_ptr</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>plpgsql_plugin_ptr</name><operator>)</operator><operator>-&gt;</operator><name>error_callback</name></name> <operator>=</operator> <name>plpgsql_exec_error_callback</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>plpgsql_plugin_ptr</name><operator>)</operator><operator>-&gt;</operator><name>assign_expr</name></name> <operator>=</operator> <name>exec_assign_expr</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><operator>(</operator><operator>*</operator><name>plpgsql_plugin_ptr</name><operator>)</operator><operator>-&gt;</operator><name>func_setup</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>(</operator><name><operator>(</operator><operator>*</operator><name>plpgsql_plugin_ptr</name><operator>)</operator><operator>-&gt;</operator><name>func_setup</name></name><operator>)</operator> <operator>(</operator><name>estate</name><operator>,</operator> <name>func</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * Release temporary memory used by expression/subselect evaluation
 *
 * NB: the result of the evaluation is no longer valid after this is done,
 * unless it is a pass-by-value datatype.
 *
 * NB: if you change this code, see also the hacks in exec_assign_value's
 * PLPGSQL_DTYPE_ARRAYELEM case for partial cleanup after subscript evals.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_eval_cleanup</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Clear result of a full SPI_execute */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>eval_tuptable</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SPI_freetuptable</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_tuptable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_tuptable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Clear result of exec_eval_simple_expr (but keep the econtext).  This
	 * also clears any short-lived allocations done via get_eval_mcontext.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>eval_econtext</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_econtext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * Generate a prepared plan
 *
 * CAUTION: it is possible for this function to throw an error after it has
 * built a SPIPlan and saved it in expr-&gt;plan.  Therefore, be wary of doing
 * additional things contingent on expr-&gt;plan being NULL.  That is, given
 * code like
 *
 *	if (query-&gt;plan == NULL)
 *	{
 *		// okay to put setup code here
 *		exec_prepare_plan(estate, query, ...);
 *		// NOT okay to put more logic here
 *	}
 *
 * extra steps at the end are unsafe because they will not be executed when
 * re-executing the calling statement, if exec_prepare_plan failed the first
 * time.  This is annoyingly error-prone, but the alternatives are worse.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_prepare_plan</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
				  <parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cursorOptions</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>keepplan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SPIPlanPtr</name></type>	<name>plan</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The grammar can't conveniently set expr-&gt;func while building the parse
	 * tree, so make sure it's set before parser hooks need it.
	 */</comment>
	<expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>func</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>func</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Generate and save the plan
	 */</comment>
	<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>SPI_prepare_params</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>query</name></name></expr></argument>,
							  <argument><expr><operator>(</operator><name>ParserSetupHook</name><operator>)</operator> <name>plpgsql_parser_setup</name></expr></argument>,
							  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>,
							  <argument><expr><name>cursorOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>plan</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_prepare_params failed for \"%s\": %s"</literal></expr></argument>,
			 <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>query</name></name></expr></argument>, <argument><expr><call><name>SPI_result_code_string</name><argument_list>(<argument><expr><name>SPI_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>keepplan</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SPI_keepplan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>plan</name></name> <operator>=</operator> <name>plan</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Mark expression as not using a read-write param.  exec_assign_value has
	 * to take steps to override this if appropriate; that seems cleaner than
	 * adding parameters to all other callers.
	 */</comment>
	<expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>rwparam</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* Check to see if it's a simple expression */</comment>
	<expr_stmt><expr><call><name>exec_simple_check_plan</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_stmt_execsql			Execute an SQL statement (possibly with INTO).
 *
 * Note: some callers rely on this not touching stmt_mcontext.  If it ever
 * needs to use that, fix those callers to push/pop stmt_mcontext.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_execsql</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
				  <parameter><decl><type><name>PLpgSQL_stmt_execsql</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramLI</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>tcount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>sqlstmt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>too_many_rows_level</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>plpgsql_extra_errors</name> <operator>&amp;</operator> <name>PLPGSQL_XCHECK_TOOMANYROWS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>too_many_rows_level</name> <operator>=</operator> <name>ERROR</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>plpgsql_extra_warnings</name> <operator>&amp;</operator> <name>PLPGSQL_XCHECK_TOOMANYROWS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>too_many_rows_level</name> <operator>=</operator> <name>WARNING</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * On the first call for this statement generate the plan, and detect
	 * whether the statement is INSERT/UPDATE/DELETE
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>plan</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>exec_prepare_plan</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>CURSOR_OPT_PARALLEL_OK</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>mod_stmt_set</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>mod_stmt</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>SPI_plan_get_plan_sources(expr-&gt;plan)</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>plansource</name> <init>= <expr><operator>(</operator><name>CachedPlanSource</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * We could look at the raw_parse_tree, but it seems simpler to
			 * check the command tag.  Note we should *not* look at the Query
			 * tree(s), since those are the result of rewriting and could have
			 * been transmogrified into something else entirely.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>plansource</name><operator>-&gt;</operator><name>commandTag</name></name> <operator>==</operator> <name>CMDTAG_INSERT</name> <operator>||</operator>
				<name><name>plansource</name><operator>-&gt;</operator><name>commandTag</name></name> <operator>==</operator> <name>CMDTAG_UPDATE</name> <operator>||</operator>
				<name><name>plansource</name><operator>-&gt;</operator><name>commandTag</name></name> <operator>==</operator> <name>CMDTAG_DELETE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>mod_stmt</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>mod_stmt_set</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Set up ParamListInfo to pass to executor
	 */</comment>
	<expr_stmt><expr><name>paramLI</name> <operator>=</operator> <call><name>setup_param_list</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we have INTO, then we only need one row back ... but if we have INTO
	 * STRICT or extra check too_many_rows, ask for two rows, so that we can
	 * verify the statement returns only one.  INSERT/UPDATE/DELETE are always
	 * treated strictly. Without INTO, just run the statement to completion
	 * (tcount = 0).
	 *
	 * We could just ask for two rows always when using INTO, but there are
	 * some cases where demanding the extra row costs significant time, eg by
	 * forcing completion of a sequential scan.  So don't do it unless we need
	 * to enforce strictness.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>into</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>strict</name></name> <operator>||</operator> <name><name>stmt</name><operator>-&gt;</operator><name>mod_stmt</name></name> <operator>||</operator> <name>too_many_rows_level</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>tcount</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>tcount</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>tcount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Execute the plan
	 */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SPI_execute_plan_with_paramlist</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><name>paramLI</name></expr></argument>,
										 <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>readonly_func</name></name></expr></argument>, <argument><expr><name>tcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check for error, and set FOUND if appropriate (for historical reasons
	 * we set FOUND only for certain query types).  Also Assert that we
	 * identified the statement type the same as SPI did.
	 */</comment>
	<switch>switch <condition>(<expr><name>rc</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>SPI_OK_SELECT</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>mod_stmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exec_set_found</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>SPI_processed</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>SPI_OK_INSERT</name></expr>:</case>
		<case>case <expr><name>SPI_OK_UPDATE</name></expr>:</case>
		<case>case <expr><name>SPI_OK_DELETE</name></expr>:</case>
		<case>case <expr><name>SPI_OK_INSERT_RETURNING</name></expr>:</case>
		<case>case <expr><name>SPI_OK_UPDATE_RETURNING</name></expr>:</case>
		<case>case <expr><name>SPI_OK_DELETE_RETURNING</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>mod_stmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exec_set_found</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>SPI_processed</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>SPI_OK_GRAPHWRITE</name></expr>:</case>
			<comment type="block">/*
			 * The command is to execute graphwrite type from pl module.
			 * 
			 * But, this command is only executed when allow_graphwrite_type
			 * (GUC variable) is true.
			 */</comment>
			<break>break;</break>

		<case>case <expr><name>SPI_OK_SELINTO</name></expr>:</case>
		<case>case <expr><name>SPI_OK_UTILITY</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>mod_stmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>SPI_OK_REWRITTEN</name></expr>:</case>

			<comment type="block">/*
			 * The command was rewritten into another kind of command. It's
			 * not clear what FOUND would mean in that case (and SPI doesn't
			 * return the row count either), so just set it to false.  Note
			 * that we can't assert anything about mod_stmt here.
			 */</comment>
			<expr_stmt><expr><call><name>exec_set_found</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/* Some SPI errors deserve specific error messages */</comment>
		<case>case <expr><name>SPI_ERROR_COPY</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot COPY to/from client in PL/pgSQL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>SPI_ERROR_TRANSACTION</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported transaction command in PL/pgSQL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_execute_plan_with_paramlist failed executing query \"%s\": %s"</literal></expr></argument>,
				 <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>query</name></name></expr></argument>, <argument><expr><call><name>SPI_result_code_string</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* All variants should save result info for GET DIAGNOSTICS */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_processed</name></name> <operator>=</operator> <name>SPI_processed</name></expr>;</expr_stmt>

	<comment type="block">/* Process INTO if present */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>into</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SPITupleTable</name> <modifier>*</modifier></type><name>tuptab</name> <init>= <expr><name>SPI_tuptable</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>n</name> <init>= <expr><name>SPI_processed</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PLpgSQL_variable</name> <modifier>*</modifier></type><name>target</name></decl>;</decl_stmt>

		<comment type="block">/* If the statement did not return a tuple table, complain */</comment>
		<if_stmt><if>if <condition>(<expr><name>tuptab</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"INTO used with a command that cannot return data"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Fetch target's datum entry */</comment>
		<expr_stmt><expr><name>target</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_variable</name> <operator>*</operator><operator>)</operator> <name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>stmt</name><operator>-&gt;</operator><name>target</name><operator>-&gt;</operator><name>dno</name></name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If SELECT ... INTO specified STRICT, and the query didn't find
		 * exactly one row, throw an error.  If STRICT was not specified, then
		 * allow the query to find any number of rows.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>strict</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>errdetail</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>print_strict_params</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>errdetail</name> <operator>=</operator> <call><name>format_expr_params</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>errdetail</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NO_DATA_FOUND</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"query returned no rows"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <ternary><condition><expr><name>errdetail</name></expr> ?</condition><then> <expr><call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"parameters: %s"</literal></expr></argument>, <argument><expr><name>errdetail</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* set the target to NULL(s) */</comment>
			<expr_stmt><expr><call><name>exec_move_row</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>tuptab</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>strict</name></name> <operator>||</operator> <name><name>stmt</name><operator>-&gt;</operator><name>mod_stmt</name></name> <operator>||</operator> <name>too_many_rows_level</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>errdetail</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>errlevel</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>print_strict_params</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>errdetail</name> <operator>=</operator> <call><name>format_expr_params</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>errdetail</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><name>errlevel</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>strict</name></name> <operator>||</operator> <name><name>stmt</name><operator>-&gt;</operator><name>mod_stmt</name></name><operator>)</operator></expr> ?</condition><then> <expr><name>ERROR</name></expr> </then><else>: <expr><name>too_many_rows_level</name></expr></else></ternary></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>errlevel</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_ROWS</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"query returned more than one row"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <ternary><condition><expr><name>errdetail</name></expr> ?</condition><then> <expr><call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"parameters: %s"</literal></expr></argument>, <argument><expr><name>errdetail</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Make sure the query returns a single row, or use LIMIT 1."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Put the first result row into the target */</comment>
			<expr_stmt><expr><call><name>exec_move_row</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name><name>tuptab</name><operator>-&gt;</operator><name>vals</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>tuptab</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Clean up */</comment>
		<expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SPI_freetuptable</name><argument_list>(<argument><expr><name>SPI_tuptable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* If the statement returned a tuple table, complain */</comment>
		<if_stmt><if>if <condition>(<expr><name>SPI_tuptable</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"query has no destination for result data"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <ternary><condition><expr><operator>(</operator><name>rc</name> <operator>==</operator> <name>SPI_OK_SELECT</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"If you want to discard the results of a SELECT, use PERFORM instead."</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_stmt_dynexecute			Execute a dynamic SQL query
 *					(possibly with INTO).
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_dynexecute</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
					 <parameter><decl><type><name>PLpgSQL_stmt_dynexecute</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>restype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>restypmod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>querystr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>exec_res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PreparedParamsData</name> <modifier>*</modifier></type><name>ppd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>stmt_mcontext</name> <init>= <expr><call><name>get_stmt_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * First we evaluate the string expression after the EXECUTE keyword. Its
	 * result is the querystring we have to execute.
	 */</comment>
	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>exec_eval_expr</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>restype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>restypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"query string argument of EXECUTE is null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Get the C-String representation */</comment>
	<expr_stmt><expr><name>querystr</name> <operator>=</operator> <call><name>convert_value_to_string</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>restype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* copy it into the stmt_mcontext before we clean up */</comment>
	<expr_stmt><expr><name>querystr</name> <operator>=</operator> <call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>, <argument><expr><name>querystr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Execute the query without preparing a saved plan.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>params</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ppd</name> <operator>=</operator> <call><name>exec_eval_using_params</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>params</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>exec_res</name> <operator>=</operator> <call><name>SPI_execute_with_args</name><argument_list>(<argument><expr><name>querystr</name></expr></argument>,
										 <argument><expr><name><name>ppd</name><operator>-&gt;</operator><name>nargs</name></name></expr></argument>, <argument><expr><name><name>ppd</name><operator>-&gt;</operator><name>types</name></name></expr></argument>,
										 <argument><expr><name><name>ppd</name><operator>-&gt;</operator><name>values</name></name></expr></argument>, <argument><expr><name><name>ppd</name><operator>-&gt;</operator><name>nulls</name></name></expr></argument>,
										 <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>readonly_func</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>exec_res</name> <operator>=</operator> <call><name>SPI_execute</name><argument_list>(<argument><expr><name>querystr</name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>readonly_func</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<switch>switch <condition>(<expr><name>exec_res</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>SPI_OK_SELECT</name></expr>:</case>
		<case>case <expr><name>SPI_OK_INSERT</name></expr>:</case>
		<case>case <expr><name>SPI_OK_UPDATE</name></expr>:</case>
		<case>case <expr><name>SPI_OK_DELETE</name></expr>:</case>
		<case>case <expr><name>SPI_OK_INSERT_RETURNING</name></expr>:</case>
		<case>case <expr><name>SPI_OK_UPDATE_RETURNING</name></expr>:</case>
		<case>case <expr><name>SPI_OK_DELETE_RETURNING</name></expr>:</case>
		<case>case <expr><name>SPI_OK_UTILITY</name></expr>:</case>
		<case>case <expr><name>SPI_OK_REWRITTEN</name></expr>:</case>
		<case>case <expr><name>SPI_OK_GRAPHWRITE</name></expr>:</case>
			<break>break;</break>

		<case>case <expr><literal type="number">0</literal></expr>:</case>

			<comment type="block">/*
			 * Also allow a zero return, which implies the querystring
			 * contained no commands.
			 */</comment>
			<break>break;</break>

		<case>case <expr><name>SPI_OK_SELINTO</name></expr>:</case>

			<comment type="block">/*
			 * We want to disallow SELECT INTO for now, because its behavior
			 * is not consistent with SELECT INTO in a normal plpgsql context.
			 * (We need to reimplement EXECUTE to parse the string as a
			 * plpgsql command, not just feed it to SPI_execute.)  This is not
			 * a functional limitation because CREATE TABLE AS is allowed.
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"EXECUTE of SELECT ... INTO is not implemented"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You might want to use EXECUTE ... INTO or EXECUTE CREATE TABLE ... AS instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/* Some SPI errors deserve specific error messages */</comment>
		<case>case <expr><name>SPI_ERROR_COPY</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot COPY to/from client in PL/pgSQL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>SPI_ERROR_TRANSACTION</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"EXECUTE of transaction commands is not implemented"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_execute failed executing query \"%s\": %s"</literal></expr></argument>,
				 <argument><expr><name>querystr</name></expr></argument>, <argument><expr><call><name>SPI_result_code_string</name><argument_list>(<argument><expr><name>exec_res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Save result info for GET DIAGNOSTICS */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_processed</name></name> <operator>=</operator> <name>SPI_processed</name></expr>;</expr_stmt>

	<comment type="block">/* Process INTO if present */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>into</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SPITupleTable</name> <modifier>*</modifier></type><name>tuptab</name> <init>= <expr><name>SPI_tuptable</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>n</name> <init>= <expr><name>SPI_processed</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PLpgSQL_variable</name> <modifier>*</modifier></type><name>target</name></decl>;</decl_stmt>

		<comment type="block">/* If the statement did not return a tuple table, complain */</comment>
		<if_stmt><if>if <condition>(<expr><name>tuptab</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"INTO used with a command that cannot return data"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Fetch target's datum entry */</comment>
		<expr_stmt><expr><name>target</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_variable</name> <operator>*</operator><operator>)</operator> <name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>stmt</name><operator>-&gt;</operator><name>target</name><operator>-&gt;</operator><name>dno</name></name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If SELECT ... INTO specified STRICT, and the query didn't find
		 * exactly one row, throw an error.  If STRICT was not specified, then
		 * allow the query to find any number of rows.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>strict</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>errdetail</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>print_strict_params</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>errdetail</name> <operator>=</operator> <call><name>format_preparedparamsdata</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>ppd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>errdetail</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NO_DATA_FOUND</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"query returned no rows"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <ternary><condition><expr><name>errdetail</name></expr> ?</condition><then> <expr><call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"parameters: %s"</literal></expr></argument>, <argument><expr><name>errdetail</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* set the target to NULL(s) */</comment>
			<expr_stmt><expr><call><name>exec_move_row</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>tuptab</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>strict</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>errdetail</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>print_strict_params</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>errdetail</name> <operator>=</operator> <call><name>format_preparedparamsdata</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>ppd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>errdetail</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_ROWS</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"query returned more than one row"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <ternary><condition><expr><name>errdetail</name></expr> ?</condition><then> <expr><call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"parameters: %s"</literal></expr></argument>, <argument><expr><name>errdetail</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Put the first result row into the target */</comment>
			<expr_stmt><expr><call><name>exec_move_row</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name><name>tuptab</name><operator>-&gt;</operator><name>vals</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>tuptab</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<comment type="block">/* clean up after exec_move_row() */</comment>
		<expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * It might be a good idea to raise an error if the query returned
		 * tuples that are being ignored, but historically we have not done
		 * that.
		 */</comment>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Release any result from SPI_execute, as well as transient data */</comment>
	<expr_stmt><expr><call><name>SPI_freetuptable</name><argument_list>(<argument><expr><name>SPI_tuptable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_stmt_dynfors			Execute a dynamic query, assign each
 *					tuple to a record or row and
 *					execute a group of statements
 *					for it.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_dynfors</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_dynfors</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Portal</name></type>		<name>portal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>exec_dynquery_with_params</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>params</name></name></expr></argument>,
									   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>CURSOR_OPT_NO_SCROLL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Execute the loop
	 */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_for_query</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_stmt_forq</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>, <argument><expr><name>portal</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Close the implicit cursor
	 */</comment>
	<expr_stmt><expr><call><name>SPI_cursor_close</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_stmt_open			Execute an OPEN cursor statement
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_open</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_open</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>curvar</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>stmt_mcontext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>curname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Portal</name></type>		<name>portal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramLI</name></decl>;</decl_stmt>

	<comment type="block">/* ----------
	 * Get the cursor variable and if it has an assigned name, check
	 * that it's not in use currently.
	 * ----------
	 */</comment>
	<expr_stmt><expr><name>curvar</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>stmt</name><operator>-&gt;</operator><name>curvar</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>curvar</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

		<comment type="block">/* We only need stmt_mcontext to hold the cursor name string */</comment>
		<expr_stmt><expr><name>stmt_mcontext</name> <operator>=</operator> <call><name>get_stmt_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>curname</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name><name>curvar</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>SPI_cursor_find</name><argument_list>(<argument><expr><name>curname</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_CURSOR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cursor \"%s\" already in use"</literal></expr></argument>, <argument><expr><name>curname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* ----------
	 * Process the OPEN according to it's type.
	 * ----------
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* ----------
		 * This is an OPEN refcursor FOR SELECT ...
		 *
		 * We just make sure the query is planned. The real work is
		 * done downstairs.
		 * ----------
		 */</comment>
		<expr_stmt><expr><name>query</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>plan</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exec_prepare_plan</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>cursor_options</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>dynquery</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* ----------
		 * This is an OPEN refcursor FOR EXECUTE ...
		 * ----------
		 */</comment>
		<expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>exec_dynquery_with_params</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
										   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>dynquery</name></name></expr></argument>,
										   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>params</name></name></expr></argument>,
										   <argument><expr><name>curname</name></expr></argument>,
										   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>cursor_options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If cursor variable was NULL, store the generated portal name in it.
		 * Note: exec_dynquery_with_params already reset the stmt_mcontext, so
		 * curname is a dangling pointer here; but testing it for nullness is
		 * OK.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>curname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>assign_text_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>curvar</name></expr></argument>, <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* ----------
		 * This is an OPEN cursor
		 *
		 * Note: parser should already have checked that statement supplies
		 * args iff cursor needs them, but we check again to be safe.
		 * ----------
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>argquery</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* ----------
			 * OPEN CURSOR with args.  We fake a SELECT ... INTO ...
			 * statement to evaluate the args and put 'em into the
			 * internal row.
			 * ----------
			 */</comment>
			<decl_stmt><decl><type><name>PLpgSQL_stmt_execsql</name></type> <name>set_args</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>curvar</name><operator>-&gt;</operator><name>cursor_explicit_argrow</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"arguments given for cursor without arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>set_args</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>set_args</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>set_args</name><operator>.</operator><name>cmd_type</name></name> <operator>=</operator> <name>PLPGSQL_STMT_EXECSQL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>set_args</name><operator>.</operator><name>lineno</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>lineno</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>set_args</name><operator>.</operator><name>sqlstmt</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>argquery</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>set_args</name><operator>.</operator><name>into</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<comment type="block">/* XXX historically this has not been STRICT */</comment>
			<expr_stmt><expr><name><name>set_args</name><operator>.</operator><name>target</name></name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_variable</name> <operator>*</operator><operator>)</operator>
				<operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>curvar</name><operator>-&gt;</operator><name>cursor_explicit_argrow</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>exec_stmt_execsql</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>set_args</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PLPGSQL_RC_OK</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"open cursor failed during argument processing"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>curvar</name><operator>-&gt;</operator><name>cursor_explicit_argrow</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"arguments required for cursor"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>query</name> <operator>=</operator> <name><name>curvar</name><operator>-&gt;</operator><name>cursor_explicit_expr</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>plan</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exec_prepare_plan</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name><name>curvar</name><operator>-&gt;</operator><name>cursor_options</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Set up ParamListInfo for this query
	 */</comment>
	<expr_stmt><expr><name>paramLI</name> <operator>=</operator> <call><name>setup_param_list</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Open the cursor (the paramlist will get copied into the portal)
	 */</comment>
	<expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>SPI_cursor_open_with_paramlist</name><argument_list>(<argument><expr><name>curname</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>,
											<argument><expr><name>paramLI</name></expr></argument>,
											<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>readonly_func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>portal</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not open cursor: %s"</literal></expr></argument>,
			 <argument><expr><call><name>SPI_result_code_string</name><argument_list>(<argument><expr><name>SPI_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If cursor variable was NULL, store the generated portal name in it
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>curname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>assign_text_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>curvar</name></expr></argument>, <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* If we had any transient data, clean it up */</comment>
	<expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>stmt_mcontext</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_stmt_fetch			Fetch from a cursor into a target, or just
 *							move the current position of the cursor
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_fetch</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_fetch</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>curvar</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>how_many</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>how_many</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SPITupleTable</name> <modifier>*</modifier></type><name>tuptab</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Portal</name></type>		<name>portal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>curname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/* ----------
	 * Get the portal of the cursor by name
	 * ----------
	 */</comment>
	<expr_stmt><expr><name>curvar</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>stmt</name><operator>-&gt;</operator><name>curvar</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>curvar</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cursor variable \"%s\" is null"</literal></expr></argument>, <argument><expr><name><name>curvar</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Use eval_mcontext for short-lived string */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>curname</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name><name>curvar</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>SPI_cursor_find</name><argument_list>(<argument><expr><name>curname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>portal</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_CURSOR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cursor \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>curname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Calculate position for FETCH_RELATIVE or FETCH_ABSOLUTE */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>expr</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

		<comment type="block">/* XXX should be doing this in LONG not INT width */</comment>
		<expr_stmt><expr><name>how_many</name> <operator>=</operator> <call><name>exec_eval_integer</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relative or absolute cursor position is null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>is_move</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PLpgSQL_variable</name> <modifier>*</modifier></type><name>target</name></decl>;</decl_stmt>

		<comment type="block">/* ----------
		 * Fetch 1 tuple from the cursor
		 * ----------
		 */</comment>
		<expr_stmt><expr><call><name>SPI_scroll_cursor_fetch</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>direction</name></name></expr></argument>, <argument><expr><name>how_many</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tuptab</name> <operator>=</operator> <name>SPI_tuptable</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <name>SPI_processed</name></expr>;</expr_stmt>

		<comment type="block">/* ----------
		 * Set the target appropriately.
		 * ----------
		 */</comment>
		<expr_stmt><expr><name>target</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_variable</name> <operator>*</operator><operator>)</operator> <name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>stmt</name><operator>-&gt;</operator><name>target</name><operator>-&gt;</operator><name>dno</name></name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exec_move_row</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>tuptab</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exec_move_row</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name><name>tuptab</name><operator>-&gt;</operator><name>vals</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>tuptab</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SPI_freetuptable</name><argument_list>(<argument><expr><name>tuptab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Move the cursor */</comment>
		<expr_stmt><expr><call><name>SPI_scroll_cursor_move</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>direction</name></name></expr></argument>, <argument><expr><name>how_many</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <name>SPI_processed</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Set the ROW_COUNT and the global FOUND variable appropriately. */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_processed</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>exec_set_found</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>n</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * exec_stmt_close			Close a cursor
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_close</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_close</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>curvar</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Portal</name></type>		<name>portal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>curname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/* ----------
	 * Get the portal of the cursor by name
	 * ----------
	 */</comment>
	<expr_stmt><expr><name>curvar</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>stmt</name><operator>-&gt;</operator><name>curvar</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>curvar</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cursor variable \"%s\" is null"</literal></expr></argument>, <argument><expr><name><name>curvar</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Use eval_mcontext for short-lived string */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>curname</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name><name>curvar</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>SPI_cursor_find</name><argument_list>(<argument><expr><name>curname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>portal</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_CURSOR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cursor \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>curname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* ----------
	 * And close it.
	 * ----------
	 */</comment>
	<expr_stmt><expr><call><name>SPI_cursor_close</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * exec_stmt_commit
 *
 * Commit the transaction.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_commit</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_commit</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>chain</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SPI_commit_and_chain</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SPI_commit</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * We need to build new simple-expression infrastructure, since the old
	 * data structures are gone.
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>simple_eval_estate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>simple_eval_resowner</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>plpgsql_create_econtext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * exec_stmt_rollback
 *
 * Abort the transaction.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_rollback</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_rollback</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>chain</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SPI_rollback_and_chain</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SPI_rollback</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * We need to build new simple-expression infrastructure, since the old
	 * data structures are gone.
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>simple_eval_estate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>simple_eval_resowner</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>plpgsql_create_econtext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * exec_stmt_set
 *
 * Execute SET/RESET statement.
 *
 * We just parse and execute the statement normally, but we have to do it
 * without setting a snapshot, for things like SET TRANSACTION.
 * XXX spi.c now handles this correctly, so we no longer need a special case.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_stmt_set</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_set</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>plan</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>exec_prepare_plan</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SPI_execute_plan</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>readonly_func</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>SPI_OK_UTILITY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_execute_plan failed executing query \"%s\": %s"</literal></expr></argument>,
			 <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>query</name></name></expr></argument>, <argument><expr><call><name>SPI_result_code_string</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>PLPGSQL_RC_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * exec_assign_expr			Put an expression's result into a variable.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_assign_expr</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
				 <parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>valtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>valtypmod</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If first time through, create a plan for this expression, and then see
	 * if we can pass the target variable as a read-write parameter to the
	 * expression.  (This is a bit messy, but it seems cleaner than modifying
	 * the API of exec_eval_expr for the purpose.)
	 *
	 * NOTE: this coding ignores the advice given in exec_prepare_plan's
	 * comments, that one should not do additional setup contingent on
	 * expr-&gt;plan being NULL.  This means that if we get an error while trying
	 * to check for the expression being simple, we won't check for a
	 * read-write parameter either, so that neither optimization will be
	 * applied in future executions.  Nothing will fail though, so we live
	 * with that bit of messiness too.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>plan</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>exec_prepare_plan</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_VAR</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exec_check_rw_parameter</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>dno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>exec_eval_expr</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>valtype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>valtypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>exec_assign_value</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>valtype</name></expr></argument>, <argument><expr><name>valtypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_assign_c_string		Put a C string into a text variable.
 *
 * We take a NULL pointer as signifying empty string, not SQL null.
 *
 * As with the underlying exec_assign_value, caller is expected to do
 * exec_eval_cleanup later.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_assign_c_string</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
					 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/* Use eval_mcontext for short-lived text value */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>str</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>cstring_to_text</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>cstring_to_text</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>exec_assign_value</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>,
					  <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_assign_value			Put a value into a target datum
 *
 * Note: in some code paths, this will leak memory in the eval_mcontext;
 * we assume that will be cleaned up later by exec_eval_cleanup.  We cannot
 * call exec_eval_cleanup here for fear of destroying the input Datum value.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_assign_value</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
				  <parameter><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
				  <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isNull</name></decl></parameter>,
				  <parameter><decl><type><name>Oid</name></type> <name>valtype</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>valtypmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>dtype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PLPGSQL_DTYPE_VAR</name></expr>:</case>
		<case>case <expr><name>PLPGSQL_DTYPE_PROMISE</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * Target is a variable
				 */</comment>
				<decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name>target</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Datum</name></type>		<name>newvalue</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>newvalue</name> <operator>=</operator> <call><name>exec_cast_value</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
										   <argument><expr><name>value</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>,
										   <argument><expr><name>valtype</name></expr></argument>,
										   <argument><expr><name>valtypmod</name></expr></argument>,
										   <argument><expr><name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typoid</name></name></expr></argument>,
										   <argument><expr><name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>isNull</name> <operator>&amp;&amp;</operator> <name><name>var</name><operator>-&gt;</operator><name>notnull</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"null value cannot be assigned to variable \"%s\" declared NOT NULL"</literal></expr></argument>,
									<argument><expr><name><name>var</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * If type is by-reference, copy the new value (which is
				 * probably in the eval_mcontext) into the procedure's main
				 * memory context.  But if it's a read/write reference to an
				 * expanded object, no physical copy needs to happen; at most
				 * we need to reparent the object's memory context.
				 *
				 * If it's an array, we force the value to be stored in R/W
				 * expanded form.  This wins if the function later does, say,
				 * a lot of array subscripting operations on the variable, and
				 * otherwise might lose.  We might need to use a different
				 * heuristic, but it's too soon to tell.  Also, are there
				 * cases where it'd be useful to force non-array values into
				 * expanded form?
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typbyval</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isNull</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typisarray</name></name> <operator>&amp;&amp;</operator>
						<operator>!</operator><call><name>VARATT_IS_EXTERNAL_EXPANDED_RW</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>newvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* array and not already R/W, so apply expand_array */</comment>
						<expr_stmt><expr><name>newvalue</name> <operator>=</operator> <call><name>expand_array</name><argument_list>(<argument><expr><name>newvalue</name></expr></argument>,
												<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>datum_context</name></name></expr></argument>,
												<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* else transfer value if R/W, else just datumCopy */</comment>
						<expr_stmt><expr><name>newvalue</name> <operator>=</operator> <call><name>datumTransfer</name><argument_list>(<argument><expr><name>newvalue</name></expr></argument>,
												 <argument><expr><name>false</name></expr></argument>,
												 <argument><expr><name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Now free the old value, if any, and assign the new one. But
				 * skip the assignment if old and new values are the same.
				 * Note that for expanded objects, this test is necessary and
				 * cannot reliably be made any earlier; we have to be looking
				 * at the object's standard R/W pointer to be sure pointer
				 * equality is meaningful.
				 *
				 * Also, if it's a promise variable, we should disarm the
				 * promise in any case --- otherwise, assigning null to an
				 * armed promise variable would fail to disarm the promise.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name> <operator>!=</operator> <name>newvalue</name> <operator>||</operator> <name><name>var</name><operator>-&gt;</operator><name>isnull</name></name> <operator>||</operator> <name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>assign_simple_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>newvalue</name></expr></argument>, <argument><expr><name>isNull</name></expr></argument>,
									  <argument><expr><operator>(</operator><operator>!</operator><name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typbyval</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isNull</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>promise</name></name> <operator>=</operator> <name>PLPGSQL_PROMISE_NONE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>PLPGSQL_DTYPE_ROW</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * Target is a row variable
				 */</comment>
				<decl_stmt><decl><type><name>PLpgSQL_row</name> <modifier>*</modifier></type><name>row</name> <init>= <expr><operator>(</operator><name>PLpgSQL_row</name> <operator>*</operator><operator>)</operator> <name>target</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* If source is null, just assign nulls to the row */</comment>
					<expr_stmt><expr><call><name>exec_move_row</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_variable</name> <operator>*</operator><operator>)</operator> <name>row</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* Source must be of RECORD or composite type */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>type_is_rowtype</name><argument_list>(<argument><expr><name>valtype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot assign non-composite value to a row variable"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>exec_move_row_from_datum</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_variable</name> <operator>*</operator><operator>)</operator> <name>row</name></expr></argument>,
											 <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>PLPGSQL_DTYPE_REC</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * Target is a record variable
				 */</comment>
				<decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name> <init>= <expr><operator>(</operator><name>PLpgSQL_rec</name> <operator>*</operator><operator>)</operator> <name>target</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>notnull</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"null value cannot be assigned to variable \"%s\" declared NOT NULL"</literal></expr></argument>,
										<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/* Set variable to a simple NULL */</comment>
					<expr_stmt><expr><call><name>exec_move_row</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_variable</name> <operator>*</operator><operator>)</operator> <name>rec</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* Source must be of RECORD or composite type */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>type_is_rowtype</name><argument_list>(<argument><expr><name>valtype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot assign non-composite value to a record variable"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>exec_move_row_from_datum</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_variable</name> <operator>*</operator><operator>)</operator> <name>rec</name></expr></argument>,
											 <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>PLPGSQL_DTYPE_RECFIELD</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * Target is a field of a record
				 */</comment>
				<decl_stmt><decl><type><name>PLpgSQL_recfield</name> <modifier>*</modifier></type><name>recfield</name> <init>= <expr><operator>(</operator><name>PLpgSQL_recfield</name> <operator>*</operator><operator>)</operator> <name>target</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>erh</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>rec</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_rec</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>recfield</name><operator>-&gt;</operator><name>recparentno</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>erh</name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>erh</name></name></expr>;</expr_stmt>

				<comment type="block">/*
				 * If record variable is NULL, instantiate it if it has a
				 * named composite type, else complain.  (This won't change
				 * the logical state of the record, but if we successfully
				 * assign below, the unassigned fields will all become NULLs.)
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>erh</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>instantiate_empty_record_variable</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>erh</name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>erh</name></name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Look up the field's properties if we have not already, or
				 * if the tuple descriptor ID changed since last time.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>recfield</name><operator>-&gt;</operator><name>rectupledescid</name></name> <operator>!=</operator> <name><name>erh</name><operator>-&gt;</operator><name>er_tupdesc_id</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>expanded_record_lookup_field</name><argument_list>(<argument><expr><name>erh</name></expr></argument>,
													  <argument><expr><name><name>recfield</name><operator>-&gt;</operator><name>fieldname</name></name></expr></argument>,
													  <argument><expr><operator>&amp;</operator><name><name>recfield</name><operator>-&gt;</operator><name>finfo</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"record \"%s\" has no field \"%s\""</literal></expr></argument>,
										<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>, <argument><expr><name><name>recfield</name><operator>-&gt;</operator><name>fieldname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>recfield</name><operator>-&gt;</operator><name>rectupledescid</name></name> <operator>=</operator> <name><name>erh</name><operator>-&gt;</operator><name>er_tupdesc_id</name></name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* We don't support assignments to system columns. */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>recfield</name><operator>-&gt;</operator><name>finfo</name><operator>.</operator><name>fnumber</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot assign to system column \"%s\""</literal></expr></argument>,
									<argument><expr><name><name>recfield</name><operator>-&gt;</operator><name>fieldname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* Cast the new value to the right type, if needed. */</comment>
				<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>exec_cast_value</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
										<argument><expr><name>value</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>,
										<argument><expr><name>valtype</name></expr></argument>,
										<argument><expr><name>valtypmod</name></expr></argument>,
										<argument><expr><name><name>recfield</name><operator>-&gt;</operator><name>finfo</name><operator>.</operator><name>ftypeid</name></name></expr></argument>,
										<argument><expr><name><name>recfield</name><operator>-&gt;</operator><name>finfo</name><operator>.</operator><name>ftypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* And assign it. */</comment>
				<expr_stmt><expr><call><name>expanded_record_set_field</name><argument_list>(<argument><expr><name>erh</name></expr></argument>, <argument><expr><name><name>recfield</name><operator>-&gt;</operator><name>finfo</name><operator>.</operator><name>fnumber</name></name></expr></argument>,
										  <argument><expr><name>value</name></expr></argument>, <argument><expr><name>isNull</name></expr></argument>, <argument><expr><operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>atomic</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>PLPGSQL_DTYPE_ARRAYELEM</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * Target is an element of an array
				 */</comment>
				<decl_stmt><decl><type><name>PLpgSQL_arrayelem</name> <modifier>*</modifier></type><name>arrayelem</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>nsubscripts</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name><name>subscripts</name><index>[<expr><name>MAXDIM</name></expr>]</index></name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name><name>subscriptvals</name><index>[<expr><name>MAXDIM</name></expr>]</index></name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Datum</name></type>		<name>oldarraydatum</name></decl>,
							<decl><type ref="prev"/><name>newarraydatum</name></decl>,
							<decl><type ref="prev"/><name>coerced_value</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>oldarrayisnull</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>parenttypoid</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int32</name></type>		<name>parenttypmod</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>SPITupleTable</name> <modifier>*</modifier></type><name>save_eval_tuptable</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * We need to do subscript evaluation, which might require
				 * evaluating general expressions; and the caller might have
				 * done that too in order to prepare the input Datum.  We have
				 * to save and restore the caller's SPI_execute result, if
				 * any.
				 */</comment>
				<expr_stmt><expr><name>save_eval_tuptable</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>eval_tuptable</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_tuptable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * To handle constructs like x[1][2] := something, we have to
				 * be prepared to deal with a chain of arrayelem datums. Chase
				 * back to find the base array datum, and save the subscript
				 * expressions as we go.  (We are scanning right to left here,
				 * but want to evaluate the subscripts left-to-right to
				 * minimize surprises.)  Note that arrayelem is left pointing
				 * to the leftmost arrayelem datum, where we will cache the
				 * array element type data.
				 */</comment>
				<expr_stmt><expr><name>nsubscripts</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<do>do
				<block>{<block_content>
					<expr_stmt><expr><name>arrayelem</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_arrayelem</name> <operator>*</operator><operator>)</operator> <name>target</name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>nsubscripts</name> <operator>&gt;=</operator> <name>MAXDIM</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of array dimensions (%d) exceeds the maximum allowed (%d)"</literal></expr></argument>,
										<argument><expr><name>nsubscripts</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>MAXDIM</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>subscripts</name><index>[<expr><name>nsubscripts</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>arrayelem</name><operator>-&gt;</operator><name>subscript</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>target</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>arrayelem</name><operator>-&gt;</operator><name>arrayparentno</name></name></expr>]</index></name></expr>;</expr_stmt>
				</block_content>}</block> while <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_ARRAYELEM</name></expr>)</condition>;</do>

				<comment type="block">/* Fetch current value of array datum */</comment>
				<expr_stmt><expr><call><name>exec_eval_datum</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>target</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>parenttypoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parenttypmod</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>oldarraydatum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oldarrayisnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Update cached type data if necessary */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>arrayelem</name><operator>-&gt;</operator><name>parenttypoid</name></name> <operator>!=</operator> <name>parenttypoid</name> <operator>||</operator>
					<name><name>arrayelem</name><operator>-&gt;</operator><name>parenttypmod</name></name> <operator>!=</operator> <name>parenttypmod</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>arraytypoid</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int32</name></type>		<name>arraytypmod</name> <init>= <expr><name>parenttypmod</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int16</name></type>		<name>arraytyplen</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>elemtypoid</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int16</name></type>		<name>elemtyplen</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type>		<name>elemtypbyval</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>char</name></type>		<name>elemtypalign</name></decl>;</decl_stmt>

					<comment type="block">/* If target is domain over array, reduce to base type */</comment>
					<expr_stmt><expr><name>arraytypoid</name> <operator>=</operator> <call><name>getBaseTypeAndTypmod</name><argument_list>(<argument><expr><name>parenttypoid</name></expr></argument>,
													   <argument><expr><operator>&amp;</operator><name>arraytypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* ... and identify the element type */</comment>
					<expr_stmt><expr><name>elemtypoid</name> <operator>=</operator> <call><name>get_element_type</name><argument_list>(<argument><expr><name>arraytypoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>elemtypoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"subscripted object is not an array"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/* Collect needed data about the types */</comment>
					<expr_stmt><expr><name>arraytyplen</name> <operator>=</operator> <call><name>get_typlen</name><argument_list>(<argument><expr><name>arraytypoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><name>elemtypoid</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>elemtyplen</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>elemtypbyval</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>elemtypalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* Now safe to update the cached data */</comment>
					<expr_stmt><expr><name><name>arrayelem</name><operator>-&gt;</operator><name>parenttypoid</name></name> <operator>=</operator> <name>parenttypoid</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>arrayelem</name><operator>-&gt;</operator><name>parenttypmod</name></name> <operator>=</operator> <name>parenttypmod</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>arrayelem</name><operator>-&gt;</operator><name>arraytypoid</name></name> <operator>=</operator> <name>arraytypoid</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>arrayelem</name><operator>-&gt;</operator><name>arraytypmod</name></name> <operator>=</operator> <name>arraytypmod</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>arrayelem</name><operator>-&gt;</operator><name>arraytyplen</name></name> <operator>=</operator> <name>arraytyplen</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>arrayelem</name><operator>-&gt;</operator><name>elemtypoid</name></name> <operator>=</operator> <name>elemtypoid</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>arrayelem</name><operator>-&gt;</operator><name>elemtyplen</name></name> <operator>=</operator> <name>elemtyplen</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>arrayelem</name><operator>-&gt;</operator><name>elemtypbyval</name></name> <operator>=</operator> <name>elemtypbyval</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>arrayelem</name><operator>-&gt;</operator><name>elemtypalign</name></name> <operator>=</operator> <name>elemtypalign</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Evaluate the subscripts, switch into left-to-right order.
				 * Like the expression built by ExecInitSubscriptingRef(),
				 * complain if any subscript is null.
				 */</comment>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nsubscripts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>bool</name></type>		<name>subisnull</name></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>subscriptvals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>
						<call><name>exec_eval_integer</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
										  <argument><expr><name><name>subscripts</name><index>[<expr><name>nsubscripts</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>i</name></expr>]</index></name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>subisnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>subisnull</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"array subscript in assignment must not be null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/*
					 * Clean up in case the subscript expression wasn't
					 * simple. We can't do exec_eval_cleanup, but we can do
					 * this much (which is safe because the integer subscript
					 * value is surely pass-by-value), and we must do it in
					 * case the next subscript expression isn't simple either.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>eval_tuptable</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>SPI_freetuptable</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_tuptable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_tuptable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				</block_content>}</block></for>

				<comment type="block">/* Now we can restore caller's SPI_execute result if any. */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_tuptable</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_tuptable</name></name> <operator>=</operator> <name>save_eval_tuptable</name></expr>;</expr_stmt>

				<comment type="block">/* Coerce source value to match array element type. */</comment>
				<expr_stmt><expr><name>coerced_value</name> <operator>=</operator> <call><name>exec_cast_value</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
												<argument><expr><name>value</name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>,
												<argument><expr><name>valtype</name></expr></argument>,
												<argument><expr><name>valtypmod</name></expr></argument>,
												<argument><expr><name><name>arrayelem</name><operator>-&gt;</operator><name>elemtypoid</name></name></expr></argument>,
												<argument><expr><name><name>arrayelem</name><operator>-&gt;</operator><name>arraytypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If the original array is null, cons up an empty array so
				 * that the assignment can proceed; we'll end with a
				 * one-element array containing just the assigned-to
				 * subscript.  This only works for varlena arrays, though; for
				 * fixed-length array types we skip the assignment.  We can't
				 * support assignment of a null entry into a fixed-length
				 * array, either, so that's a no-op too.  This is all ugly but
				 * corresponds to the current behavior of execExpr*.c.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>arrayelem</name><operator>-&gt;</operator><name>arraytyplen</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>	<comment type="block">/* fixed-length array? */</comment>
					<operator>(</operator><name>oldarrayisnull</name> <operator>||</operator> <name>isNull</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<return>return;</return></block_content></block></if></if_stmt>

				<comment type="block">/* empty array, if any, and newarraydatum are short-lived */</comment>
				<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>oldarrayisnull</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>oldarraydatum</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>construct_empty_array</name><argument_list>(<argument><expr><name><name>arrayelem</name><operator>-&gt;</operator><name>elemtypoid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Build the modified array value.
				 */</comment>
				<expr_stmt><expr><name>newarraydatum</name> <operator>=</operator> <call><name>array_set_element</name><argument_list>(<argument><expr><name>oldarraydatum</name></expr></argument>,
												  <argument><expr><name>nsubscripts</name></expr></argument>,
												  <argument><expr><name>subscriptvals</name></expr></argument>,
												  <argument><expr><name>coerced_value</name></expr></argument>,
												  <argument><expr><name>isNull</name></expr></argument>,
												  <argument><expr><name><name>arrayelem</name><operator>-&gt;</operator><name>arraytyplen</name></name></expr></argument>,
												  <argument><expr><name><name>arrayelem</name><operator>-&gt;</operator><name>elemtyplen</name></name></expr></argument>,
												  <argument><expr><name><name>arrayelem</name><operator>-&gt;</operator><name>elemtypbyval</name></name></expr></argument>,
												  <argument><expr><name><name>arrayelem</name><operator>-&gt;</operator><name>elemtypalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Assign the new array to the base variable.  It's never NULL
				 * at this point.  Note that if the target is a domain,
				 * coercing the base array type back up to the domain will
				 * happen within exec_assign_value.
				 */</comment>
				<expr_stmt><expr><call><name>exec_assign_value</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>target</name></expr></argument>,
								  <argument><expr><name>newarraydatum</name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>,
								  <argument><expr><name><name>arrayelem</name><operator>-&gt;</operator><name>arraytypoid</name></name></expr></argument>,
								  <argument><expr><name><name>arrayelem</name><operator>-&gt;</operator><name>arraytypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized dtype: %d"</literal></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>dtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * exec_eval_datum				Get current value of a PLpgSQL_datum
 *
 * The type oid, typmod, value in Datum format, and null flag are returned.
 *
 * At present this doesn't handle PLpgSQL_expr or PLpgSQL_arrayelem datums;
 * that's not needed because we never pass references to such datums to SPI.
 *
 * NOTE: the returned Datum points right at the stored value in the case of
 * pass-by-reference datatypes.  Generally callers should take care not to
 * modify the stored value.  Some callers intentionally manipulate variables
 * referenced by R/W expanded pointers, though; it is those callers'
 * responsibility that the results are semantically OK.
 *
 * In some cases we have to palloc a return value, and in such cases we put
 * it into the estate's eval_mcontext.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_eval_datum</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
				<parameter><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>datum</name></decl></parameter>,
				<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>typeid</name></decl></parameter>,
				<parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>typetypmod</name></decl></parameter>,
				<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>value</name></decl></parameter>,
				<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>datum</name><operator>-&gt;</operator><name>dtype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PLPGSQL_DTYPE_PROMISE</name></expr>:</case>
			<comment type="block">/* fulfill promise if needed, then handle like regular var */</comment>
			<expr_stmt><expr><call><name>plpgsql_fulfill_promise</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* FALL THRU */</comment>

		<case>case <expr><name>PLPGSQL_DTYPE_VAR</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name>datum</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><operator>*</operator><name>typeid</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typoid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>typetypmod</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>PLPGSQL_DTYPE_ROW</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PLpgSQL_row</name> <modifier>*</modifier></type><name>row</name> <init>= <expr><operator>(</operator><name>PLpgSQL_row</name> <operator>*</operator><operator>)</operator> <name>datum</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>

				<comment type="block">/* We get here if there are multiple OUT parameters */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>row</name><operator>-&gt;</operator><name>rowtupdesc</name></name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* should not happen */</comment>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"row variable has no tupdesc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<comment type="block">/* Make sure we have a valid type/typmod setting */</comment>
				<expr_stmt><expr><call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name><name>row</name><operator>-&gt;</operator><name>rowtupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>make_tuple_from_row</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><name><name>row</name><operator>-&gt;</operator><name>rowtupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>tup</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* should not happen */</comment>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"row not compatible with its own tupdesc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><operator>*</operator><name>typeid</name> <operator>=</operator> <name><name>row</name><operator>-&gt;</operator><name>rowtupdesc</name><operator>-&gt;</operator><name>tdtypeid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>typetypmod</name> <operator>=</operator> <name><name>row</name><operator>-&gt;</operator><name>rowtupdesc</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>PLPGSQL_DTYPE_REC</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name> <init>= <expr><operator>(</operator><name>PLpgSQL_rec</name> <operator>*</operator><operator>)</operator> <name>datum</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>erh</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Treat uninstantiated record as a simple NULL */</comment>
					<expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<comment type="block">/* Report variable's declared type */</comment>
					<expr_stmt><expr><operator>*</operator><name>typeid</name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>rectypeid</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>typetypmod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>ExpandedRecordIsEmpty</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>erh</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* Empty record is also a NULL */</comment>
						<expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
						<expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <call><name>ExpandedRecordGetDatum</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>erh</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>rectypeid</name></name> <operator>!=</operator> <name>RECORDOID</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* Report variable's declared type, if not RECORD */</comment>
						<expr_stmt><expr><operator>*</operator><name>typeid</name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>rectypeid</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><operator>*</operator><name>typetypmod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* Report record's actual type if declared RECORD */</comment>
						<expr_stmt><expr><operator>*</operator><name>typeid</name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>erh</name><operator>-&gt;</operator><name>er_typeid</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><operator>*</operator><name>typetypmod</name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>erh</name><operator>-&gt;</operator><name>er_typmod</name></name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>PLPGSQL_DTYPE_RECFIELD</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PLpgSQL_recfield</name> <modifier>*</modifier></type><name>recfield</name> <init>= <expr><operator>(</operator><name>PLpgSQL_recfield</name> <operator>*</operator><operator>)</operator> <name>datum</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>erh</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>rec</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_rec</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>recfield</name><operator>-&gt;</operator><name>recparentno</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>erh</name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>erh</name></name></expr>;</expr_stmt>

				<comment type="block">/*
				 * If record variable is NULL, instantiate it if it has a
				 * named composite type, else complain.  (This won't change
				 * the logical state of the record: it's still NULL.)
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>erh</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>instantiate_empty_record_variable</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>erh</name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>erh</name></name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Look up the field's properties if we have not already, or
				 * if the tuple descriptor ID changed since last time.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>recfield</name><operator>-&gt;</operator><name>rectupledescid</name></name> <operator>!=</operator> <name><name>erh</name><operator>-&gt;</operator><name>er_tupdesc_id</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>expanded_record_lookup_field</name><argument_list>(<argument><expr><name>erh</name></expr></argument>,
													  <argument><expr><name><name>recfield</name><operator>-&gt;</operator><name>fieldname</name></name></expr></argument>,
													  <argument><expr><operator>&amp;</operator><name><name>recfield</name><operator>-&gt;</operator><name>finfo</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"record \"%s\" has no field \"%s\""</literal></expr></argument>,
										<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>, <argument><expr><name><name>recfield</name><operator>-&gt;</operator><name>fieldname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>recfield</name><operator>-&gt;</operator><name>rectupledescid</name></name> <operator>=</operator> <name><name>erh</name><operator>-&gt;</operator><name>er_tupdesc_id</name></name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Report type data. */</comment>
				<expr_stmt><expr><operator>*</operator><name>typeid</name> <operator>=</operator> <name><name>recfield</name><operator>-&gt;</operator><name>finfo</name><operator>.</operator><name>ftypeid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>typetypmod</name> <operator>=</operator> <name><name>recfield</name><operator>-&gt;</operator><name>finfo</name><operator>.</operator><name>ftypmod</name></name></expr>;</expr_stmt>

				<comment type="block">/* And fetch the field value. */</comment>
				<expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <call><name>expanded_record_get_field</name><argument_list>(<argument><expr><name>erh</name></expr></argument>,
												   <argument><expr><name><name>recfield</name><operator>-&gt;</operator><name>finfo</name><operator>.</operator><name>fnumber</name></name></expr></argument>,
												   <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized dtype: %d"</literal></expr></argument>, <argument><expr><name><name>datum</name><operator>-&gt;</operator><name>dtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * plpgsql_exec_get_datum_type				Get datatype of a PLpgSQL_datum
 *
 * This is the same logic as in exec_eval_datum, but we skip acquiring
 * the actual value of the variable.  Also, needn't support DTYPE_ROW.
 */</comment>
<function><type><name>Oid</name></type>
<name>plpgsql_exec_get_datum_type</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
							<parameter><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>datum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typeid</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>datum</name><operator>-&gt;</operator><name>dtype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PLPGSQL_DTYPE_VAR</name></expr>:</case>
		<case>case <expr><name>PLPGSQL_DTYPE_PROMISE</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name>datum</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>typeid</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typoid</name></name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>PLPGSQL_DTYPE_REC</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name> <init>= <expr><operator>(</operator><name>PLpgSQL_rec</name> <operator>*</operator><operator>)</operator> <name>datum</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>erh</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>rec</name><operator>-&gt;</operator><name>rectypeid</name></name> <operator>!=</operator> <name>RECORDOID</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Report variable's declared type */</comment>
					<expr_stmt><expr><name>typeid</name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>rectypeid</name></name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* Report record's actual type if declared RECORD */</comment>
					<expr_stmt><expr><name>typeid</name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>erh</name><operator>-&gt;</operator><name>er_typeid</name></name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>PLPGSQL_DTYPE_RECFIELD</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PLpgSQL_recfield</name> <modifier>*</modifier></type><name>recfield</name> <init>= <expr><operator>(</operator><name>PLpgSQL_recfield</name> <operator>*</operator><operator>)</operator> <name>datum</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>rec</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_rec</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>recfield</name><operator>-&gt;</operator><name>recparentno</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

				<comment type="block">/*
				 * If record variable is NULL, instantiate it if it has a
				 * named composite type, else complain.  (This won't change
				 * the logical state of the record: it's still NULL.)
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>erh</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>instantiate_empty_record_variable</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Look up the field's properties if we have not already, or
				 * if the tuple descriptor ID changed since last time.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>recfield</name><operator>-&gt;</operator><name>rectupledescid</name></name> <operator>!=</operator> <name><name>rec</name><operator>-&gt;</operator><name>erh</name><operator>-&gt;</operator><name>er_tupdesc_id</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>expanded_record_lookup_field</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>erh</name></name></expr></argument>,
													  <argument><expr><name><name>recfield</name><operator>-&gt;</operator><name>fieldname</name></name></expr></argument>,
													  <argument><expr><operator>&amp;</operator><name><name>recfield</name><operator>-&gt;</operator><name>finfo</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"record \"%s\" has no field \"%s\""</literal></expr></argument>,
										<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>, <argument><expr><name><name>recfield</name><operator>-&gt;</operator><name>fieldname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>recfield</name><operator>-&gt;</operator><name>rectupledescid</name></name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>erh</name><operator>-&gt;</operator><name>er_tupdesc_id</name></name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>typeid</name> <operator>=</operator> <name><name>recfield</name><operator>-&gt;</operator><name>finfo</name><operator>.</operator><name>ftypeid</name></name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized dtype: %d"</literal></expr></argument>, <argument><expr><name><name>datum</name><operator>-&gt;</operator><name>dtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>typeid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>typeid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * plpgsql_exec_get_datum_type_info			Get datatype etc of a PLpgSQL_datum
 *
 * An extended version of plpgsql_exec_get_datum_type, which also retrieves the
 * typmod and collation of the datum.  Note however that we don't report the
 * possibly-mutable typmod of RECORD values, but say -1 always.
 */</comment>
<function><type><name>void</name></type>
<name>plpgsql_exec_get_datum_type_info</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
								 <parameter><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>datum</name></decl></parameter>,
								 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>typeId</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>typMod</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>collation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>datum</name><operator>-&gt;</operator><name>dtype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PLPGSQL_DTYPE_VAR</name></expr>:</case>
		<case>case <expr><name>PLPGSQL_DTYPE_PROMISE</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name>datum</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><operator>*</operator><name>typeId</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typoid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>typMod</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>collation</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>collation</name></name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>PLPGSQL_DTYPE_REC</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name> <init>= <expr><operator>(</operator><name>PLpgSQL_rec</name> <operator>*</operator><operator>)</operator> <name>datum</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>erh</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>rec</name><operator>-&gt;</operator><name>rectypeid</name></name> <operator>!=</operator> <name>RECORDOID</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Report variable's declared type */</comment>
					<expr_stmt><expr><operator>*</operator><name>typeId</name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>rectypeid</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>typMod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* Report record's actual type if declared RECORD */</comment>
					<expr_stmt><expr><operator>*</operator><name>typeId</name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>erh</name><operator>-&gt;</operator><name>er_typeid</name></name></expr>;</expr_stmt>
					<comment type="block">/* do NOT return the mutable typmod of a RECORD variable */</comment>
					<expr_stmt><expr><operator>*</operator><name>typMod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<comment type="block">/* composite types are never collatable */</comment>
				<expr_stmt><expr><operator>*</operator><name>collation</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>PLPGSQL_DTYPE_RECFIELD</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PLpgSQL_recfield</name> <modifier>*</modifier></type><name>recfield</name> <init>= <expr><operator>(</operator><name>PLpgSQL_recfield</name> <operator>*</operator><operator>)</operator> <name>datum</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>rec</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_rec</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>recfield</name><operator>-&gt;</operator><name>recparentno</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

				<comment type="block">/*
				 * If record variable is NULL, instantiate it if it has a
				 * named composite type, else complain.  (This won't change
				 * the logical state of the record: it's still NULL.)
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>erh</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>instantiate_empty_record_variable</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Look up the field's properties if we have not already, or
				 * if the tuple descriptor ID changed since last time.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>recfield</name><operator>-&gt;</operator><name>rectupledescid</name></name> <operator>!=</operator> <name><name>rec</name><operator>-&gt;</operator><name>erh</name><operator>-&gt;</operator><name>er_tupdesc_id</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>expanded_record_lookup_field</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>erh</name></name></expr></argument>,
													  <argument><expr><name><name>recfield</name><operator>-&gt;</operator><name>fieldname</name></name></expr></argument>,
													  <argument><expr><operator>&amp;</operator><name><name>recfield</name><operator>-&gt;</operator><name>finfo</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"record \"%s\" has no field \"%s\""</literal></expr></argument>,
										<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>, <argument><expr><name><name>recfield</name><operator>-&gt;</operator><name>fieldname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>recfield</name><operator>-&gt;</operator><name>rectupledescid</name></name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>erh</name><operator>-&gt;</operator><name>er_tupdesc_id</name></name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><operator>*</operator><name>typeId</name> <operator>=</operator> <name><name>recfield</name><operator>-&gt;</operator><name>finfo</name><operator>.</operator><name>ftypeid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>typMod</name> <operator>=</operator> <name><name>recfield</name><operator>-&gt;</operator><name>finfo</name><operator>.</operator><name>ftypmod</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>collation</name> <operator>=</operator> <name><name>recfield</name><operator>-&gt;</operator><name>finfo</name><operator>.</operator><name>fcollation</name></name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized dtype: %d"</literal></expr></argument>, <argument><expr><name><name>datum</name><operator>-&gt;</operator><name>dtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>typeId</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
			<expr_stmt><expr><operator>*</operator><name>typMod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>collation</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* ----------
 * exec_eval_integer		Evaluate an expression, coerce result to int4
 *
 * Note we do not do exec_eval_cleanup here; the caller must do it at
 * some later point.  (We do this because the caller may be holding the
 * results of other, pass-by-reference, expression evaluations, such as
 * an array value to be subscripted.)
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_eval_integer</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
				  <parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>exprdatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>exprtypeid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>exprtypmod</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>exprdatum</name> <operator>=</operator> <call><name>exec_eval_expr</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>isNull</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exprtypeid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exprtypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>exprdatum</name> <operator>=</operator> <call><name>exec_cast_value</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>exprdatum</name></expr></argument>, <argument><expr><name>isNull</name></expr></argument>,
								<argument><expr><name>exprtypeid</name></expr></argument>, <argument><expr><name>exprtypmod</name></expr></argument>,
								<argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>exprdatum</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * exec_eval_boolean		Evaluate an expression, coerce result to bool
 *
 * Note we do not do exec_eval_cleanup here; the caller must do it at
 * some later point.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>exec_eval_boolean</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
				  <parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>exprdatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>exprtypeid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>exprtypmod</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>exprdatum</name> <operator>=</operator> <call><name>exec_eval_expr</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>isNull</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exprtypeid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exprtypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>exprdatum</name> <operator>=</operator> <call><name>exec_cast_value</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>exprdatum</name></expr></argument>, <argument><expr><name>isNull</name></expr></argument>,
								<argument><expr><name>exprtypeid</name></expr></argument>, <argument><expr><name>exprtypmod</name></expr></argument>,
								<argument><expr><name>BOOLOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>exprdatum</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * exec_eval_expr			Evaluate an expression and return
 *					the result Datum, along with data type/typmod.
 *
 * NOTE: caller must do exec_eval_cleanup when done with the Datum.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>exec_eval_expr</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
			   <parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
			   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>,
			   <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>rettype</name></decl></parameter>,
			   <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>rettypmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If first time through, create a plan for this expression.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>plan</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>exec_prepare_plan</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>CURSOR_OPT_PARALLEL_OK</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If this is a simple expression, bypass SPI and use the executor
	 * directly
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>exec_eval_simple_expr</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>isNull</name></expr></argument>, <argument><expr><name>rettype</name></expr></argument>, <argument><expr><name>rettypmod</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Else do it the hard way via exec_run_select
	 */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_run_select</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>SPI_OK_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"query \"%s\" did not return data"</literal></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check that the expression returns exactly one column...
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>eval_tuptable</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg_plural</name><argument_list>(<argument><expr><literal type="string">"query \"%s\" returned %d column"</literal></expr></argument>,
							   <argument><expr><literal type="string">"query \"%s\" returned %d columns"</literal></expr></argument>,
							   <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_tuptable</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>,
							   <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>query</name></name></expr></argument>,
							   <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_tuptable</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * ... and get the column's datatype.
	 */</comment>
	<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_tuptable</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>rettype</name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>rettypmod</name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there are no rows selected, the result is a NULL of that type.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>eval_processed</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>isNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check that the expression returned no more than one row.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>eval_processed</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CARDINALITY_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"query \"%s\" returned more than one row"</literal></expr></argument>,
						<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Return the single result Datum.
	 */</comment>
	<return>return <expr><call><name>SPI_getbinval</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_tuptable</name><operator>-&gt;</operator><name>vals</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
						 <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_tuptable</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>isNull</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_run_select			Execute a select query
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_run_select</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
				<parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>maxtuples</name></decl></parameter>, <parameter><decl><type><name>Portal</name> <modifier>*</modifier></type><name>portalP</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramLI</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * On the first call for this expression generate the plan.
	 *
	 * If we don't need to return a portal, then we're just going to execute
	 * the query immediately, which means it's OK to use a parallel plan, even
	 * if the number of rows being fetched is limited.  If we do need to
	 * return a portal (i.e., this is for a FOR loop), the user's code might
	 * invoke additional operations inside the FOR loop, making parallel query
	 * unsafe.  In any case, we don't expect any cursor operations to be done,
	 * so specify NO_SCROLL for efficiency and semantic safety.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>plan</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>cursorOptions</name> <init>= <expr><name>CURSOR_OPT_NO_SCROLL</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>portalP</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cursorOptions</name> <operator>|=</operator> <name>CURSOR_OPT_PARALLEL_OK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>exec_prepare_plan</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>cursorOptions</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Set up ParamListInfo to pass to executor
	 */</comment>
	<expr_stmt><expr><name>paramLI</name> <operator>=</operator> <call><name>setup_param_list</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If a portal was requested, put the query and paramlist into the portal
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>portalP</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>portalP</name> <operator>=</operator> <call><name>SPI_cursor_open_with_paramlist</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>,
												  <argument><expr><name>paramLI</name></expr></argument>,
												  <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>readonly_func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>portalP</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not open implicit cursor for query \"%s\": %s"</literal></expr></argument>,
				 <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>query</name></name></expr></argument>, <argument><expr><call><name>SPI_result_code_string</name><argument_list>(<argument><expr><name>SPI_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>SPI_OK_CURSOR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Execute the query
	 */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SPI_execute_plan_with_paramlist</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><name>paramLI</name></expr></argument>,
										 <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>readonly_func</name></name></expr></argument>, <argument><expr><name>maxtuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>SPI_OK_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"query \"%s\" is not a SELECT"</literal></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Save query results for eventual cleanup */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_tuptable</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_tuptable</name></name> <operator>=</operator> <name>SPI_tuptable</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_processed</name></name> <operator>=</operator> <name>SPI_processed</name></expr>;</expr_stmt>

	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * exec_for_query --- execute body of FOR loop for each row from a portal
 *
 * Used by exec_stmt_fors, exec_stmt_forc and exec_stmt_dynfors
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>exec_for_query</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt_forq</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>,
			   <parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>prefetch_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PLpgSQL_variable</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SPITupleTable</name> <modifier>*</modifier></type><name>tuptab</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rc</name> <init>= <expr><name>PLPGSQL_RC_OK</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>previous_id</name> <init>= <expr><name>INVALID_TUPLEDESC_IDENTIFIER</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>tupdescs_match</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>n</name></decl>;</decl_stmt>

	<comment type="block">/* Fetch loop variable's datum entry */</comment>
	<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_variable</name> <operator>*</operator><operator>)</operator> <name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>stmt</name><operator>-&gt;</operator><name>var</name><operator>-&gt;</operator><name>dno</name></name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make sure the portal doesn't get closed by the user statements we
	 * execute.
	 */</comment>
	<expr_stmt><expr><call><name>PinPortal</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In a non-atomic context, we dare not prefetch, even if it would
	 * otherwise be safe.  Aside from any semantic hazards that that might
	 * create, if we prefetch toasted data and then the user commits the
	 * transaction, the toast references could turn into dangling pointers.
	 * (Rows we haven't yet fetched from the cursor are safe, because the
	 * PersistHoldablePortal mechanism handles this scenario.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>atomic</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>prefetch_ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Fetch the initial tuple(s).  If prefetching is allowed then we grab a
	 * few more rows to avoid multiple trips through executor startup
	 * overhead.
	 */</comment>
	<expr_stmt><expr><call><name>SPI_cursor_fetch</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><ternary><condition><expr><name>prefetch_ok</name></expr> ?</condition><then> <expr><literal type="number">10</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuptab</name> <operator>=</operator> <name>SPI_tuptable</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> <operator>=</operator> <name>SPI_processed</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the query didn't return any rows, set the target to NULL and fall
	 * through with found = false.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>exec_move_row</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>tuptab</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>			<comment type="block">/* processed at least one tuple */</comment>

	<comment type="block">/*
	 * Now do the loop
	 */</comment>
	<while>while <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/*
			 * Assign the tuple to the target.  Here, because we know that all
			 * loop iterations should be assigning the same tupdesc, we can
			 * optimize away repeated creations of expanded records with
			 * identical tupdescs.  Testing for changes of er_tupdesc_id is
			 * reliable even if the loop body contains assignments that
			 * replace the target's value entirely, because it's assigned from
			 * a process-global counter.  The case where the tupdescs don't
			 * match could possibly be handled more efficiently than this
			 * coding does, but it's not clear extra effort is worthwhile.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_REC</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name> <init>= <expr><operator>(</operator><name>PLpgSQL_rec</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>erh</name></name> <operator>&amp;&amp;</operator>
					<name><name>rec</name><operator>-&gt;</operator><name>erh</name><operator>-&gt;</operator><name>er_tupdesc_id</name></name> <operator>==</operator> <name>previous_id</name> <operator>&amp;&amp;</operator>
					<name>tupdescs_match</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Only need to assign a new tuple value */</comment>
					<expr_stmt><expr><call><name>expanded_record_set_tuple</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>erh</name></name></expr></argument>, <argument><expr><name><name>tuptab</name><operator>-&gt;</operator><name>vals</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
											  <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>atomic</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * First time through, or var's tupdesc changed in loop,
					 * or we have to do it the hard way because type coercion
					 * is needed.
					 */</comment>
					<expr_stmt><expr><call><name>exec_move_row</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
								  <argument><expr><name><name>tuptab</name><operator>-&gt;</operator><name>vals</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>tuptab</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * Check to see if physical assignment is OK next time.
					 * Once the tupdesc comparison has failed once, we don't
					 * bother rechecking in subsequent loop iterations.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>tupdescs_match</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>tupdescs_match</name> <operator>=</operator>
							<operator>(</operator><name><name>rec</name><operator>-&gt;</operator><name>rectypeid</name></name> <operator>==</operator> <name>RECORDOID</name> <operator>||</operator>
							 <name><name>rec</name><operator>-&gt;</operator><name>rectypeid</name></name> <operator>==</operator> <name><name>tuptab</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>tdtypeid</name></name> <operator>||</operator>
							 <call><name>compatible_tupdescs</name><argument_list>(<argument><expr><name><name>tuptab</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>,
												 <argument><expr><call><name>expanded_record_get_tupdesc</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>erh</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name>previous_id</name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>erh</name><operator>-&gt;</operator><name>er_tupdesc_id</name></name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>exec_move_row</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name><name>tuptab</name><operator>-&gt;</operator><name>vals</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>tuptab</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Execute the statements
			 */</comment>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>exec_stmts</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<macro><name>LOOP_RC_PROCESSING</name><argument_list>(<argument>stmt-&gt;label</argument>, <argument>goto loop_exit</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>SPI_freetuptable</name><argument_list>(<argument><expr><name>tuptab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Fetch more tuples.  If prefetching is allowed, grab 50 at a time.
		 */</comment>
		<expr_stmt><expr><call><name>SPI_cursor_fetch</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><ternary><condition><expr><name>prefetch_ok</name></expr> ?</condition><then> <expr><literal type="number">50</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tuptab</name> <operator>=</operator> <name>SPI_tuptable</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <name>SPI_processed</name></expr>;</expr_stmt>
	</block_content>}</block></while>

<label><name>loop_exit</name>:</label>

	<comment type="block">/*
	 * Release last group of tuples (if any)
	 */</comment>
	<expr_stmt><expr><call><name>SPI_freetuptable</name><argument_list>(<argument><expr><name>tuptab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UnpinPortal</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set the FOUND variable to indicate the result of executing the loop
	 * (namely, whether we looped one or more times). This must be set last so
	 * that it does not interfere with the value of the FOUND variable inside
	 * the loop processing itself.
	 */</comment>
	<expr_stmt><expr><call><name>exec_set_found</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_eval_simple_expr -		Evaluate a simple expression returning
 *								a Datum by directly calling ExecEvalExpr().
 *
 * If successful, store results into *result, *isNull, *rettype, *rettypmod
 * and return true.  If the expression cannot be handled by simple evaluation,
 * return false.
 *
 * Because we only store one execution tree for a simple expression, we
 * can't handle recursion cases.  So, if we see the tree is already busy
 * with an evaluation in the current xact, we just return false and let the
 * caller run the expression the hard way.  (Other alternatives such as
 * creating a new tree for a recursive call either introduce memory leaks,
 * or add enough bookkeeping to be doubtful wins anyway.)  Another case that
 * is covered by the expr_simple_in_use test is where a previous execution
 * of the tree was aborted by an error: the tree may contain bogus state
 * so we dare not re-use it.
 *
 * It is possible that we'd need to replan a simple expression; for example,
 * someone might redefine a SQL function that had been inlined into the simple
 * expression.  That cannot cause a simple expression to become non-simple (or
 * vice versa), but we do have to handle replacing the expression tree.
 *
 * Note: if pass-by-reference, the result is in the eval_mcontext.
 * It will be freed when exec_eval_cleanup is done.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>exec_eval_simple_expr</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
					  <parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
					  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>result</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>,
					  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>rettype</name></decl></parameter>,
					  <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>rettypmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>eval_econtext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LocalTransactionId</name></type> <name>curlxid</name> <init>= <expr><name><name>MyProc</name><operator>-&gt;</operator><name>lxid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramLI</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>save_setup_arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>need_snapshot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Forget it if expression wasn't simple before.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_expr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If expression is in use in current xact, don't touch it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_in_use</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name><name>expr</name><operator>-&gt;</operator><name>expr_simple_lxid</name></name> <operator>==</operator> <name>curlxid</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Ensure that there's a portal-level snapshot, in case this simple
	 * expression is the first thing evaluated after a COMMIT or ROLLBACK.
	 * We'd have to do this anyway before executing the expression, so we
	 * might as well do it now to ensure that any possible replanning doesn't
	 * need to take a new snapshot.
	 */</comment>
	<expr_stmt><expr><call><name>EnsurePortalSnapshotExists</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check to see if the cached plan has been invalidated.  If not, and this
	 * is the first use in the current transaction, save a plan refcount in
	 * the simple-expression resowner.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><call><name>CachedPlanIsSimplyValid</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_plansource</name></name></expr></argument>,
									   <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_plan</name></name></expr></argument>,
									   <argument><expr><operator>(</operator><ternary><condition><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_plan_lxid</name></name> <operator>!=</operator> <name>curlxid</name></expr> ?</condition><then>
										<expr><name><name>estate</name><operator>-&gt;</operator><name>simple_eval_resowner</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * It's still good, so just remember that we have a refcount on the
		 * plan in the current transaction.  (If we already had one, this
		 * assignment is a no-op.)
		 */</comment>
		<expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_plan_lxid</name></name> <operator>=</operator> <name>curlxid</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Need to replan */</comment>
		<decl_stmt><decl><type><name>CachedPlan</name> <modifier>*</modifier></type><name>cplan</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * If we have a valid refcount on some previous version of the plan,
		 * release it, so we don't leak plans intra-transaction.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_plan_lxid</name></name> <operator>==</operator> <name>curlxid</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ResourceOwner</name></type> <name>saveResourceOwner</name> <init>= <expr><name>CurrentResourceOwner</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>simple_eval_resowner</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReleaseCachedPlan</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_plan</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>saveResourceOwner</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_plan</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_plan_lxid</name></name> <operator>=</operator> <name>InvalidLocalTransactionId</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Do the replanning work in the eval_mcontext */</comment>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cplan</name> <operator>=</operator> <call><name>SPI_plan_get_cached_plan</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We can't get a failure here, because the number of
		 * CachedPlanSources in the SPI plan can't change from what
		 * exec_simple_check_plan saw; it's a property of the raw parsetree
		 * generated from the query text.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cplan</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * This test probably can't fail either, but if it does, cope by
		 * declaring the plan to be non-simple.  On success, we'll acquire a
		 * refcount on the new plan, stored in simple_eval_resowner.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>CachedPlanAllowsSimpleValidityCheck</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_plansource</name></name></expr></argument>,
												<argument><expr><name>cplan</name></expr></argument>,
												<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>simple_eval_resowner</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Remember that we have the refcount */</comment>
			<expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_plan</name></name> <operator>=</operator> <name>cplan</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_plan_lxid</name></name> <operator>=</operator> <name>curlxid</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Release SPI_plan_get_cached_plan's refcount */</comment>
			<expr_stmt><expr><call><name>ReleaseCachedPlan</name><argument_list>(<argument><expr><name>cplan</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Mark expression as non-simple, and fail */</comment>
			<expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_expr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * SPI_plan_get_cached_plan acquired a plan refcount stored in the
		 * active resowner.  We don't need that anymore, so release it.
		 */</comment>
		<expr_stmt><expr><call><name>ReleaseCachedPlan</name><argument_list>(<argument><expr><name>cplan</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Extract desired scalar expression from cached plan */</comment>
		<expr_stmt><expr><call><name>exec_save_simple_expr</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>cplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* better recheck r/w safety, as it could change due to inlining */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>rwparam</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exec_check_rw_parameter</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>rwparam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Pass back previously-determined result type.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>rettype</name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>expr_simple_type</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>rettypmod</name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>expr_simple_typmod</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up ParamListInfo to pass to executor.  For safety, save and restore
	 * estate-&gt;paramLI-&gt;parserSetupArg around our use of the param list.
	 */</comment>
	<expr_stmt><expr><name>paramLI</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>paramLI</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>save_setup_arg</name> <operator>=</operator> <name><name>paramLI</name><operator>-&gt;</operator><name>parserSetupArg</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We can skip using setup_param_list() in favor of just doing this
	 * unconditionally, because there's no need for the optimization of
	 * possibly setting ecxt_param_list_info to NULL; we've already forced use
	 * of a generic plan.
	 */</comment>
	<expr_stmt><expr><name><name>paramLI</name><operator>-&gt;</operator><name>parserSetupArg</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_param_list_info</name></name> <operator>=</operator> <name>paramLI</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Prepare the expression for execution, if it's not been done already in
	 * the current transaction.  (This will be forced to happen if we called
	 * exec_save_simple_expr above.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_lxid</name></name> <operator>!=</operator> <name>curlxid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>simple_eval_estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_state</name></name> <operator>=</operator>
			<call><name>ExecInitExprWithParams</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_expr</name></name></expr></argument>,
								   <argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_param_list_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_in_use</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_lxid</name></name> <operator>=</operator> <name>curlxid</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We have to do some of the things SPI_execute_plan would do, in
	 * particular push a new snapshot so that stable functions within the
	 * expression can see updates made so far by our own function.  However,
	 * we can skip doing that (and just invoke the expression with the same
	 * snapshot passed to our function) in some cases, which is useful because
	 * it's quite expensive relative to the cost of a simple expression.  We
	 * can skip it if the expression contains no stable or volatile functions;
	 * immutable functions shouldn't need to see our updates.  Also, if this
	 * is a read-only function, we haven't made any updates so again it's okay
	 * to skip.
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>need_snapshot</name> <operator>=</operator> <operator>(</operator><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_mutable</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>readonly_func</name></name><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>need_snapshot</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Mark expression as busy for the duration of the ExecEvalExpr call.
	 */</comment>
	<expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_in_use</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Finally we can call the executor to evaluate the expression
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_state</name></name></expr></argument>,
						   <argument><expr><name>econtext</name></expr></argument>,
						   <argument><expr><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Assorted cleanup */</comment>
	<expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_in_use</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_param_list_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>paramLI</name><operator>-&gt;</operator><name>parserSetupArg</name></name> <operator>=</operator> <name>save_setup_arg</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>need_snapshot</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * That's it.
	 */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Create a ParamListInfo to pass to SPI
 *
 * We use a single ParamListInfo struct for all SPI calls made from this
 * estate; it contains no per-param data, just hook functions, so it's
 * effectively read-only for SPI.
 *
 * An exception from pure read-only-ness is that the parserSetupArg points
 * to the specific PLpgSQL_expr being evaluated.  This is not an issue for
 * statement-level callers, but lower-level callers must save and restore
 * estate-&gt;paramLI-&gt;parserSetupArg just in case there's an active evaluation
 * at an outer call level.  (A plausible alternative design would be to
 * create a ParamListInfo struct for each PLpgSQL_expr, but for the moment
 * that seems like a waste of memory.)
 */</comment>
<function><type><specifier>static</specifier> <name>ParamListInfo</name></type>
<name>setup_param_list</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramLI</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We must have created the SPIPlan already (hence, query text has been
	 * parsed/analyzed at least once); else we cannot rely on expr-&gt;paramnos.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>plan</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We only need a ParamListInfo if the expression has parameters.  In
	 * principle we should test with bms_is_empty(), but we use a not-null
	 * test because it's faster.  In current usage bits are never removed from
	 * expr-&gt;paramnos, only added, so this test is correct anyway.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>paramnos</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Use the common ParamListInfo */</comment>
		<expr_stmt><expr><name>paramLI</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>paramLI</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Set up link to active expr where the hook functions can find it.
		 * Callers must save and restore parserSetupArg if there is any chance
		 * that they are interrupting an active use of parameters.
		 */</comment>
		<expr_stmt><expr><name><name>paramLI</name><operator>-&gt;</operator><name>parserSetupArg</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Also make sure this is set before parser hooks need it.  There is
		 * no need to save and restore, since the value is always correct once
		 * set.  (Should be set already, but let's be sure.)
		 */</comment>
		<expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>func</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>func</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Expression requires no parameters.  Be sure we represent this case
		 * as a NULL ParamListInfo, so that plancache.c knows there is no
		 * point in a custom plan.
		 */</comment>
		<expr_stmt><expr><name>paramLI</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>paramLI</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * plpgsql_param_fetch		paramFetch callback for dynamic parameter fetch
 *
 * We always use the caller's workspace to construct the returned struct.
 *
 * Note: this is no longer used during query execution.  It is used during
 * planning (with speculative == true) and when the ParamListInfo we supply
 * to the executor is copied into a cursor portal or transferred to a
 * parallel child process.
 */</comment>
<function><type><specifier>static</specifier> <name>ParamExternData</name> <modifier>*</modifier></type>
<name>plpgsql_param_fetch</name><parameter_list>(<parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>paramid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>speculative</name></decl></parameter>,
					<parameter><decl><type><name>ParamExternData</name> <modifier>*</modifier></type><name>prm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>dno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ok</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>prmtypmod</name></decl>;</decl_stmt>

	<comment type="block">/* paramid's are 1-based, but dnos are 0-based */</comment>
	<expr_stmt><expr><name>dno</name> <operator>=</operator> <name>paramid</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>dno</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>dno</name> <operator>&lt;</operator> <name><name>params</name><operator>-&gt;</operator><name>numParams</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* fetch back the hook data */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_execstate</name> <operator>*</operator><operator>)</operator> <name><name>params</name><operator>-&gt;</operator><name>paramFetchArg</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_expr</name> <operator>*</operator><operator>)</operator> <name><name>params</name><operator>-&gt;</operator><name>parserSetupArg</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>numParams</name></name> <operator>==</operator> <name><name>estate</name><operator>-&gt;</operator><name>ndatums</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* now we can access the target datum */</comment>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>dno</name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since copyParamList() or SerializeParamList() will try to materialize
	 * every single parameter slot, it's important to return a dummy param
	 * when asked for a datum that's not supposed to be used by this SQL
	 * expression.  Otherwise we risk failures in exec_eval_datum(), or
	 * copying a lot more data than necessary.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>dno</name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>paramnos</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>

	<comment type="block">/*
	 * If the access is speculative, we prefer to return no data rather than
	 * to fail in exec_eval_datum().  Check the likely failure cases.
	 */</comment>
	<if type="elseif">else if <condition>(<expr><name>speculative</name></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name><name>datum</name><operator>-&gt;</operator><name>dtype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>PLPGSQL_DTYPE_VAR</name></expr>:</case>
			<case>case <expr><name>PLPGSQL_DTYPE_PROMISE</name></expr>:</case>
				<comment type="block">/* always safe */</comment>
				<break>break;</break>

			<case>case <expr><name>PLPGSQL_DTYPE_ROW</name></expr>:</case>
				<comment type="block">/* should be safe in all interesting cases */</comment>
				<break>break;</break>

			<case>case <expr><name>PLPGSQL_DTYPE_REC</name></expr>:</case>
				<comment type="block">/* always safe (might return NULL, that's fine) */</comment>
				<break>break;</break>

			<case>case <expr><name>PLPGSQL_DTYPE_RECFIELD</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>PLpgSQL_recfield</name> <modifier>*</modifier></type><name>recfield</name> <init>= <expr><operator>(</operator><name>PLpgSQL_recfield</name> <operator>*</operator><operator>)</operator> <name>datum</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>rec</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_rec</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>recfield</name><operator>-&gt;</operator><name>recparentno</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

					<comment type="block">/*
					 * If record variable is NULL, don't risk anything.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>erh</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>

					<comment type="block">/*
					 * Look up the field's properties if we have not already,
					 * or if the tuple descriptor ID changed since last time.
					 */</comment>
					<if type="elseif">else if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>recfield</name><operator>-&gt;</operator><name>rectupledescid</name></name> <operator>!=</operator> <name><name>rec</name><operator>-&gt;</operator><name>erh</name><operator>-&gt;</operator><name>er_tupdesc_id</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>expanded_record_lookup_field</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>erh</name></name></expr></argument>,
														 <argument><expr><name><name>recfield</name><operator>-&gt;</operator><name>fieldname</name></name></expr></argument>,
														 <argument><expr><operator>&amp;</operator><name><name>recfield</name><operator>-&gt;</operator><name>finfo</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>recfield</name><operator>-&gt;</operator><name>rectupledescid</name></name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>erh</name><operator>-&gt;</operator><name>er_tupdesc_id</name></name></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><name>ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
					</block_content>}</block></if></if_stmt>
					<break>break;</break>
				</block_content>}</block>

			<default>default:</default>
				<expr_stmt><expr><name>ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Return "no such parameter" if not ok */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>pflags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<return>return <expr><name>prm</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* OK, evaluate the value and store into the return struct */</comment>
	<expr_stmt><expr><call><name>exec_eval_datum</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>,
					<argument><expr><operator>&amp;</operator><name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prmtypmod</name></expr></argument>,
					<argument><expr><operator>&amp;</operator><name><name>prm</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* We can always mark params as "const" for executor's purposes */</comment>
	<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>pflags</name></name> <operator>=</operator> <name>PARAM_FLAG_CONST</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If it's a read/write expanded datum, convert reference to read-only,
	 * unless it's safe to pass as read-write.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>dno</name> <operator>!=</operator> <name><name>expr</name><operator>-&gt;</operator><name>rwparam</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>datum</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_VAR</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>MakeExpandedObjectReadOnly</name><argument_list>(<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name></expr></argument>,
													<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name></expr></argument>,
													<argument><expr><operator>(</operator><operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name>datum</name><operator>)</operator><operator>-&gt;</operator><name><name>datatype</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>datum</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_REC</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>MakeExpandedObjectReadOnly</name><argument_list>(<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name></expr></argument>,
													<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name></expr></argument>,
													<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>prm</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * plpgsql_param_compile		paramCompile callback for plpgsql parameters
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>plpgsql_param_compile</name><parameter_list>(<parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>, <parameter><decl><type><name>Param</name> <modifier>*</modifier></type><name>param</name></decl></parameter>,
					  <parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
					  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>resv</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>resnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprEvalStep</name></type> <name>scratch</name></decl>;</decl_stmt>

	<comment type="block">/* fetch back the hook data */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_execstate</name> <operator>*</operator><operator>)</operator> <name><name>params</name><operator>-&gt;</operator><name>paramFetchArg</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_expr</name> <operator>*</operator><operator>)</operator> <name><name>params</name><operator>-&gt;</operator><name>parserSetupArg</name></name></expr>;</expr_stmt>

	<comment type="block">/* paramid's are 1-based, but dnos are 0-based */</comment>
	<expr_stmt><expr><name>dno</name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>paramid</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>dno</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>dno</name> <operator>&lt;</operator> <name><name>estate</name><operator>-&gt;</operator><name>ndatums</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* now we can access the target datum */</comment>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>dno</name></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_PARAM_CALLBACK</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>resvalue</name></name> <operator>=</operator> <name>resv</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>resnull</name></name> <operator>=</operator> <name>resnull</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Select appropriate eval function.  It seems worth special-casing
	 * DTYPE_VAR and DTYPE_RECFIELD for performance.  Also, we can determine
	 * in advance whether MakeExpandedObjectReadOnly() will be required.
	 * Currently, only VAR/PROMISE and REC datums could contain read/write
	 * expanded objects.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>datum</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_VAR</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>dno</name> <operator>!=</operator> <name><name>expr</name><operator>-&gt;</operator><name>rwparam</name></name> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name>datum</name><operator>)</operator><operator>-&gt;</operator><name><name>datatype</name><operator>-&gt;</operator><name>typlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>cparam</name><operator>.</operator><name>paramfunc</name></name> <operator>=</operator> <name>plpgsql_param_eval_var_ro</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>cparam</name><operator>.</operator><name>paramfunc</name></name> <operator>=</operator> <name>plpgsql_param_eval_var</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>datum</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_RECFIELD</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>cparam</name><operator>.</operator><name>paramfunc</name></name> <operator>=</operator> <name>plpgsql_param_eval_recfield</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>datum</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_PROMISE</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>dno</name> <operator>!=</operator> <name><name>expr</name><operator>-&gt;</operator><name>rwparam</name></name> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name>datum</name><operator>)</operator><operator>-&gt;</operator><name><name>datatype</name><operator>-&gt;</operator><name>typlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>cparam</name><operator>.</operator><name>paramfunc</name></name> <operator>=</operator> <name>plpgsql_param_eval_generic_ro</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>cparam</name><operator>.</operator><name>paramfunc</name></name> <operator>=</operator> <name>plpgsql_param_eval_generic</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>datum</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_REC</name> <operator>&amp;&amp;</operator>
			 <name>dno</name> <operator>!=</operator> <name><name>expr</name><operator>-&gt;</operator><name>rwparam</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>cparam</name><operator>.</operator><name>paramfunc</name></name> <operator>=</operator> <name>plpgsql_param_eval_generic_ro</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>cparam</name><operator>.</operator><name>paramfunc</name></name> <operator>=</operator> <name>plpgsql_param_eval_generic</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Note: it's tempting to use paramarg to store the estate pointer and
	 * thereby save an indirection or two in the eval functions.  But that
	 * doesn't work because the compiled expression might be used with
	 * different estates for the same PL/pgSQL function.
	 */</comment>
	<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>cparam</name><operator>.</operator><name>paramarg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>cparam</name><operator>.</operator><name>paramid</name></name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>paramid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>cparam</name><operator>.</operator><name>paramtype</name></name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>paramtype</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * plpgsql_param_eval_var		evaluation of EEOP_PARAM_CALLBACK step
 *
 * This is specialized to the case of DTYPE_VAR variables for which
 * we do not need to invoke MakeExpandedObjectReadOnly.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>plpgsql_param_eval_var</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>,
					   <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>params</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dno</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>cparam</name><operator>.</operator><name>paramid</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

	<comment type="block">/* fetch back the hook data */</comment>
	<expr_stmt><expr><name>params</name> <operator>=</operator> <name><name>econtext</name><operator>-&gt;</operator><name>ecxt_param_list_info</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_execstate</name> <operator>*</operator><operator>)</operator> <name><name>params</name><operator>-&gt;</operator><name>paramFetchArg</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>dno</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>dno</name> <operator>&lt;</operator> <name><name>estate</name><operator>-&gt;</operator><name>ndatums</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* now we can access the target datum */</comment>
	<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>dno</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* inlined version of exec_eval_datum() */</comment>
	<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>

	<comment type="block">/* safety check -- an assertion should be sufficient */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typoid</name></name> <operator>==</operator> <name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>cparam</name><operator>.</operator><name>paramtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * plpgsql_param_eval_var_ro		evaluation of EEOP_PARAM_CALLBACK step
 *
 * This is specialized to the case of DTYPE_VAR variables for which
 * we need to invoke MakeExpandedObjectReadOnly.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>plpgsql_param_eval_var_ro</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>,
						  <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>params</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dno</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>cparam</name><operator>.</operator><name>paramid</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

	<comment type="block">/* fetch back the hook data */</comment>
	<expr_stmt><expr><name>params</name> <operator>=</operator> <name><name>econtext</name><operator>-&gt;</operator><name>ecxt_param_list_info</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_execstate</name> <operator>*</operator><operator>)</operator> <name><name>params</name><operator>-&gt;</operator><name>paramFetchArg</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>dno</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>dno</name> <operator>&lt;</operator> <name><name>estate</name><operator>-&gt;</operator><name>ndatums</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* now we can access the target datum */</comment>
	<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>dno</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Inlined version of exec_eval_datum() ... and while we're at it, force
	 * expanded datums to read-only.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>MakeExpandedObjectReadOnly</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr></argument>,
											   <argument><expr><name><name>var</name><operator>-&gt;</operator><name>isnull</name></name></expr></argument>,
											   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>

	<comment type="block">/* safety check -- an assertion should be sufficient */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typoid</name></name> <operator>==</operator> <name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>cparam</name><operator>.</operator><name>paramtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * plpgsql_param_eval_recfield		evaluation of EEOP_PARAM_CALLBACK step
 *
 * This is specialized to the case of DTYPE_RECFIELD variables, for which
 * we never need to invoke MakeExpandedObjectReadOnly.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>plpgsql_param_eval_recfield</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>,
							<parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>params</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dno</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>cparam</name><operator>.</operator><name>paramid</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PLpgSQL_recfield</name> <modifier>*</modifier></type><name>recfield</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>erh</name></decl>;</decl_stmt>

	<comment type="block">/* fetch back the hook data */</comment>
	<expr_stmt><expr><name>params</name> <operator>=</operator> <name><name>econtext</name><operator>-&gt;</operator><name>ecxt_param_list_info</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_execstate</name> <operator>*</operator><operator>)</operator> <name><name>params</name><operator>-&gt;</operator><name>paramFetchArg</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>dno</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>dno</name> <operator>&lt;</operator> <name><name>estate</name><operator>-&gt;</operator><name>ndatums</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* now we can access the target datum */</comment>
	<expr_stmt><expr><name>recfield</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_recfield</name> <operator>*</operator><operator>)</operator> <name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>dno</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>recfield</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_RECFIELD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* inline the relevant part of exec_eval_datum */</comment>
	<expr_stmt><expr><name>rec</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_rec</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>recfield</name><operator>-&gt;</operator><name>recparentno</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>erh</name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>erh</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If record variable is NULL, instantiate it if it has a named composite
	 * type, else complain.  (This won't change the logical state of the
	 * record: it's still NULL.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>erh</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>instantiate_empty_record_variable</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>erh</name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>erh</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Look up the field's properties if we have not already, or if the tuple
	 * descriptor ID changed since last time.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>recfield</name><operator>-&gt;</operator><name>rectupledescid</name></name> <operator>!=</operator> <name><name>erh</name><operator>-&gt;</operator><name>er_tupdesc_id</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>expanded_record_lookup_field</name><argument_list>(<argument><expr><name>erh</name></expr></argument>,
										  <argument><expr><name><name>recfield</name><operator>-&gt;</operator><name>fieldname</name></name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name><name>recfield</name><operator>-&gt;</operator><name>finfo</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"record \"%s\" has no field \"%s\""</literal></expr></argument>,
							<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>, <argument><expr><name><name>recfield</name><operator>-&gt;</operator><name>fieldname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>recfield</name><operator>-&gt;</operator><name>rectupledescid</name></name> <operator>=</operator> <name><name>erh</name><operator>-&gt;</operator><name>er_tupdesc_id</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* OK to fetch the field value. */</comment>
	<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>expanded_record_get_field</name><argument_list>(<argument><expr><name>erh</name></expr></argument>,
											  <argument><expr><name><name>recfield</name><operator>-&gt;</operator><name>finfo</name><operator>.</operator><name>fnumber</name></name></expr></argument>,
											  <argument><expr><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* safety check -- needed for, eg, record fields */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>recfield</name><operator>-&gt;</operator><name>finfo</name><operator>.</operator><name>ftypeid</name></name> <operator>!=</operator> <name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>cparam</name><operator>.</operator><name>paramtype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type of parameter %d (%s) does not match that when preparing the plan (%s)"</literal></expr></argument>,
						<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>cparam</name><operator>.</operator><name>paramid</name></name></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>recfield</name><operator>-&gt;</operator><name>finfo</name><operator>.</operator><name>ftypeid</name></name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>cparam</name><operator>.</operator><name>paramtype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * plpgsql_param_eval_generic		evaluation of EEOP_PARAM_CALLBACK step
 *
 * This handles all variable types, but assumes we do not need to invoke
 * MakeExpandedObjectReadOnly.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>plpgsql_param_eval_generic</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>,
						   <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>params</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dno</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>cparam</name><operator>.</operator><name>paramid</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>datumtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>datumtypmod</name></decl>;</decl_stmt>

	<comment type="block">/* fetch back the hook data */</comment>
	<expr_stmt><expr><name>params</name> <operator>=</operator> <name><name>econtext</name><operator>-&gt;</operator><name>ecxt_param_list_info</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_execstate</name> <operator>*</operator><operator>)</operator> <name><name>params</name><operator>-&gt;</operator><name>paramFetchArg</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>dno</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>dno</name> <operator>&lt;</operator> <name><name>estate</name><operator>-&gt;</operator><name>ndatums</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* now we can access the target datum */</comment>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>dno</name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* fetch datum's value */</comment>
	<expr_stmt><expr><call><name>exec_eval_datum</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>,
					<argument><expr><operator>&amp;</operator><name>datumtype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>datumtypmod</name></expr></argument>,
					<argument><expr><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* safety check -- needed for, eg, record fields */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>datumtype</name> <operator>!=</operator> <name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>cparam</name><operator>.</operator><name>paramtype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type of parameter %d (%s) does not match that when preparing the plan (%s)"</literal></expr></argument>,
						<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>cparam</name><operator>.</operator><name>paramid</name></name></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>datumtype</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>cparam</name><operator>.</operator><name>paramtype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * plpgsql_param_eval_generic_ro	evaluation of EEOP_PARAM_CALLBACK step
 *
 * This handles all variable types, but assumes we need to invoke
 * MakeExpandedObjectReadOnly (hence, variable must be of a varlena type).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>plpgsql_param_eval_generic_ro</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>,
							  <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>params</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dno</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>cparam</name><operator>.</operator><name>paramid</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>datumtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>datumtypmod</name></decl>;</decl_stmt>

	<comment type="block">/* fetch back the hook data */</comment>
	<expr_stmt><expr><name>params</name> <operator>=</operator> <name><name>econtext</name><operator>-&gt;</operator><name>ecxt_param_list_info</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_execstate</name> <operator>*</operator><operator>)</operator> <name><name>params</name><operator>-&gt;</operator><name>paramFetchArg</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>dno</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>dno</name> <operator>&lt;</operator> <name><name>estate</name><operator>-&gt;</operator><name>ndatums</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* now we can access the target datum */</comment>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>dno</name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* fetch datum's value */</comment>
	<expr_stmt><expr><call><name>exec_eval_datum</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>,
					<argument><expr><operator>&amp;</operator><name>datumtype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>datumtypmod</name></expr></argument>,
					<argument><expr><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* safety check -- needed for, eg, record fields */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>datumtype</name> <operator>!=</operator> <name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>cparam</name><operator>.</operator><name>paramtype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type of parameter %d (%s) does not match that when preparing the plan (%s)"</literal></expr></argument>,
						<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>cparam</name><operator>.</operator><name>paramid</name></name></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>datumtype</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>cparam</name><operator>.</operator><name>paramtype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* force the value to read-only */</comment>
	<expr_stmt><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name> <operator>=</operator> <call><name>MakeExpandedObjectReadOnly</name><argument_list>(<argument><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resvalue</name></name></expr></argument>,
											   <argument><expr><operator>*</operator><name><name>op</name><operator>-&gt;</operator><name>resnull</name></name></expr></argument>,
											   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * exec_move_row			Move one tuple's values into a record or row
 *
 * tup and tupdesc may both be NULL if we're just assigning an indeterminate
 * composite NULL to the target.  Alternatively, can have tup be NULL and
 * tupdesc not NULL, in which case we assign a row of NULLs to the target.
 *
 * Since this uses the mcontext for workspace, caller should eventually call
 * exec_eval_cleanup to prevent long-term memory leaks.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_move_row</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
			  <parameter><decl><type><name>PLpgSQL_variable</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
			  <parameter><decl><type><name>HeapTuple</name></type> <name>tup</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>newerh</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If target is RECORD, we may be able to avoid field-by-field processing.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_REC</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name> <init>= <expr><operator>(</operator><name>PLpgSQL_rec</name> <operator>*</operator><operator>)</operator> <name>target</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If we have no source tupdesc, just set the record variable to NULL.
		 * (If we have a source tupdesc but not a tuple, we'll set the
		 * variable to a row of nulls, instead.  This is odd perhaps, but
		 * backwards compatible.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>tupdesc</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>datatype</name></name> <operator>&amp;&amp;</operator>
				<name><name>rec</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_DOMAIN</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * If it's a composite domain, NULL might not be a legal
				 * value, so we instead need to make an empty expanded record
				 * and ensure that domain type checking gets done.  If there
				 * is already an expanded record, piggyback on its lookups.
				 */</comment>
				<expr_stmt><expr><name>newerh</name> <operator>=</operator> <call><name>make_expanded_record_for_rec</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>,
													  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>rec</name><operator>-&gt;</operator><name>erh</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>expanded_record_set_tuple</name><argument_list>(<argument><expr><name>newerh</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>assign_record_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>, <argument><expr><name>newerh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Just clear it to NULL */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>erh</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>DeleteExpandedObject</name><argument_list>(<argument><expr><call><name>ExpandedRecordGetDatum</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>erh</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>rec</name><operator>-&gt;</operator><name>erh</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Build a new expanded record with appropriate tupdesc.
		 */</comment>
		<expr_stmt><expr><name>newerh</name> <operator>=</operator> <call><name>make_expanded_record_for_rec</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the rowtypes match, or if we have no tuple anyway, we can
		 * complete the assignment without field-by-field processing.
		 *
		 * The tests here are ordered more or less in order of cheapness.  We
		 * can easily detect it will work if the target is declared RECORD or
		 * has the same typeid as the source.  But when assigning from a query
		 * result, it's common to have a source tupdesc that's labeled RECORD
		 * but is actually physically compatible with a named-composite-type
		 * target, so it's worth spending extra cycles to check for that.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>rectypeid</name></name> <operator>==</operator> <name>RECORDOID</name> <operator>||</operator>
			<name><name>rec</name><operator>-&gt;</operator><name>rectypeid</name></name> <operator>==</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypeid</name></name> <operator>||</operator>
			<operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>compatible_tupdescs</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><call><name>expanded_record_get_tupdesc</name><argument_list>(<argument><expr><name>newerh</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* No data, so force the record into all-nulls state */</comment>
				<expr_stmt><expr><call><name>deconstruct_expanded_record</name><argument_list>(<argument><expr><name>newerh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* No coercion is needed, so just assign the row value */</comment>
				<expr_stmt><expr><call><name>expanded_record_set_tuple</name><argument_list>(<argument><expr><name>newerh</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>atomic</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/* Complete the assignment */</comment>
			<expr_stmt><expr><call><name>assign_record_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>, <argument><expr><name>newerh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise, deconstruct the tuple and do field-by-field assignment,
	 * using exec_move_row_from_fields.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>tupdesc</name> <operator>&amp;&amp;</operator> <call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>td_natts</name> <init>= <expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values_local</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls_local</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Need workspace arrays.  If td_natts is small enough, use local
		 * arrays to save doing a palloc.  Even if it's not small, we can
		 * allocate both the Datum and isnull arrays in one palloc chunk.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>td_natts</name> <operator>&lt;=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>values_local</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>values</name> <operator>=</operator> <name>values_local</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>nulls</name> <operator>=</operator> <name>nulls_local</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>chunk</name> <operator>=</operator> <call><name>eval_mcontext_alloc</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
										<argument><expr><name>td_natts</name> <operator>*</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <name>chunk</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>nulls</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>chunk</name> <operator>+</operator> <name>td_natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>exec_move_row_from_fields</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>newerh</name></expr></argument>,
								  <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Assign all-nulls.
		 */</comment>
		<expr_stmt><expr><call><name>exec_move_row_from_fields</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>newerh</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Verify that a PLpgSQL_rec's rectypeid is up-to-date.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>revalidate_rectypeid</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PLpgSQL_type</name> <modifier>*</modifier></type><name>typ</name> <init>= <expr><name><name>rec</name><operator>-&gt;</operator><name>datatype</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>rectypeid</name></name> <operator>==</operator> <name>RECORDOID</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* it's RECORD, so nothing to do */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>typ</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>typ</name><operator>-&gt;</operator><name>tcache</name></name> <operator>&amp;&amp;</operator>
		<name><name>typ</name><operator>-&gt;</operator><name>tcache</name><operator>-&gt;</operator><name>tupDesc_identifier</name></name> <operator>==</operator> <name><name>typ</name><operator>-&gt;</operator><name>tupdesc_id</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Although *typ is known up-to-date, it's possible that rectypeid
		 * isn't, because *rec is cloned during each function startup from a
		 * copy that we don't have a good way to update.  Hence, forcibly fix
		 * rectypeid before returning.
		 */</comment>
		<expr_stmt><expr><name><name>rec</name><operator>-&gt;</operator><name>rectypeid</name></name> <operator>=</operator> <name><name>typ</name><operator>-&gt;</operator><name>typoid</name></name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * typcache entry has suffered invalidation, so re-look-up the type name
	 * if possible, and then recheck the type OID.  If we don't have a
	 * TypeName, then we just have to soldier on with the OID we've got.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>typ</name><operator>-&gt;</operator><name>origtypname</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* this bit should match parse_datatype() in pl_gram.y */</comment>
		<expr_stmt><expr><call><name>typenameTypeIdAndMod</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>typ</name><operator>-&gt;</operator><name>origtypname</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>typ</name><operator>-&gt;</operator><name>typoid</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>typ</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* this bit should match build_datatype() in pl_comp.c */</comment>
	<expr_stmt><expr><name>typentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name><name>typ</name><operator>-&gt;</operator><name>typoid</name></name></expr></argument>,
								 <argument><expr><name>TYPECACHE_TUPDESC</name> <operator>|</operator>
								 <name>TYPECACHE_DOMAIN_BASE_INFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>typentry</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_DOMAIN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>typentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>domainBaseType</name></name></expr></argument>,
									 <argument><expr><name>TYPECACHE_TUPDESC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>typentry</name><operator>-&gt;</operator><name>tupDesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we get here, user tried to replace a composite type with a
		 * non-composite one.  We're not gonna support that.
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type %s is not composite"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>typ</name><operator>-&gt;</operator><name>typoid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Update tcache and tupdesc_id.  Since we don't support changing to a
	 * non-composite type, none of the rest of *typ needs to change.
	 */</comment>
	<expr_stmt><expr><name><name>typ</name><operator>-&gt;</operator><name>tcache</name></name> <operator>=</operator> <name>typentry</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>typ</name><operator>-&gt;</operator><name>tupdesc_id</name></name> <operator>=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>tupDesc_identifier</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Update *rec, too.  (We'll deal with subsidiary RECFIELDs as needed.)
	 */</comment>
	<expr_stmt><expr><name><name>rec</name><operator>-&gt;</operator><name>rectypeid</name></name> <operator>=</operator> <name><name>typ</name><operator>-&gt;</operator><name>typoid</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Build an expanded record object suitable for assignment to "rec".
 *
 * Caller must supply either a source tuple descriptor or a source expanded
 * record (not both).  If the record variable has declared type RECORD,
 * it'll adopt the source's rowtype.  Even if it doesn't, we may be able to
 * piggyback on a source expanded record to save a typcache lookup.
 *
 * Caller must fill the object with data, then do assign_record_var().
 *
 * The new record is initially put into the mcontext, so it will be cleaned up
 * if we fail before reaching assign_record_var().
 */</comment>
<function><type><specifier>static</specifier> <name>ExpandedRecordHeader</name> <modifier>*</modifier></type>
<name>make_expanded_record_for_rec</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
							 <parameter><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name></decl></parameter>,
							 <parameter><decl><type><name>TupleDesc</name></type> <name>srctupdesc</name></decl></parameter>,
							 <parameter><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>srcerh</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>newerh</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>mcontext</name> <init>= <expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>rectypeid</name></name> <operator>!=</operator> <name>RECORDOID</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Make sure rec-&gt;rectypeid is up-to-date before using it.
		 */</comment>
		<expr_stmt><expr><call><name>revalidate_rectypeid</name><argument_list>(<argument><expr><name>rec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * New record must be of desired type, but maybe srcerh has already
		 * done all the same lookups.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>srcerh</name> <operator>&amp;&amp;</operator> <name><name>rec</name><operator>-&gt;</operator><name>rectypeid</name></name> <operator>==</operator> <name><name>srcerh</name><operator>-&gt;</operator><name>er_decltypeid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>newerh</name> <operator>=</operator> <call><name>make_expanded_record_from_exprecord</name><argument_list>(<argument><expr><name>srcerh</name></expr></argument>,
														 <argument><expr><name>mcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>newerh</name> <operator>=</operator> <call><name>make_expanded_record_from_typeid</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>rectypeid</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
													  <argument><expr><name>mcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * We'll adopt the input tupdesc.  We can still use
		 * make_expanded_record_from_exprecord, if srcerh isn't a composite
		 * domain.  (If it is, we effectively adopt its base type.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>srcerh</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ExpandedRecordIsDomain</name><argument_list>(<argument><expr><name>srcerh</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>newerh</name> <operator>=</operator> <call><name>make_expanded_record_from_exprecord</name><argument_list>(<argument><expr><name>srcerh</name></expr></argument>,
														 <argument><expr><name>mcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>srctupdesc</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>srctupdesc</name> <operator>=</operator> <call><name>expanded_record_get_tupdesc</name><argument_list>(<argument><expr><name>srcerh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>newerh</name> <operator>=</operator> <call><name>make_expanded_record_from_tupdesc</name><argument_list>(<argument><expr><name>srctupdesc</name></expr></argument>,
													   <argument><expr><name>mcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>newerh</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * exec_move_row_from_fields	Move arrays of field values into a record or row
 *
 * When assigning to a record, the caller must have already created a suitable
 * new expanded record object, newerh.  Pass NULL when assigning to a row.
 *
 * tupdesc describes the input row, which might have different column
 * types and/or different dropped-column positions than the target.
 * values/nulls/tupdesc can all be NULL if we just want to assign nulls to
 * all fields of the record or row.
 *
 * Since this uses the mcontext for workspace, caller should eventually call
 * exec_eval_cleanup to prevent long-term memory leaks.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_move_row_from_fields</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
						  <parameter><decl><type><name>PLpgSQL_variable</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
						  <parameter><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>newerh</name></decl></parameter>,
						  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>,
						  <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>td_natts</name> <init>= <expr><ternary><condition><expr><name>tupdesc</name></expr> ?</condition><then> <expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>anum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>strict_multiassignment_level</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * The extra check strict strict_multi_assignment can be active, only when
	 * input tupdesc is specified.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>tupdesc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>plpgsql_extra_errors</name> <operator>&amp;</operator> <name>PLPGSQL_XCHECK_STRICTMULTIASSIGNMENT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>strict_multiassignment_level</name> <operator>=</operator> <name>ERROR</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>plpgsql_extra_warnings</name> <operator>&amp;</operator> <name>PLPGSQL_XCHECK_STRICTMULTIASSIGNMENT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>strict_multiassignment_level</name> <operator>=</operator> <name>WARNING</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Handle RECORD-target case */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_REC</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name> <init>= <expr><operator>(</operator><name>PLpgSQL_rec</name> <operator>*</operator><operator>)</operator> <name>target</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>var_tupdesc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>newvalues_local</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>newnulls_local</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newerh</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* caller must have built new object */</comment>

		<expr_stmt><expr><name>var_tupdesc</name> <operator>=</operator> <call><name>expanded_record_get_tupdesc</name><argument_list>(<argument><expr><name>newerh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Coerce field values if needed.  This might involve dealing with
		 * different sets of dropped columns and/or coercing individual column
		 * types.  That's sort of a pain, but historically plpgsql has allowed
		 * it, so we preserve the behavior.  However, it's worth a quick check
		 * to see if the tupdescs are identical.  (Since expandedrecord.c
		 * prefers to use refcounted tupdescs from the typcache, expanded
		 * records with the same rowtype will have pointer-equal tupdescs.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>var_tupdesc</name> <operator>!=</operator> <name>tupdesc</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>vtd_natts</name> <init>= <expr><name><name>var_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>newvalues</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>newnulls</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Need workspace arrays.  If vtd_natts is small enough, use local
			 * arrays to save doing a palloc.  Even if it's not small, we can
			 * allocate both the Datum and isnull arrays in one palloc chunk.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>vtd_natts</name> <operator>&lt;=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>newvalues_local</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>newvalues</name> <operator>=</operator> <name>newvalues_local</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>newnulls</name> <operator>=</operator> <name>newnulls_local</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>chunk</name> <operator>=</operator> <call><name>eval_mcontext_alloc</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
											<argument><expr><name>vtd_natts</name> <operator>*</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>newvalues</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <name>chunk</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>newnulls</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>chunk</name> <operator>+</operator> <name>vtd_natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/* Walk over destination columns */</comment>
			<expr_stmt><expr><name>anum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>fnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>fnum</name> <operator>&lt;</operator> <name>vtd_natts</name></expr>;</condition> <incr><expr><name>fnum</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>var_tupdesc</name></expr></argument>, <argument><expr><name>fnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>valtype</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int32</name></type>		<name>valtypmod</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* expanded_record_set_fields should ignore this column */</comment>
					<continue>continue;</continue>	<comment type="block">/* skip dropped column in record */</comment>
				</block_content>}</block></if></if_stmt>

				<while>while <condition>(<expr><name>anum</name> <operator>&lt;</operator> <name>td_natts</name> <operator>&amp;&amp;</operator>
					   <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>anum</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>anum</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>		<comment type="block">/* skip dropped column in tuple */</comment>

				<if_stmt><if>if <condition>(<expr><name>anum</name> <operator>&lt;</operator> <name>td_natts</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>value</name> <operator>=</operator> <name><name>values</name><index>[<expr><name>anum</name></expr>]</index></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>isnull</name> <operator>=</operator> <name><name>nulls</name><index>[<expr><name>anum</name></expr>]</index></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>valtype</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>anum</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>valtypmod</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>anum</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypmod</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>anum</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* no source for destination column */</comment>
					<expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>valtype</name> <operator>=</operator> <name>UNKNOWNOID</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>valtypmod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

					<comment type="block">/* When source value is missing */</comment>
					<if_stmt><if>if <condition>(<expr><name>strict_multiassignment_level</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>strict_multiassignment_level</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of source and target fields in assignment does not match"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<comment type="block">/* translator: %s represents a name of an extra check */</comment>
								 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s check of %s is active."</literal></expr></argument>,
										   <argument><expr><literal type="string">"strict_multi_assignment"</literal></expr></argument>,
										   <argument><expr><ternary><condition><expr><name>strict_multiassignment_level</name> <operator>==</operator> <name>ERROR</name></expr> ?</condition><then> <expr><literal type="string">"extra_errors"</literal></expr> </then><else>:
										   <expr><literal type="string">"extra_warnings"</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Make sure the query returns the exact list of columns."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></else></if_stmt>

				<comment type="block">/* Cast the new value to the right type, if needed. */</comment>
				<expr_stmt><expr><name><name>newvalues</name><index>[<expr><name>fnum</name></expr>]</index></name> <operator>=</operator> <call><name>exec_cast_value</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
												  <argument><expr><name>value</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>,
												  <argument><expr><name>valtype</name></expr></argument>,
												  <argument><expr><name>valtypmod</name></expr></argument>,
												  <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
												  <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newnulls</name><index>[<expr><name>fnum</name></expr>]</index></name> <operator>=</operator> <name>isnull</name></expr>;</expr_stmt>
			</block_content>}</block></for>

			<comment type="block">/*
			 * When strict_multiassignment extra check is active, then ensure
			 * there are no unassigned source attributes.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>strict_multiassignment_level</name> <operator>&amp;&amp;</operator> <name>anum</name> <operator>&lt;</operator> <name>td_natts</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* skip dropped columns in the source descriptor */</comment>
				<while>while <condition>(<expr><name>anum</name> <operator>&lt;</operator> <name>td_natts</name> <operator>&amp;&amp;</operator>
					   <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>anum</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>anum</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

				<if_stmt><if>if <condition>(<expr><name>anum</name> <operator>&lt;</operator> <name>td_natts</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>strict_multiassignment_level</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of source and target fields in assignment does not match"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					<comment type="block">/* translator: %s represents a name of an extra check */</comment>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s check of %s is active."</literal></expr></argument>,
									   <argument><expr><literal type="string">"strict_multi_assignment"</literal></expr></argument>,
									   <argument><expr><ternary><condition><expr><name>strict_multiassignment_level</name> <operator>==</operator> <name>ERROR</name></expr> ?</condition><then> <expr><literal type="string">"extra_errors"</literal></expr> </then><else>:
									   <expr><literal type="string">"extra_warnings"</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Make sure the query returns the exact list of columns."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>values</name> <operator>=</operator> <name>newvalues</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>nulls</name> <operator>=</operator> <name>newnulls</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Insert the coerced field values into the new expanded record */</comment>
		<expr_stmt><expr><call><name>expanded_record_set_fields</name><argument_list>(<argument><expr><name>newerh</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>atomic</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Complete the assignment */</comment>
		<expr_stmt><expr><call><name>assign_record_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>, <argument><expr><name>newerh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* newerh should not have been passed in non-RECORD cases */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newerh</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For a row, we assign the individual field values to the variables the
	 * row points to.
	 *
	 * NOTE: both this code and the record code above silently ignore extra
	 * columns in the source and assume NULL for missing columns.  This is
	 * pretty dubious but it's the historical behavior.
	 *
	 * If we have no input data at all, we'll assign NULL to all columns of
	 * the row variable.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_ROW</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PLpgSQL_row</name> <modifier>*</modifier></type><name>row</name> <init>= <expr><operator>(</operator><name>PLpgSQL_row</name> <operator>*</operator><operator>)</operator> <name>target</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>anum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>fnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>fnum</name> <operator>&lt;</operator> <name><name>row</name><operator>-&gt;</operator><name>nfields</name></name></expr>;</condition> <incr><expr><name>fnum</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>valtype</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type>		<name>valtypmod</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>row</name><operator>-&gt;</operator><name>varnos</name><index>[<expr><name>fnum</name></expr>]</index></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

			<while>while <condition>(<expr><name>anum</name> <operator>&lt;</operator> <name>td_natts</name> <operator>&amp;&amp;</operator>
				   <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>anum</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>anum</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>			<comment type="block">/* skip dropped column in tuple */</comment>

			<if_stmt><if>if <condition>(<expr><name>anum</name> <operator>&lt;</operator> <name>td_natts</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>value</name> <operator>=</operator> <name><name>values</name><index>[<expr><name>anum</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>isnull</name> <operator>=</operator> <name><name>nulls</name><index>[<expr><name>anum</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>valtype</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>anum</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>valtypmod</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>anum</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypmod</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>anum</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* no source for destination column */</comment>
				<expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>valtype</name> <operator>=</operator> <name>UNKNOWNOID</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>valtypmod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>strict_multiassignment_level</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>strict_multiassignment_level</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of source and target fields in assignment does not match"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					<comment type="block">/* translator: %s represents a name of an extra check */</comment>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s check of %s is active."</literal></expr></argument>,
									   <argument><expr><literal type="string">"strict_multi_assignment"</literal></expr></argument>,
									   <argument><expr><ternary><condition><expr><name>strict_multiassignment_level</name> <operator>==</operator> <name>ERROR</name></expr> ?</condition><then> <expr><literal type="string">"extra_errors"</literal></expr> </then><else>:
									   <expr><literal type="string">"extra_warnings"</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Make sure the query returns the exact list of columns."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>exec_assign_value</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_datum</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>,
							  <argument><expr><name>value</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>valtype</name></expr></argument>, <argument><expr><name>valtypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * When strict_multiassignment extra check is active, ensure there are
		 * no unassigned source attributes.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>strict_multiassignment_level</name> <operator>&amp;&amp;</operator> <name>anum</name> <operator>&lt;</operator> <name>td_natts</name></expr>)</condition>
		<block>{<block_content>
			<while>while <condition>(<expr><name>anum</name> <operator>&lt;</operator> <name>td_natts</name> <operator>&amp;&amp;</operator>
				   <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>anum</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>anum</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>			<comment type="block">/* skip dropped column in tuple */</comment>

			<if_stmt><if>if <condition>(<expr><name>anum</name> <operator>&lt;</operator> <name>td_natts</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>strict_multiassignment_level</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of source and target fields in assignment does not match"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				<comment type="block">/* translator: %s represents a name of an extra check */</comment>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s check of %s is active."</literal></expr></argument>,
								   <argument><expr><literal type="string">"strict_multi_assignment"</literal></expr></argument>,
								   <argument><expr><ternary><condition><expr><name>strict_multiassignment_level</name> <operator>==</operator> <name>ERROR</name></expr> ?</condition><then> <expr><literal type="string">"extra_errors"</literal></expr> </then><else>:
								   <expr><literal type="string">"extra_warnings"</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Make sure the query returns the exact list of columns."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported target type: %d"</literal></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>dtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * compatible_tupdescs: detect whether two tupdescs are physically compatible
 *
 * TRUE indicates that a tuple satisfying src_tupdesc can be used directly as
 * a value for a composite variable using dst_tupdesc.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>compatible_tupdescs</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>src_tupdesc</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>dst_tupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Possibly we could allow src_tupdesc to have extra columns? */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dst_tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>!=</operator> <name><name>src_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>dst_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>dattr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>dst_tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>sattr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>src_tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>dattr</name><operator>-&gt;</operator><name>attisdropped</name></name> <operator>!=</operator> <name><name>sattr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dattr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Normal columns must match by type and typmod */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>dattr</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>!=</operator> <name><name>sattr</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>||</operator>
				<operator>(</operator><name><name>dattr</name><operator>-&gt;</operator><name>atttypmod</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				 <name><name>dattr</name><operator>-&gt;</operator><name>atttypmod</name></name> <operator>!=</operator> <name><name>sattr</name><operator>-&gt;</operator><name>atttypmod</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Dropped columns are OK as long as length/alignment match */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>dattr</name><operator>-&gt;</operator><name>attlen</name></name> <operator>!=</operator> <name><name>sattr</name><operator>-&gt;</operator><name>attlen</name></name> <operator>||</operator>
				<name><name>dattr</name><operator>-&gt;</operator><name>attalign</name></name> <operator>!=</operator> <name><name>sattr</name><operator>-&gt;</operator><name>attalign</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * make_tuple_from_row		Make a tuple from the values of a row object
 *
 * A NULL return indicates rowtype mismatch; caller must raise suitable error
 *
 * The result tuple is freshly palloc'd in caller's context.  Some junk
 * may be left behind in eval_mcontext, too.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>make_tuple_from_row</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
					<parameter><decl><type><name>PLpgSQL_row</name> <modifier>*</modifier></type><name>row</name></decl></parameter>,
					<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>natts</name> <init>= <expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>dvalues</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>natts</name> <operator>!=</operator> <name><name>row</name><operator>-&gt;</operator><name>nfields</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>dvalues</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>eval_mcontext_alloc0</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nulls</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>eval_mcontext_alloc</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>fieldtypeid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>fieldtypmod</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* leave the column as null */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>exec_eval_datum</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>row</name><operator>-&gt;</operator><name>varnos</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>fieldtypeid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fieldtypmod</name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name><name>dvalues</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>fieldtypeid</name> <operator>!=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
		<comment type="block">/* XXX should we insist on typmod match, too? */</comment>
	</block_content>}</block></for>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>dvalues</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * deconstruct_composite_datum		extract tuple+tupdesc from composite Datum
 *
 * The caller must supply a HeapTupleData variable, in which we set up a
 * tuple header pointing to the composite datum's body.  To make the tuple
 * value outlive that variable, caller would need to apply heap_copytuple...
 * but current callers only need a short-lived tuple value anyway.
 *
 * Returns a pointer to the TupleDesc of the datum's rowtype.
 * Caller is responsible for calling ReleaseTupleDesc when done with it.
 *
 * Note: it's caller's responsibility to be sure value is of composite type.
 * Also, best to call this in a short-lived context, as it might leak memory.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleDesc</name></type>
<name>deconstruct_composite_datum</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>HeapTupleData</name> <modifier>*</modifier></type><name>tmptup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>td</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>tupType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>tupTypmod</name></decl>;</decl_stmt>

	<comment type="block">/* Get tuple body (note this could involve detoasting) */</comment>
	<expr_stmt><expr><name>td</name> <operator>=</operator> <call><name>DatumGetHeapTupleHeader</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build a temporary HeapTuple control structure */</comment>
	<expr_stmt><expr><name><name>tmptup</name><operator>-&gt;</operator><name>t_len</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetDatumLength</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tmptup</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmptup</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmptup</name><operator>-&gt;</operator><name>t_data</name></name> <operator>=</operator> <name>td</name></expr>;</expr_stmt>

	<comment type="block">/* Extract rowtype info and find a tupdesc */</comment>
	<expr_stmt><expr><name>tupType</name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypeId</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupTypmod</name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypMod</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>lookup_rowtype_tupdesc</name><argument_list>(<argument><expr><name>tupType</name></expr></argument>, <argument><expr><name>tupTypmod</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * exec_move_row_from_datum		Move a composite Datum into a record or row
 *
 * This is equivalent to deconstruct_composite_datum() followed by
 * exec_move_row(), but we can optimize things if the Datum is an
 * expanded-record reference.
 *
 * Note: it's caller's responsibility to be sure value is of composite type.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_move_row_from_datum</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
						 <parameter><decl><type><name>PLpgSQL_variable</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
						 <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Check to see if source is an expanded record */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_EXPANDED</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>erh</name> <init>= <expr><operator>(</operator><name>ExpandedRecordHeader</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetEOHP</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>newerh</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>erh</name><operator>-&gt;</operator><name>er_magic</name></name> <operator>==</operator> <name>ER_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* These cases apply if the target is record not row... */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_REC</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name> <init>= <expr><operator>(</operator><name>PLpgSQL_rec</name> <operator>*</operator><operator>)</operator> <name>target</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * If it's the same record already stored in the variable, do
			 * nothing.  This would happen only in silly cases like "r := r",
			 * but we need some check to avoid possibly freeing the variable's
			 * live value below.  Note that this applies even if what we have
			 * is a R/O pointer.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>erh</name> <operator>==</operator> <name><name>rec</name><operator>-&gt;</operator><name>erh</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Make sure rec-&gt;rectypeid is up-to-date before using it.
			 */</comment>
			<expr_stmt><expr><call><name>revalidate_rectypeid</name><argument_list>(<argument><expr><name>rec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If we have a R/W pointer, we're allowed to just commandeer
			 * ownership of the expanded record.  If it's of the right type to
			 * put into the record variable, do that.  (Note we don't accept
			 * an expanded record of a composite-domain type as a RECORD
			 * value.  We'll treat it as the base composite type instead;
			 * compare logic in make_expanded_record_for_rec.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_EXPANDED_RW</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<operator>(</operator><name><name>rec</name><operator>-&gt;</operator><name>rectypeid</name></name> <operator>==</operator> <name><name>erh</name><operator>-&gt;</operator><name>er_decltypeid</name></name> <operator>||</operator>
				 <operator>(</operator><name><name>rec</name><operator>-&gt;</operator><name>rectypeid</name></name> <operator>==</operator> <name>RECORDOID</name> <operator>&amp;&amp;</operator>
				  <operator>!</operator><call><name>ExpandedRecordIsDomain</name><argument_list>(<argument><expr><name>erh</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>assign_record_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>, <argument><expr><name>erh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * If we already have an expanded record object in the target
			 * variable, and the source record contains a valid tuple
			 * representation with the right rowtype, then we can skip making
			 * a new expanded record and just assign the tuple with
			 * expanded_record_set_tuple.  (We can't do the equivalent if we
			 * have to do field-by-field assignment, since that wouldn't be
			 * atomic if there's an error.)  We consider that there's a
			 * rowtype match only if it's the same named composite type or
			 * same registered rowtype; checking for matches of anonymous
			 * rowtypes would be more expensive than this is worth.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>erh</name></name> <operator>&amp;&amp;</operator>
				<operator>(</operator><name><name>erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>ER_FLAG_FVALUE_VALID</name><operator>)</operator> <operator>&amp;&amp;</operator>
				<name><name>erh</name><operator>-&gt;</operator><name>er_typeid</name></name> <operator>==</operator> <name><name>rec</name><operator>-&gt;</operator><name>erh</name><operator>-&gt;</operator><name>er_typeid</name></name> <operator>&amp;&amp;</operator>
				<operator>(</operator><name><name>erh</name><operator>-&gt;</operator><name>er_typeid</name></name> <operator>!=</operator> <name>RECORDOID</name> <operator>||</operator>
				 <operator>(</operator><name><name>erh</name><operator>-&gt;</operator><name>er_typmod</name></name> <operator>==</operator> <name><name>rec</name><operator>-&gt;</operator><name>erh</name><operator>-&gt;</operator><name>er_typmod</name></name> <operator>&amp;&amp;</operator>
				  <name><name>erh</name><operator>-&gt;</operator><name>er_typmod</name></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>expanded_record_set_tuple</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>erh</name></name></expr></argument>, <argument><expr><name><name>erh</name><operator>-&gt;</operator><name>fvalue</name></name></expr></argument>,
										  <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>atomic</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Otherwise we're gonna need a new expanded record object.  Make
			 * it here in hopes of piggybacking on the source object's
			 * previous typcache lookup.
			 */</comment>
			<expr_stmt><expr><name>newerh</name> <operator>=</operator> <call><name>make_expanded_record_for_rec</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>erh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If the expanded record contains a valid tuple representation,
			 * and we don't need rowtype conversion, then just copying the
			 * tuple is probably faster than field-by-field processing.  (This
			 * isn't duplicative of the previous check, since here we will
			 * catch the case where the record variable was previously empty.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>ER_FLAG_FVALUE_VALID</name><operator>)</operator> <operator>&amp;&amp;</operator>
				<operator>(</operator><name><name>rec</name><operator>-&gt;</operator><name>rectypeid</name></name> <operator>==</operator> <name>RECORDOID</name> <operator>||</operator>
				 <name><name>rec</name><operator>-&gt;</operator><name>rectypeid</name></name> <operator>==</operator> <name><name>erh</name><operator>-&gt;</operator><name>er_typeid</name></name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>expanded_record_set_tuple</name><argument_list>(<argument><expr><name>newerh</name></expr></argument>, <argument><expr><name><name>erh</name><operator>-&gt;</operator><name>fvalue</name></name></expr></argument>,
										  <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>atomic</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>assign_record_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>, <argument><expr><name>newerh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Need to special-case empty source record, else code below would
			 * leak newerh.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>ExpandedRecordIsEmpty</name><argument_list>(<argument><expr><name>erh</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Set newerh to a row of NULLs */</comment>
				<expr_stmt><expr><call><name>deconstruct_expanded_record</name><argument_list>(<argument><expr><name>newerh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>assign_record_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>, <argument><expr><name>newerh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>						<comment type="block">/* end of record-target-only cases */</comment>

		<comment type="block">/*
		 * If the source expanded record is empty, we should treat that like a
		 * NULL tuple value.  (We're unlikely to see such a case, but we must
		 * check this; deconstruct_expanded_record would cause a change of
		 * logical state, which is not OK.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ExpandedRecordIsEmpty</name><argument_list>(<argument><expr><name>erh</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>exec_move_row</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><call><name>expanded_record_get_tupdesc</name><argument_list>(<argument><expr><name>erh</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Otherwise, ensure that the source record is deconstructed, and
		 * assign from its field values.
		 */</comment>
		<expr_stmt><expr><call><name>deconstruct_expanded_record</name><argument_list>(<argument><expr><name>erh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exec_move_row_from_fields</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>newerh</name></expr></argument>,
								  <argument><expr><name><name>erh</name><operator>-&gt;</operator><name>dvalues</name></name></expr></argument>, <argument><expr><name><name>erh</name><operator>-&gt;</operator><name>dnulls</name></name></expr></argument>,
								  <argument><expr><call><name>expanded_record_get_tupdesc</name><argument_list>(<argument><expr><name>erh</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Nope, we've got a plain composite Datum.  Deconstruct it; but we
		 * don't use deconstruct_composite_datum(), because we may be able to
		 * skip calling lookup_rowtype_tupdesc().
		 */</comment>
		<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>td</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>tmptup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>tupType</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>tupTypmod</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

		<comment type="block">/* Ensure that any detoasted data winds up in the eval_mcontext */</comment>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Get tuple body (note this could involve detoasting) */</comment>
		<expr_stmt><expr><name>td</name> <operator>=</operator> <call><name>DatumGetHeapTupleHeader</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Build a temporary HeapTuple control structure */</comment>
		<expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetDatumLength</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tmptup</name><operator>.</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_tableOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <name>td</name></expr>;</expr_stmt>

		<comment type="block">/* Extract rowtype info */</comment>
		<expr_stmt><expr><name>tupType</name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypeId</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tupTypmod</name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypMod</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Now, if the target is record not row, maybe we can optimize ... */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_REC</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name> <init>= <expr><operator>(</operator><name>PLpgSQL_rec</name> <operator>*</operator><operator>)</operator> <name>target</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * If we already have an expanded record object in the target
			 * variable, and the source datum has a matching rowtype, then we
			 * can skip making a new expanded record and just assign the tuple
			 * with expanded_record_set_tuple.  We consider that there's a
			 * rowtype match only if it's the same named composite type or
			 * same registered rowtype.  (Checking to reject an anonymous
			 * rowtype here should be redundant, but let's be safe.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>erh</name></name> <operator>&amp;&amp;</operator>
				<name>tupType</name> <operator>==</operator> <name><name>rec</name><operator>-&gt;</operator><name>erh</name><operator>-&gt;</operator><name>er_typeid</name></name> <operator>&amp;&amp;</operator>
				<operator>(</operator><name>tupType</name> <operator>!=</operator> <name>RECORDOID</name> <operator>||</operator>
				 <operator>(</operator><name>tupTypmod</name> <operator>==</operator> <name><name>rec</name><operator>-&gt;</operator><name>erh</name><operator>-&gt;</operator><name>er_typmod</name></name> <operator>&amp;&amp;</operator>
				  <name>tupTypmod</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>expanded_record_set_tuple</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>erh</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmptup</name></expr></argument>,
										  <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>atomic</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * If the source datum has a rowtype compatible with the target
			 * variable, just build a new expanded record and assign the tuple
			 * into it.  Using make_expanded_record_from_typeid() here saves
			 * one typcache lookup compared to the code below.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>rectypeid</name></name> <operator>==</operator> <name>RECORDOID</name> <operator>||</operator> <name><name>rec</name><operator>-&gt;</operator><name>rectypeid</name></name> <operator>==</operator> <name>tupType</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>newerh</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>MemoryContext</name></type> <name>mcontext</name> <init>= <expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>newerh</name> <operator>=</operator> <call><name>make_expanded_record_from_typeid</name><argument_list>(<argument><expr><name>tupType</name></expr></argument>, <argument><expr><name>tupTypmod</name></expr></argument>,
														  <argument><expr><name>mcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>expanded_record_set_tuple</name><argument_list>(<argument><expr><name>newerh</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmptup</name></expr></argument>,
										  <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>atomic</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>assign_record_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>, <argument><expr><name>newerh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Otherwise, we're going to need conversion, so fall through to
			 * do it the hard way.
			 */</comment>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * ROW target, or unoptimizable RECORD target, so we have to expend a
		 * lookup to obtain the source datum's tupdesc.
		 */</comment>
		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc</name><argument_list>(<argument><expr><name>tupType</name></expr></argument>, <argument><expr><name>tupTypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Do the move */</comment>
		<expr_stmt><expr><call><name>exec_move_row</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmptup</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Release tupdesc usage count */</comment>
		<expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * If we have not created an expanded record to hold the record variable's
 * value, do so.  The expanded record will be "empty", so this does not
 * change the logical state of the record variable: it's still NULL.
 * However, now we'll have a tupdesc with which we can e.g. look up fields.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>instantiate_empty_record_variable</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>erh</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* else caller error */</comment>

	<comment type="block">/* If declared type is RECORD, we can't instantiate */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>rectypeid</name></name> <operator>==</operator> <name>RECORDOID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"record \"%s\" is not assigned yet"</literal></expr></argument>, <argument><expr><name><name>rec</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The tuple structure of a not-yet-assigned record is indeterminate."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Make sure rec-&gt;rectypeid is up-to-date before using it */</comment>
	<expr_stmt><expr><call><name>revalidate_rectypeid</name><argument_list>(<argument><expr><name>rec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* OK, do it */</comment>
	<expr_stmt><expr><name><name>rec</name><operator>-&gt;</operator><name>erh</name></name> <operator>=</operator> <call><name>make_expanded_record_from_typeid</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>rectypeid</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
												<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>datum_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * convert_value_to_string			Convert a non-null Datum to C string
 *
 * Note: the result is in the estate's eval_mcontext, and will be cleared
 * by the next exec_eval_cleanup() call.  The invoked output function might
 * leave additional cruft there as well, so just pfree'ing the result string
 * would not be enough to avoid memory leaks if we did not do it like this.
 * In most usages the Datum being passed in is also in that context (if
 * pass-by-reference) and so an exec_eval_cleanup() call is needed anyway.
 *
 * Note: not caching the conversion function lookup is bad for performance.
 * However, this function isn't currently used in any places where an extra
 * catalog lookup or two seems like a big deal.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>convert_value_to_string</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>valtype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typoutput</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typIsVarlena</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name>valtype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typoutput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typIsVarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>typoutput</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * exec_cast_value			Cast a value if required
 *
 * Note that *isnull is an input and also an output parameter.  While it's
 * unlikely that a cast operation would produce null from non-null or vice
 * versa, that could happen in principle.
 *
 * Note: the estate's eval_mcontext is used for temporary storage, and may
 * also contain the result Datum if we have to do a conversion to a pass-
 * by-reference data type.  Be sure to do an exec_eval_cleanup() call when
 * done with the result.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>exec_cast_value</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
				<parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>,
				<parameter><decl><type><name>Oid</name></type> <name>valtype</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>valtypmod</name></decl></parameter>,
				<parameter><decl><type><name>Oid</name></type> <name>reqtype</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>reqtypmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If the type of the given value isn't what's requested, convert it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>valtype</name> <operator>!=</operator> <name>reqtype</name> <operator>||</operator>
		<operator>(</operator><name>valtypmod</name> <operator>!=</operator> <name>reqtypmod</name> <operator>&amp;&amp;</operator> <name>reqtypmod</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>plpgsql_CastHashEntry</name> <modifier>*</modifier></type><name>cast_entry</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>cast_entry</name> <operator>=</operator> <call><name>get_cast_hashentry</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
										<argument><expr><name>valtype</name></expr></argument>, <argument><expr><name>valtypmod</name></expr></argument>,
										<argument><expr><name>reqtype</name></expr></argument>, <argument><expr><name>reqtypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cast_entry</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>eval_econtext</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>caseValue_datum</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>caseValue_isNull</name></name> <operator>=</operator> <operator>*</operator><name>isnull</name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>cast_entry</name><operator>-&gt;</operator><name>cast_in_use</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name><name>cast_entry</name><operator>-&gt;</operator><name>cast_exprstate</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>,
								 <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>cast_entry</name><operator>-&gt;</operator><name>cast_in_use</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * get_cast_hashentry			Look up how to perform a type cast
 *
 * Returns a plpgsql_CastHashEntry if an expression has to be evaluated,
 * or NULL if the cast is a mere no-op relabeling.  If there's work to be
 * done, the cast_exprstate field contains an expression evaluation tree
 * based on a CaseTestExpr input, and the cast_in_use field should be set
 * true while executing it.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>plpgsql_CastHashEntry</name> <modifier>*</modifier></type>
<name>get_cast_hashentry</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
				   <parameter><decl><type><name>Oid</name></type> <name>srctype</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>srctypmod</name></decl></parameter>,
				   <parameter><decl><type><name>Oid</name></type> <name>dsttype</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>dsttypmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>plpgsql_CastHashKey</name></type> <name>cast_key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>plpgsql_CastHashEntry</name> <modifier>*</modifier></type><name>cast_entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LocalTransactionId</name></type> <name>curlxid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/* Look for existing entry */</comment>
	<expr_stmt><expr><name><name>cast_key</name><operator>.</operator><name>srctype</name></name> <operator>=</operator> <name>srctype</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cast_key</name><operator>.</operator><name>dsttype</name></name> <operator>=</operator> <name>dsttype</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cast_key</name><operator>.</operator><name>srctypmod</name></name> <operator>=</operator> <name>srctypmod</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cast_key</name><operator>.</operator><name>dsttypmod</name></name> <operator>=</operator> <name>dsttypmod</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cast_entry</name> <operator>=</operator> <operator>(</operator><name>plpgsql_CastHashEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>cast_hash</name></name></expr></argument>,
													   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>cast_key</name></expr></argument>,
													   <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>					<comment type="block">/* initialize if new entry */</comment>
		<expr_stmt><expr><name><name>cast_entry</name><operator>-&gt;</operator><name>cast_cexpr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cast_entry</name><operator>-&gt;</operator><name>cast_cexpr</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<operator>!</operator><name><name>cast_entry</name><operator>-&gt;</operator><name>cast_cexpr</name><operator>-&gt;</operator><name>is_valid</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We've not looked up this coercion before, or we have but the cached
		 * expression has been invalidated.
		 */</comment>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>cast_expr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CachedExpression</name> <modifier>*</modifier></type><name>cast_cexpr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CaseTestExpr</name> <modifier>*</modifier></type><name>placeholder</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Drop old cached expression if there is one.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cast_entry</name><operator>-&gt;</operator><name>cast_cexpr</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>FreeCachedExpression</name><argument_list>(<argument><expr><name><name>cast_entry</name><operator>-&gt;</operator><name>cast_cexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cast_entry</name><operator>-&gt;</operator><name>cast_cexpr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Since we could easily fail (no such coercion), construct a
		 * temporary coercion expression tree in the short-lived
		 * eval_mcontext, then if successful save it as a CachedExpression.
		 */</comment>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We use a CaseTestExpr as the base of the coercion tree, since it's
		 * very cheap to insert the source value for that.
		 */</comment>
		<expr_stmt><expr><name>placeholder</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CaseTestExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>placeholder</name><operator>-&gt;</operator><name>typeId</name></name> <operator>=</operator> <name>srctype</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>placeholder</name><operator>-&gt;</operator><name>typeMod</name></name> <operator>=</operator> <name>srctypmod</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>placeholder</name><operator>-&gt;</operator><name>collation</name></name> <operator>=</operator> <call><name>get_typcollation</name><argument_list>(<argument><expr><name>srctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Apply coercion.  We use ASSIGNMENT coercion because that's the
		 * closest match to plpgsql's historical behavior; in particular,
		 * EXPLICIT coercion would allow silent truncation to a destination
		 * varchar/bpchar's length, which we do not want.
		 *
		 * If source type is UNKNOWN, coerce_to_target_type will fail (it only
		 * expects to see that for Const input nodes), so don't call it; we'll
		 * apply CoerceViaIO instead.  Likewise, it doesn't currently work for
		 * coercing RECORD to some other type, so skip for that too.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>srctype</name> <operator>==</operator> <name>UNKNOWNOID</name> <operator>||</operator> <name>srctype</name> <operator>==</operator> <name>RECORDOID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cast_expr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>cast_expr</name> <operator>=</operator> <call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
											  <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>placeholder</name></expr></argument>, <argument><expr><name>srctype</name></expr></argument>,
											  <argument><expr><name>dsttype</name></expr></argument>, <argument><expr><name>dsttypmod</name></expr></argument>,
											  <argument><expr><name>COERCION_ASSIGNMENT</name></expr></argument>,
											  <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
											  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * If there's no cast path according to the parser, fall back to using
		 * an I/O coercion; this is semantically dubious but matches plpgsql's
		 * historical behavior.  We would need something of the sort for
		 * UNKNOWN literals in any case.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>cast_expr</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CoerceViaIO</name> <modifier>*</modifier></type><name>iocoerce</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CoerceViaIO</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>iocoerce</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>placeholder</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>iocoerce</name><operator>-&gt;</operator><name>resulttype</name></name> <operator>=</operator> <name>dsttype</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>iocoerce</name><operator>-&gt;</operator><name>resultcollid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>iocoerce</name><operator>-&gt;</operator><name>coerceformat</name></name> <operator>=</operator> <name>COERCE_IMPLICIT_CAST</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>iocoerce</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>cast_expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>iocoerce</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>dsttypmod</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>cast_expr</name> <operator>=</operator> <call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
												  <argument><expr><name>cast_expr</name></expr></argument>, <argument><expr><name>dsttype</name></expr></argument>,
												  <argument><expr><name>dsttype</name></expr></argument>, <argument><expr><name>dsttypmod</name></expr></argument>,
												  <argument><expr><name>COERCION_ASSIGNMENT</name></expr></argument>,
												  <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
												  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Note: we don't bother labeling the expression tree with collation */</comment>

		<comment type="block">/* Plan the expression and build a CachedExpression */</comment>
		<expr_stmt><expr><name>cast_cexpr</name> <operator>=</operator> <call><name>GetCachedExpression</name><argument_list>(<argument><expr><name>cast_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cast_expr</name> <operator>=</operator> <name><name>cast_cexpr</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>

		<comment type="block">/* Detect whether we have a no-op (RelabelType) coercion */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>cast_expr</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>cast_expr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name> <operator>==</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>placeholder</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cast_expr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Now we can fill in the hashtable entry. */</comment>
		<expr_stmt><expr><name><name>cast_entry</name><operator>-&gt;</operator><name>cast_cexpr</name></name> <operator>=</operator> <name>cast_cexpr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cast_entry</name><operator>-&gt;</operator><name>cast_expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>cast_expr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cast_entry</name><operator>-&gt;</operator><name>cast_exprstate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cast_entry</name><operator>-&gt;</operator><name>cast_in_use</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cast_entry</name><operator>-&gt;</operator><name>cast_lxid</name></name> <operator>=</operator> <name>InvalidLocalTransactionId</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Done if we have determined that this is a no-op cast. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cast_entry</name><operator>-&gt;</operator><name>cast_expr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Prepare the expression for execution, if it's not been done already in
	 * the current transaction; also, if it's marked busy in the current
	 * transaction, abandon that expression tree and build a new one, so as to
	 * avoid potential problems with recursive cast expressions and failed
	 * executions.  (We will leak some memory intra-transaction if that
	 * happens a lot, but we don't expect it to.)  It's okay to update the
	 * hash table with the new tree because all plpgsql functions within a
	 * given transaction share the same simple_eval_estate.  (Well, regular
	 * functions do; DO blocks have private simple_eval_estates, and private
	 * cast hash tables to go with them.)
	 */</comment>
	<expr_stmt><expr><name>curlxid</name> <operator>=</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>lxid</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>cast_entry</name><operator>-&gt;</operator><name>cast_lxid</name></name> <operator>!=</operator> <name>curlxid</name> <operator>||</operator> <name><name>cast_entry</name><operator>-&gt;</operator><name>cast_in_use</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>simple_eval_estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cast_entry</name><operator>-&gt;</operator><name>cast_exprstate</name></name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><name><name>cast_entry</name><operator>-&gt;</operator><name>cast_expr</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cast_entry</name><operator>-&gt;</operator><name>cast_in_use</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cast_entry</name><operator>-&gt;</operator><name>cast_lxid</name></name> <operator>=</operator> <name>curlxid</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>cast_entry</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * exec_simple_check_plan -		Check if a plan is simple enough to
 *								be evaluated by ExecEvalExpr() instead
 *								of SPI.
 *
 * Note: the refcount manipulations in this function assume that expr-&gt;plan
 * is a "saved" SPI plan.  That's a bit annoying from the caller's standpoint,
 * but it's otherwise difficult to avoid leaking the plan on failure.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_simple_check_plan</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>plansources</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>plansource</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CachedPlan</name> <modifier>*</modifier></type><name>cplan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Initialize to "not simple".
	 */</comment>
	<expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_expr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check the analyzed-and-rewritten form of the query to see if we will be
	 * able to treat it as a simple expression.  Since this function is only
	 * called immediately after creating the CachedPlanSource, we need not
	 * worry about the query being stale.
	 */</comment>

	<comment type="block">/*
	 * We can only test queries that resulted in exactly one CachedPlanSource
	 */</comment>
	<expr_stmt><expr><name>plansources</name> <operator>=</operator> <call><name>SPI_plan_get_plan_sources</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>plansources</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>plansource</name> <operator>=</operator> <operator>(</operator><name>CachedPlanSource</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>plansources</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * 1. There must be one single querytree.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>query_list</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>query</name> <operator>=</operator> <operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>query_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * 2. It must be a plain SELECT query without any input tables
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * 3. Can't have any subplans, aggregates, qual clauses either.  (These
	 * tests should generally match what inline_function() checks before
	 * inlining a SQL function; otherwise, inlining could change our
	 * conclusion about whether an expression is simple, which we don't want.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>cteList</name></name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>windowClause</name></name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>setOperations</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * 4. The query must have a single attribute as result
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * OK, we can treat it as a simple plan.
	 *
	 * Get the generic plan for the query.  If replanning is needed, do that
	 * work in the eval_mcontext.  (Note that replanning could throw an error,
	 * in which case the expr is left marked "not simple", which is fine.)
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cplan</name> <operator>=</operator> <call><name>SPI_plan_get_cached_plan</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Can't fail, because we checked for a single CachedPlanSource above */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cplan</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Verify that plancache.c thinks the plan is simple enough to use
	 * CachedPlanIsSimplyValid.  Given the restrictions above, it's unlikely
	 * that this could fail, but if it does, just treat plan as not simple. On
	 * success, save a refcount on the plan in the simple-expression resowner.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>CachedPlanAllowsSimpleValidityCheck</name><argument_list>(<argument><expr><name>plansource</name></expr></argument>, <argument><expr><name>cplan</name></expr></argument>,
											<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>simple_eval_resowner</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Remember that we have the refcount */</comment>
		<expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_plansource</name></name> <operator>=</operator> <name>plansource</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_plan</name></name> <operator>=</operator> <name>cplan</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_plan_lxid</name></name> <operator>=</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>lxid</name></name></expr>;</expr_stmt>

		<comment type="block">/* Share the remaining work with the replan code path */</comment>
		<expr_stmt><expr><call><name>exec_save_simple_expr</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>cplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Release the plan refcount obtained by SPI_plan_get_cached_plan.  (This
	 * refcount is held by the wrong resowner, so we can't just repurpose it.)
	 */</comment>
	<expr_stmt><expr><call><name>ReleaseCachedPlan</name><argument_list>(<argument><expr><name>cplan</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * exec_save_simple_expr --- extract simple expression from CachedPlan
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_save_simple_expr</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>CachedPlan</name> <modifier>*</modifier></type><name>cplan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>tle_expr</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Given the checks that exec_simple_check_plan did, none of the Asserts
	 * here should ever fail.
	 */</comment>

	<comment type="block">/* Extract the single PlannedStmt */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>cplan</name><operator>-&gt;</operator><name>stmt_list</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>stmt</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>, <argument><expr><name><name>cplan</name><operator>-&gt;</operator><name>stmt_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Ordinarily, the plan node should be a simple Result.  However, if
	 * force_parallel_mode is on, the planner might've stuck a Gather node
	 * atop that.  The simplest way to deal with this is to look through the
	 * Gather node.  The Gather node's tlist would normally contain a Var
	 * referencing the child node's output, but it could also be a Param, or
	 * it could be a Const that setrefs.c copied as-is.
	 */</comment>
	<expr_stmt><expr><name>plan</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>planTree</name></name></expr>;</expr_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/* Extract the single tlist expression */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tle_expr</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>, <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>expr</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				   <name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				   <name><name>plan</name><operator>-&gt;</operator><name>initPlan</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				   <name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				   <operator>(</operator><operator>(</operator><name>Result</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>resconstantqual</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>Gather</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				   <name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				   <name><name>plan</name><operator>-&gt;</operator><name>initPlan</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				   <name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* If setrefs.c copied up a Const, no need to look further */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>tle_expr</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<comment type="block">/* Otherwise, it had better be a Param or an outer Var */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>tle_expr</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name>tle_expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
											<operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>tle_expr</name><operator>)</operator><operator>-&gt;</operator><name>varno</name> <operator>==</operator> <name>OUTER_VAR</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Descend to the child node */</comment>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected plan node type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Save the simple expression, and initialize state to "not valid in
	 * current transaction".
	 */</comment>
	<expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_expr</name></name> <operator>=</operator> <name>tle_expr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_state</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_in_use</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_lxid</name></name> <operator>=</operator> <name>InvalidLocalTransactionId</name></expr>;</expr_stmt>
	<comment type="block">/* Also stash away the expression result type */</comment>
	<expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_type</name></name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>tle_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_typmod</name></name> <operator>=</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>tle_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* We also want to remember if it is immutable or not */</comment>
	<expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_mutable</name></name> <operator>=</operator> <call><name>contain_mutable_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>tle_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * exec_check_rw_parameter --- can we pass expanded object as read/write param?
 *
 * If we have an assignment like "x := array_append(x, foo)" in which the
 * top-level function is trusted not to corrupt its argument in case of an
 * error, then when x has an expanded object as value, it is safe to pass the
 * value as a read/write pointer and let the function modify the value
 * in-place.
 *
 * This function checks for a safe expression, and sets expr-&gt;rwparam to the
 * dno of the target variable (x) if safe, or -1 if not safe.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_check_rw_parameter</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>target_dno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>funcid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>fargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Assume unsafe */</comment>
	<expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>rwparam</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the expression isn't simple, there's no point in trying to optimize
	 * (because the exec_run_select code path will flatten any expanded result
	 * anyway).  Even without that, this seems like a good safety restriction.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_expr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If target variable isn't referenced by expression, no need to look
	 * further.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>target_dno</name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>paramnos</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Top level of expression must be a simple FuncExpr or OpExpr.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_expr</name></name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>fexpr</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>expr_simple_expr</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>funcid</name> <operator>=</operator> <name><name>fexpr</name><operator>-&gt;</operator><name>funcid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>fargs</name> <operator>=</operator> <name><name>fexpr</name><operator>-&gt;</operator><name>args</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>expr_simple_expr</name></name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>opexpr</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>expr_simple_expr</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>funcid</name> <operator>=</operator> <name><name>opexpr</name><operator>-&gt;</operator><name>opfuncid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>fargs</name> <operator>=</operator> <name><name>opexpr</name><operator>-&gt;</operator><name>args</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return;</return></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * The top-level function must be one that we trust to be "safe".
	 * Currently we hard-wire the list, but it would be very desirable to
	 * allow extensions to mark their functions as safe ...
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>funcid</name> <operator>==</operator> <name>F_ARRAY_APPEND</name> <operator>||</operator>
		  <name>funcid</name> <operator>==</operator> <name>F_ARRAY_PREPEND</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The target variable (in the form of a Param) must only appear as a
	 * direct argument of the top-level function.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>fargs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* A Param is OK, whether it's the target variable or not */</comment>
		<if_stmt><if>if <condition>(<expr><name>arg</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<comment type="block">/* Otherwise, argument expression must not reference target */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>contains_target_param</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>target_dno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* OK, we can pass target as a read-write parameter */</comment>
	<expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>rwparam</name></name> <operator>=</operator> <name>target_dno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Recursively check for a Param referencing the target variable
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contains_target_param</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>target_dno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Param</name>	   <modifier>*</modifier></type><name>param</name> <init>= <expr><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>==</operator> <name>PARAM_EXTERN</name> <operator>&amp;&amp;</operator>
			<name><name>param</name><operator>-&gt;</operator><name>paramid</name></name> <operator>==</operator> <operator>*</operator><name>target_dno</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>contains_target_param</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>target_dno</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * exec_set_found			Set the global found variable to true/false
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_set_found</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>estate</name><operator>-&gt;</operator><name>found_varno</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assign_simple_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * plpgsql_create_econtext --- create an eval_econtext for the current function
 *
 * We may need to create a new shared_simple_eval_estate too, if there's not
 * one already for the current transaction.  The EState will be cleaned up at
 * transaction end.  Ditto for shared_simple_eval_resowner.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>plpgsql_create_econtext</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SimpleEcontextStackEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Create an EState for evaluation of simple expressions, if there's not
	 * one already in the current transaction.  The EState is made a child of
	 * TopTransactionContext so it will have the right lifespan.
	 *
	 * Note that this path is never taken when beginning a DO block; the
	 * required EState was already made by plpgsql_inline_handler.  However,
	 * if the DO block executes COMMIT or ROLLBACK, then we'll come here and
	 * make a shared EState to use for the rest of the DO block.  That's OK;
	 * see the comments for shared_simple_eval_estate.  (Note also that a DO
	 * block will continue to use its private cast hash table for the rest of
	 * the block.  That's okay for now, but it might cause problems someday.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>simple_eval_estate</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>shared_simple_eval_estate</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>shared_simple_eval_estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>simple_eval_estate</name></name> <operator>=</operator> <name>shared_simple_eval_estate</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Likewise for the simple-expression resource owner.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>simple_eval_resowner</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>shared_simple_eval_resowner</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>shared_simple_eval_resowner</name> <operator>=</operator>
				<call><name>ResourceOwnerCreate</name><argument_list>(<argument><expr><name>TopTransactionResourceOwner</name></expr></argument>,
									<argument><expr><literal type="string">"PL/pgSQL simple expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>simple_eval_resowner</name></name> <operator>=</operator> <name>shared_simple_eval_resowner</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Create a child econtext for the current function.
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_econtext</name></name> <operator>=</operator> <call><name>CreateExprContext</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>simple_eval_estate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make a stack entry so we can clean up the econtext at subxact end.
	 * Stack entries are kept in TopTransactionContext for simplicity.
	 */</comment>
	<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>SimpleEcontextStackEntry</name> <operator>*</operator><operator>)</operator>
		<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>,
						   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SimpleEcontextStackEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>stack_econtext</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>eval_econtext</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>xact_subxid</name></name> <operator>=</operator> <call><name>GetCurrentSubTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>simple_econtext_stack</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>simple_econtext_stack</name> <operator>=</operator> <name>entry</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * plpgsql_destroy_econtext --- destroy function's econtext
 *
 * We check that it matches the top stack entry, and destroy the stack
 * entry along with the context.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>plpgsql_destroy_econtext</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SimpleEcontextStackEntry</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>simple_econtext_stack</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>simple_econtext_stack</name><operator>-&gt;</operator><name>stack_econtext</name></name> <operator>==</operator> <name><name>estate</name><operator>-&gt;</operator><name>eval_econtext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>simple_econtext_stack</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>simple_econtext_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>simple_econtext_stack</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FreeExprContext</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_econtext</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eval_econtext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * plpgsql_xact_cb --- post-transaction-commit-or-abort cleanup
 *
 * If a simple-expression EState was created in the current transaction,
 * it has to be cleaned up.  The same for the simple-expression resowner.
 */</comment>
<function><type><name>void</name></type>
<name>plpgsql_xact_cb</name><parameter_list>(<parameter><decl><type><name>XactEvent</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If we are doing a clean transaction shutdown, free the EState and tell
	 * the resowner to release whatever plancache references it has, so that
	 * all remaining resources will be released correctly.  (We don't need to
	 * actually delete the resowner here; deletion of the
	 * TopTransactionResourceOwner will take care of that.)
	 *
	 * In an abort, we expect the regular abort recovery procedures to release
	 * everything of interest, so just clear our pointers.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>event</name> <operator>==</operator> <name>XACT_EVENT_COMMIT</name> <operator>||</operator>
		<name>event</name> <operator>==</operator> <name>XACT_EVENT_PARALLEL_COMMIT</name> <operator>||</operator>
		<name>event</name> <operator>==</operator> <name>XACT_EVENT_PREPARE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>simple_econtext_stack</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>shared_simple_eval_estate</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>shared_simple_eval_estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>shared_simple_eval_estate</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>shared_simple_eval_resowner</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ResourceOwnerReleaseAllPlanCacheRefs</name><argument_list>(<argument><expr><name>shared_simple_eval_resowner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>shared_simple_eval_resowner</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>event</name> <operator>==</operator> <name>XACT_EVENT_ABORT</name> <operator>||</operator>
			 <name>event</name> <operator>==</operator> <name>XACT_EVENT_PARALLEL_ABORT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>simple_econtext_stack</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>shared_simple_eval_estate</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>shared_simple_eval_resowner</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * plpgsql_subxact_cb --- post-subtransaction-commit-or-abort cleanup
 *
 * Make sure any simple-expression econtexts created in the current
 * subtransaction get cleaned up.  We have to do this explicitly because
 * no other code knows which econtexts belong to which level of subxact.
 */</comment>
<function><type><name>void</name></type>
<name>plpgsql_subxact_cb</name><parameter_list>(<parameter><decl><type><name>SubXactEvent</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>SubTransactionId</name></type> <name>mySubid</name></decl></parameter>,
				   <parameter><decl><type><name>SubTransactionId</name></type> <name>parentSubid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>event</name> <operator>==</operator> <name>SUBXACT_EVENT_COMMIT_SUB</name> <operator>||</operator> <name>event</name> <operator>==</operator> <name>SUBXACT_EVENT_ABORT_SUB</name></expr>)</condition>
	<block>{<block_content>
		<while>while <condition>(<expr><name>simple_econtext_stack</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			   <name><name>simple_econtext_stack</name><operator>-&gt;</operator><name>xact_subxid</name></name> <operator>==</operator> <name>mySubid</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SimpleEcontextStackEntry</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FreeExprContext</name><argument_list>(<argument><expr><name><name>simple_econtext_stack</name><operator>-&gt;</operator><name>stack_econtext</name></name></expr></argument>,
							<argument><expr><operator>(</operator><name>event</name> <operator>==</operator> <name>SUBXACT_EVENT_COMMIT_SUB</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>simple_econtext_stack</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>simple_econtext_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>simple_econtext_stack</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * assign_simple_var --- assign a new value to any VAR datum.
 *
 * This should be the only mechanism for assignment to simple variables,
 * lest we do the release of the old value incorrectly (not to mention
 * the detoasting business).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>assign_simple_var</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>,
				  <parameter><decl><type><name>Datum</name></type> <name>newvalue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>freeable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_VAR</name> <operator>||</operator>
		   <name><name>var</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_PROMISE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In non-atomic contexts, we do not want to store TOAST pointers in
	 * variables, because such pointers might become stale after a commit.
	 * Forcibly detoast in such cases.  We don't want to detoast (flatten)
	 * expanded objects, however; those should be OK across a transaction
	 * boundary since they're just memory-resident objects.  (Elsewhere in
	 * this module, operations on expanded records likewise need to request
	 * detoasting of record fields when !estate-&gt;atomic.  Expanded arrays are
	 * not a problem since all array entries are always detoasted.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>atomic</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isnull</name> <operator>&amp;&amp;</operator> <name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
		<call><name>VARATT_IS_EXTERNAL_NON_EXPANDED</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>newvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>detoasted</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Do the detoasting in the eval_mcontext to avoid long-term leakage
		 * of whatever memory toast fetching might leak.  Then we have to copy
		 * the detoasted datum to the function's main context, which is a
		 * pain, but there's little choice.
		 */</comment>
		<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>detoasted</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>detoast_external_attr</name><argument_list>(<argument><expr><operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>newvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Now's a good time to not leak the input value if it's freeable */</comment>
		<if_stmt><if>if <condition>(<expr><name>freeable</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>newvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* Once we copy the value, it's definitely freeable */</comment>
		<expr_stmt><expr><name>newvalue</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name>detoasted</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>freeable</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<comment type="block">/* Can't clean up eval_mcontext here, but it'll happen before long */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Free the old value if needed */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>freeval</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>DatumIsReadWriteExpandedObject</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr></argument>,
										   <argument><expr><name><name>var</name><operator>-&gt;</operator><name>isnull</name></name></expr></argument>,
										   <argument><expr><name><name>var</name><operator>-&gt;</operator><name>datatype</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>DeleteExpandedObject</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Assign new value to datum */</comment>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>newvalue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>isnull</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>freeval</name></name> <operator>=</operator> <name>freeable</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If it's a promise variable, then either we just assigned the promised
	 * value, or the user explicitly assigned an overriding value.  Either
	 * way, cancel the promise.
	 */</comment>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>promise</name></name> <operator>=</operator> <name>PLPGSQL_PROMISE_NONE</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * free old value of a text variable and assign new value from C string
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>assign_text_var</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assign_simple_var</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * assign_record_var --- assign a new value to any REC datum.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>assign_record_var</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name></decl></parameter>,
				  <parameter><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>erh</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_REC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Transfer new record object into datum_context */</comment>
	<expr_stmt><expr><call><name>TransferExpandedRecord</name><argument_list>(<argument><expr><name>erh</name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>datum_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Free the old value ... */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>erh</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>DeleteExpandedObject</name><argument_list>(<argument><expr><call><name>ExpandedRecordGetDatum</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>erh</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* ... and install the new */</comment>
	<expr_stmt><expr><name><name>rec</name><operator>-&gt;</operator><name>erh</name></name> <operator>=</operator> <name>erh</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * exec_eval_using_params --- evaluate params of USING clause
 *
 * The result data structure is created in the stmt_mcontext, and should
 * be freed by resetting that context.
 */</comment>
<function><type><specifier>static</specifier> <name>PreparedParamsData</name> <modifier>*</modifier></type>
<name>exec_eval_using_params</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PreparedParamsData</name> <modifier>*</modifier></type><name>ppd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>stmt_mcontext</name> <init>= <expr><call><name>get_stmt_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ppd</name> <operator>=</operator> <operator>(</operator><name>PreparedParamsData</name> <operator>*</operator><operator>)</operator>
		<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PreparedParamsData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ppd</name><operator>-&gt;</operator><name>nargs</name></name> <operator>=</operator> <name>nargs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ppd</name><operator>-&gt;</operator><name>types</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator>
		<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>, <argument><expr><name>nargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ppd</name><operator>-&gt;</operator><name>values</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator>
		<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>, <argument><expr><name>nargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ppd</name><operator>-&gt;</operator><name>nulls</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator>
		<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>, <argument><expr><name>nargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>params</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>param</name> <init>= <expr><operator>(</operator><name>PLpgSQL_expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>ppdtypmod</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>ppd</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>exec_eval_expr</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>param</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name><name>ppd</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>ppdtypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ppd</name><operator>-&gt;</operator><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>isnull</name></expr> ?</condition><then> <expr><literal type="char">'n'</literal></expr> </then><else>: <expr><literal type="char">' '</literal></expr></else></ternary></expr>;</expr_stmt>

		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>ppd</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Treat 'unknown' parameters as text, since that's what most
			 * people would expect. SPI_execute_with_args can coerce unknown
			 * constants in a more intelligent way, but not unknown Params.
			 * This code also takes care of copying into the right context.
			 * Note we assume 'unknown' has the representation of C-string.
			 */</comment>
			<expr_stmt><expr><name><name>ppd</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>TEXTOID</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>ppd</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name><name>ppd</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<comment type="block">/* pass-by-ref non null values must be copied into stmt_mcontext */</comment>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int16</name></type>		<name>typLen</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>typByVal</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>get_typlenbyval</name><argument_list>(<argument><expr><name><name>ppd</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typLen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typByVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>typByVal</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>ppd</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>ppd</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>typByVal</name></expr></argument>, <argument><expr><name>typLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>ppd</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Open portal for dynamic query
 *
 * Caution: this resets the stmt_mcontext at exit.  We might eventually need
 * to move that responsibility to the callers, but currently no caller needs
 * to have statement-lifetime temp data that survives past this, so it's
 * simpler to do it here.
 */</comment>
<function><type><specifier>static</specifier> <name>Portal</name></type>
<name>exec_dynquery_with_params</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
						  <parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>dynquery</name></decl></parameter>,
						  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>params</name></decl></parameter>,
						  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>portalname</name></decl></parameter>,
						  <parameter><decl><type><name>int</name></type> <name>cursorOptions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Portal</name></type>		<name>portal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>restype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>restypmod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>querystr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>stmt_mcontext</name> <init>= <expr><call><name>get_stmt_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Evaluate the string expression after the EXECUTE keyword. Its result is
	 * the querystring we have to execute.
	 */</comment>
	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>exec_eval_expr</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>dynquery</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>restype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>restypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"query string argument of EXECUTE is null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Get the C-String representation */</comment>
	<expr_stmt><expr><name>querystr</name> <operator>=</operator> <call><name>convert_value_to_string</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>restype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* copy it into the stmt_mcontext before we clean up */</comment>
	<expr_stmt><expr><name>querystr</name> <operator>=</operator> <call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>, <argument><expr><name>querystr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>exec_eval_cleanup</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Open an implicit cursor for the query.  We use
	 * SPI_cursor_open_with_args even when there are no params, because this
	 * avoids making and freeing one copy of the plan.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>params</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PreparedParamsData</name> <modifier>*</modifier></type><name>ppd</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>ppd</name> <operator>=</operator> <call><name>exec_eval_using_params</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>SPI_cursor_open_with_args</name><argument_list>(<argument><expr><name>portalname</name></expr></argument>,
										   <argument><expr><name>querystr</name></expr></argument>,
										   <argument><expr><name><name>ppd</name><operator>-&gt;</operator><name>nargs</name></name></expr></argument>, <argument><expr><name><name>ppd</name><operator>-&gt;</operator><name>types</name></name></expr></argument>,
										   <argument><expr><name><name>ppd</name><operator>-&gt;</operator><name>values</name></name></expr></argument>, <argument><expr><name><name>ppd</name><operator>-&gt;</operator><name>nulls</name></name></expr></argument>,
										   <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>readonly_func</name></name></expr></argument>,
										   <argument><expr><name>cursorOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>SPI_cursor_open_with_args</name><argument_list>(<argument><expr><name>portalname</name></expr></argument>,
										   <argument><expr><name>querystr</name></expr></argument>,
										   <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
										   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
										   <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>readonly_func</name></name></expr></argument>,
										   <argument><expr><name>cursorOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>portal</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not open implicit cursor for query \"%s\": %s"</literal></expr></argument>,
			 <argument><expr><name>querystr</name></expr></argument>, <argument><expr><call><name>SPI_result_code_string</name><argument_list>(<argument><expr><name>SPI_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Release transient data */</comment>
	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>stmt_mcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>portal</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return a formatted string with information about an expression's parameters,
 * or NULL if the expression does not take any parameters.
 * The result is in the eval_mcontext.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>format_expr_params</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
				   <parameter><decl><type><specifier>const</specifier> <name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>paramno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>paramstr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>expr</name><operator>-&gt;</operator><name>paramnos</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>paramstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>paramno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>dno</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>dno</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>paramnos</name></name></expr></argument>, <argument><expr><name>dno</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>paramdatum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>paramtypeid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>paramisnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>paramtypmod</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>curvar</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>curvar</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>dno</name></expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>exec_eval_datum</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>PLpgSQL_datum</name> <operator>*</operator><operator>)</operator> <name>curvar</name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>paramtypeid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>paramtypmod</name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>paramdatum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>paramisnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>paramstr</name></expr></argument>, <argument><expr><literal type="string">"%s%s = "</literal></expr></argument>,
						 <argument><expr><ternary><condition><expr><name>paramno</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">", "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
						 <argument><expr><name><name>curvar</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>paramisnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>paramstr</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoStringQuoted</name><argument_list>(<argument><expr><operator>&amp;</operator><name>paramstr</name></expr></argument>,
										 <argument><expr><call><name>convert_value_to_string</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
																 <argument><expr><name>paramdatum</name></expr></argument>,
																 <argument><expr><name>paramtypeid</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>paramno</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>paramstr</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return a formatted string with information about PreparedParamsData, or NULL
 * if there are no parameters.
 * The result is in the eval_mcontext.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>format_preparedparamsdata</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
						  <parameter><decl><type><specifier>const</specifier> <name>PreparedParamsData</name> <modifier>*</modifier></type><name>ppd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>paramno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>paramstr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ppd</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_eval_mcontext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>paramstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>paramno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>paramno</name> <operator>&lt;</operator> <name><name>ppd</name><operator>-&gt;</operator><name>nargs</name></name></expr>;</condition> <incr><expr><name>paramno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>paramstr</name></expr></argument>, <argument><expr><literal type="string">"%s$%d = "</literal></expr></argument>,
						 <argument><expr><ternary><condition><expr><name>paramno</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">", "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
						 <argument><expr><name>paramno</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>ppd</name><operator>-&gt;</operator><name>nulls</name><index>[<expr><name>paramno</name></expr>]</index></name> <operator>==</operator> <literal type="char">'n'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>paramstr</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoStringQuoted</name><argument_list>(<argument><expr><operator>&amp;</operator><name>paramstr</name></expr></argument>,
										 <argument><expr><call><name>convert_value_to_string</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
																 <argument><expr><name><name>ppd</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>paramno</name></expr>]</index></name></expr></argument>,
																 <argument><expr><name><name>ppd</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>paramno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>paramstr</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>
</unit>
