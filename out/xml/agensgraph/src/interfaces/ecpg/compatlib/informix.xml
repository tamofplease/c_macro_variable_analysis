<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/interfaces/ecpg/compatlib/informix.c"><comment type="block">/* src/interfaces/ecpg/compatlib/informix.c */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POSTGRES_ECPG_INTERNAL</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ecpg_informix.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ecpgerrno.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ecpgtype.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgtypes_date.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgtypes_error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgtypes_numeric.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlca.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqltypes.h"</cpp:file></cpp:include>

<comment type="block">/* this is also defined in ecpglib/misc.c, by defining it twice we don't have to export the symbol */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>sqlca_t</name></name></type> <name>sqlca_init</name> <init>=
<expr><block>{
	<expr><block>{
		<expr><literal type="char">'S'</literal></expr>, <expr><literal type="char">'Q'</literal></expr>, <expr><literal type="char">'L'</literal></expr>, <expr><literal type="char">'C'</literal></expr>, <expr><literal type="char">'A'</literal></expr>, <expr><literal type="char">' '</literal></expr>, <expr><literal type="char">' '</literal></expr>, <expr><literal type="char">' '</literal></expr>
	}</block></expr>,
	<expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>sqlca_t</name></expr></argument>)</argument_list></sizeof></expr>,
	<expr><literal type="number">0</literal></expr>,
	<expr><block>{
		<expr><literal type="number">0</literal></expr>,
		<expr><block>{
			<expr><literal type="number">0</literal></expr>
		}</block></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="char">'N'</literal></expr>, <expr><literal type="char">'O'</literal></expr>, <expr><literal type="char">'T'</literal></expr>, <expr><literal type="char">' '</literal></expr>, <expr><literal type="char">'S'</literal></expr>, <expr><literal type="char">'E'</literal></expr>, <expr><literal type="char">'T'</literal></expr>, <expr><literal type="char">' '</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="char">'0'</literal></expr>, <expr><literal type="char">'0'</literal></expr>, <expr><literal type="char">'0'</literal></expr>, <expr><literal type="char">'0'</literal></expr>, <expr><literal type="char">'0'</literal></expr>
	}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>deccall2</name><parameter_list>(<parameter><decl><type><name>decimal</name> <modifier>*</modifier></type><name>arg1</name></decl></parameter>, <parameter><decl><type><name>decimal</name> <modifier>*</modifier></type><name>arg2</name></decl></parameter>, <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>ptr</name>) <parameter_list>(<parameter><decl><type><name>numeric</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>numeric</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>numeric</name>    <modifier>*</modifier></type><name>a1</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>a2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>a1</name> <operator>=</operator> <call><name>PGTYPESnumeric_new</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ECPG_INFORMIX_OUT_OF_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>a2</name> <operator>=</operator> <call><name>PGTYPESnumeric_new</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PGTYPESnumeric_free</name><argument_list>(<argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>ECPG_INFORMIX_OUT_OF_MEMORY</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PGTYPESnumeric_from_decimal</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>a1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PGTYPESnumeric_free</name><argument_list>(<argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PGTYPESnumeric_free</name><argument_list>(<argument><expr><name>a2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>ECPG_INFORMIX_OUT_OF_MEMORY</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PGTYPESnumeric_from_decimal</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><name>a2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PGTYPESnumeric_free</name><argument_list>(<argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PGTYPESnumeric_free</name><argument_list>(<argument><expr><name>a2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>ECPG_INFORMIX_OUT_OF_MEMORY</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <call>(<modifier>*</modifier><name>ptr</name>) <argument_list>(<argument><expr><name>a1</name></expr></argument>, <argument><expr><name>a2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PGTYPESnumeric_free</name><argument_list>(<argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PGTYPESnumeric_free</name><argument_list>(<argument><expr><name>a2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>deccall3</name><parameter_list>(<parameter><decl><type><name>decimal</name> <modifier>*</modifier></type><name>arg1</name></decl></parameter>, <parameter><decl><type><name>decimal</name> <modifier>*</modifier></type><name>arg2</name></decl></parameter>, <parameter><decl><type><name>decimal</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>ptr</name>) <parameter_list>(<parameter><decl><type><name>numeric</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>numeric</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>numeric</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>numeric</name>    <modifier>*</modifier></type><name>a1</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>a2</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>nres</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * we must NOT set the result to NULL here because it may be the same
	 * variable as one of the arguments
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>risnull</name><argument_list>(<argument><expr><name>CDECIMALTYPE</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>arg1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>risnull</name><argument_list>(<argument><expr><name>CDECIMALTYPE</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>arg2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>a1</name> <operator>=</operator> <call><name>PGTYPESnumeric_new</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ECPG_INFORMIX_OUT_OF_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>a2</name> <operator>=</operator> <call><name>PGTYPESnumeric_new</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PGTYPESnumeric_free</name><argument_list>(<argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>ECPG_INFORMIX_OUT_OF_MEMORY</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>nres</name> <operator>=</operator> <call><name>PGTYPESnumeric_new</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PGTYPESnumeric_free</name><argument_list>(<argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PGTYPESnumeric_free</name><argument_list>(<argument><expr><name>a2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>ECPG_INFORMIX_OUT_OF_MEMORY</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PGTYPESnumeric_from_decimal</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>a1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PGTYPESnumeric_free</name><argument_list>(<argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PGTYPESnumeric_free</name><argument_list>(<argument><expr><name>a2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PGTYPESnumeric_free</name><argument_list>(<argument><expr><name>nres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>ECPG_INFORMIX_OUT_OF_MEMORY</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PGTYPESnumeric_from_decimal</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><name>a2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PGTYPESnumeric_free</name><argument_list>(<argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PGTYPESnumeric_free</name><argument_list>(<argument><expr><name>a2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PGTYPESnumeric_free</name><argument_list>(<argument><expr><name>nres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>ECPG_INFORMIX_OUT_OF_MEMORY</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <call>(<modifier>*</modifier><name>ptr</name>) <argument_list>(<argument><expr><name>a1</name></expr></argument>, <argument><expr><name>a2</name></expr></argument>, <argument><expr><name>nres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>					<comment type="block">/* No error */</comment>
	<block>{<block_content>

		<comment type="block">/* set the result to null in case it errors out later */</comment>
		<expr_stmt><expr><call><name>rsetnull</name><argument_list>(<argument><expr><name>CDECIMALTYPE</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PGTYPESnumeric_to_decimal</name><argument_list>(<argument><expr><name>nres</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PGTYPESnumeric_free</name><argument_list>(<argument><expr><name>nres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PGTYPESnumeric_free</name><argument_list>(<argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PGTYPESnumeric_free</name><argument_list>(<argument><expr><name>a2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* we start with the numeric functions */</comment>
<function><type><name>int</name></type>
<name>decadd</name><parameter_list>(<parameter><decl><type><name>decimal</name> <modifier>*</modifier></type><name>arg1</name></decl></parameter>, <parameter><decl><type><name>decimal</name> <modifier>*</modifier></type><name>arg2</name></decl></parameter>, <parameter><decl><type><name>decimal</name> <modifier>*</modifier></type><name>sum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>deccall3</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>, <argument><expr><name>sum</name></expr></argument>, <argument><expr><name>PGTYPESnumeric_add</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>PGTYPES_NUM_OVERFLOW</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ECPG_INFORMIX_NUM_OVERFLOW</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>errno</name> <operator>==</operator> <name>PGTYPES_NUM_UNDERFLOW</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ECPG_INFORMIX_NUM_UNDERFLOW</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>errno</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>deccmp</name><parameter_list>(<parameter><decl><type><name>decimal</name> <modifier>*</modifier></type><name>arg1</name></decl></parameter>, <parameter><decl><type><name>decimal</name> <modifier>*</modifier></type><name>arg2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>deccall2</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>, <argument><expr><name>PGTYPESnumeric_cmp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>deccopy</name><parameter_list>(<parameter><decl><type><name>decimal</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>decimal</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>decimal</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>deccvasc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>decimal</name> <modifier>*</modifier></type><name>np</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>numeric</name>    <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>rsetnull</name><argument_list>(<argument><expr><name>CDECIMALTYPE</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>risnull</name><argument_list>(<argument><expr><name>CSTRINGTYPE</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pnstrdup</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* decimal_in always converts the complete
								 * string */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>str</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ECPG_INFORMIX_NUM_UNDERFLOW</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PGTYPESnumeric_from_asc</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition>
		<block>{<block_content>
			<switch>switch <condition>(<expr><name>errno</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>PGTYPES_NUM_OVERFLOW</name></expr>:</case>
					<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ECPG_INFORMIX_NUM_OVERFLOW</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>PGTYPES_NUM_BAD_NUMERIC</name></expr>:</case>
					<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ECPG_INFORMIX_BAD_NUMERIC</name></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ECPG_INFORMIX_BAD_EXPONENT</name></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><call><name>PGTYPESnumeric_to_decimal</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>np</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>PGTYPESnumeric_free</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ECPG_INFORMIX_NUM_OVERFLOW</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>deccvdbl</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>dbl</name></decl></parameter>, <parameter><decl><type><name>decimal</name> <modifier>*</modifier></type><name>np</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>numeric</name>    <modifier>*</modifier></type><name>nres</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>rsetnull</name><argument_list>(<argument><expr><name>CDECIMALTYPE</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>risnull</name><argument_list>(<argument><expr><name>CDOUBLETYPE</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>dbl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>nres</name> <operator>=</operator> <call><name>PGTYPESnumeric_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nres</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ECPG_INFORMIX_OUT_OF_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PGTYPESnumeric_from_double</name><argument_list>(<argument><expr><name>dbl</name></expr></argument>, <argument><expr><name>nres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PGTYPESnumeric_to_decimal</name><argument_list>(<argument><expr><name>nres</name></expr></argument>, <argument><expr><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PGTYPESnumeric_free</name><argument_list>(<argument><expr><name>nres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>deccvint</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>in</name></decl></parameter>, <parameter><decl><type><name>decimal</name> <modifier>*</modifier></type><name>np</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>numeric</name>    <modifier>*</modifier></type><name>nres</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>rsetnull</name><argument_list>(<argument><expr><name>CDECIMALTYPE</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>risnull</name><argument_list>(<argument><expr><name>CINTTYPE</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>in</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>nres</name> <operator>=</operator> <call><name>PGTYPESnumeric_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nres</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ECPG_INFORMIX_OUT_OF_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PGTYPESnumeric_from_int</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><name>nres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PGTYPESnumeric_to_decimal</name><argument_list>(<argument><expr><name>nres</name></expr></argument>, <argument><expr><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PGTYPESnumeric_free</name><argument_list>(<argument><expr><name>nres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>deccvlong</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>lng</name></decl></parameter>, <parameter><decl><type><name>decimal</name> <modifier>*</modifier></type><name>np</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>numeric</name>    <modifier>*</modifier></type><name>nres</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>rsetnull</name><argument_list>(<argument><expr><name>CDECIMALTYPE</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>risnull</name><argument_list>(<argument><expr><name>CLONGTYPE</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>lng</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>nres</name> <operator>=</operator> <call><name>PGTYPESnumeric_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nres</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ECPG_INFORMIX_OUT_OF_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PGTYPESnumeric_from_long</name><argument_list>(<argument><expr><name>lng</name></expr></argument>, <argument><expr><name>nres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PGTYPESnumeric_to_decimal</name><argument_list>(<argument><expr><name>nres</name></expr></argument>, <argument><expr><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PGTYPESnumeric_free</name><argument_list>(<argument><expr><name>nres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>decdiv</name><parameter_list>(<parameter><decl><type><name>decimal</name> <modifier>*</modifier></type><name>n1</name></decl></parameter>, <parameter><decl><type><name>decimal</name> <modifier>*</modifier></type><name>n2</name></decl></parameter>, <parameter><decl><type><name>decimal</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>deccall3</name><argument_list>(<argument><expr><name>n1</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>PGTYPESnumeric_div</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<switch>switch <condition>(<expr><name>errno</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>PGTYPES_NUM_DIVIDE_ZERO</name></expr>:</case>
				<return>return <expr><name>ECPG_INFORMIX_DIVIDE_ZERO</name></expr>;</return>
				<break>break;</break>
			<case>case <expr><name>PGTYPES_NUM_OVERFLOW</name></expr>:</case>
				<return>return <expr><name>ECPG_INFORMIX_NUM_OVERFLOW</name></expr>;</return>
				<break>break;</break>
			<default>default:</default>
				<return>return <expr><name>ECPG_INFORMIX_NUM_UNDERFLOW</name></expr>;</return>
				<break>break;</break>
		</block_content>}</block></switch></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>decmul</name><parameter_list>(<parameter><decl><type><name>decimal</name> <modifier>*</modifier></type><name>n1</name></decl></parameter>, <parameter><decl><type><name>decimal</name> <modifier>*</modifier></type><name>n2</name></decl></parameter>, <parameter><decl><type><name>decimal</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>deccall3</name><argument_list>(<argument><expr><name>n1</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>PGTYPESnumeric_mul</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<switch>switch <condition>(<expr><name>errno</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>PGTYPES_NUM_OVERFLOW</name></expr>:</case>
				<return>return <expr><name>ECPG_INFORMIX_NUM_OVERFLOW</name></expr>;</return>
				<break>break;</break>
			<default>default:</default>
				<return>return <expr><name>ECPG_INFORMIX_NUM_UNDERFLOW</name></expr>;</return>
				<break>break;</break>
		</block_content>}</block></switch></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>decsub</name><parameter_list>(<parameter><decl><type><name>decimal</name> <modifier>*</modifier></type><name>n1</name></decl></parameter>, <parameter><decl><type><name>decimal</name> <modifier>*</modifier></type><name>n2</name></decl></parameter>, <parameter><decl><type><name>decimal</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>deccall3</name><argument_list>(<argument><expr><name>n1</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>PGTYPESnumeric_sub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<switch>switch <condition>(<expr><name>errno</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>PGTYPES_NUM_OVERFLOW</name></expr>:</case>
				<return>return <expr><name>ECPG_INFORMIX_NUM_OVERFLOW</name></expr>;</return>
				<break>break;</break>
			<default>default:</default>
				<return>return <expr><name>ECPG_INFORMIX_NUM_UNDERFLOW</name></expr>;</return>
				<break>break;</break>
		</block_content>}</block></switch></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>dectoasc</name><parameter_list>(<parameter><decl><type><name>decimal</name> <modifier>*</modifier></type><name>np</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>right</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>numeric</name>    <modifier>*</modifier></type><name>nres</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>rsetnull</name><argument_list>(<argument><expr><name>CSTRINGTYPE</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>risnull</name><argument_list>(<argument><expr><name>CDECIMALTYPE</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>np</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>nres</name> <operator>=</operator> <call><name>PGTYPESnumeric_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nres</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ECPG_INFORMIX_OUT_OF_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PGTYPESnumeric_from_decimal</name><argument_list>(<argument><expr><name>np</name></expr></argument>, <argument><expr><name>nres</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PGTYPESnumeric_free</name><argument_list>(<argument><expr><name>nres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>ECPG_INFORMIX_OUT_OF_MEMORY</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>right</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>PGTYPESnumeric_to_asc</name><argument_list>(<argument><expr><name>nres</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>PGTYPESnumeric_to_asc</name><argument_list>(<argument><expr><name>nres</name></expr></argument>, <argument><expr><name><name>nres</name><operator>-&gt;</operator><name>dscale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>PGTYPESnumeric_free</name><argument_list>(<argument><expr><name>nres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>str</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * TODO: have to take care of len here and create exponential notation if
	 * necessary
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;</operator> <name>len</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>cp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'*'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>dectodbl</name><parameter_list>(<parameter><decl><type><name>decimal</name> <modifier>*</modifier></type><name>np</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>dblp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>numeric</name>    <modifier>*</modifier></type><name>nres</name> <init>= <expr><call><name>PGTYPESnumeric_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>nres</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ECPG_INFORMIX_OUT_OF_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PGTYPESnumeric_from_decimal</name><argument_list>(<argument><expr><name>np</name></expr></argument>, <argument><expr><name>nres</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PGTYPESnumeric_free</name><argument_list>(<argument><expr><name>nres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>ECPG_INFORMIX_OUT_OF_MEMORY</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>PGTYPESnumeric_to_double</name><argument_list>(<argument><expr><name>nres</name></expr></argument>, <argument><expr><name>dblp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PGTYPESnumeric_free</name><argument_list>(<argument><expr><name>nres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>dectoint</name><parameter_list>(<parameter><decl><type><name>decimal</name> <modifier>*</modifier></type><name>np</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ip</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>numeric</name>    <modifier>*</modifier></type><name>nres</name> <init>= <expr><call><name>PGTYPESnumeric_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>nres</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ECPG_INFORMIX_OUT_OF_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PGTYPESnumeric_from_decimal</name><argument_list>(<argument><expr><name>np</name></expr></argument>, <argument><expr><name>nres</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PGTYPESnumeric_free</name><argument_list>(<argument><expr><name>nres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>ECPG_INFORMIX_OUT_OF_MEMORY</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>PGTYPESnumeric_to_int</name><argument_list>(<argument><expr><name>nres</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PGTYPESnumeric_free</name><argument_list>(<argument><expr><name>nres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>PGTYPES_NUM_OVERFLOW</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ECPG_INFORMIX_NUM_OVERFLOW</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>dectolong</name><parameter_list>(<parameter><decl><type><name>decimal</name> <modifier>*</modifier></type><name>np</name></decl></parameter>, <parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>lngp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>numeric</name>    <modifier>*</modifier></type><name>nres</name> <init>= <expr><call><name>PGTYPESnumeric_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>nres</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ECPG_INFORMIX_OUT_OF_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PGTYPESnumeric_from_decimal</name><argument_list>(<argument><expr><name>np</name></expr></argument>, <argument><expr><name>nres</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PGTYPESnumeric_free</name><argument_list>(<argument><expr><name>nres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>ECPG_INFORMIX_OUT_OF_MEMORY</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>PGTYPESnumeric_to_long</name><argument_list>(<argument><expr><name>nres</name></expr></argument>, <argument><expr><name>lngp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PGTYPESnumeric_free</name><argument_list>(<argument><expr><name>nres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>PGTYPES_NUM_OVERFLOW</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ECPG_INFORMIX_NUM_OVERFLOW</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Now the date functions */</comment>
<function><type><name>int</name></type>
<name>rdatestr</name><parameter_list>(<parameter><decl><type><name>date</name></type> <name>d</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>PGTYPESdate_to_asc</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmp</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ECPG_INFORMIX_DATE_CONVERT</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* move to user allocated buffer */</comment>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
*
* the input for this function is mmddyyyy and any non-numeric
* character can be used as a separator
*
*/</comment>
<function><type><name>int</name></type>
<name>rstrdate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>date</name> <modifier>*</modifier></type> <name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>rdefmtdate</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="string">"mm/dd/yyyy"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rtoday</name><parameter_list>(<parameter><decl><type><name>date</name> <modifier>*</modifier></type> <name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PGTYPESdate_today</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rjulmdy</name><parameter_list>(<parameter><decl><type><name>date</name></type> <name>d</name></decl></parameter>, <parameter><decl><type><name>short</name> <modifier>*</modifier></type><name>mdy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>mdy_int</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PGTYPESdate_julmdy</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>mdy_int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mdy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>short</name><operator>)</operator> <name><name>mdy_int</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mdy</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>short</name><operator>)</operator> <name><name>mdy_int</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mdy</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>short</name><operator>)</operator> <name><name>mdy_int</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rdefmtdate</name><parameter_list>(<parameter><decl><type><name>date</name> <modifier>*</modifier></type> <name>d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* TODO: take care of DBCENTURY environment variable */</comment>
	<comment type="block">/* PGSQL functions allow all centuries */</comment>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PGTYPESdate_defmt_asc</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name>errno</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PGTYPES_DATE_ERR_ENOSHORTDATE</name></expr>:</case>
			<return>return <expr><name>ECPG_INFORMIX_ENOSHORTDATE</name></expr>;</return>
		<case>case <expr><name>PGTYPES_DATE_ERR_EARGS</name></expr>:</case>
		<case>case <expr><name>PGTYPES_DATE_ERR_ENOTDMY</name></expr>:</case>
			<return>return <expr><name>ECPG_INFORMIX_ENOTDMY</name></expr>;</return>
		<case>case <expr><name>PGTYPES_DATE_BAD_DAY</name></expr>:</case>
			<return>return <expr><name>ECPG_INFORMIX_BAD_DAY</name></expr>;</return>
		<case>case <expr><name>PGTYPES_DATE_BAD_MONTH</name></expr>:</case>
			<return>return <expr><name>ECPG_INFORMIX_BAD_MONTH</name></expr>;</return>
		<default>default:</default>
			<return>return <expr><name>ECPG_INFORMIX_BAD_YEAR</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rfmtdate</name><parameter_list>(<parameter><decl><type><name>date</name></type> <name>d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PGTYPESdate_fmt_asc</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOMEM</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ECPG_INFORMIX_OUT_OF_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>ECPG_INFORMIX_DATE_CONVERT</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rmdyjul</name><parameter_list>(<parameter><decl><type><name>short</name> <modifier>*</modifier></type><name>mdy</name></decl></parameter>, <parameter><decl><type><name>date</name> <modifier>*</modifier></type> <name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>mdy_int</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>mdy_int</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>mdy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mdy_int</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>mdy</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mdy_int</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>mdy</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PGTYPESdate_mdyjul</name><argument_list>(<argument><expr><name>mdy_int</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rdayofweek</name><parameter_list>(<parameter><decl><type><name>date</name></type> <name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>PGTYPESdate_dayofweek</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* And the datetime stuff */</comment>

<function><type><name>void</name></type>
<name>dtcurrent</name><parameter_list>(<parameter><decl><type><name>timestamp</name> <modifier>*</modifier></type> <name>ts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PGTYPEStimestamp_current</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>dtcvasc</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>timestamp</name> <modifier>*</modifier></type> <name>ts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>timestamp</name></type>	<name>ts_tmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>endptr</name> <init>= <expr><operator>&amp;</operator><name>str</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>ts_tmp</name> <operator>=</operator> <call><name>PGTYPEStimestamp_from_asc</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>endptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>i</name></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* TODO: rewrite to Informix error codes */</comment>
		<return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>*</operator><name>endptr</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* extra characters exist at the end */</comment>
		<return>return <expr><name>ECPG_INFORMIX_EXTRA_CHARS</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* TODO: other Informix error codes missing */</comment>

	<comment type="block">/* everything went fine */</comment>
	<expr_stmt><expr><operator>*</operator><name>ts</name> <operator>=</operator> <name>ts_tmp</name></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>dtcvfmtasc</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>inbuf</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fmtstr</name></decl></parameter>, <parameter><decl><type><name>timestamp</name> <modifier>*</modifier></type> <name>dtvalue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>PGTYPEStimestamp_defmt_asc</name><argument_list>(<argument><expr><name>inbuf</name></expr></argument>, <argument><expr><name>fmtstr</name></expr></argument>, <argument><expr><name>dtvalue</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>dtsub</name><parameter_list>(<parameter><decl><type><name>timestamp</name> <modifier>*</modifier></type> <name>ts1</name></decl></parameter>, <parameter><decl><type><name>timestamp</name> <modifier>*</modifier></type> <name>ts2</name></decl></parameter>, <parameter><decl><type><name>interval</name> <modifier>*</modifier></type> <name>iv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>PGTYPEStimestamp_sub</name><argument_list>(<argument><expr><name>ts1</name></expr></argument>, <argument><expr><name>ts2</name></expr></argument>, <argument><expr><name>iv</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>dttoasc</name><parameter_list>(<parameter><decl><type><name>timestamp</name> <modifier>*</modifier></type> <name>ts</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>output</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>asctime</name> <init>= <expr><call><name>PGTYPEStimestamp_to_asc</name><argument_list>(<argument><expr><operator>*</operator><name>ts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>asctime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>asctime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>dttofmtasc</name><parameter_list>(<parameter><decl><type><name>timestamp</name> <modifier>*</modifier></type> <name>ts</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>output</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>str_len</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fmtstr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>PGTYPEStimestamp_fmt_asc</name><argument_list>(<argument><expr><name>ts</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>str_len</name></expr></argument>, <argument><expr><name>fmtstr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>intoasc</name><parameter_list>(<parameter><decl><type><name>interval</name> <modifier>*</modifier></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>PGTYPESinterval_to_asc</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmp</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><name>errno</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<struct><specifier>static</specifier> struct
<block>{
	<decl_stmt><decl><type><name>long</name></type>		<name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxdigits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>digits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>remaining</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>sign</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val_string</name></decl>;</decl_stmt>
}</block>			<decl><name>value</name></decl>;</struct>

<comment type="block" format="doxygen">/**
 * initialize the struct, which holds the different forms
 * of the long value
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>initValue</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>lng_val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>l</name></decl>,
				<decl><type ref="prev"/><name>dig</name></decl>;</decl_stmt>

	<comment type="block">/* set some obvious things */</comment>
	<expr_stmt><expr><name><name>value</name><operator>.</operator><name>val</name></name> <operator>=</operator> <ternary><condition><expr><name>lng_val</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>lng_val</name></expr> </then><else>: <expr><name>lng_val</name> <operator>*</operator> <operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>value</name><operator>.</operator><name>sign</name></name> <operator>=</operator> <ternary><condition><expr><name>lng_val</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="char">'+'</literal></expr> </then><else>: <expr><literal type="char">'-'</literal></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>value</name><operator>.</operator><name>maxdigits</name></name> <operator>=</operator> <call><name>log10</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>*</operator> <operator>(</operator><literal type="number">8</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* determine the number of digits */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>l</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<do>do
	<block>{<block_content>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>l</name> <operator>*=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
	</block_content>}</block>
	while <condition>(<expr><operator>(</operator><name>l</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;</operator> <name><name>value</name><operator>.</operator><name>val</name></name> <operator>&amp;&amp;</operator> <name>l</name> <operator>&lt;=</operator> <name>LONG_MAX</name> <operator>/</operator> <literal type="number">10</literal></expr>)</condition>;</do>

	<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&lt;=</operator> <name>LONG_MAX</name> <operator>/</operator> <literal type="number">10</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>value</name><operator>.</operator><name>digits</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>l</name> <operator>/=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>value</name><operator>.</operator><name>digits</name></name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>value</name><operator>.</operator><name>remaining</name></name> <operator>=</operator> <name><name>value</name><operator>.</operator><name>digits</name></name></expr>;</expr_stmt>

	<comment type="block">/* convert the long to string */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>value</name><operator>.</operator><name>val_string</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name><name>value</name><operator>.</operator><name>digits</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>dig</name> <operator>=</operator> <name><name>value</name><operator>.</operator><name>val</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>value</name><operator>.</operator><name>digits</name></name></expr><operator>,</operator> <expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>value</name><operator>.</operator><name>val_string</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>dig</name> <operator>/</operator> <name>l</name> <operator>+</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>dig</name> <operator>=</operator> <name>dig</name> <operator>%</operator> <name>l</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>l</name> <operator>/=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>value</name><operator>.</operator><name>val_string</name><index>[<expr><name><name>value</name><operator>.</operator><name>digits</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* return the position of the right-most dot in some string */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>getRightMostDot</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>len</name> <operator>-</operator> <name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* And finally some misc functions */</comment>
<function><type><name>int</name></type>
<name>rfmtlong</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>lng_val</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>outbuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>fmt_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>temp_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>,				<comment type="block">/* position in temp */</comment>
				<decl><type ref="prev"/><name>k</name></decl>,
				<decl><type ref="prev"/><name>dotpos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>leftalign</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>blank</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>sign</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>entitydone</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>signdone</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>brackets_ok</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>tmp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><literal type="string">" "</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>lastfmt</name> <init>= <expr><literal type="char">' '</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>fmtchar</name> <init>= <expr><literal type="char">' '</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>temp</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>fmt_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>temp</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOMEM</name></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* put all info about the long in a struct */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>initValue</name><argument_list>(<argument><expr><name>lng_val</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOMEM</name></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* '&lt;' is the only format, where we have to align left */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <literal type="char">'&lt;'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>leftalign</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* '(' requires ')' */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <literal type="char">'('</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>brackets_ok</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* get position of the right-most dot in the format-string */</comment>
	<comment type="block">/* and fill the temp-string wit '0's up to there. */</comment>
	<expr_stmt><expr><name>dotpos</name> <operator>=</operator> <call><name>getRightMostDot</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* start to parse the format-string */</comment>
	<expr_stmt><expr><name><name>temp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>k</name> <operator>=</operator> <name><name>value</name><operator>.</operator><name>digits</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>		<comment type="block">/* position in the value_string */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>fmt_len</name> <operator>-</operator> <literal type="number">1</literal></expr><operator>,</operator> <expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* qualify, where we are in the value_string */</comment>
		<if_stmt><if>if <condition>(<expr><name>k</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>blank</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>sign</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>leftalign</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* can't use strncat(,,0) here, Solaris would freak out */</comment>
				<if_stmt><if>if <condition>(<expr><name>sign</name></expr>)</condition><block type="pseudo"><block_content>
					<if_stmt><if>if <condition>(<expr><name>signdone</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>temp</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* if we're right side of the right-most dot, print '0' */</comment>
		<if_stmt><if>if <condition>(<expr><name>dotpos</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>dotpos</name> <operator>&lt;=</operator> <name>i</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>dotpos</name> <operator>&lt;</operator> <name>i</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>fmt</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">')'</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>tmp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name><name>value</name><operator>.</operator><name>sign</name></name> <operator>==</operator> <literal type="char">'-'</literal></expr> ?</condition><then> <expr><literal type="char">')'</literal></expr> </then><else>: <expr><literal type="char">' '</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>tmp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>tmp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* the ',' needs special attention, if it is in the blank area */</comment>
		<if_stmt><if>if <condition>(<expr><name>blank</name> <operator>&amp;&amp;</operator> <name><name>fmt</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">','</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>fmtchar</name> <operator>=</operator> <name>lastfmt</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>fmtchar</name> <operator>=</operator> <name><name>fmt</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<comment type="block">/* waiting for the sign */</comment>
		<if_stmt><if>if <condition>(<expr><name>k</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>leftalign</name> <operator>&amp;&amp;</operator> <name>sign</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>signdone</name> <operator>&amp;&amp;</operator> <name>fmtchar</name> <operator>!=</operator> <literal type="char">'+'</literal> <operator>&amp;&amp;</operator> <name>fmtchar</name> <operator>!=</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<comment type="block">/* analyse this format-char */</comment>
		<switch>switch <condition>(<expr><name>fmtchar</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">','</literal></expr>:</case>
				<expr_stmt><expr><name><name>tmp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">','</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>k</name><operator>++</operator></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'*'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>blank</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>tmp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'*'</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>tmp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>value</name><operator>.</operator><name>val_string</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'&amp;'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>blank</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>tmp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>tmp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>value</name><operator>.</operator><name>val_string</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'#'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>blank</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>tmp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>tmp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>value</name><operator>.</operator><name>val_string</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'-'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>sign</name> <operator>&amp;&amp;</operator> <name><name>value</name><operator>.</operator><name>sign</name></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>signdone</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>tmp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>signdone</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>blank</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>tmp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>tmp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>value</name><operator>.</operator><name>val_string</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'+'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>sign</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>signdone</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>tmp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>value</name><operator>.</operator><name>sign</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>signdone</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>blank</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>tmp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>tmp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>value</name><operator>.</operator><name>val_string</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'('</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>sign</name> <operator>&amp;&amp;</operator> <name>brackets_ok</name> <operator>&amp;&amp;</operator> <name><name>value</name><operator>.</operator><name>sign</name></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>tmp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'('</literal></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>blank</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>tmp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>tmp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>value</name><operator>.</operator><name>val_string</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">')'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>brackets_ok</name> <operator>&amp;&amp;</operator> <name><name>value</name><operator>.</operator><name>sign</name></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>tmp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">')'</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>tmp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'$'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>blank</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>entitydone</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>tmp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'$'</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>entitydone</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>blank</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>tmp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>tmp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>value</name><operator>.</operator><name>val_string</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'&lt;'</literal></expr>:</case>
				<expr_stmt><expr><name><name>tmp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>value</name><operator>.</operator><name>val_string</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><name><name>tmp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>fmt</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></switch>
		<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lastfmt</name> <operator>=</operator> <name><name>fmt</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>k</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* safety-net */</comment>
	<expr_stmt><expr><name><name>temp</name><index>[<expr><name>fmt_len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<comment type="block">/* reverse the temp-string and put it into the outbuf */</comment>
	<expr_stmt><expr><name>temp_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>outbuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>temp_len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>tmp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>temp</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>outbuf</name><index>[<expr><name>temp_len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<comment type="block">/* cleaning up */</comment>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>value</name><operator>.</operator><name>val_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rupshift</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>str</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>str</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><call><name>islower</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>str</name> <operator>=</operator> <call><name>toupper</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>byleng</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<for>for <control>(<init><expr><name>len</name><operator>--</operator></expr>;</init> <condition><expr><name><name>str</name><index>[<expr><name>len</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>str</name><index>[<expr><name>len</name></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>;</condition> <incr><expr><name>len</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
	<return>return <expr><operator>(</operator><name>len</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ldchar</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>dlen</name> <init>= <expr><call><name>byleng</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dest</name><index>[<expr><name>dlen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rgetmsg</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>msgnum</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxsize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>msgnum</name></expr>;</expr_stmt>				<comment type="block">/* keep the compiler quiet */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>s</name></expr>;</expr_stmt>					<comment type="block">/* keep the compiler quiet */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>maxsize</name></expr>;</expr_stmt>				<comment type="block">/* keep the compiler quiet */</comment>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rtypalign</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>offset</name></expr>;</expr_stmt>				<comment type="block">/* keep the compiler quiet */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>type</name></expr>;</expr_stmt>				<comment type="block">/* keep the compiler quiet */</comment>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rtypmsize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>type</name></expr>;</expr_stmt>				<comment type="block">/* keep the compiler quiet */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>len</name></expr>;</expr_stmt>					<comment type="block">/* keep the compiler quiet */</comment>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rtypwidth</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sqltype</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sqllen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>sqltype</name></expr>;</expr_stmt>				<comment type="block">/* keep the compiler quiet */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>sqllen</name></expr>;</expr_stmt>				<comment type="block">/* keep the compiler quiet */</comment>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ECPG_informix_set_var</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>number</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pointer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ECPGset_var</name><argument_list>(<argument><expr><name>number</name></expr></argument>, <argument><expr><name>pointer</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>
<name>ECPG_informix_get_var</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>number</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ECPGget_var</name><argument_list>(<argument><expr><name>number</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ECPG_informix_reset_sqlca</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>sqlca_t</name></name> <modifier>*</modifier></type><name>sqlca</name> <init>= <expr><call><name>ECPGget_sqlca</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>sqlca</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>sqlca</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>sqlca_init</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>sqlca_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rsetnull</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>t</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ECPGset_noind_null</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>risnull</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>t</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ECPGis_noind_null</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
