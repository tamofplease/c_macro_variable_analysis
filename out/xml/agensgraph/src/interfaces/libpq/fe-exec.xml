<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/interfaces/libpq/fe-exec.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * fe-exec.c
 *	  functions related to sending a query down to the backend
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/interfaces/libpq/fe-exec.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"win32.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-int.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>

<comment type="block">/* keep this in same order as ExecStatusType in libpq-fe.h */</comment>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier><specifier>const</specifier></type> <name><name>pgresStatus</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="string">"PGRES_EMPTY_QUERY"</literal></expr>,
	<expr><literal type="string">"PGRES_COMMAND_OK"</literal></expr>,
	<expr><literal type="string">"PGRES_TUPLES_OK"</literal></expr>,
	<expr><literal type="string">"PGRES_COPY_OUT"</literal></expr>,
	<expr><literal type="string">"PGRES_COPY_IN"</literal></expr>,
	<expr><literal type="string">"PGRES_BAD_RESPONSE"</literal></expr>,
	<expr><literal type="string">"PGRES_NONFATAL_ERROR"</literal></expr>,
	<expr><literal type="string">"PGRES_FATAL_ERROR"</literal></expr>,
	<expr><literal type="string">"PGRES_COPY_BOTH"</literal></expr>,
	<expr><literal type="string">"PGRES_SINGLE_TUPLE"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * static state needed by PQescapeString and PQescapeBytea; initialize to
 * values that result in backward-compatible behavior
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>static_client_encoding</name> <init>= <expr><name>PG_SQL_ASCII</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>static_std_strings</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>


<function_decl><type><specifier>static</specifier> <name>PGEvent</name> <modifier>*</modifier></type><name>dupEvents</name><parameter_list>(<parameter><decl><type><name>PGEvent</name> <modifier>*</modifier></type><name>events</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>memSize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>pqAddTuple</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>PGresAttValue</name> <modifier>*</modifier></type><name>tup</name></decl></parameter>,
					   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>errmsgp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>PQsendQueryStart</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>PQsendQueryGuts</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>command</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmtName</name></decl></parameter>,
							<parameter><decl><type><name>int</name></type> <name>nParams</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>Oid</name> <modifier>*</modifier></type><name>paramTypes</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>paramValues</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>int</name> <modifier>*</modifier></type><name>paramLengths</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>int</name> <modifier>*</modifier></type><name>paramFormats</name></decl></parameter>,
							<parameter><decl><type><name>int</name></type> <name>resultFormat</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>parseInput</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>getCopyResult</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>ExecStatusType</name></type> <name>copytype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>PQexecStart</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>PQexecFinish</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>PQsendDescribe</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>desc_type</name></decl></parameter>,
						   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>desc_target</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>check_field_number</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>field_num</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* ----------------
 * Space management for PGresult.
 *
 * Formerly, libpq did a separate malloc() for each field of each tuple
 * returned by a query.  This was remarkably expensive --- malloc/free
 * consumed a sizable part of the application's runtime.  And there is
 * no real need to keep track of the fields separately, since they will
 * all be freed together when the PGresult is released.  So now, we grab
 * large blocks of storage from malloc and allocate space for query data
 * within these blocks, using a trivially simple allocator.  This reduces
 * the number of malloc/free calls dramatically, and it also avoids
 * fragmentation of the malloc storage arena.
 * The PGresult structure itself is still malloc'd separately.  We could
 * combine it with the first allocation block, but that would waste space
 * for the common case that no extra storage is actually needed (that is,
 * the SQL command did not return tuples).
 *
 * We also malloc the top-level array of tuple pointers separately, because
 * we need to be able to enlarge it via realloc, and our trivial space
 * allocator doesn't handle that effectively.  (Too bad the FE/BE protocol
 * doesn't tell us up front how many tuples will be returned.)
 * All other subsidiary storage for a PGresult is kept in PGresult_data blocks
 * of size PGRESULT_DATA_BLOCKSIZE.  The overhead at the start of each block
 * is just a link to the next one, if any.  Free-space management info is
 * kept in the owning PGresult.
 * A query returning a small amount of data will thus require three malloc
 * calls: one for the PGresult, one for the tuples pointer array, and one
 * PGresult_data block.
 *
 * Only the most recently allocated PGresult_data block is a candidate to
 * have more stuff added to it --- any extra space left over in older blocks
 * is wasted.  We could be smarter and search the whole chain, but the point
 * here is to be simple and fast.  Typical applications do not keep a PGresult
 * around very long anyway, so some wasted space within one is not a problem.
 *
 * Tuning constants for the space allocator are:
 * PGRESULT_DATA_BLOCKSIZE: size of a standard allocation block, in bytes
 * PGRESULT_ALIGN_BOUNDARY: assumed alignment requirement for binary data
 * PGRESULT_SEP_ALLOC_THRESHOLD: objects bigger than this are given separate
 *	 blocks, instead of being crammed into a regular allocation block.
 * Requirements for correct function are:
 * PGRESULT_ALIGN_BOUNDARY must be a multiple of the alignment requirements
 *		of all machine data types.  (Currently this is set from configure
 *		tests, so it should be OK automatically.)
 * PGRESULT_SEP_ALLOC_THRESHOLD + PGRESULT_BLOCK_OVERHEAD &lt;=
 *			PGRESULT_DATA_BLOCKSIZE
 *		pqResultAlloc assumes an object smaller than the threshold will fit
 *		in a new block.
 * The amount of space wasted at the end of a block could be as much as
 * PGRESULT_SEP_ALLOC_THRESHOLD, so it doesn't pay to make that too large.
 * ----------------
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PGRESULT_DATA_BLOCKSIZE</name></cpp:macro>		<cpp:value>2048</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PGRESULT_ALIGN_BOUNDARY</name></cpp:macro>		<cpp:value>MAXIMUM_ALIGNOF</cpp:value></cpp:define> <comment type="block">/* from configure */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PGRESULT_BLOCK_OVERHEAD</name></cpp:macro>		<cpp:value>Max(sizeof(PGresult_data), PGRESULT_ALIGN_BOUNDARY)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PGRESULT_SEP_ALLOC_THRESHOLD</name></cpp:macro>	<cpp:value>(PGRESULT_DATA_BLOCKSIZE / 2)</cpp:value></cpp:define>


<comment type="block">/*
 * PQmakeEmptyPGresult
 *	 returns a newly allocated, initialized PGresult with given status.
 *	 If conn is not NULL and status indicates an error, the conn's
 *	 errorMessage is copied.  Also, any PGEvents are copied from the conn.
 */</comment>
<function><type><name>PGresult</name> <modifier>*</modifier></type>
<name>PQmakeEmptyPGresult</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>ExecStatusType</name></type> <name>status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PGresult</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PGresult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>ntups</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>numAttributes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>attDescs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>tuples</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>tupArrSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>numParameters</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>paramDescs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>resultStatus</name></name> <operator>=</operator> <name>status</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>cmdStatus</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>binary</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nEvents</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>errMsg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>errFields</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>errQuery</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>null_field</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>curBlock</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>curOffset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>spaceLeft</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>memorySize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGresult</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>conn</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* copy connection data we might need for operations on PGresult */</comment>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>noticeHooks</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>noticeHooks</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>client_encoding</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>client_encoding</name></name></expr>;</expr_stmt>

		<comment type="block">/* consider copying conn's errorMessage */</comment>
		<switch>switch <condition>(<expr><name>status</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>PGRES_EMPTY_QUERY</name></expr>:</case>
			<case>case <expr><name>PGRES_COMMAND_OK</name></expr>:</case>
			<case>case <expr><name>PGRES_TUPLES_OK</name></expr>:</case>
			<case>case <expr><name>PGRES_COPY_OUT</name></expr>:</case>
			<case>case <expr><name>PGRES_COPY_IN</name></expr>:</case>
			<case>case <expr><name>PGRES_COPY_BOTH</name></expr>:</case>
			<case>case <expr><name>PGRES_SINGLE_TUPLE</name></expr>:</case>
				<comment type="block">/* non-error cases */</comment>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>pqSetResultError</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<comment type="block">/* copy events last; result must be valid if we need to PQclear */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>nEvents</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <call><name>dupEvents</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>events</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nEvents</name></name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>memorySize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>result</name><operator>-&gt;</operator><name>events</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nEvents</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>nEvents</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* defaults... */</comment>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>noticeHooks</name><operator>.</operator><name>noticeRec</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>noticeHooks</name><operator>.</operator><name>noticeRecArg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>noticeHooks</name><operator>.</operator><name>noticeProc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>noticeHooks</name><operator>.</operator><name>noticeProcArg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>client_encoding</name></name> <operator>=</operator> <name>PG_SQL_ASCII</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PQsetResultAttrs
 *
 * Set the attributes for a given result.  This function fails if there are
 * already attributes contained in the provided result.  The call is
 * ignored if numAttributes is zero or attDescs is NULL.  If the
 * function fails, it returns zero.  If the function succeeds, it
 * returns a non-zero value.
 */</comment>
<function><type><name>int</name></type>
<name>PQsetResultAttrs</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numAttributes</name></decl></parameter>, <parameter><decl><type><name>PGresAttDesc</name> <modifier>*</modifier></type><name>attDescs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* If attrs already exist, they cannot be overwritten. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name> <operator>||</operator> <name><name>res</name><operator>-&gt;</operator><name>numAttributes</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* ignore no-op request */</comment>
	<if_stmt><if>if <condition>(<expr><name>numAttributes</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><name>attDescs</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>attDescs</name></name> <operator>=</operator> <operator>(</operator><name>PGresAttDesc</name> <operator>*</operator><operator>)</operator>
		<call><name>PQresultAlloc</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>numAttributes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGresAttDesc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>res</name><operator>-&gt;</operator><name>attDescs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>numAttributes</name></name> <operator>=</operator> <name>numAttributes</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>attDescs</name></name></expr></argument>, <argument><expr><name>attDescs</name></expr></argument>, <argument><expr><name>numAttributes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGresAttDesc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* deep-copy the attribute names, and determine format */</comment>
	<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>binary</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>res</name><operator>-&gt;</operator><name>numAttributes</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>attDescs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>attDescs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>=</operator> <call><name>pqResultStrdup</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>attDescs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>attDescs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>=</operator> <name><name>res</name><operator>-&gt;</operator><name>null_field</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>res</name><operator>-&gt;</operator><name>attDescs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>attDescs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>format</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>binary</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PQcopyResult
 *
 * Returns a deep copy of the provided 'src' PGresult, which cannot be NULL.
 * The 'flags' argument controls which portions of the result will or will
 * NOT be copied.  The created result is always put into the
 * PGRES_TUPLES_OK status.  The source result error message is not copied,
 * although cmdStatus is.
 *
 * To set custom attributes, use PQsetResultAttrs.  That function requires
 * that there are no attrs contained in the result, so to use that
 * function you cannot use the PG_COPYRES_ATTRS or PG_COPYRES_TUPLES
 * options with this function.
 *
 * Options:
 *	 PG_COPYRES_ATTRS - Copy the source result's attributes
 *
 *	 PG_COPYRES_TUPLES - Copy the source result's tuples.  This implies
 *	 copying the attrs, seeing how the attrs are needed by the tuples.
 *
 *	 PG_COPYRES_EVENTS - Copy the source result's events.
 *
 *	 PG_COPYRES_NOTICEHOOKS - Copy the source result's notice hooks.
 */</comment>
<function><type><name>PGresult</name> <modifier>*</modifier></type>
<name>PQcopyResult</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>dest</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>src</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>dest</name> <operator>=</operator> <call><name>PQmakeEmptyPGresult</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dest</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Always copy these over.  Is cmdStatus really useful here? */</comment>
	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>client_encoding</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>client_encoding</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>dest</name><operator>-&gt;</operator><name>cmdStatus</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>cmdStatus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Wants attrs? */</comment>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>PG_COPYRES_ATTRS</name> <operator>|</operator> <name>PG_COPYRES_TUPLES</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQsetResultAttrs</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>numAttributes</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>attDescs</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Wants to copy tuples? */</comment>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>PG_COPYRES_TUPLES</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>tup</name></decl>,
					<decl><type ref="prev"/><name>field</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>tup</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>tup</name> <operator>&lt;</operator> <name><name>src</name><operator>-&gt;</operator><name>ntups</name></name></expr>;</condition> <incr><expr><name>tup</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>field</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>field</name> <operator>&lt;</operator> <name><name>src</name><operator>-&gt;</operator><name>numAttributes</name></name></expr>;</condition> <incr><expr><name>field</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQsetvalue</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><name>field</name></expr></argument>,
								<argument><expr><name><name>src</name><operator>-&gt;</operator><name>tuples</name><index>[<expr><name>tup</name></expr>]</index><index>[<expr><name>field</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>,
								<argument><expr><name><name>src</name><operator>-&gt;</operator><name>tuples</name><index>[<expr><name>tup</name></expr>]</index><index>[<expr><name>field</name></expr>]</index></name><operator>.</operator><name>len</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>NULL</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Wants to copy notice hooks? */</comment>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>PG_COPYRES_NOTICEHOOKS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>noticeHooks</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>noticeHooks</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Wants to copy PGEvents? */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>PG_COPYRES_EVENTS</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>src</name><operator>-&gt;</operator><name>nEvents</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <call><name>dupEvents</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>events</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>nEvents</name></name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name><name>dest</name><operator>-&gt;</operator><name>memorySize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dest</name><operator>-&gt;</operator><name>events</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>nEvents</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>nEvents</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Okay, trigger PGEVT_RESULTCOPY event */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>dest</name><operator>-&gt;</operator><name>nEvents</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>src</name><operator>-&gt;</operator><name>events</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>resultInitialized</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PGEventResultCopy</name></type> <name>evt</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>evt</name><operator>.</operator><name>src</name></name> <operator>=</operator> <name>src</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>evt</name><operator>.</operator><name>dest</name></name> <operator>=</operator> <name>dest</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dest</name><operator>-&gt;</operator><name>events</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>proc</name><argument_list>(<argument><expr><name>PGEVT_RESULTCOPY</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>evt</name></expr></argument>,
									  <argument><expr><name><name>dest</name><operator>-&gt;</operator><name>events</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>passThrough</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>events</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>resultInitialized</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>dest</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Copy an array of PGEvents (with no extra space for more).
 * Does not duplicate the event instance data, sets this to NULL.
 * Also, the resultInitialized flags are all cleared.
 * The total space allocated is added to *memSize.
 */</comment>
<function><type><specifier>static</specifier> <name>PGEvent</name> <modifier>*</modifier></type>
<name>dupEvents</name><parameter_list>(<parameter><decl><type><name>PGEvent</name> <modifier>*</modifier></type><name>events</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>memSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGEvent</name>    <modifier>*</modifier></type><name>newEvents</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>msize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>events</name> <operator>||</operator> <name>count</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>msize</name> <operator>=</operator> <name>count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGEvent</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>newEvents</name> <operator>=</operator> <operator>(</operator><name>PGEvent</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>msize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>newEvents</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>newEvents</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>proc</name> <operator>=</operator> <name><name>events</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>proc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newEvents</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>passThrough</name> <operator>=</operator> <name><name>events</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>passThrough</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newEvents</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>data</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newEvents</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>resultInitialized</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newEvents</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name><name>events</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>newEvents</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr>)</condition>
		<block>{<block_content>
			<while>while <condition>(<expr><operator>--</operator><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>newEvents</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>newEvents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>msize</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>events</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><operator>*</operator><name>memSize</name> <operator>+=</operator> <name>msize</name></expr>;</expr_stmt>
	<return>return <expr><name>newEvents</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Sets the value for a tuple field.  The tup_num must be less than or
 * equal to PQntuples(res).  If it is equal, a new tuple is created and
 * added to the result.
 * Returns a non-zero value for success and zero for failure.
 * (On failure, we report the specific problem via pqInternalNotice.)
 */</comment>
<function><type><name>int</name></type>
<name>PQsetvalue</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tup_num</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>field_num</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresAttValue</name> <modifier>*</modifier></type><name>attval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errmsg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Note that this check also protects us against null "res" */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>check_field_number</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>field_num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Invalid tup_num, must be &lt;= ntups */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tup_num</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>tup_num</name></expr></argument> &gt;</argument_list></name> <name><name>res</name><operator>-&gt;</operator><name>ntups</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pqInternalNotice</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>res</name><operator>-&gt;</operator><name>noticeHooks</name></name></expr></argument>,
						 <argument><expr><literal type="string">"row number %d is out of range 0..%d"</literal></expr></argument>,
						 <argument><expr><name>tup_num</name></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>ntups</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* need to allocate a new tuple? */</comment>
	<if_stmt><if>if <condition>(<expr><name>tup_num</name> <operator>==</operator> <name><name>res</name><operator>-&gt;</operator><name>ntups</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresAttValue</name> <modifier>*</modifier></type><name>tup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tup</name> <operator>=</operator> <operator>(</operator><name>PGresAttValue</name> <operator>*</operator><operator>)</operator>
			<call><name>pqResultAlloc</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>numAttributes</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGresAttValue</name></expr></argument>)</argument_list></sizeof></expr></argument>,
						  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tup</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

		<comment type="block">/* initialize each column to NULL */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>res</name><operator>-&gt;</operator><name>numAttributes</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>tup</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name> <operator>=</operator> <name>NULL_LEN</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tup</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name><name>res</name><operator>-&gt;</operator><name>null_field</name></name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* add it to the array */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pqAddTuple</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errmsg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>attval</name> <operator>=</operator> <operator>&amp;</operator><name><name>res</name><operator>-&gt;</operator><name>tuples</name><index>[<expr><name>tup_num</name></expr>]</index><index>[<expr><name>field_num</name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* treat either NULL_LEN or NULL value pointer as a NULL field */</comment>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <name>NULL_LEN</name> <operator>||</operator> <name>value</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>attval</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>NULL_LEN</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>attval</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name><name>res</name><operator>-&gt;</operator><name>null_field</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>attval</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>attval</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name><name>res</name><operator>-&gt;</operator><name>null_field</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>attval</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>pqResultAlloc</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>attval</name><operator>-&gt;</operator><name>value</name></name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>attval</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>attval</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>attval</name><operator>-&gt;</operator><name>value</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>

	<comment type="block">/*
	 * Report failure via pqInternalNotice.  If preceding code didn't provide
	 * an error message, assume "out of memory" was meant.
	 */</comment>
<label><name>fail</name>:</label>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>errmsg</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>errmsg</name> <operator>=</operator> <call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>pqInternalNotice</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>res</name><operator>-&gt;</operator><name>noticeHooks</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>errmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pqResultAlloc - exported routine to allocate local storage in a PGresult.
 *
 * We force all such allocations to be maxaligned, since we don't know
 * whether the value might be binary.
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>PQresultAlloc</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nBytes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>pqResultAlloc</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>nBytes</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pqResultAlloc -
 *		Allocate subsidiary storage for a PGresult.
 *
 * nBytes is the amount of space needed for the object.
 * If isBinary is true, we assume that we need to align the object on
 * a machine allocation boundary.
 * If isBinary is false, we assume the object is a char string and can
 * be allocated on any byte boundary.
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>pqResultAlloc</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nBytes</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isBinary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>space</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult_data</name> <modifier>*</modifier></type><name>block</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>nBytes</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>res</name><operator>-&gt;</operator><name>null_field</name></name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If alignment is needed, round up the current position to an alignment
	 * boundary.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isBinary</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>offset</name> <init>= <expr><name><name>res</name><operator>-&gt;</operator><name>curOffset</name></name> <operator>%</operator> <name>PGRESULT_ALIGN_BOUNDARY</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>offset</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>curOffset</name></name> <operator>+=</operator> <name>PGRESULT_ALIGN_BOUNDARY</name> <operator>-</operator> <name>offset</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>spaceLeft</name></name> <operator>-=</operator> <name>PGRESULT_ALIGN_BOUNDARY</name> <operator>-</operator> <name>offset</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If there's enough space in the current block, no problem. */</comment>
	<if_stmt><if>if <condition>(<expr><name>nBytes</name> <operator>&lt;=</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name><name>res</name><operator>-&gt;</operator><name>spaceLeft</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>space</name> <operator>=</operator> <name><name>res</name><operator>-&gt;</operator><name>curBlock</name><operator>-&gt;</operator><name>space</name></name> <operator>+</operator> <name><name>res</name><operator>-&gt;</operator><name>curOffset</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>curOffset</name></name> <operator>+=</operator> <name>nBytes</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>spaceLeft</name></name> <operator>-=</operator> <name>nBytes</name></expr>;</expr_stmt>
		<return>return <expr><name>space</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the requested object is very large, give it its own block; this
	 * avoids wasting what might be most of the current block to start a new
	 * block.  (We'd have to special-case requests bigger than the block size
	 * anyway.)  The object is always given binary alignment in this case.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nBytes</name> <operator>&gt;=</operator> <name>PGRESULT_SEP_ALLOC_THRESHOLD</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type>		<name>alloc_size</name> <init>= <expr><name>nBytes</name> <operator>+</operator> <name>PGRESULT_BLOCK_OVERHEAD</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>block</name> <operator>=</operator> <operator>(</operator><name>PGresult_data</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>alloc_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>block</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>memorySize</name></name> <operator>+=</operator> <name>alloc_size</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>space</name> <operator>=</operator> <name><name>block</name><operator>-&gt;</operator><name>space</name></name> <operator>+</operator> <name>PGRESULT_BLOCK_OVERHEAD</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>curBlock</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Tuck special block below the active block, so that we don't
			 * have to waste the free space in the active block.
			 */</comment>
			<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>res</name><operator>-&gt;</operator><name>curBlock</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>curBlock</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>block</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Must set up the new block as the first active block. */</comment>
			<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>curBlock</name></name> <operator>=</operator> <name>block</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>spaceLeft</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* be sure it's marked full */</comment>
		</block_content>}</block></else></if_stmt>
		<return>return <expr><name>space</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Otherwise, start a new block. */</comment>
	<expr_stmt><expr><name>block</name> <operator>=</operator> <operator>(</operator><name>PGresult_data</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>PGRESULT_DATA_BLOCKSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>block</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>memorySize</name></name> <operator>+=</operator> <name>PGRESULT_DATA_BLOCKSIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>res</name><operator>-&gt;</operator><name>curBlock</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>curBlock</name></name> <operator>=</operator> <name>block</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isBinary</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* object needs full alignment */</comment>
		<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>curOffset</name></name> <operator>=</operator> <name>PGRESULT_BLOCK_OVERHEAD</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>spaceLeft</name></name> <operator>=</operator> <name>PGRESULT_DATA_BLOCKSIZE</name> <operator>-</operator> <name>PGRESULT_BLOCK_OVERHEAD</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* we can cram it right after the overhead pointer */</comment>
		<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>curOffset</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGresult_data</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>spaceLeft</name></name> <operator>=</operator> <name>PGRESULT_DATA_BLOCKSIZE</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGresult_data</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>space</name> <operator>=</operator> <name><name>block</name><operator>-&gt;</operator><name>space</name></name> <operator>+</operator> <name><name>res</name><operator>-&gt;</operator><name>curOffset</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>curOffset</name></name> <operator>+=</operator> <name>nBytes</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>spaceLeft</name></name> <operator>-=</operator> <name>nBytes</name></expr>;</expr_stmt>
	<return>return <expr><name>space</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PQresultMemorySize -
 *		Returns total space allocated for the PGresult.
 */</comment>
<function><type><name>size_t</name></type>
<name>PQresultMemorySize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name><name>res</name><operator>-&gt;</operator><name>memorySize</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pqResultStrdup -
 *		Like strdup, but the space is subsidiary PGresult space.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>pqResultStrdup</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>space</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>pqResultAlloc</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>space</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>space</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>space</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pqSetResultError -
 *		assign a new error message to a PGresult
 */</comment>
<function><type><name>void</name></type>
<name>pqSetResultError</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>msg</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>msg</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>errMsg</name></name> <operator>=</operator> <call><name>pqResultStrdup</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>errMsg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pqCatenateResultError -
 *		concatenate a new error message to the one already in a PGresult
 */</comment>
<function><type><name>void</name></type>
<name>pqCatenateResultError</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>errorBuf</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name> <operator>||</operator> <operator>!</operator><name>msg</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errorBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>errMsg</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errorBuf</name></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>errMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errorBuf</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqSetResultError</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name><name>errorBuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errorBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PQclear -
 *	  free's the memory associated with a PGresult
 */</comment>
<function><type><name>void</name></type>
<name>PQclear</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult_data</name> <modifier>*</modifier></type><name>block</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>res</name><operator>-&gt;</operator><name>nEvents</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* only send DESTROY to successfully-initialized event procs */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>events</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>resultInitialized</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PGEventResultDestroy</name></type> <name>evt</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>evt</name><operator>.</operator><name>result</name></name> <operator>=</operator> <name>res</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name><name>res</name><operator>-&gt;</operator><name>events</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>proc</name><argument_list>(<argument><expr><name>PGEVT_RESULTDESTROY</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>evt</name></expr></argument>,
									   <argument><expr><name><name>res</name><operator>-&gt;</operator><name>events</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>passThrough</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>events</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>events</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>events</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Free all the subsidiary blocks */</comment>
	<while>while <condition>(<expr><operator>(</operator><name>block</name> <operator>=</operator> <name><name>res</name><operator>-&gt;</operator><name>curBlock</name></name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>curBlock</name></name> <operator>=</operator> <name><name>block</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Free the top-level tuple pointer array */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>tuples</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>tuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* zero out the pointer fields to catch programming errors */</comment>
	<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>attDescs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>tuples</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>paramDescs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>errFields</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>nEvents</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* res-&gt;curBlock was zeroed out earlier */</comment>

	<comment type="block">/* Free the PGresult structure itself */</comment>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Handy subroutine to deallocate any partially constructed async result.
 *
 * Any "next" result gets cleared too.
 */</comment>
<function><type><name>void</name></type>
<name>pqClearAsyncResult</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>next_result</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>next_result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>next_result</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This subroutine deletes any existing async result, sets conn-&gt;result
 * to a PGresult with status PGRES_FATAL_ERROR, and stores the current
 * contents of conn-&gt;errorMessage into that result.  It differs from a
 * plain call on PQmakeEmptyPGresult() in that if there is already an
 * async result with status PGRES_FATAL_ERROR, the current error message
 * is APPENDED to the old error message instead of replacing it.  This
 * behavior lets us report multiple error conditions properly, if necessary.
 * (An example where this is needed is when the backend sends an 'E' message
 * and immediately closes the connection --- we want to report both the
 * backend error and the connection closure error.)
 */</comment>
<function><type><name>void</name></type>
<name>pqSaveErrorResult</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If no old async result, just let PQmakeEmptyPGresult make one. Likewise
	 * if old result is not an error message.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<name><name>conn</name><operator>-&gt;</operator><name>result</name><operator>-&gt;</operator><name>resultStatus</name></name> <operator>!=</operator> <name>PGRES_FATAL_ERROR</name> <operator>||</operator>
		<name><name>conn</name><operator>-&gt;</operator><name>result</name><operator>-&gt;</operator><name>errMsg</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pqClearAsyncResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <call><name>PQmakeEmptyPGresult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>PGRES_FATAL_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Else, concatenate error message to existing async result. */</comment>
		<expr_stmt><expr><call><name>pqCatenateResultError</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * As above, and append conn-&gt;write_err_msg to whatever other error we have.
 * This is used when we've detected a write failure and have exhausted our
 * chances of reporting something else instead.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pqSaveWriteError</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Ensure conn-&gt;result is an error result, and add anything in
	 * conn-&gt;errorMessage to it.
	 */</comment>
	<expr_stmt><expr><call><name>pqSaveErrorResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now append write_err_msg to that.  If it's null because of previous
	 * strdup failure, do what we can.  (It's likely our machinations here are
	 * all getting OOM failures as well, but ...)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>write_err_msg</name></name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>write_err_msg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pqCatenateResultError</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>write_err_msg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pqCatenateResultError</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"write to server failed\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This subroutine prepares an async result object for return to the caller.
 * If there is not already an async result object, build an error object
 * using whatever is in conn-&gt;errorMessage.  In any case, clear the async
 * result storage and make sure PQerrorMessage will agree with the result's
 * error string.
 */</comment>
<function><type><name>PGresult</name> <modifier>*</modifier></type>
<name>pqPrepareAsyncResult</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * conn-&gt;result is the PGresult to return.  If it is NULL (which probably
	 * shouldn't happen) we assume there is an appropriate error message in
	 * conn-&gt;errorMessage.
	 */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>result</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQmakeEmptyPGresult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>PGRES_FATAL_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Make sure PQerrorMessage agrees with result; it could be different
		 * if we have concatenated messages.
		 */</comment>
		<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							 <argument><expr><call><name>PQresultErrorMessage</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Replace conn-&gt;result with next_result, if any.  In the normal case
	 * there isn't a next result and we're just dropping ownership of the
	 * current result.  In single-row mode this restores the situation to what
	 * it was before we created the current single-row result.
	 */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>next_result</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>next_result</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pqInternalNotice - produce an internally-generated notice message
 *
 * A format string and optional arguments can be passed.  Note that we do
 * libpq_gettext() here, so callers need not.
 *
 * The supplied text is taken as primary message (ie., it should not include
 * a trailing newline, and should not be more than one line).
 */</comment>
<function><type><name>void</name></type>
<name>pqInternalNotice</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGNoticeHooks</name> <modifier>*</modifier></type><name>hooks</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>msgBuf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>va_list</name></type>		<name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hooks</name><operator>-&gt;</operator><name>noticeRec</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* nobody home to receive notice? */</comment>

	<comment type="block">/* Format the message */</comment>
	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>vsnprintf</name><argument_list>(<argument><expr><name>msgBuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msgBuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>msgBuf</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>msgBuf</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>	<comment type="block">/* make real sure it's terminated */</comment>

	<comment type="block">/* Make a PGresult to pass to the notice receiver */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQmakeEmptyPGresult</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>PGRES_NONFATAL_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>noticeHooks</name></name> <operator>=</operator> <operator>*</operator><name>hooks</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up fields of notice.
	 */</comment>
	<expr_stmt><expr><call><name>pqSaveMessageField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_MESSAGE_PRIMARY</name></expr></argument>, <argument><expr><name>msgBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqSaveMessageField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_SEVERITY</name></expr></argument>, <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"NOTICE"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqSaveMessageField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_SEVERITY_NONLOCALIZED</name></expr></argument>, <argument><expr><literal type="string">"NOTICE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* XXX should provide a SQLSTATE too? */</comment>

	<comment type="block">/*
	 * Result text is always just the primary message + newline. If we can't
	 * allocate it, don't bother invoking the receiver.
	 */</comment>
	<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>errMsg</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>pqResultAlloc</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>msgBuf</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>errMsg</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>errMsg</name></name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>msgBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Pass to receiver, then free it.
		 */</comment>
		<expr_stmt><expr><call><name><name>res</name><operator>-&gt;</operator><name>noticeHooks</name><operator>.</operator><name>noticeRec</name></name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>noticeHooks</name><operator>.</operator><name>noticeRecArg</name></name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pqAddTuple
 *	  add a row pointer to the PGresult structure, growing it if necessary
 *	  Returns true if OK, false if an error prevented adding the row
 *
 * On error, *errmsgp can be set to an error string to be returned.
 * If it is left NULL, the error is presumed to be "out of memory".
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pqAddTuple</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>PGresAttValue</name> <modifier>*</modifier></type><name>tup</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>errmsgp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>ntups</name></name> <operator>&gt;=</operator> <name><name>res</name><operator>-&gt;</operator><name>tupArrSize</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Try to grow the array.
		 *
		 * We can use realloc because shallow copying of the structure is
		 * okay. Note that the first time through, res-&gt;tuples is NULL. While
		 * ANSI says that realloc() should act like malloc() in that case,
		 * some old C libraries (like SunOS 4.1.x) coredump instead. On
		 * failure realloc is supposed to return NULL without damaging the
		 * existing allocation. Note that the positions beyond res-&gt;ntups are
		 * garbage, not necessarily NULL.
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>newSize</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGresAttValue</name> <modifier>*</modifier><modifier>*</modifier></type><name>newTuples</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Since we use integers for row numbers, we can't support more than
		 * INT_MAX rows.  Make sure we allow that many, though.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>tupArrSize</name></name> <operator>&lt;=</operator> <name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>newSize</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>res</name><operator>-&gt;</operator><name>tupArrSize</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>res</name><operator>-&gt;</operator><name>tupArrSize</name></name> <operator>*</operator> <literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">128</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>tupArrSize</name></name> <operator>&lt;</operator> <name>INT_MAX</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>newSize</name> <operator>=</operator> <name>INT_MAX</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>errmsgp</name> <operator>=</operator> <call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"PGresult cannot support more than INT_MAX tuples"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Also, on 32-bit platforms we could, in theory, overflow size_t even
		 * before newSize gets to INT_MAX.  (In practice we'd doubtless hit
		 * OOM long before that, but let's check.)
		 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>INT_MAX</name> <operator>&gt;=</operator> <operator>(</operator><name>SIZE_MAX</name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr></cpp:if>
		<if_stmt><if>if <condition>(<expr><name>newSize</name> <operator>&gt;</operator> <name>SIZE_MAX</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGresAttValue</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>errmsgp</name> <operator>=</operator> <call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"size_t overflow"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>tuples</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>newTuples</name> <operator>=</operator> <operator>(</operator><name>PGresAttValue</name> <operator>*</operator><operator>*</operator><operator>)</operator>
				<call><name>malloc</name><argument_list>(<argument><expr><name>newSize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGresAttValue</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>newTuples</name> <operator>=</operator> <operator>(</operator><name>PGresAttValue</name> <operator>*</operator><operator>*</operator><operator>)</operator>
				<call><name>realloc</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>tuples</name></name></expr></argument>, <argument><expr><name>newSize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGresAttValue</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>newTuples</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* malloc or realloc failed */</comment>
		<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>memorySize</name></name> <operator>+=</operator>
			<operator>(</operator><name>newSize</name> <operator>-</operator> <name><name>res</name><operator>-&gt;</operator><name>tupArrSize</name></name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGresAttValue</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>tupArrSize</name></name> <operator>=</operator> <name>newSize</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>tuples</name></name> <operator>=</operator> <name>newTuples</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>tuples</name><index>[<expr><name><name>res</name><operator>-&gt;</operator><name>ntups</name></name></expr>]</index></name> <operator>=</operator> <name>tup</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>ntups</name></name><operator>++</operator></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pqSaveMessageField - save one field of an error or notice message
 */</comment>
<function><type><name>void</name></type>
<name>pqSaveMessageField</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGMessageField</name> <modifier>*</modifier></type><name>pfield</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pfield</name> <operator>=</operator> <operator>(</operator><name>PGMessageField</name> <operator>*</operator><operator>)</operator>
		<call><name>pqResultAlloc</name><argument_list>(<argument><expr><name>res</name></expr></argument>,
					  <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PGMessageField</name></expr></argument>, <argument><expr><name>contents</name></expr></argument>)</argument_list></call> <operator>+</operator>
					  <call><name>strlen</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
					  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pfield</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* out of memory? */</comment>
	<expr_stmt><expr><name><name>pfield</name><operator>-&gt;</operator><name>code</name></name> <operator>=</operator> <name>code</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>pfield</name><operator>-&gt;</operator><name>contents</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pfield</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>res</name><operator>-&gt;</operator><name>errFields</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>errFields</name></name> <operator>=</operator> <name>pfield</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pqSaveParameterStatus - remember parameter status sent by backend
 */</comment>
<function><type><name>void</name></type>
<name>pqSaveParameterStatus</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pgParameterStatus</name> <modifier>*</modifier></type><name>pstatus</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgParameterStatus</name> <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>Pfdebug</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>Pfdebug</name></name></expr></argument>, <argument><expr><literal type="string">"pqSaveParameterStatus: '%s' = '%s'\n"</literal></expr></argument>,
				<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Forget any old information about the parameter
	 */</comment>
	<for>for <control>(<init><expr><name>pstatus</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>pstatus</name></name></expr><operator>,</operator> <expr><name>prev</name> <operator>=</operator> <name>NULL</name></expr>;</init>
		 <condition><expr><name>pstatus</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
		 <incr><expr><name>prev</name> <operator>=</operator> <name>pstatus</name></expr><operator>,</operator> <expr><name>pstatus</name> <operator>=</operator> <name><name>pstatus</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>pstatus</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>prev</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>pstatus</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pstatus</name></name> <operator>=</operator> <name><name>pstatus</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pstatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* frees name and value strings too */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Store new info as a single malloc block
	 */</comment>
	<expr_stmt><expr><name>pstatus</name> <operator>=</operator> <operator>(</operator><name>pgParameterStatus</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pgParameterStatus</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
										   <call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pstatus</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>pstatus</name><operator>)</operator> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pgParameterStatus</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pstatus</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pstatus</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pstatus</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>pstatus</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pstatus</name></name> <operator>=</operator> <name>pstatus</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Special hacks: remember client_encoding and
	 * standard_conforming_strings, and convert server version to a numeric
	 * form.  We keep the first two of these in static variables as well, so
	 * that PQescapeString and PQescapeBytea can behave somewhat sanely (at
	 * least in single-connection-using programs).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"client_encoding"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>client_encoding</name></name> <operator>=</operator> <call><name>pg_char_to_encoding</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* if we don't recognize the encoding name, fall back to SQL_ASCII */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>client_encoding</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>client_encoding</name></name> <operator>=</operator> <name>PG_SQL_ASCII</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>static_client_encoding</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>client_encoding</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"standard_conforming_strings"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>std_strings</name></name> <operator>=</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"on"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>static_std_strings</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>std_strings</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"server_version"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>cnt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>vmaj</name></decl>,
					<decl><type ref="prev"/><name>vmin</name></decl>,
					<decl><type ref="prev"/><name>vrev</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>cnt</name> <operator>=</operator> <call><name>sscanf</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"%d.%d.%d"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>vmaj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vmin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vrev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>cnt</name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* old style, e.g. 9.6.1 */</comment>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sversion</name></name> <operator>=</operator> <operator>(</operator><literal type="number">100</literal> <operator>*</operator> <name>vmaj</name> <operator>+</operator> <name>vmin</name><operator>)</operator> <operator>*</operator> <literal type="number">100</literal> <operator>+</operator> <name>vrev</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>cnt</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>vmaj</name> <operator>&gt;=</operator> <literal type="number">10</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* new style, e.g. 10.1 */</comment>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sversion</name></name> <operator>=</operator> <literal type="number">100</literal> <operator>*</operator> <literal type="number">100</literal> <operator>*</operator> <name>vmaj</name> <operator>+</operator> <name>vmin</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* old style without minor version, e.g. 9.6devel */</comment>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sversion</name></name> <operator>=</operator> <operator>(</operator><literal type="number">100</literal> <operator>*</operator> <name>vmaj</name> <operator>+</operator> <name>vmin</name><operator>)</operator> <operator>*</operator> <literal type="number">100</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>cnt</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* new style without minor version, e.g. 10devel */</comment>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sversion</name></name> <operator>=</operator> <literal type="number">100</literal> <operator>*</operator> <literal type="number">100</literal> <operator>*</operator> <name>vmaj</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sversion</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt> <comment type="block">/* unknown */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"agversion"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>cnt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>vmaj</name></decl>,
					<decl><type ref="prev"/><name>vmin</name></decl>,
					<decl><type ref="prev"/><name>vrev</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>cnt</name> <operator>=</operator> <call><name>sscanf</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"%d.%d.%d"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>vmaj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vmin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vrev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>cnt</name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* default style, e.g. 2.1.0 */</comment>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>agversion</name></name> <operator>=</operator> <operator>(</operator><literal type="number">100</literal> <operator>*</operator> <name>vmaj</name> <operator>+</operator> <name>vmin</name><operator>)</operator> <operator>*</operator> <literal type="number">100</literal> <operator>+</operator> <name>vrev</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>cnt</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* e.g. 2.2devel*/</comment>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>agversion</name></name> <operator>=</operator> <operator>(</operator><literal type="number">100</literal> <operator>*</operator> <name>vmaj</name> <operator>+</operator> <name>vmin</name><operator>)</operator> <operator>*</operator> <literal type="number">100</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>agversion</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt> <comment type="block">/* unknown */</comment>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * pqRowProcessor
 *	  Add the received row to the current async result (conn-&gt;result).
 *	  Returns 1 if OK, 0 if error occurred.
 *
 * On error, *errmsgp can be set to an error string to be returned.
 * If it is left NULL, the error is presumed to be "out of memory".
 *
 * In single-row mode, we create a new result holding just the current row,
 * stashing the previous result in conn-&gt;next_result so that it becomes
 * active again after pqPrepareAsyncResult().  This allows the result metadata
 * (column descriptions) to be carried forward to each result row.
 */</comment>
<function><type><name>int</name></type>
<name>pqRowProcessor</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>errmsgp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nfields</name> <init>= <expr><name><name>res</name><operator>-&gt;</operator><name>numAttributes</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>PGdataValue</name> <modifier>*</modifier></type><name>columns</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>rowBuf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresAttValue</name> <modifier>*</modifier></type><name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * In single-row mode, make a new PGresult that will hold just this one
	 * row; the original conn-&gt;result is left unchanged so that it can be used
	 * again as the template for future rows.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>singleRowMode</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Copy everything that should be in the result at this point */</comment>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQcopyResult</name><argument_list>(<argument><expr><name>res</name></expr></argument>,
						   <argument><expr><name>PG_COPYRES_ATTRS</name> <operator>|</operator> <name>PG_COPYRES_EVENTS</name> <operator>|</operator>
						   <name>PG_COPYRES_NOTICEHOOKS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Basically we just allocate space in the PGresult for each field and
	 * copy the data over.
	 *
	 * Note: on malloc failure, we return 0 leaving *errmsgp still NULL, which
	 * caller will take to mean "out of memory".  This is preferable to trying
	 * to set up such a message here, because evidently there's not enough
	 * memory for gettext() to do anything.
	 */</comment>
	<expr_stmt><expr><name>tup</name> <operator>=</operator> <operator>(</operator><name>PGresAttValue</name> <operator>*</operator><operator>)</operator>
		<call><name>pqResultAlloc</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>nfields</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGresAttValue</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tup</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nfields</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>clen</name> <init>= <expr><name><name>columns</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* null field */</comment>
			<expr_stmt><expr><name><name>tup</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name> <operator>=</operator> <name>NULL_LEN</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tup</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name><name>res</name><operator>-&gt;</operator><name>null_field</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>isbinary</name> <init>= <expr><operator>(</operator><name><name>res</name><operator>-&gt;</operator><name>attDescs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>format</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>pqResultAlloc</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>clen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>isbinary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

			<comment type="block">/* copy and zero-terminate the data (even if it's binary) */</comment>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name><name>columns</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>, <argument><expr><name>clen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>val</name><index>[<expr><name>clen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>tup</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name> <operator>=</operator> <name>clen</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tup</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* And add the tuple to the PGresult's tuple array */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pqAddTuple</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><name>errmsgp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Success.  In single-row mode, make the result available to the client
	 * immediately.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>singleRowMode</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Change result status to special single-row value */</comment>
		<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>resultStatus</name></name> <operator>=</operator> <name>PGRES_SINGLE_TUPLE</name></expr>;</expr_stmt>
		<comment type="block">/* Stash old result for re-use later */</comment>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>next_result</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>result</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <name>res</name></expr>;</expr_stmt>
		<comment type="block">/* And mark the result ready to return */</comment>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_READY</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">1</literal></expr>;</return>

<label><name>fail</name>:</label>
	<comment type="block">/* release locally allocated PGresult, if we made one */</comment>
	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name><name>conn</name><operator>-&gt;</operator><name>result</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PQsendQuery
 *	 Submit a query, but don't wait for it to finish
 *
 * Returns: 1 if successfully submitted
 *			0 if error (conn-&gt;errorMessage is set)
 */</comment>
<function><type><name>int</name></type>
<name>PQsendQuery</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQsendQueryStart</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* check the argument */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>query</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"command string is a null pointer\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* construct the outgoing Query message */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pqPutMsgStart</name><argument_list>(<argument><expr><literal type="char">'Q'</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pqPuts</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pqPutMsgEnd</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* error message should be set up already */</comment>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* remember we are using simple query protocol */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>queryclass</name></name> <operator>=</operator> <name>PGQUERY_SIMPLE</name></expr>;</expr_stmt>

	<comment type="block">/* and remember the query text too, if possible */</comment>
	<comment type="block">/* if insufficient memory, last_query just winds up NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>last_query</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>last_query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>last_query</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Give the data a push.  In nonblock mode, don't complain if we're unable
	 * to send it all; PQgetResult() will do any additional flushing needed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pqFlush</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* error message should be set up already */</comment>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* OK, it's launched! */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_BUSY</name></expr>;</expr_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PQsendQueryParams
 *		Like PQsendQuery, but use protocol 3.0 so we can pass parameters
 */</comment>
<function><type><name>int</name></type>
<name>PQsendQueryParams</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
				  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>command</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>nParams</name></decl></parameter>,
				  <parameter><decl><type><specifier>const</specifier> <name>Oid</name> <modifier>*</modifier></type><name>paramTypes</name></decl></parameter>,
				  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>paramValues</name></decl></parameter>,
				  <parameter><decl><type><specifier>const</specifier> <name>int</name> <modifier>*</modifier></type><name>paramLengths</name></decl></parameter>,
				  <parameter><decl><type><specifier>const</specifier> <name>int</name> <modifier>*</modifier></type><name>paramFormats</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>resultFormat</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQsendQueryStart</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* check the arguments */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>command</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"command string is a null pointer\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>nParams</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>nParams</name></expr></argument> &gt;</argument_list></name> <literal type="number">65535</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"number of parameters must be between 0 and 65535\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>PQsendQueryGuts</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
						   <argument><expr><name>command</name></expr></argument>,
						   <argument><expr><literal type="string">""</literal></expr></argument>,	<comment type="block">/* use unnamed statement */</comment>
						   <argument><expr><name>nParams</name></expr></argument>,
						   <argument><expr><name>paramTypes</name></expr></argument>,
						   <argument><expr><name>paramValues</name></expr></argument>,
						   <argument><expr><name>paramLengths</name></expr></argument>,
						   <argument><expr><name>paramFormats</name></expr></argument>,
						   <argument><expr><name>resultFormat</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PQsendPrepare
 *	 Submit a Parse message, but don't wait for it to finish
 *
 * Returns: 1 if successfully submitted
 *			0 if error (conn-&gt;errorMessage is set)
 */</comment>
<function><type><name>int</name></type>
<name>PQsendPrepare</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
			  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmtName</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>nParams</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Oid</name> <modifier>*</modifier></type><name>paramTypes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQsendQueryStart</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* check the arguments */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>stmtName</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"statement name is a null pointer\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>query</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"command string is a null pointer\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>nParams</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>nParams</name></expr></argument> &gt;</argument_list></name> <literal type="number">65535</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"number of parameters must be between 0 and 65535\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* This isn't gonna work on a 2.0 server */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pversion</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"function requires at least protocol version 3.0\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* construct the Parse message */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pqPutMsgStart</name><argument_list>(<argument><expr><literal type="char">'P'</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pqPuts</name><argument_list>(<argument><expr><name>stmtName</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pqPuts</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>sendFailed</name>;</goto></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>nParams</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>paramTypes</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>pqPutInt</name><argument_list>(<argument><expr><name>nParams</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>sendFailed</name>;</goto></block_content></block></if></if_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nParams</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pqPutInt</name><argument_list>(<argument><expr><name><name>paramTypes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>sendFailed</name>;</goto></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pqPutInt</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>sendFailed</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pqPutMsgEnd</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>sendFailed</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/* construct the Sync message */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pqPutMsgStart</name><argument_list>(<argument><expr><literal type="char">'S'</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pqPutMsgEnd</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>sendFailed</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/* remember we are doing just a Parse */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>queryclass</name></name> <operator>=</operator> <name>PGQUERY_PREPARE</name></expr>;</expr_stmt>

	<comment type="block">/* and remember the query text too, if possible */</comment>
	<comment type="block">/* if insufficient memory, last_query just winds up NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>last_query</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>last_query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>last_query</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Give the data a push.  In nonblock mode, don't complain if we're unable
	 * to send it all; PQgetResult() will do any additional flushing needed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pqFlush</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>sendFailed</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/* OK, it's launched! */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_BUSY</name></expr>;</expr_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>

<label><name>sendFailed</name>:</label>
	<comment type="block">/* error message should be set up already */</comment>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PQsendQueryPrepared
 *		Like PQsendQuery, but execute a previously prepared statement,
 *		using protocol 3.0 so we can pass parameters
 */</comment>
<function><type><name>int</name></type>
<name>PQsendQueryPrepared</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
					<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmtName</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>nParams</name></decl></parameter>,
					<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>paramValues</name></decl></parameter>,
					<parameter><decl><type><specifier>const</specifier> <name>int</name> <modifier>*</modifier></type><name>paramLengths</name></decl></parameter>,
					<parameter><decl><type><specifier>const</specifier> <name>int</name> <modifier>*</modifier></type><name>paramFormats</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>resultFormat</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQsendQueryStart</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* check the arguments */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>stmtName</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"statement name is a null pointer\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>nParams</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>nParams</name></expr></argument> &gt;</argument_list></name> <literal type="number">65535</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"number of parameters must be between 0 and 65535\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>PQsendQueryGuts</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
						   <argument><expr><name>NULL</name></expr></argument>,	<comment type="block">/* no command to parse */</comment>
						   <argument><expr><name>stmtName</name></expr></argument>,
						   <argument><expr><name>nParams</name></expr></argument>,
						   <argument><expr><name>NULL</name></expr></argument>,	<comment type="block">/* no param types */</comment>
						   <argument><expr><name>paramValues</name></expr></argument>,
						   <argument><expr><name>paramLengths</name></expr></argument>,
						   <argument><expr><name>paramFormats</name></expr></argument>,
						   <argument><expr><name>resultFormat</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Common startup code for PQsendQuery and sibling routines
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>PQsendQueryStart</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* clear the error string */</comment>
	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Don't try to send if we know there's no live connection. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>CONNECTION_OK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"no connection to the server\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Can't send while already busy, either. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>!=</operator> <name>PGASYNC_IDLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"another command is already in progress\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* initialize async result-accumulation state */</comment>
	<expr_stmt><expr><call><name>pqClearAsyncResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* reset single-row processing mode */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>singleRowMode</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* ready to send command message */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PQsendQueryGuts
 *		Common code for protocol-3.0 query sending
 *		PQsendQueryStart should be done already
 *
 * command may be NULL to indicate we use an already-prepared statement
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>PQsendQueryGuts</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
				<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>command</name></decl></parameter>,
				<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmtName</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>nParams</name></decl></parameter>,
				<parameter><decl><type><specifier>const</specifier> <name>Oid</name> <modifier>*</modifier></type><name>paramTypes</name></decl></parameter>,
				<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>paramValues</name></decl></parameter>,
				<parameter><decl><type><specifier>const</specifier> <name>int</name> <modifier>*</modifier></type><name>paramLengths</name></decl></parameter>,
				<parameter><decl><type><specifier>const</specifier> <name>int</name> <modifier>*</modifier></type><name>paramFormats</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>resultFormat</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* This isn't gonna work on a 2.0 server */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pversion</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"function requires at least protocol version 3.0\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We will send Parse (if needed), Bind, Describe Portal, Execute, Sync,
	 * using specified statement name and the unnamed portal.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><name>command</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* construct the Parse message */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pqPutMsgStart</name><argument_list>(<argument><expr><literal type="char">'P'</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>pqPuts</name><argument_list>(<argument><expr><name>stmtName</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>pqPuts</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>sendFailed</name>;</goto></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>nParams</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>paramTypes</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pqPutInt</name><argument_list>(<argument><expr><name>nParams</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>sendFailed</name>;</goto></block_content></block></if></if_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nParams</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>pqPutInt</name><argument_list>(<argument><expr><name><name>paramTypes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<goto>goto <name>sendFailed</name>;</goto></block_content></block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pqPutInt</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>sendFailed</name>;</goto></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>pqPutMsgEnd</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>sendFailed</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Construct the Bind message */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pqPutMsgStart</name><argument_list>(<argument><expr><literal type="char">'B'</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pqPuts</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pqPuts</name><argument_list>(<argument><expr><name>stmtName</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>sendFailed</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/* Send parameter formats */</comment>
	<if_stmt><if>if <condition>(<expr><name>nParams</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>paramFormats</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pqPutInt</name><argument_list>(<argument><expr><name>nParams</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>sendFailed</name>;</goto></block_content></block></if></if_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nParams</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pqPutInt</name><argument_list>(<argument><expr><name><name>paramFormats</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>sendFailed</name>;</goto></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pqPutInt</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>sendFailed</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pqPutInt</name><argument_list>(<argument><expr><name>nParams</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>sendFailed</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/* Send parameters */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nParams</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>paramValues</name> <operator>&amp;&amp;</operator> <name><name>paramValues</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>nbytes</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>paramFormats</name> <operator>&amp;&amp;</operator> <name><name>paramFormats</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* binary parameter */</comment>
				<if_stmt><if>if <condition>(<expr><name>paramLengths</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <name><name>paramLengths</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
									  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"length must be given for binary parameter\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>sendFailed</name>;</goto>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* text parameter, do not use paramLengths */</comment>
				<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>paramValues</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>pqPutInt</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>pqPutnchar</name><argument_list>(<argument><expr><name><name>paramValues</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>sendFailed</name>;</goto></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* take the param as NULL */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>pqPutInt</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>sendFailed</name>;</goto></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><call><name>pqPutInt</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pqPutInt</name><argument_list>(<argument><expr><name>resultFormat</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>sendFailed</name>;</goto></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pqPutMsgEnd</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>sendFailed</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/* construct the Describe Portal message */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pqPutMsgStart</name><argument_list>(<argument><expr><literal type="char">'D'</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pqPutc</name><argument_list>(<argument><expr><literal type="char">'P'</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pqPuts</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pqPutMsgEnd</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>sendFailed</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/* construct the Execute message */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pqPutMsgStart</name><argument_list>(<argument><expr><literal type="char">'E'</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pqPuts</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pqPutInt</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pqPutMsgEnd</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>sendFailed</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/* construct the Sync message */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pqPutMsgStart</name><argument_list>(<argument><expr><literal type="char">'S'</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pqPutMsgEnd</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>sendFailed</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/* remember we are using extended query protocol */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>queryclass</name></name> <operator>=</operator> <name>PGQUERY_EXTENDED</name></expr>;</expr_stmt>

	<comment type="block">/* and remember the query text too, if possible */</comment>
	<comment type="block">/* if insufficient memory, last_query just winds up NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>last_query</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>last_query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>command</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>last_query</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>last_query</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Give the data a push.  In nonblock mode, don't complain if we're unable
	 * to send it all; PQgetResult() will do any additional flushing needed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pqFlush</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>sendFailed</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/* OK, it's launched! */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_BUSY</name></expr>;</expr_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>

<label><name>sendFailed</name>:</label>
	<comment type="block">/* error message should be set up already */</comment>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Select row-by-row processing mode
 */</comment>
<function><type><name>int</name></type>
<name>PQsetSingleRowMode</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Only allow setting the flag when we have launched a query and not yet
	 * received any results.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>!=</operator> <name>PGASYNC_BUSY</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>queryclass</name></name> <operator>!=</operator> <name>PGQUERY_SIMPLE</name> <operator>&amp;&amp;</operator>
		<name><name>conn</name><operator>-&gt;</operator><name>queryclass</name></name> <operator>!=</operator> <name>PGQUERY_EXTENDED</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* OK, set flag */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>singleRowMode</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Consume any available input from the backend
 * 0 return: some kind of trouble
 * 1 return: no problem
 */</comment>
<function><type><name>int</name></type>
<name>PQconsumeInput</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * for non-blocking connections try to flush the send-queue, otherwise we
	 * may never get a response for something that may not have already been
	 * sent because it's in our write buffer!
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pqIsnonblocking</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pqFlush</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Load more data, if available. We do this no matter what state we are
	 * in, since we are probably getting called because the application wants
	 * to get rid of a read-select condition. Note that we will NOT block
	 * waiting for more input.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pqReadData</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Parsing of the data waits till later. */</comment>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * parseInput: if appropriate, parse input data from backend
 * until input is exhausted or a stopping state is reached.
 * Note that this function will NOT attempt to read more data from the backend.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>parseInput</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pversion</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pqParseInput3</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pqParseInput2</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PQisBusy
 *	 Return true if PQgetResult would block waiting for input.
 */</comment>

<function><type><name>int</name></type>
<name>PQisBusy</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Parse any available data, if our state permits. */</comment>
	<expr_stmt><expr><call><name>parseInput</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * PQgetResult will return immediately in all states except BUSY.  Also,
	 * if we've detected read EOF and dropped the connection, we can expect
	 * that PQgetResult will fail immediately.  Note that we do *not* check
	 * conn-&gt;write_failed here --- once that's become set, we know we have
	 * trouble, but we need to keep trying to read until we have a complete
	 * server message or detect read EOF.
	 */</comment>
	<return>return <expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>==</operator> <name>PGASYNC_BUSY</name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>CONNECTION_BAD</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PQgetResult
 *	  Get the next PGresult produced by a query.  Returns NULL if no
 *	  query work remains or an error has occurred (e.g. out of
 *	  memory).
 */</comment>

<function><type><name>PGresult</name> <modifier>*</modifier></type>
<name>PQgetResult</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Parse any available data, if our state permits. */</comment>
	<expr_stmt><expr><call><name>parseInput</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If not ready to return something, block until we are. */</comment>
	<while>while <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>==</operator> <name>PGASYNC_BUSY</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>flushResult</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * If data remains unsent, send it.  Else we might be waiting for the
		 * result of a command the backend hasn't even got yet.
		 */</comment>
		<while>while <condition>(<expr><operator>(</operator><name>flushResult</name> <operator>=</operator> <call><name>pqFlush</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pqWait</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>flushResult</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></while>

		<comment type="block">/*
		 * Wait for some more data, and load it.  (Note: if the connection has
		 * been lost, pqWait should return immediately because the socket
		 * should be read-ready, either with the last server data or with an
		 * EOF indication.  We expect therefore that this won't result in any
		 * undue delay in reporting a previous write failure.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>flushResult</name> <operator>||</operator>
			<call><name>pqWait</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>pqReadData</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * conn-&gt;errorMessage has been set by pqWait or pqReadData. We
			 * want to append it to any already-received error message.
			 */</comment>
			<expr_stmt><expr><call><name>pqSaveErrorResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_IDLE</name></expr>;</expr_stmt>
			<return>return <expr><call><name>pqPrepareAsyncResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Parse it. */</comment>
		<expr_stmt><expr><call><name>parseInput</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we had a write error, but nothing above obtained a query result
		 * or detected a read error, report the write error.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>write_failed</name></name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>==</operator> <name>PGASYNC_BUSY</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pqSaveWriteError</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_IDLE</name></expr>;</expr_stmt>
			<return>return <expr><call><name>pqPrepareAsyncResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Return the appropriate thing. */</comment>
	<switch>switch <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PGASYNC_IDLE</name></expr>:</case>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>			<comment type="block">/* query is complete */</comment>
			<break>break;</break>
		<case>case <expr><name>PGASYNC_READY</name></expr>:</case>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pqPrepareAsyncResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Set the state back to BUSY, allowing parsing to proceed. */</comment>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_BUSY</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PGASYNC_COPY_IN</name></expr>:</case>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>getCopyResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>PGRES_COPY_IN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PGASYNC_COPY_OUT</name></expr>:</case>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>getCopyResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>PGRES_COPY_OUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PGASYNC_COPY_BOTH</name></expr>:</case>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>getCopyResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>PGRES_COPY_BOTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"unexpected asyncStatus: %d\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQmakeEmptyPGresult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>PGRES_FATAL_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>res</name><operator>-&gt;</operator><name>nEvents</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PGEventResultCreate</name></type> <name>evt</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>evt</name><operator>.</operator><name>conn</name></name> <operator>=</operator> <name>conn</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>evt</name><operator>.</operator><name>result</name></name> <operator>=</operator> <name>res</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>res</name><operator>-&gt;</operator><name>events</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>proc</name><argument_list>(<argument><expr><name>PGEVT_RESULTCREATE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>evt</name></expr></argument>,
									 <argument><expr><name><name>res</name><operator>-&gt;</operator><name>events</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>passThrough</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
								  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"PGEventProc \"%s\" failed during PGEVT_RESULTCREATE event\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name><name>res</name><operator>-&gt;</operator><name>events</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pqSetResultError</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>resultStatus</name></name> <operator>=</operator> <name>PGRES_FATAL_ERROR</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>events</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>resultInitialized</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getCopyResult
 *	  Helper for PQgetResult: generate result for COPY-in-progress cases
 */</comment>
<function><type><specifier>static</specifier> <name>PGresult</name> <modifier>*</modifier></type>
<name>getCopyResult</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>ExecStatusType</name></type> <name>copytype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If the server connection has been lost, don't pretend everything is
	 * hunky-dory; instead return a PGRES_FATAL_ERROR result, and reset the
	 * asyncStatus to idle (corresponding to what we'd do if we'd detected I/O
	 * error in the earlier steps in PQgetResult).  The text returned in the
	 * result is whatever is in conn-&gt;errorMessage; we hope that was filled
	 * with something relevant when the lost connection was detected.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>CONNECTION_OK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pqSaveErrorResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_IDLE</name></expr>;</expr_stmt>
		<return>return <expr><call><name>pqPrepareAsyncResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If we have an async result for the COPY, return that */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>result</name><operator>-&gt;</operator><name>resultStatus</name></name> <operator>==</operator> <name>copytype</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>pqPrepareAsyncResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Otherwise, invent a suitable PGresult */</comment>
	<return>return <expr><call><name>PQmakeEmptyPGresult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>copytype</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PQexec
 *	  send a query to the backend and package up the result in a PGresult
 *
 * If the query was not even sent, return NULL; conn-&gt;errorMessage is set to
 * a relevant message.
 * If the query was sent, a new PGresult is returned (which could indicate
 * either success or failure).
 * The user is responsible for freeing the PGresult via PQclear()
 * when done with it.
 */</comment>
<function><type><name>PGresult</name> <modifier>*</modifier></type>
<name>PQexec</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQexecStart</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQsendQuery</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><call><name>PQexecFinish</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PQexecParams
 *		Like PQexec, but use protocol 3.0 so we can pass parameters
 */</comment>
<function><type><name>PGresult</name> <modifier>*</modifier></type>
<name>PQexecParams</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
			 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>command</name></decl></parameter>,
			 <parameter><decl><type><name>int</name></type> <name>nParams</name></decl></parameter>,
			 <parameter><decl><type><specifier>const</specifier> <name>Oid</name> <modifier>*</modifier></type><name>paramTypes</name></decl></parameter>,
			 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>paramValues</name></decl></parameter>,
			 <parameter><decl><type><specifier>const</specifier> <name>int</name> <modifier>*</modifier></type><name>paramLengths</name></decl></parameter>,
			 <parameter><decl><type><specifier>const</specifier> <name>int</name> <modifier>*</modifier></type><name>paramFormats</name></decl></parameter>,
			 <parameter><decl><type><name>int</name></type> <name>resultFormat</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQexecStart</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQsendQueryParams</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>command</name></expr></argument>,
						   <argument><expr><name>nParams</name></expr></argument>, <argument><expr><name>paramTypes</name></expr></argument>, <argument><expr><name>paramValues</name></expr></argument>, <argument><expr><name>paramLengths</name></expr></argument>,
						   <argument><expr><name>paramFormats</name></expr></argument>, <argument><expr><name>resultFormat</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><call><name>PQexecFinish</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PQprepare
 *	  Creates a prepared statement by issuing a v3.0 parse message.
 *
 * If the query was not even sent, return NULL; conn-&gt;errorMessage is set to
 * a relevant message.
 * If the query was sent, a new PGresult is returned (which could indicate
 * either success or failure).
 * The user is responsible for freeing the PGresult via PQclear()
 * when done with it.
 */</comment>
<function><type><name>PGresult</name> <modifier>*</modifier></type>
<name>PQprepare</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
		  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmtName</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
		  <parameter><decl><type><name>int</name></type> <name>nParams</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Oid</name> <modifier>*</modifier></type><name>paramTypes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQexecStart</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQsendPrepare</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>stmtName</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>nParams</name></expr></argument>, <argument><expr><name>paramTypes</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><call><name>PQexecFinish</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PQexecPrepared
 *		Like PQexec, but execute a previously prepared statement,
 *		using protocol 3.0 so we can pass parameters
 */</comment>
<function><type><name>PGresult</name> <modifier>*</modifier></type>
<name>PQexecPrepared</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
			   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmtName</name></decl></parameter>,
			   <parameter><decl><type><name>int</name></type> <name>nParams</name></decl></parameter>,
			   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>paramValues</name></decl></parameter>,
			   <parameter><decl><type><specifier>const</specifier> <name>int</name> <modifier>*</modifier></type><name>paramLengths</name></decl></parameter>,
			   <parameter><decl><type><specifier>const</specifier> <name>int</name> <modifier>*</modifier></type><name>paramFormats</name></decl></parameter>,
			   <parameter><decl><type><name>int</name></type> <name>resultFormat</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQexecStart</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQsendQueryPrepared</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>stmtName</name></expr></argument>,
							 <argument><expr><name>nParams</name></expr></argument>, <argument><expr><name>paramValues</name></expr></argument>, <argument><expr><name>paramLengths</name></expr></argument>,
							 <argument><expr><name>paramFormats</name></expr></argument>, <argument><expr><name>resultFormat</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><call><name>PQexecFinish</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Common code for PQexec and sibling routines: prepare to send command
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>PQexecStart</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Silently discard any prior query result that application didn't eat.
	 * This is probably poor design, but it's here for backward compatibility.
	 */</comment>
	<while>while <condition>(<expr><operator>(</operator><name>result</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExecStatusType</name></type> <name>resultStatus</name> <init>= <expr><name><name>result</name><operator>-&gt;</operator><name>resultStatus</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* only need its status */</comment>
		<if_stmt><if>if <condition>(<expr><name>resultStatus</name> <operator>==</operator> <name>PGRES_COPY_IN</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pversion</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* In protocol 3, we can get out of a COPY IN state */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>PQputCopyEnd</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
								 <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"COPY terminated by new PQexec"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
				<comment type="block">/* keep waiting to swallow the copy's failure message */</comment>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* In older protocols we have to punt */</comment>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
								  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"COPY IN state must be terminated first\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>resultStatus</name> <operator>==</operator> <name>PGRES_COPY_OUT</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pversion</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * In protocol 3, we can get out of a COPY OUT state: we just
				 * switch back to BUSY and allow the remaining COPY data to be
				 * dropped on the floor.
				 */</comment>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_BUSY</name></expr>;</expr_stmt>
				<comment type="block">/* keep waiting to swallow the copy's completion message */</comment>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* In older protocols we have to punt */</comment>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
								  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"COPY OUT state must be terminated first\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>resultStatus</name> <operator>==</operator> <name>PGRES_COPY_BOTH</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* We don't allow PQexec during COPY BOTH */</comment>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"PQexec not allowed during COPY BOTH\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* check for loss of connection, too */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>CONNECTION_BAD</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* OK to send a command */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Common code for PQexec and sibling routines: wait for command result
 */</comment>
<function><type><specifier>static</specifier> <name>PGresult</name> <modifier>*</modifier></type>
<name>PQexecFinish</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>lastResult</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * For backwards compatibility, return the last result if there are more
	 * than one --- but merge error messages if we get more than one error
	 * result.
	 *
	 * We have to stop if we see copy in/out/both, however. We will resume
	 * parsing after application performs the data transfer.
	 *
	 * Also stop if the connection is lost (else we'll loop infinitely).
	 */</comment>
	<expr_stmt><expr><name>lastResult</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>result</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>lastResult</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>lastResult</name><operator>-&gt;</operator><name>resultStatus</name></name> <operator>==</operator> <name>PGRES_FATAL_ERROR</name> <operator>&amp;&amp;</operator>
				<name><name>result</name><operator>-&gt;</operator><name>resultStatus</name></name> <operator>==</operator> <name>PGRES_FATAL_ERROR</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pqCatenateResultError</name><argument_list>(<argument><expr><name>lastResult</name></expr></argument>, <argument><expr><name><name>result</name><operator>-&gt;</operator><name>errMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>lastResult</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Make sure PQerrorMessage agrees with concatenated result
				 */</comment>
				<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>, <argument><expr><name><name>result</name><operator>-&gt;</operator><name>errMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>lastResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>lastResult</name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>resultStatus</name></name> <operator>==</operator> <name>PGRES_COPY_IN</name> <operator>||</operator>
			<name><name>result</name><operator>-&gt;</operator><name>resultStatus</name></name> <operator>==</operator> <name>PGRES_COPY_OUT</name> <operator>||</operator>
			<name><name>result</name><operator>-&gt;</operator><name>resultStatus</name></name> <operator>==</operator> <name>PGRES_COPY_BOTH</name> <operator>||</operator>
			<name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>CONNECTION_BAD</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>lastResult</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PQdescribePrepared
 *	  Obtain information about a previously prepared statement
 *
 * If the query was not even sent, return NULL; conn-&gt;errorMessage is set to
 * a relevant message.
 * If the query was sent, a new PGresult is returned (which could indicate
 * either success or failure).  On success, the PGresult contains status
 * PGRES_COMMAND_OK, and its parameter and column-heading fields describe
 * the statement's inputs and outputs respectively.
 * The user is responsible for freeing the PGresult via PQclear()
 * when done with it.
 */</comment>
<function><type><name>PGresult</name> <modifier>*</modifier></type>
<name>PQdescribePrepared</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQexecStart</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQsendDescribe</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="char">'S'</literal></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><call><name>PQexecFinish</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PQdescribePortal
 *	  Obtain information about a previously created portal
 *
 * This is much like PQdescribePrepared, except that no parameter info is
 * returned.  Note that at the moment, libpq doesn't really expose portals
 * to the client; but this can be used with a portal created by a SQL
 * DECLARE CURSOR command.
 */</comment>
<function><type><name>PGresult</name> <modifier>*</modifier></type>
<name>PQdescribePortal</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>portal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQexecStart</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQsendDescribe</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="char">'P'</literal></expr></argument>, <argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><call><name>PQexecFinish</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PQsendDescribePrepared
 *	 Submit a Describe Statement command, but don't wait for it to finish
 *
 * Returns: 1 if successfully submitted
 *			0 if error (conn-&gt;errorMessage is set)
 */</comment>
<function><type><name>int</name></type>
<name>PQsendDescribePrepared</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>PQsendDescribe</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="char">'S'</literal></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PQsendDescribePortal
 *	 Submit a Describe Portal command, but don't wait for it to finish
 *
 * Returns: 1 if successfully submitted
 *			0 if error (conn-&gt;errorMessage is set)
 */</comment>
<function><type><name>int</name></type>
<name>PQsendDescribePortal</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>portal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>PQsendDescribe</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="char">'P'</literal></expr></argument>, <argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PQsendDescribe
 *	 Common code to send a Describe command
 *
 * Available options for desc_type are
 *	 'S' to describe a prepared statement; or
 *	 'P' to describe a portal.
 * Returns 1 on success and 0 on failure.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>PQsendDescribe</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>desc_type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>desc_target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Treat null desc_target as empty string */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>desc_target</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>desc_target</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQsendQueryStart</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* This isn't gonna work on a 2.0 server */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pversion</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"function requires at least protocol version 3.0\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* construct the Describe message */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pqPutMsgStart</name><argument_list>(<argument><expr><literal type="char">'D'</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pqPutc</name><argument_list>(<argument><expr><name>desc_type</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pqPuts</name><argument_list>(<argument><expr><name>desc_target</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pqPutMsgEnd</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>sendFailed</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/* construct the Sync message */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pqPutMsgStart</name><argument_list>(<argument><expr><literal type="char">'S'</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pqPutMsgEnd</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>sendFailed</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/* remember we are doing a Describe */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>queryclass</name></name> <operator>=</operator> <name>PGQUERY_DESCRIBE</name></expr>;</expr_stmt>

	<comment type="block">/* reset last_query string (not relevant now) */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>last_query</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>last_query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>last_query</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Give the data a push.  In nonblock mode, don't complain if we're unable
	 * to send it all; PQgetResult() will do any additional flushing needed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pqFlush</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>sendFailed</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/* OK, it's launched! */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_BUSY</name></expr>;</expr_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>

<label><name>sendFailed</name>:</label>
	<comment type="block">/* error message should be set up already */</comment>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PQnotifies
 *	  returns a PGnotify* structure of the latest async notification
 * that has not yet been handled
 *
 * returns NULL, if there is currently
 * no unhandled async notification from the backend
 *
 * the CALLER is responsible for FREE'ing the structure returned
 *
 * Note that this function does not read any new data from the socket;
 * so usually, caller should call PQconsumeInput() first.
 */</comment>
<function><type><name>PGnotify</name> <modifier>*</modifier></type>
<name>PQnotifies</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGnotify</name>   <modifier>*</modifier></type><name>event</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Parse any available data to see if we can extract NOTIFY messages. */</comment>
	<expr_stmt><expr><call><name>parseInput</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>event</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>notifyHead</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>event</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>notifyHead</name></name> <operator>=</operator> <name><name>event</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>notifyHead</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>notifyTail</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>event</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* don't let app see the internal state */</comment>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>event</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PQputCopyData - send some data to the backend during COPY IN or COPY BOTH
 *
 * Returns 1 if successful, 0 if data could not be sent (only possible
 * in nonblock mode), or -1 if an error occurs.
 */</comment>
<function><type><name>int</name></type>
<name>PQputCopyData</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nbytes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>!=</operator> <name>PGASYNC_COPY_IN</name> <operator>&amp;&amp;</operator>
		<name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>!=</operator> <name>PGASYNC_COPY_BOTH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"no COPY in progress\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Process any NOTICE or NOTIFY messages that might be pending in the
	 * input buffer.  Since the server might generate many notices during the
	 * COPY, we want to clean those out reasonably promptly to prevent
	 * indefinite expansion of the input buffer.  (Note: the actual read of
	 * input data into the input buffer happens down inside pqSendSome, but
	 * it's not authorized to get rid of the data again.)
	 */</comment>
	<expr_stmt><expr><call><name>parseInput</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Try to flush any previously sent data in preference to growing the
		 * output buffer.  If we can't enlarge the buffer enough to hold the
		 * data, return 0 in the nonblock case, else hard error. (For
		 * simplicity, always assume 5 bytes of overhead even in protocol 2.0
		 * case.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>outBufSize</name></name> <operator>-</operator> <name><name>conn</name><operator>-&gt;</operator><name>outCount</name></name> <operator>-</operator> <literal type="number">5</literal><operator>)</operator> <operator>&lt;</operator> <name>nbytes</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pqFlush</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>pqCheckOutBufferSpace</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>outCount</name></name> <operator>+</operator> <literal type="number">5</literal> <operator>+</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name>nbytes</name></expr></argument>,
									  <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><ternary><condition><expr><call><name>pqIsnonblocking</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Send the data (too simple to delegate to fe-protocol files) */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pversion</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pqPutMsgStart</name><argument_list>(<argument><expr><literal type="char">'d'</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>pqPutnchar</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>pqPutMsgEnd</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pqPutMsgStart</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>pqPutnchar</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>pqPutMsgEnd</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PQputCopyEnd - send EOF indication to the backend during COPY IN
 *
 * After calling this, use PQgetResult() to check command completion status.
 *
 * Returns 1 if successful, 0 if data could not be sent (only possible
 * in nonblock mode), or -1 if an error occurs.
 */</comment>
<function><type><name>int</name></type>
<name>PQputCopyEnd</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errormsg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>!=</operator> <name>PGASYNC_COPY_IN</name> <operator>&amp;&amp;</operator>
		<name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>!=</operator> <name>PGASYNC_COPY_BOTH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"no COPY in progress\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Send the COPY END indicator.  This is simple enough that we don't
	 * bother delegating it to the fe-protocol files.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pversion</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errormsg</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Send COPY FAIL */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>pqPutMsgStart</name><argument_list>(<argument><expr><literal type="char">'f'</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>pqPuts</name><argument_list>(<argument><expr><name>errormsg</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>pqPutMsgEnd</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Send COPY DONE */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>pqPutMsgStart</name><argument_list>(<argument><expr><literal type="char">'c'</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>pqPutMsgEnd</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * If we sent the COPY command in extended-query mode, we must issue a
		 * Sync as well.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>queryclass</name></name> <operator>!=</operator> <name>PGQUERY_SIMPLE</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pqPutMsgStart</name><argument_list>(<argument><expr><literal type="char">'S'</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>pqPutMsgEnd</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errormsg</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Oops, no way to do this in 2.0 */</comment>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"function requires at least protocol version 3.0\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Send old-style end-of-data marker */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>pqPutMsgStart</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>pqPutnchar</name><argument_list>(<argument><expr><literal type="string">"\\.\n"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>pqPutMsgEnd</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Return to active duty */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>==</operator> <name>PGASYNC_COPY_BOTH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_COPY_OUT</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_BUSY</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Try to flush data */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pqFlush</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PQgetCopyData - read a row of data from the backend during COPY OUT
 * or COPY BOTH
 *
 * If successful, sets *buffer to point to a malloc'd row of data, and
 * returns row length (always &gt; 0) as result.
 * Returns 0 if no row available yet (only possible if async is true),
 * -1 if end of copy (consult PQgetResult), or -2 if error (consult
 * PQerrorMessage).
 */</comment>
<function><type><name>int</name></type>
<name>PQgetCopyData</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>async</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>buffer</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>				<comment type="block">/* for all failure cases */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>!=</operator> <name>PGASYNC_COPY_OUT</name> <operator>&amp;&amp;</operator>
		<name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>!=</operator> <name>PGASYNC_COPY_BOTH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"no COPY in progress\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">2</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pversion</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>pqGetCopyData3</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>async</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>pqGetCopyData2</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>async</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PQgetline - gets a newline-terminated string from the backend.
 *
 * Chiefly here so that applications can use "COPY &lt;rel&gt; to stdout"
 * and read the output string.  Returns a null-terminated string in s.
 *
 * XXX this routine is now deprecated, because it can't handle binary data.
 * If called during a COPY BINARY we return EOF.
 *
 * PQgetline reads up to maxlen-1 characters (like fgets(3)) but strips
 * the terminating \n (like gets(3)).
 *
 * CAUTION: the caller is responsible for detecting the end-of-copy signal
 * (a line containing just "\.") when using this routine.
 *
 * RETURNS:
 *		EOF if error (eg, invalid arguments are given)
 *		0 if EOL is reached (i.e., \n has been read)
 *				(this is required for backward-compatibility -- this
 *				 routine used to always return EOF or 0, assuming that
 *				 the line ended within maxlen bytes.)
 *		1 in other cases (i.e., the buffer was filled before \n is reached)
 */</comment>
<function><type><name>int</name></type>
<name>PQgetline</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxlen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>s</name> <operator>||</operator> <name>maxlen</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<comment type="block">/* maxlen must be at least 3 to hold the \. terminator! */</comment>
	<if_stmt><if>if <condition>(<expr><name>maxlen</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pversion</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>pqGetline3</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>pqGetline2</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PQgetlineAsync - gets a COPY data row without blocking.
 *
 * This routine is for applications that want to do "COPY &lt;rel&gt; to stdout"
 * asynchronously, that is without blocking.  Having issued the COPY command
 * and gotten a PGRES_COPY_OUT response, the app should call PQconsumeInput
 * and this routine until the end-of-data signal is detected.  Unlike
 * PQgetline, this routine takes responsibility for detecting end-of-data.
 *
 * On each call, PQgetlineAsync will return data if a complete data row
 * is available in libpq's input buffer.  Otherwise, no data is returned
 * until the rest of the row arrives.
 *
 * If -1 is returned, the end-of-data signal has been recognized (and removed
 * from libpq's input buffer).  The caller *must* next call PQendcopy and
 * then return to normal processing.
 *
 * RETURNS:
 *	 -1    if the end-of-copy-data marker has been recognized
 *	 0	   if no data is available
 *	 &gt;0    the number of bytes returned.
 *
 * The data returned will not extend beyond a data-row boundary.  If possible
 * a whole row will be returned at one time.  But if the buffer offered by
 * the caller is too small to hold a row sent by the backend, then a partial
 * data row will be returned.  In text mode this can be detected by testing
 * whether the last returned byte is '\n' or not.
 *
 * The returned data is *not* null-terminated.
 */</comment>

<function><type><name>int</name></type>
<name>PQgetlineAsync</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bufsize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pversion</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>pqGetlineAsync3</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>pqGetlineAsync2</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PQputline -- sends a string to the backend during COPY IN.
 * Returns 0 if OK, EOF if not.
 *
 * This is deprecated primarily because the return convention doesn't allow
 * caller to tell the difference between a hard error and a nonblock-mode
 * send failure.
 */</comment>
<function><type><name>int</name></type>
<name>PQputline</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>PQputnbytes</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PQputnbytes -- like PQputline, but buffer need not be null-terminated.
 * Returns 0 if OK, EOF if not.
 */</comment>
<function><type><name>int</name></type>
<name>PQputnbytes</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nbytes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>PQputCopyData</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>EOF</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PQendcopy
 *		After completing the data transfer portion of a copy in/out,
 *		the application must call this routine to finish the command protocol.
 *
 * When using protocol 3.0 this is deprecated; it's cleaner to use PQgetResult
 * to get the transfer status.  Note however that when using 2.0 protocol,
 * recovering from a copy failure often requires a PQreset.  PQendcopy will
 * take care of that, PQgetResult won't.
 *
 * RETURNS:
 *		0 on success
 *		1 on failure
 */</comment>
<function><type><name>int</name></type>
<name>PQendcopy</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pversion</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>pqEndcopy3</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>pqEndcopy2</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------------
 *		PQfn -	Send a function call to the POSTGRES backend.
 *
 *		conn			: backend connection
 *		fnid			: OID of function to be called
 *		result_buf		: pointer to result buffer
 *		result_len		: actual length of result is returned here
 *		result_is_int	: If the result is an integer, this must be 1,
 *						  otherwise this should be 0
 *		args			: pointer to an array of function arguments
 *						  (each has length, if integer, and value/pointer)
 *		nargs			: # of arguments in args array.
 *
 * RETURNS
 *		PGresult with status = PGRES_COMMAND_OK if successful.
 *			*result_len is &gt; 0 if there is a return value, 0 if not.
 *		PGresult with status = PGRES_FATAL_ERROR if backend returns an error.
 *		NULL on communications failure.  conn-&gt;errorMessage will be set.
 * ----------------
 */</comment>

<function><type><name>PGresult</name> <modifier>*</modifier></type>
<name>PQfn</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
	 <parameter><decl><type><name>int</name></type> <name>fnid</name></decl></parameter>,
	 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>result_buf</name></decl></parameter>,
	 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>result_len</name></decl></parameter>,
	 <parameter><decl><type><name>int</name></type> <name>result_is_int</name></decl></parameter>,
	 <parameter><decl><type><specifier>const</specifier> <name>PQArgBlock</name> <modifier>*</modifier></type><name>args</name></decl></parameter>,
	 <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>result_len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* clear the error string */</comment>
	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name> <operator>==</operator> <name>PGINVALID_SOCKET</name> <operator>||</operator> <name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>!=</operator> <name>PGASYNC_IDLE</name> <operator>||</operator>
		<name><name>conn</name><operator>-&gt;</operator><name>result</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"connection in wrong state\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pversion</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>pqFunctionCall3</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>fnid</name></expr></argument>,
							   <argument><expr><name>result_buf</name></expr></argument>, <argument><expr><name>result_len</name></expr></argument>,
							   <argument><expr><name>result_is_int</name></expr></argument>,
							   <argument><expr><name>args</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>pqFunctionCall2</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>fnid</name></expr></argument>,
							   <argument><expr><name>result_buf</name></expr></argument>, <argument><expr><name>result_len</name></expr></argument>,
							   <argument><expr><name>result_is_int</name></expr></argument>,
							   <argument><expr><name>args</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/* ====== accessor funcs for PGresult ======== */</comment>

<function><type><name>ExecStatusType</name></type>
<name>PQresultStatus</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>PGRES_FATAL_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name><name>res</name><operator>-&gt;</operator><name>resultStatus</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>PQresStatus</name><parameter_list>(<parameter><decl><type><name>ExecStatusType</name></type> <name>status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name>status</name> <operator>&gt;=</operator> <sizeof>sizeof <name>pgresStatus</name></sizeof> <operator>/</operator> <sizeof>sizeof <name><name>pgresStatus</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"invalid ExecStatusType code"</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name><name>pgresStatus</name><index>[<expr><name>status</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>PQresultErrorMessage</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name> <operator>||</operator> <operator>!</operator><name><name>res</name><operator>-&gt;</operator><name>errMsg</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="string">""</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name><name>res</name><operator>-&gt;</operator><name>errMsg</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>PQresultVerboseErrorMessage</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>,
							<parameter><decl><type><name>PGVerbosity</name></type> <name>verbosity</name></decl></parameter>,
							<parameter><decl><type><name>PGContextVisibility</name></type> <name>show_context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>workBuf</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Because the caller is expected to free the result string, we must
	 * strdup any constant result.  We use plain strdup and document that
	 * callers should expect NULL if out-of-memory.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name> <operator>||</operator>
		<operator>(</operator><name><name>res</name><operator>-&gt;</operator><name>resultStatus</name></name> <operator>!=</operator> <name>PGRES_FATAL_ERROR</name> <operator>&amp;&amp;</operator>
		 <name><name>res</name><operator>-&gt;</operator><name>resultStatus</name></name> <operator>!=</operator> <name>PGRES_NONFATAL_ERROR</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>strdup</name><argument_list>(<argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"PGresult is not an error result\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>workBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Currently, we pass this off to fe-protocol3.c in all cases; it will
	 * behave reasonably sanely with an error reported by fe-protocol2.c as
	 * well.  If necessary, we could record the protocol version in PGresults
	 * so as to be able to invoke a version-specific message formatter, but
	 * for now there's no need.
	 */</comment>
	<expr_stmt><expr><call><name>pqBuildErrorMessage3</name><argument_list>(<argument><expr><operator>&amp;</operator><name>workBuf</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>verbosity</name></expr></argument>, <argument><expr><name>show_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If insufficient memory to format the message, fail cleanly */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PQExpBufferDataBroken</name><argument_list>(<argument><expr><name>workBuf</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>workBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>strdup</name><argument_list>(<argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>workBuf</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>PQresultErrorField</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fieldcode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGMessageField</name> <modifier>*</modifier></type><name>pfield</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<for>for <control>(<init><expr><name>pfield</name> <operator>=</operator> <name><name>res</name><operator>-&gt;</operator><name>errFields</name></name></expr>;</init> <condition><expr><name>pfield</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>pfield</name> <operator>=</operator> <name><name>pfield</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>pfield</name><operator>-&gt;</operator><name>code</name></name> <operator>==</operator> <name>fieldcode</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>pfield</name><operator>-&gt;</operator><name>contents</name></name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>PQntuples</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name><name>res</name><operator>-&gt;</operator><name>ntups</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>PQnfields</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name><name>res</name><operator>-&gt;</operator><name>numAttributes</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>PQbinaryTuples</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name><name>res</name><operator>-&gt;</operator><name>binary</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper routines to range-check field numbers and tuple numbers.
 * Return true if OK, false if not
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>check_field_number</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>field_num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* no way to display error message... */</comment>
	<if_stmt><if>if <condition>(<expr><name>field_num</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>field_num</name> <operator>&gt;=</operator> <name><name>res</name><operator>-&gt;</operator><name>numAttributes</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pqInternalNotice</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>res</name><operator>-&gt;</operator><name>noticeHooks</name></name></expr></argument>,
						 <argument><expr><literal type="string">"column number %d is out of range 0..%d"</literal></expr></argument>,
						 <argument><expr><name>field_num</name></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>numAttributes</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>check_tuple_field_number</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>tup_num</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>field_num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* no way to display error message... */</comment>
	<if_stmt><if>if <condition>(<expr><name>tup_num</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>tup_num</name> <operator>&gt;=</operator> <name><name>res</name><operator>-&gt;</operator><name>ntups</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pqInternalNotice</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>res</name><operator>-&gt;</operator><name>noticeHooks</name></name></expr></argument>,
						 <argument><expr><literal type="string">"row number %d is out of range 0..%d"</literal></expr></argument>,
						 <argument><expr><name>tup_num</name></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>ntups</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>field_num</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>field_num</name> <operator>&gt;=</operator> <name><name>res</name><operator>-&gt;</operator><name>numAttributes</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pqInternalNotice</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>res</name><operator>-&gt;</operator><name>noticeHooks</name></name></expr></argument>,
						 <argument><expr><literal type="string">"column number %d is out of range 0..%d"</literal></expr></argument>,
						 <argument><expr><name>field_num</name></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>numAttributes</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>check_param_number</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>param_num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* no way to display error message... */</comment>
	<if_stmt><if>if <condition>(<expr><name>param_num</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>param_num</name> <operator>&gt;=</operator> <name><name>res</name><operator>-&gt;</operator><name>numParameters</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pqInternalNotice</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>res</name><operator>-&gt;</operator><name>noticeHooks</name></name></expr></argument>,
						 <argument><expr><literal type="string">"parameter number %d is out of range 0..%d"</literal></expr></argument>,
						 <argument><expr><name>param_num</name></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>numParameters</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * returns NULL if the field_num is invalid
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>PQfname</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>field_num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>check_field_number</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>field_num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>attDescs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>res</name><operator>-&gt;</operator><name>attDescs</name><index>[<expr><name>field_num</name></expr>]</index></name><operator>.</operator><name>name</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PQfnumber: find column number given column name
 *
 * The column name is parsed as if it were in a SQL statement, including
 * case-folding and double-quote processing.  But note a possible gotcha:
 * downcasing in the frontend might follow different locale rules than
 * downcasing in the backend...
 *
 * Returns -1 if no match.  In the present backend it is also possible
 * to have multiple matches, in which case the first one is found.
 */</comment>
<function><type><name>int</name></type>
<name>PQfnumber</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>field_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>field_case</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>in_quotes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>all_lower</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>iptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>optr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Note: it is correct to reject a zero-length input string; the proper
	 * input to match a zero-length field name would be "".
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>field_name</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<name><name>field_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator>
		<name><name>res</name><operator>-&gt;</operator><name>attDescs</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check if we can avoid the strdup() and related work because the
	 * passed-in string wouldn't be changed before we do the check anyway.
	 */</comment>
	<for>for <control>(<init><expr><name>iptr</name> <operator>=</operator> <name>field_name</name></expr>;</init> <condition><expr><operator>*</operator><name>iptr</name></expr>;</condition> <incr><expr><name>iptr</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name>c</name> <init>= <expr><operator>*</operator><name>iptr</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'"'</literal> <operator>||</operator> <name>c</name> <operator>!=</operator> <call><name>pg_tolower</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>all_lower</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>all_lower</name></expr>)</condition><block type="pseudo"><block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>res</name><operator>-&gt;</operator><name>numAttributes</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>field_name</name></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>attDescs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for></block_content></block></if></if_stmt>

	<comment type="block">/* Fall through to the normal check if that didn't work out. */</comment>

	<comment type="block">/*
	 * Note: this code will not reject partially quoted strings, eg
	 * foo"BAR"foo will become fooBARfoo when it probably ought to be an error
	 * condition.
	 */</comment>
	<expr_stmt><expr><name>field_case</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>field_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>field_case</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* grotty */</comment>

	<expr_stmt><expr><name>in_quotes</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>optr</name> <operator>=</operator> <name>field_case</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>iptr</name> <operator>=</operator> <name>field_case</name></expr>;</init> <condition><expr><operator>*</operator><name>iptr</name></expr>;</condition> <incr><expr><name>iptr</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name>c</name> <init>= <expr><operator>*</operator><name>iptr</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>in_quotes</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>iptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* doubled quotes become a single quote */</comment>
					<expr_stmt><expr><operator>*</operator><name>optr</name><operator>++</operator> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>iptr</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>in_quotes</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>optr</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>in_quotes</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>pg_tolower</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>optr</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><operator>*</operator><name>optr</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>res</name><operator>-&gt;</operator><name>numAttributes</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>field_case</name></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>attDescs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>field_case</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>i</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>field_case</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>Oid</name></type>
<name>PQftable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>field_num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>check_field_number</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>field_num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>attDescs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>res</name><operator>-&gt;</operator><name>attDescs</name><index>[<expr><name>field_num</name></expr>]</index></name><operator>.</operator><name>tableid</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>PQftablecol</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>field_num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>check_field_number</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>field_num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>attDescs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>res</name><operator>-&gt;</operator><name>attDescs</name><index>[<expr><name>field_num</name></expr>]</index></name><operator>.</operator><name>columnid</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>PQfformat</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>field_num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>check_field_number</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>field_num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>attDescs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>res</name><operator>-&gt;</operator><name>attDescs</name><index>[<expr><name>field_num</name></expr>]</index></name><operator>.</operator><name>format</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>Oid</name></type>
<name>PQftype</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>field_num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>check_field_number</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>field_num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>attDescs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>res</name><operator>-&gt;</operator><name>attDescs</name><index>[<expr><name>field_num</name></expr>]</index></name><operator>.</operator><name>typid</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>PQfsize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>field_num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>check_field_number</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>field_num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>attDescs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>res</name><operator>-&gt;</operator><name>attDescs</name><index>[<expr><name>field_num</name></expr>]</index></name><operator>.</operator><name>typlen</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>PQfmod</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>field_num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>check_field_number</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>field_num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>attDescs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>res</name><operator>-&gt;</operator><name>attDescs</name><index>[<expr><name>field_num</name></expr>]</index></name><operator>.</operator><name>atttypmod</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>PQcmdStatus</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name><name>res</name><operator>-&gt;</operator><name>cmdStatus</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PQoidStatus -
 *	if the last command was an INSERT, return the oid string
 *	if not, return ""
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>PQoidStatus</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * This must be enough to hold the result. Don't laugh, this is better
	 * than what this function used to do.
	 */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">24</literal></expr>]</index></name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>size_t</name></type>		<name>len</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name> <operator>||</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>cmdStatus</name></name></expr></argument>, <argument><expr><literal type="string">"INSERT "</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="string">""</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strspn</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>cmdStatus</name></name> <operator>+</operator> <literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"0123456789"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>cmdStatus</name></name> <operator>+</operator> <literal type="number">7</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PQoidValue -
 *	a perhaps preferable form of the above which just returns
 *	an Oid type
 */</comment>
<function><type><name>Oid</name></type>
<name>PQoidValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name> <operator>||</operator>
		<call><name>strncmp</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>cmdStatus</name></name></expr></argument>, <argument><expr><literal type="string">"INSERT "</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
		<name><name>res</name><operator>-&gt;</operator><name>cmdStatus</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="char">'0'</literal> <operator>||</operator>
		<name><name>res</name><operator>-&gt;</operator><name>cmdStatus</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>&gt;</operator> <literal type="char">'9'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>cmdStatus</name></name> <operator>+</operator> <literal type="number">7</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>endptr</name> <operator>||</operator> <operator>(</operator><operator>*</operator><name>endptr</name> <operator>!=</operator> <literal type="char">' '</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>endptr</name> <operator>!=</operator> <literal type="char">'\0'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>Oid</name><operator>)</operator> <name>result</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * PQcmdTuples -
 *	If the last command was INSERT/UPDATE/DELETE/MOVE/FETCH/COPY, return
 *	a string containing the number of inserted/affected tuples. If not,
 *	return "".
 *
 *	XXX: this should probably return an int
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>PQcmdTuples</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="string">""</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>cmdStatus</name></name></expr></argument>, <argument><expr><literal type="string">"INSERT "</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>res</name><operator>-&gt;</operator><name>cmdStatus</name></name> <operator>+</operator> <literal type="number">7</literal></expr>;</expr_stmt>
		<comment type="block">/* INSERT: skip oid and space */</comment>
		<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>interpret_error</name>;</goto></block_content></block></if></if_stmt>	<comment type="block">/* no space? */</comment>
		<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>cmdStatus</name></name></expr></argument>, <argument><expr><literal type="string">"SELECT "</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			 <call><name>strncmp</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>cmdStatus</name></name></expr></argument>, <argument><expr><literal type="string">"DELETE "</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			 <call><name>strncmp</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>cmdStatus</name></name></expr></argument>, <argument><expr><literal type="string">"UPDATE "</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>res</name><operator>-&gt;</operator><name>cmdStatus</name></name> <operator>+</operator> <literal type="number">7</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>cmdStatus</name></name></expr></argument>, <argument><expr><literal type="string">"FETCH "</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>res</name><operator>-&gt;</operator><name>cmdStatus</name></name> <operator>+</operator> <literal type="number">6</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>cmdStatus</name></name></expr></argument>, <argument><expr><literal type="string">"MOVE "</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			 <call><name>strncmp</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>cmdStatus</name></name></expr></argument>, <argument><expr><literal type="string">"COPY "</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>res</name><operator>-&gt;</operator><name>cmdStatus</name></name> <operator>+</operator> <literal type="number">5</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><literal type="string">""</literal></expr>;</return></block_content></block></else></if_stmt>

	<comment type="block">/* check that we have an integer (at least one digit, nothing else) */</comment>
	<for>for <control>(<init><expr><name>c</name> <operator>=</operator> <name>p</name></expr>;</init> <condition><expr><operator>*</operator><name>c</name></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>interpret_error</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>p</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>interpret_error</name>;</goto></block_content></block></if></if_stmt>

	<return>return <expr><name>p</name></expr>;</return>

<label><name>interpret_error</name>:</label>
	<expr_stmt><expr><call><name>pqInternalNotice</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>res</name><operator>-&gt;</operator><name>noticeHooks</name></name></expr></argument>,
					 <argument><expr><literal type="string">"could not interpret result from server: %s"</literal></expr></argument>,
					 <argument><expr><name><name>res</name><operator>-&gt;</operator><name>cmdStatus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="string">""</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PQgetvalue:
 *	return the value of field 'field_num' of row 'tup_num'
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>PQgetvalue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tup_num</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>field_num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>check_tuple_field_number</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>tup_num</name></expr></argument>, <argument><expr><name>field_num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name><name>res</name><operator>-&gt;</operator><name>tuples</name><index>[<expr><name>tup_num</name></expr>]</index><index>[<expr><name>field_num</name></expr>]</index></name><operator>.</operator><name>value</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* PQgetlength:
 *	returns the actual length of a field value in bytes.
 */</comment>
<function><type><name>int</name></type>
<name>PQgetlength</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tup_num</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>field_num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>check_tuple_field_number</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>tup_num</name></expr></argument>, <argument><expr><name>field_num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>tuples</name><index>[<expr><name>tup_num</name></expr>]</index><index>[<expr><name>field_num</name></expr>]</index></name><operator>.</operator><name>len</name> <operator>!=</operator> <name>NULL_LEN</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>res</name><operator>-&gt;</operator><name>tuples</name><index>[<expr><name>tup_num</name></expr>]</index><index>[<expr><name>field_num</name></expr>]</index></name><operator>.</operator><name>len</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* PQgetisnull:
 *	returns the null status of a field value.
 */</comment>
<function><type><name>int</name></type>
<name>PQgetisnull</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tup_num</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>field_num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>check_tuple_field_number</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>tup_num</name></expr></argument>, <argument><expr><name>field_num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* pretend it is null */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>tuples</name><index>[<expr><name>tup_num</name></expr>]</index><index>[<expr><name>field_num</name></expr>]</index></name><operator>.</operator><name>len</name> <operator>==</operator> <name>NULL_LEN</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* PQnparams:
 *	returns the number of input parameters of a prepared statement.
 */</comment>
<function><type><name>int</name></type>
<name>PQnparams</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name><name>res</name><operator>-&gt;</operator><name>numParameters</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* PQparamtype:
 *	returns type Oid of the specified statement parameter.
 */</comment>
<function><type><name>Oid</name></type>
<name>PQparamtype</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>param_num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>check_param_number</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>param_num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>paramDescs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>res</name><operator>-&gt;</operator><name>paramDescs</name><index>[<expr><name>param_num</name></expr>]</index></name><operator>.</operator><name>typid</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/* PQsetnonblocking:
 *	sets the PGconn's database connection non-blocking if the arg is true
 *	or makes it blocking if the arg is false, this will not protect
 *	you from PQexec(), you'll only be safe when using the non-blocking API.
 *	Needs to be called only on a connected database connection.
 */</comment>
<function><type><name>int</name></type>
<name>PQsetnonblocking</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>barg</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name> <operator>||</operator> <name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>CONNECTION_BAD</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>barg</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>arg</name></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* early out if the socket is already in the state requested */</comment>
	<if_stmt><if>if <condition>(<expr><name>barg</name> <operator>==</operator> <name><name>conn</name><operator>-&gt;</operator><name>nonblocking</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * to guarantee constancy for flushing/query/result-polling behavior we
	 * need to flush the send queue at this point in order to guarantee proper
	 * behavior. this is ok because either they are making a transition _from_
	 * or _to_ blocking mode, either way we can block them.
	 */</comment>
	<comment type="block">/* if we are going from blocking to non-blocking flush here */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pqFlush</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>nonblocking</name></name> <operator>=</operator> <name>barg</name></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * return the blocking status of the database connection
 *		true == nonblocking, false == blocking
 */</comment>
<function><type><name>int</name></type>
<name>PQisnonblocking</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>pqIsnonblocking</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* libpq is thread-safe? */</comment>
<function><type><name>int</name></type>
<name>PQisthreadsafe</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_THREAD_SAFETY</name></cpp:ifdef>
	<return>return <expr><name>true</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><name>false</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<comment type="block">/* try to force data out, really only useful for non-blocking users */</comment>
<function><type><name>int</name></type>
<name>PQflush</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>pqFlush</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *		PQfreemem - safely frees memory allocated
 *
 * Needed mostly by Win32, unless multithreaded DLL (/MD in VC6)
 * Used for freeing memory from PQescapeBytea()/PQunescapeBytea()
 */</comment>
<function><type><name>void</name></type>
<name>PQfreemem</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PQfreeNotify - free's the memory associated with a PGnotify
 *
 * This function is here only for binary backward compatibility.
 * New code should use PQfreemem().  A macro will automatically map
 * calls to PQfreemem.  It should be removed in the future.  bjm 2003-03-24
 */</comment>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PQfreeNotify</name></cpp:undef>
<function_decl><type><name>void</name></type>		<name>PQfreeNotify</name><parameter_list>(<parameter><decl><type><name>PGnotify</name> <modifier>*</modifier></type><name>notify</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>void</name></type>
<name>PQfreeNotify</name><parameter_list>(<parameter><decl><type><name>PGnotify</name> <modifier>*</modifier></type><name>notify</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PQfreemem</name><argument_list>(<argument><expr><name>notify</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Escaping arbitrary strings to get valid SQL literal strings.
 *
 * Replaces "'" with "''", and if not std_strings, replaces "\" with "\\".
 *
 * length is the length of the source string.  (Note: if a terminating NUL
 * is encountered sooner, PQescapeString stops short of "length"; the behavior
 * is thus rather like strncpy.)
 *
 * For safety the buffer at "to" must be at least 2*length + 1 bytes long.
 * A terminating NUL character is added to the output string, whether the
 * input is NUL-terminated or not.
 *
 * Returns the actual length of the output (not counting the terminating NUL).
 */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>PQescapeStringInternal</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
					   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>to</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>length</name></decl></parameter>,
					   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>error</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>encoding</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>std_strings</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>source</name> <init>= <expr><name>from</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>target</name> <init>= <expr><name>to</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>remaining</name> <init>= <expr><name>length</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>error</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>error</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><name>remaining</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>source</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name>c</name> <init>= <expr><operator>*</operator><name>source</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/* Fast path for plain ASCII */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Apply quoting if needed */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>SQL_STR_DOUBLE</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>!</operator><name>std_strings</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>target</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* Copy the character */</comment>
			<expr_stmt><expr><operator>*</operator><name>target</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>source</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>remaining</name><operator>--</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Slow path for possible multibyte characters */</comment>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>pg_encoding_mblen</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Copy the character */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>remaining</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>*</operator><name>source</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><operator>*</operator><name>target</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>source</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>remaining</name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * If we hit premature end of string (ie, incomplete multibyte
		 * character), try to pad out to the correct length with spaces. We
		 * may not be able to pad completely, but we will always be able to
		 * insert at least one pad space (since we'd not have quoted a
		 * multibyte character).  This should be enough to make a string that
		 * the server will error out on.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>error</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>error</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
								  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"incomplete multibyte character\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator> <operator>(</operator><name>target</name> <operator>-</operator> <name>to</name><operator>)</operator><operator>)</operator> <operator>/</operator> <literal type="number">2</literal> <operator>&gt;=</operator> <name>length</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
				<expr_stmt><expr><operator>*</operator><name>target</name><operator>++</operator> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
			</block_content>}</block></for>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Write the terminating NUL character. */</comment>
	<expr_stmt><expr><operator>*</operator><name>target</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<return>return <expr><name>target</name> <operator>-</operator> <name>to</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type>
<name>PQescapeStringConn</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
				   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>to</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>length</name></decl></parameter>,
				   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>error</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* force empty-string result */</comment>
		<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>error</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>error</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>PQescapeStringInternal</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>error</name></expr></argument>,
								  <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>client_encoding</name></name></expr></argument>,
								  <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>std_strings</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type>
<name>PQescapeString</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>to</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>PQescapeStringInternal</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><name>static_client_encoding</name></expr></argument>,
								  <argument><expr><name>static_std_strings</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Escape arbitrary strings.  If as_ident is true, we escape the result
 * as an identifier; if false, as a literal.  The result is returned in
 * a newly allocated buffer.  If we fail due to an encoding violation or out
 * of memory condition, we return NULL, storing an error message into conn.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>PQescapeInternal</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>as_ident</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>rp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_quotes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* single or double, depending on as_ident */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_backslashes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>input_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>result_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>quote_char</name> <init>= <expr><ternary><condition><expr><name>as_ident</name></expr> ?</condition><then> <expr><literal type="char">'"'</literal></expr> </then><else>: <expr><literal type="char">'\''</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<comment type="block">/* We must have a connection, else fail immediately. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Scan the string for characters that must be escaped. */</comment>
	<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>str</name></expr>;</init> <condition><expr><operator>(</operator><name>s</name> <operator>-</operator> <name>str</name><operator>)</operator> <operator>&lt;</operator> <name>len</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><operator>++</operator><name>s</name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <name>quote_char</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>++</operator><name>num_quotes</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>++</operator><name>num_backslashes</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>charlen</name></decl>;</decl_stmt>

			<comment type="block">/* Slow path for possible multibyte characters */</comment>
			<expr_stmt><expr><name>charlen</name> <operator>=</operator> <call><name>pg_encoding_mblen</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>client_encoding</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Multibyte character overruns allowable length. */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>s</name> <operator>-</operator> <name>str</name><operator>)</operator> <operator>+</operator> <name>charlen</name> <operator>&gt;</operator> <name>len</name> <operator>||</operator> <call><name>memchr</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>charlen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
								  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"incomplete multibyte character\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Adjust s, bearing in mind that for loop will increment it. */</comment>
			<expr_stmt><expr><name>s</name> <operator>+=</operator> <name>charlen</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Allocate output buffer. */</comment>
	<expr_stmt><expr><name>input_len</name> <operator>=</operator> <name>s</name> <operator>-</operator> <name>str</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>result_size</name> <operator>=</operator> <name>input_len</name> <operator>+</operator> <name>num_quotes</name> <operator>+</operator> <literal type="number">3</literal></expr>;</expr_stmt>	<comment type="block">/* two quotes, plus a NUL */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>as_ident</name> <operator>&amp;&amp;</operator> <name>num_backslashes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result_size</name> <operator>+=</operator> <name>num_backslashes</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>rp</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>result_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rp</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we are escaping a literal that contains backslashes, we use the
	 * escape string syntax so that the result is correct under either value
	 * of standard_conforming_strings.  We also emit a leading space in this
	 * case, to guard against the possibility that the result might be
	 * interpolated immediately following an identifier.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>as_ident</name> <operator>&amp;&amp;</operator> <name>num_backslashes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>rp</name><operator>++</operator> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>rp</name><operator>++</operator> <operator>=</operator> <literal type="char">'E'</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Opening quote. */</comment>
	<expr_stmt><expr><operator>*</operator><name>rp</name><operator>++</operator> <operator>=</operator> <name>quote_char</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Use fast path if possible.
	 *
	 * We've already verified that the input string is well-formed in the
	 * current encoding.  If it contains no quotes and, in the case of
	 * literal-escaping, no backslashes, then we can just copy it directly to
	 * the output buffer, adding the necessary quotes.
	 *
	 * If not, we must rescan the input and process each character
	 * individually.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>num_quotes</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>num_backslashes</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>as_ident</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>rp</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>input_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rp</name> <operator>+=</operator> <name>input_len</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>str</name></expr>;</init> <condition><expr><name>s</name> <operator>-</operator> <name>str</name> <operator>&lt;</operator> <name>input_len</name></expr>;</condition> <incr><expr><operator>++</operator><name>s</name></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <name>quote_char</name> <operator>||</operator> <operator>(</operator><operator>!</operator><name>as_ident</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\\'</literal><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>rp</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>s</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>rp</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>s</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>rp</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>s</name></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><call><name>pg_encoding_mblen</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>client_encoding</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><operator>*</operator><name>rp</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>s</name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>--</operator><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
					<expr_stmt><expr><operator>++</operator><name>s</name></expr>;</expr_stmt>		<comment type="block">/* for loop will provide the final increment */</comment>
				</block_content>}</block></while>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Closing quote and terminating NUL. */</comment>
	<expr_stmt><expr><operator>*</operator><name>rp</name><operator>++</operator> <operator>=</operator> <name>quote_char</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>rp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>PQescapeLiteral</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>PQescapeInternal</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>PQescapeIdentifier</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>PQescapeInternal</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* HEX encoding support for bytea */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>hextbl</name><index>[]</index></name> <init>= <expr><literal type="string">"0123456789abcdef"</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int8</name></type> <name><name>hexlookup</name><index>[<expr><literal type="number">128</literal></expr>]</index></name> <init>= <expr><block>{
	<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>,
	<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>,
	<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>,
	<expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">9</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>,
	<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">11</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>,
	<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>,
	<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">11</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>,
	<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>char</name></type>
<name>get_hex</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>res</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;</operator> <literal type="number">127</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <name><name>hexlookup</name><index>[<expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>char</name><operator>)</operator> <name>res</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *		PQescapeBytea	- converts from binary string to the
 *		minimal encoding necessary to include the string in an SQL
 *		INSERT statement with a bytea type column as the target.
 *
 *		We can use either hex or escape (traditional) encoding.
 *		In escape mode, the following transformations are applied:
 *		'\0' == ASCII  0 == \000
 *		'\'' == ASCII 39 == ''
 *		'\\' == ASCII 92 == \\
 *		anything &lt; 0x20, or &gt; 0x7e ---&gt; \ooo
 *										(where ooo is an octal expression)
 *
 *		If not std_strings, all backslashes sent to the output are doubled.
 */</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type>
<name>PQescapeByteaInternal</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
					  <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>from_length</name></decl></parameter>,
					  <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>to_length</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>std_strings</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_hex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>vp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>rp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>bslash_len</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>std_strings</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * empty string has 1 char ('\0')
	 */</comment>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>use_hex</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>bslash_len</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>from_length</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>vp</name> <operator>=</operator> <name>from</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>from_length</name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr><operator>,</operator> <expr><name>vp</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>vp</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0x20</literal> <operator>||</operator> <operator>*</operator><name>vp</name></expr></argument> &gt;</argument_list></name> <literal type="number">0x7e</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>bslash_len</name> <operator>+</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><operator>*</operator><name>vp</name> <operator>==</operator> <literal type="char">'\''</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>len</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><operator>*</operator><name>vp</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>bslash_len</name> <operator>+</operator> <name>bslash_len</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>to_length</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rp</name> <operator>=</operator> <name>result</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rp</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>use_hex</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>std_strings</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>rp</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>rp</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>rp</name><operator>++</operator> <operator>=</operator> <literal type="char">'x'</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>vp</name> <operator>=</operator> <name>from</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>from_length</name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr><operator>,</operator> <expr><name>vp</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name> <init>= <expr><operator>*</operator><name>vp</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>use_hex</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>rp</name><operator>++</operator> <operator>=</operator> <name><name>hextbl</name><index>[<expr><operator>(</operator><name>c</name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xF</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>rp</name><operator>++</operator> <operator>=</operator> <name><name>hextbl</name><index>[<expr><name>c</name> <operator>&amp;</operator> <literal type="number">0xF</literal></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>c</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0x20</literal> <operator>||</operator> <name>c</name></expr></argument> &gt;</argument_list></name> <literal type="number">0x7e</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>std_strings</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>rp</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><operator>*</operator><name>rp</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>rp</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>c</name> <operator>&gt;&gt;</operator> <literal type="number">6</literal><operator>)</operator> <operator>+</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>rp</name><operator>++</operator> <operator>=</operator> <operator>(</operator><operator>(</operator><name>c</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">07</literal><operator>)</operator> <operator>+</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>rp</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">07</literal><operator>)</operator> <operator>+</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\''</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>rp</name><operator>++</operator> <operator>=</operator> <literal type="char">'\''</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>rp</name><operator>++</operator> <operator>=</operator> <literal type="char">'\''</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>std_strings</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>rp</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>rp</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><operator>*</operator><name>rp</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>rp</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>rp</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><operator>*</operator><name>rp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type>
<name>PQescapeByteaConn</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
				  <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>from_length</name></decl></parameter>,
				  <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>to_length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><call><name>PQescapeByteaInternal</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>from_length</name></expr></argument>, <argument><expr><name>to_length</name></expr></argument>,
								 <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>std_strings</name></name></expr></argument>,
								 <argument><expr><operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type>
<name>PQescapeBytea</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>from_length</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>to_length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>PQescapeByteaInternal</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>from_length</name></expr></argument>, <argument><expr><name>to_length</name></expr></argument>,
								 <argument><expr><name>static_std_strings</name></expr></argument>,
								 <argument><expr><name>false</name></expr></argument> <comment type="block">/* can't use hex */</comment> )</argument_list></call></expr>;</return>
</block_content>}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISFIRSTOCTDIGIT</name><parameter_list>(<parameter><type><name>CH</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((CH) &gt;= '0' &amp;&amp; (CH) &lt;= '3')</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISOCTDIGIT</name><parameter_list>(<parameter><type><name>CH</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((CH) &gt;= '0' &amp;&amp; (CH) &lt;= '7')</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OCTVAL</name><parameter_list>(<parameter><type><name>CH</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((CH) - '0')</cpp:value></cpp:define>

<comment type="block">/*
 *		PQunescapeBytea - converts the null terminated string representation
 *		of a bytea, strtext, into binary, filling a buffer. It returns a
 *		pointer to the buffer (or NULL on error), and the size of the
 *		buffer in retbuflen. The pointer may subsequently be used as an
 *		argument to the function PQfreemem.
 *
 *		The following transformations are made:
 *		\\	 == ASCII 92 == \
 *		\ooo == a byte whose value = ooo (ooo is an octal number)
 *		\x	 == x (x is any character not matched by the above transformations)
 */</comment>
<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type>
<name>PQunescapeBytea</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>strtext</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>retbuflen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>strtextlen</name></decl>,
				<decl><type ref="prev"/><name>buflen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buffer</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tmpbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>strtext</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>strtextlen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name>strtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>strtext</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name><name>strtext</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'x'</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>buflen</name> <operator>=</operator> <operator>(</operator><name>strtextlen</name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<comment type="block">/* Avoid unportable malloc(0) */</comment>
		<expr_stmt><expr><name>buffer</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><ternary><condition><expr><name>buflen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>buflen</name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>buffer</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>s</name> <operator>=</operator> <name>strtext</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>*</operator><name>s</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name>v1</name></decl>,
						<decl><type ref="prev"/><name>v2</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Bad input is silently ignored.  Note that this includes
			 * whitespace between hex pairs, which is allowed by byteain.
			 */</comment>
			<expr_stmt><expr><name>v1</name> <operator>=</operator> <call><name>get_hex</name><argument_list>(<argument><expr><operator>*</operator><name>s</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>s</name> <operator>||</operator> <name>v1</name> <operator>==</operator> <operator>(</operator><name>char</name><operator>)</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>v2</name> <operator>=</operator> <call><name>get_hex</name><argument_list>(<argument><expr><operator>*</operator><name>s</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>v2</name> <operator>!=</operator> <operator>(</operator><name>char</name><operator>)</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>v1</name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>|</operator> <name>v2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><name>buflen</name> <operator>=</operator> <name>p</name> <operator>-</operator> <name>buffer</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Length of input is max length of output, but add one to avoid
		 * unportable malloc(0) if input is zero-length.
		 */</comment>
		<expr_stmt><expr><name>buffer</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>strtextlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>buffer</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>strtextlen</name></expr>;</condition><incr/>)</control>
		<block>{<block_content>
			<switch>switch <condition>(<expr><name><name>strtext</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><literal type="char">'\\'</literal></expr>:</case>
					<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>strtext</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>buffer</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>strtext</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
					<else>else
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>ISFIRSTOCTDIGIT</name><argument_list>(<argument><expr><name><name>strtext</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
							<operator>(</operator><call><name>ISOCTDIGIT</name><argument_list>(<argument><expr><name><name>strtext</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
							<operator>(</operator><call><name>ISOCTDIGIT</name><argument_list>(<argument><expr><name><name>strtext</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
						<block>{<block_content>
							<decl_stmt><decl><type><name>int</name></type>			<name>byte</name></decl>;</decl_stmt>

							<expr_stmt><expr><name>byte</name> <operator>=</operator> <call><name>OCTVAL</name><argument_list>(<argument><expr><name><name>strtext</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>byte</name> <operator>=</operator> <operator>(</operator><name>byte</name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>+</operator> <call><name>OCTVAL</name><argument_list>(<argument><expr><name><name>strtext</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>byte</name> <operator>=</operator> <operator>(</operator><name>byte</name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>+</operator> <call><name>OCTVAL</name><argument_list>(<argument><expr><name><name>strtext</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>buffer</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>byte</name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></else></if_stmt>

					<comment type="block">/*
					 * Note: if we see '\' followed by something that isn't a
					 * recognized escape sequence, we loop around having done
					 * nothing except advance i.  Therefore the something will
					 * be emitted as ordinary data on the next cycle. Corner
					 * case: '\' at end of string will just be discarded.
					 */</comment>
					<break>break;</break>

				<default>default:</default>
					<expr_stmt><expr><name><name>buffer</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>strtext</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></for>
		<expr_stmt><expr><name>buflen</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>				<comment type="block">/* buflen is the length of the dequoted data */</comment>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Shrink the buffer to be no larger than necessary */</comment>
	<comment type="block">/* +1 avoids unportable behavior when buflen==0 */</comment>
	<expr_stmt><expr><name>tmpbuf</name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>buflen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* It would only be a very brain-dead realloc that could fail, but... */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmpbuf</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>retbuflen</name> <operator>=</operator> <name>buflen</name></expr>;</expr_stmt>
	<return>return <expr><name>tmpbuf</name></expr>;</return>
</block_content>}</block></function>
</unit>
