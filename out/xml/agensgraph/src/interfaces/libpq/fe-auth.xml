<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/interfaces/libpq/fe-auth.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * fe-auth.c
 *	   The front-end (client) authorization routines
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/interfaces/libpq/fe-auth.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * INTERFACE ROUTINES
 *	   frontend (client) routines:
 *		pg_fe_sendauth			send authentication information
 *		pg_fe_getauthname		get user's name according to the client side
 *								of the authentication system
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"win32.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>			<comment type="block">/* for MAXHOSTNAMELEN on most */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/socket.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_UCRED_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/ucred.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive>  <name>MAXHOSTNAMELEN</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netdb.h&gt;</cpp:file></cpp:include>				<comment type="block">/* for MAXHOSTNAMELEN on some */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pwd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/md5.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/scram-common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe-auth.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_GSS</name></cpp:ifdef>
<comment type="block">/*
 * GSSAPI authentication system.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe-gssapi-common.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Continue GSS authentication with next token as needed.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_GSS_continue</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>payloadlen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OM_uint32</name></type>	<name>maj_stat</name></decl>,
				<decl><type ref="prev"/><name>min_stat</name></decl>,
				<decl><type ref="prev"/><name>lmin_s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>gss_buffer_desc</name></type> <name>ginbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>gss_buffer_desc</name></type> <name>goutbuf</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * On first call, there's no input token. On subsequent calls, read the
	 * input token into a GSS buffer.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>gctx</name></name> <operator>!=</operator> <name>GSS_C_NO_CONTEXT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ginbuf</name><operator>.</operator><name>length</name></name> <operator>=</operator> <name>payloadlen</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ginbuf</name><operator>.</operator><name>value</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>payloadlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ginbuf</name><operator>.</operator><name>value</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory allocating GSSAPI buffer (%d)\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>payloadlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>pqGetnchar</name><argument_list>(<argument><expr><name><name>ginbuf</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name>payloadlen</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Shouldn't happen, because the caller should've ensured that the
			 * whole message is already in the input buffer.
			 */</comment>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>ginbuf</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>ginbuf</name><operator>.</operator><name>length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ginbuf</name><operator>.</operator><name>value</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>maj_stat</name> <operator>=</operator> <call><name>gss_init_sec_context</name><argument_list>(<argument><expr><operator>&amp;</operator><name>min_stat</name></expr></argument>,
									<argument><expr><name>GSS_C_NO_CREDENTIAL</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>gctx</name></name></expr></argument>,
									<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>gtarg_nam</name></name></expr></argument>,
									<argument><expr><name>GSS_C_NO_OID</name></expr></argument>,
									<argument><expr><name>GSS_C_MUTUAL_FLAG</name></expr></argument>,
									<argument><expr><literal type="number">0</literal></expr></argument>,
									<argument><expr><name>GSS_C_NO_CHANNEL_BINDINGS</name></expr></argument>,
									<argument><expr><ternary><condition><expr><operator>(</operator><name><name>ginbuf</name><operator>.</operator><name>value</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name>GSS_C_NO_BUFFER</name></expr> </then><else>: <expr><operator>&amp;</operator><name>ginbuf</name></expr></else></ternary></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>goutbuf</name></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ginbuf</name><operator>.</operator><name>value</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>ginbuf</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>goutbuf</name><operator>.</operator><name>length</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * GSS generated data to send to the server. We don't care if it's the
		 * first or subsequent packet, just send the same kind of password
		 * packet.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pqPacketSend</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="char">'p'</literal></expr></argument>,
						 <argument><expr><name><name>goutbuf</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name><name>goutbuf</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>STATUS_OK</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>gss_release_buffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lmin_s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>goutbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>gss_release_buffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lmin_s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>goutbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>maj_stat</name> <operator>!=</operator> <name>GSS_S_COMPLETE</name> <operator>&amp;&amp;</operator> <name>maj_stat</name> <operator>!=</operator> <name>GSS_S_CONTINUE_NEEDED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_GSS_error</name><argument_list>(<argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"GSSAPI continuation error"</literal></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>conn</name></expr></argument>,
					 <argument><expr><name>maj_stat</name></expr></argument>, <argument><expr><name>min_stat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>gss_release_name</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lmin_s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>gtarg_nam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>gctx</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>gss_delete_sec_context</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lmin_s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>gctx</name></name></expr></argument>, <argument><expr><name>GSS_C_NO_BUFFER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>maj_stat</name> <operator>==</operator> <name>GSS_S_COMPLETE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>gss_release_name</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lmin_s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>gtarg_nam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Send initial GSS authentication token
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_GSS_startup</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>payloadlen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>host</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>whichhost</name></name></expr>]</index></name><operator>.</operator><name>host</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>host</name> <operator>&amp;&amp;</operator> <name><name>host</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"host name must be specified\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>gctx</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"duplicate GSS authentication request\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pg_GSS_load_servicename</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Initial packet is the same as a continuation packet with no initial
	 * context.
	 */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>gctx</name></name> <operator>=</operator> <name>GSS_C_NO_CONTEXT</name></expr>;</expr_stmt>

	<return>return <expr><call><name>pg_GSS_continue</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>payloadlen</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* ENABLE_GSS */</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_SSPI</name></cpp:ifdef>
<comment type="block">/*
 * SSPI authentication system (Windows only)
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pg_SSPI_error</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mprefix</name></decl></parameter>, <parameter><decl><type><name>SECURITY_STATUS</name></type> <name>r</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>sysmsg</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>FormatMessage</name><argument_list>(<argument><expr><name>FORMAT_MESSAGE_IGNORE_INSERTS</name> <operator>|</operator>
					  <name>FORMAT_MESSAGE_FROM_SYSTEM</name></expr></argument>,
					  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					  <argument><expr><name>sysmsg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sysmsg</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>, <argument><expr><literal type="string">"%s: SSPI error %x\n"</literal></expr></argument>,
						  <argument><expr><name>mprefix</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>, <argument><expr><literal type="string">"%s: %s (%x)\n"</literal></expr></argument>,
						  <argument><expr><name>mprefix</name></expr></argument>, <argument><expr><name>sysmsg</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Continue SSPI authentication with next token as needed.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_SSPI_continue</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>payloadlen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SECURITY_STATUS</name></type> <name>r</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CtxtHandle</name></type>	<name>newContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ULONG</name></type>		<name>contextAttr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SecBufferDesc</name></type> <name>inbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SecBufferDesc</name></type> <name>outbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SecBuffer</name></type>	<name><name>OutBuffers</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SecBuffer</name></type>	<name><name>InBuffers</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>inputbuf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sspictx</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * On runs other than the first we have some data to send. Put this
		 * data in a SecBuffer type structure.
		 */</comment>
		<expr_stmt><expr><name>inputbuf</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>payloadlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>inputbuf</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory allocating SSPI buffer (%d)\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>payloadlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>pqGetnchar</name><argument_list>(<argument><expr><name>inputbuf</name></expr></argument>, <argument><expr><name>payloadlen</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Shouldn't happen, because the caller should've ensured that the
			 * whole message is already in the input buffer.
			 */</comment>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>inputbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>inbuf</name><operator>.</operator><name>ulVersion</name></name> <operator>=</operator> <name>SECBUFFER_VERSION</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>inbuf</name><operator>.</operator><name>cBuffers</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>inbuf</name><operator>.</operator><name>pBuffers</name></name> <operator>=</operator> <name>InBuffers</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>InBuffers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pvBuffer</name> <operator>=</operator> <name>inputbuf</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>InBuffers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>cbBuffer</name> <operator>=</operator> <name>payloadlen</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>InBuffers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>BufferType</name> <operator>=</operator> <name>SECBUFFER_TOKEN</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>OutBuffers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pvBuffer</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>OutBuffers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>BufferType</name> <operator>=</operator> <name>SECBUFFER_TOKEN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>OutBuffers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>cbBuffer</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>outbuf</name><operator>.</operator><name>cBuffers</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>outbuf</name><operator>.</operator><name>pBuffers</name></name> <operator>=</operator> <name>OutBuffers</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>outbuf</name><operator>.</operator><name>ulVersion</name></name> <operator>=</operator> <name>SECBUFFER_VERSION</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>InitializeSecurityContext</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sspicred</name></name></expr></argument>,
								  <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sspictx</name></name></expr></argument>,
								  <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sspitarget</name></name></expr></argument>,
								  <argument><expr><name>ISC_REQ_ALLOCATE_MEMORY</name></expr></argument>,
								  <argument><expr><literal type="number">0</literal></expr></argument>,
								  <argument><expr><name>SECURITY_NETWORK_DREP</name></expr></argument>,
								  <argument><expr><ternary><condition><expr><operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>sspictx</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>&amp;</operator><name>inbuf</name></expr></else></ternary></expr></argument>,
								  <argument><expr><literal type="number">0</literal></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>newContext</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>outbuf</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>contextAttr</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we don't need the input anymore */</comment>
	<if_stmt><if>if <condition>(<expr><name>inputbuf</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>inputbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>SEC_E_OK</name> <operator>&amp;&amp;</operator> <name>r</name> <operator>!=</operator> <name>SEC_I_CONTINUE_NEEDED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_SSPI_error</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"SSPI continuation error"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sspictx</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* On first run, transfer retrieved context handle */</comment>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sspictx</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CtxtHandle</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sspictx</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>, <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sspictx</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newContext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CtxtHandle</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If SSPI returned any data to be sent to the server (as it normally
	 * would), send this data as a password packet.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>outbuf</name><operator>.</operator><name>cBuffers</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>outbuf</name><operator>.</operator><name>cBuffers</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * This should never happen, at least not for Kerberos
			 * authentication. Keep check in case it shows up with other
			 * authentication methods later.
			 */</comment>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>, <argument><expr><literal type="string">"SSPI returned invalid number of output buffers\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If the negotiation is complete, there may be zero bytes to send.
		 * The server is at this point not expecting any more data, so don't
		 * send it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>outbuf</name><operator>.</operator><name>pBuffers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>cbBuffer</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pqPacketSend</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="char">'p'</literal></expr></argument>,
							 <argument><expr><name><name>outbuf</name><operator>.</operator><name>pBuffers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pvBuffer</name></expr></argument>, <argument><expr><name><name>outbuf</name><operator>.</operator><name>pBuffers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>cbBuffer</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>FreeContextBuffer</name><argument_list>(<argument><expr><name><name>outbuf</name><operator>.</operator><name>pBuffers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pvBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>FreeContextBuffer</name><argument_list>(<argument><expr><name><name>outbuf</name><operator>.</operator><name>pBuffers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pvBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Cleanup is handled by the code in freePGconn() */</comment>
	<return>return <expr><name>STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Send initial SSPI authentication token.
 * If use_negotiate is 0, use kerberos authentication package which is
 * compatible with Unix. If use_negotiate is 1, use the negotiate package
 * which supports both kerberos and NTLM, but is not compatible with Unix.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_SSPI_startup</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>use_negotiate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>payloadlen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SECURITY_STATUS</name></type> <name>r</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeStamp</name></type>	<name>expire</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>host</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>whichhost</name></name></expr>]</index></name><operator>.</operator><name>host</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sspictx</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"duplicate SSPI authentication request\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Retrieve credentials handle
	 */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sspicred</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CredHandle</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sspicred</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>, <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>AcquireCredentialsHandle</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><ternary><condition><expr><name>use_negotiate</name></expr> ?</condition><then> <expr><literal type="string">"negotiate"</literal></expr> </then><else>: <expr><literal type="string">"kerberos"</literal></expr></else></ternary></expr></argument>,
								 <argument><expr><name>SECPKG_CRED_OUTBOUND</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sspicred</name></name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>expire</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>SEC_E_OK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_SSPI_error</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"could not acquire SSPI credentials"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sspicred</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sspicred</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Compute target principal name. SSPI has a different format from GSSAPI,
	 * but not more complex. We can skip the @REALM part, because Windows will
	 * fill that in for us automatically.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>host</name> <operator>&amp;&amp;</operator> <name><name>host</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"host name must be specified\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sspitarget</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>krbsrvname</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>host</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>sspitarget</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>, <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sspitarget</name></name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>krbsrvname</name></name></expr></argument>, <argument><expr><name>host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Indicate that we're in SSPI authentication mode to make sure that
	 * pg_SSPI_continue is called next time in the negotiation.
	 */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>usesspi</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<return>return <expr><call><name>pg_SSPI_continue</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>payloadlen</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* ENABLE_SSPI */</comment>

<comment type="block">/*
 * Initialize SASL authentication exchange.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_SASL_init</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>payloadlen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>initialresponse</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>initialresponselen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>done</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>success</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>selected_mechanism</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>mechanism_buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>password</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mechanism_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>channel_binding</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'r'</literal> <operator>&amp;&amp;</operator>	<comment type="block">/* require */</comment>
		<operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>ssl_in_use</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"channel binding required, but SSL not in use\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>error</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sasl_state</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"duplicate SASL authentication request\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>error</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Parse the list of SASL authentication mechanisms in the
	 * AuthenticationSASL message, and select the best mechanism that we
	 * support.  SCRAM-SHA-256-PLUS and SCRAM-SHA-256 are the only ones
	 * supported at the moment, listed by order of decreasing importance.
	 */</comment>
	<expr_stmt><expr><name>selected_mechanism</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pqGets</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mechanism_buf</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><literal type="string">"fe_sendauth: invalid authentication request from server: invalid list of authentication mechanisms\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>error</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQExpBufferDataBroken</name><argument_list>(<argument><expr><name>mechanism_buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>oom_error</name>;</goto></block_content></block></if></if_stmt>

		<comment type="block">/* An empty string indicates end of list */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>mechanism_buf</name><operator>.</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Select the mechanism to use.  Pick SCRAM-SHA-256-PLUS over anything
		 * else if a channel binding type is set and if the client supports it
		 * (and did not set channel_binding=disable). Pick SCRAM-SHA-256 if
		 * nothing else has already been picked.  If we add more mechanisms, a
		 * more refined priority mechanism might become necessary.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>mechanism_buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>SCRAM_SHA_256_PLUS_NAME</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>ssl_in_use</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* The server has offered SCRAM-SHA-256-PLUS. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_PGTLS_GET_PEER_CERTIFICATE_HASH</name></cpp:ifdef>
				<comment type="block">/*
				 * The client supports channel binding, which is chosen if
				 * channel_binding is not disabled.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>channel_binding</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'d'</literal></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* disable */</comment>
					<expr_stmt><expr><name>selected_mechanism</name> <operator>=</operator> <name>SCRAM_SHA_256_PLUS_NAME</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
				<comment type="block">/*
				 * The client does not support channel binding.  If it is
				 * required, complain immediately instead of the error below
				 * which would be confusing as the server is publishing
				 * SCRAM-SHA-256-PLUS.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>channel_binding</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'r'</literal></expr>)</condition>	<comment type="block">/* require */</comment>
				<block>{<block_content>
					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
									  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"channel binding is required, but client does not support it\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>error</name>;</goto>
				</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * The server offered SCRAM-SHA-256-PLUS, but the connection
				 * is not SSL-encrypted. That's not sane. Perhaps SSL was
				 * stripped by a proxy? There's no point in continuing,
				 * because the server will reject the connection anyway if we
				 * try authenticate without channel binding even though both
				 * the client and server supported it. The SCRAM exchange
				 * checks for that, to prevent downgrade attacks.
				 */</comment>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
								  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"server offered SCRAM-SHA-256-PLUS authentication over a non-SSL connection\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>error</name>;</goto>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>mechanism_buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>SCRAM_SHA_256_NAME</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				 <operator>!</operator><name>selected_mechanism</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>selected_mechanism</name> <operator>=</operator> <name>SCRAM_SHA_256_NAME</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>selected_mechanism</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"none of the server's SASL authentication mechanisms are supported\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>error</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>channel_binding</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'r'</literal> <operator>&amp;&amp;</operator>	<comment type="block">/* require */</comment>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>selected_mechanism</name></expr></argument>, <argument><expr><name>SCRAM_SHA_256_PLUS_NAME</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"channel binding is required, but server did not offer an authentication method that supports channel binding\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>error</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now that the SASL mechanism has been chosen for the exchange,
	 * initialize its state information.
	 */</comment>

	<comment type="block">/*
	 * First, select the password to use for the exchange, complaining if
	 * there isn't one.  Currently, all supported SASL mechanisms require a
	 * password, so we can just go ahead here without further distinction.
	 */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>password_needed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>password</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>whichhost</name></name></expr>]</index></name><operator>.</operator><name>password</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>password</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>password</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>pgpass</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>password</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>password</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><name>PQnoPasswordSupplied</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>error</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Initialize the SASL state information with all the information gathered
	 * during the initial exchange.
	 *
	 * Note: Only tls-unique is supported for the moment.
	 */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sasl_state</name></name> <operator>=</operator> <call><name>pg_fe_scram_init</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
										<argument><expr><name>password</name></expr></argument>,
										<argument><expr><name>selected_mechanism</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>sasl_state</name></name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>oom_error</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/* Get the mechanism-specific Initial Client Response, if any */</comment>
	<expr_stmt><expr><call><name>pg_fe_scram_exchange</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sasl_state</name></name></expr></argument>,
						 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name>initialresponse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>initialresponselen</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name>done</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>success</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>done</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>success</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Build a SASLInitialResponse message, and send it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pqPutMsgStart</name><argument_list>(<argument><expr><literal type="char">'p'</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pqPuts</name><argument_list>(<argument><expr><name>selected_mechanism</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>initialresponse</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pqPutInt</name><argument_list>(<argument><expr><name>initialresponselen</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>pqPutnchar</name><argument_list>(<argument><expr><name>initialresponse</name></expr></argument>, <argument><expr><name>initialresponselen</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pqPutMsgEnd</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pqFlush</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mechanism_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>initialresponse</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>initialresponse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>STATUS_OK</name></expr>;</return>

<label><name>error</name>:</label>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mechanism_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>initialresponse</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>initialresponse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>STATUS_ERROR</name></expr>;</return>

<label><name>oom_error</name>:</label>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mechanism_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>initialresponse</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>initialresponse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
					  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Exchange a message for SASL communication protocol with the backend.
 * This should be used after calling pg_SASL_init to set up the status of
 * the protocol.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_SASL_continue</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>payloadlen</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>final</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>output</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>outputlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>done</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>success</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>challenge</name></decl>;</decl_stmt>

	<comment type="block">/* Read the SASL challenge from the AuthenticationSASLContinue message. */</comment>
	<expr_stmt><expr><name>challenge</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>payloadlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>challenge</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory allocating SASL buffer (%d)\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>payloadlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pqGetnchar</name><argument_list>(<argument><expr><name>challenge</name></expr></argument>, <argument><expr><name>payloadlen</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>challenge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* For safety and convenience, ensure the buffer is NULL-terminated. */</comment>
	<expr_stmt><expr><name><name>challenge</name><index>[<expr><name>payloadlen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_fe_scram_exchange</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sasl_state</name></name></expr></argument>,
						 <argument><expr><name>challenge</name></expr></argument>, <argument><expr><name>payloadlen</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name>output</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outputlen</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name>done</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>success</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>challenge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>			<comment type="block">/* don't need the input anymore */</comment>

	<if_stmt><if>if <condition>(<expr><name>final</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>done</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>outputlen</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"AuthenticationSASLFinal received from server, but SASL authentication was not completed\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>outputlen</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Send the SASL response to the server.
		 */</comment>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pqPacketSend</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="char">'p'</literal></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>outputlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>done</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>success</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Respond to AUTH_REQ_SCM_CREDS challenge.
 *
 * Note: this is dead code as of Postgres 9.1, because current backends will
 * never send this challenge.  But we must keep it as long as libpq needs to
 * interoperate with pre-9.1 servers.  It is believed to be needed only on
 * Debian/kFreeBSD (ie, FreeBSD kernel with Linux userland, so that the
 * getpeereid() function isn't provided by libc).
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_local_sendauth</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_STRUCT_CMSGCRED</name></cpp:ifdef>
	<decl_stmt><decl><type><name>char</name></type>		<name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>iovec</name></name></type> <name>iov</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>msghdr</name></name></type> <name>msg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>cmsghdr</name></name> <modifier>*</modifier></type><name>cmsg</name></decl>;</decl_stmt>
	<union>union
	<block>{
		<decl_stmt><decl><type><name><name>struct</name> <name>cmsghdr</name></name></type> <name>hdr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr><call><name>CMSG_SPACE</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>cmsgcred</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>
	}</block>			<decl><name>cmsgbuf</name></decl>;</union>

	<comment type="block">/*
	 * The backend doesn't care what we send here, but it wants exactly one
	 * character to force recvmsg() to block and wait for us.
	 */</comment>
	<expr_stmt><expr><name>buf</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iov</name><operator>.</operator><name>iov_base</name></name> <operator>=</operator> <operator>&amp;</operator><name>buf</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iov</name><operator>.</operator><name>iov_len</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>msg</name><operator>.</operator><name>msg_iov</name></name> <operator>=</operator> <operator>&amp;</operator><name>iov</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>msg</name><operator>.</operator><name>msg_iovlen</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* We must set up a message that will be filled in by kernel */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmsgbuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cmsgbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>msg</name><operator>.</operator><name>msg_control</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>cmsgbuf</name><operator>.</operator><name>buf</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>msg</name><operator>.</operator><name>msg_controllen</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>cmsgbuf</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>cmsg</name> <operator>=</operator> <call><name>CMSG_FIRSTHDR</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cmsg</name><operator>-&gt;</operator><name>cmsg_len</name></name> <operator>=</operator> <call><name>CMSG_LEN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>cmsgcred</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cmsg</name><operator>-&gt;</operator><name>cmsg_level</name></name> <operator>=</operator> <name>SOL_SOCKET</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cmsg</name><operator>-&gt;</operator><name>cmsg_type</name></name> <operator>=</operator> <name>SCM_CREDS</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>sendmsg</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>sebuf</name><index>[<expr><name>PG_STRERROR_R_BUFLEN</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><literal type="string">"pg_local_sendauth: sendmsg: %s\n"</literal></expr></argument>,
						  <argument><expr><call><name>strerror_r</name><argument_list>(<argument><expr><name>errno</name></expr></argument>, <argument><expr><name>sebuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sebuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>STATUS_OK</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
					  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"SCM_CRED authentication method not supported\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_password_sendauth</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>password</name></decl></parameter>, <parameter><decl><type><name>AuthRequest</name></type> <name>areq</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>crypt_pwd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pwd_to_send</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>md5Salt</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* Read the salt from the AuthenticationMD5Password message. */</comment>
	<if_stmt><if>if <condition>(<expr><name>areq</name> <operator>==</operator> <name>AUTH_REQ_MD5</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pqGetnchar</name><argument_list>(<argument><expr><name>md5Salt</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* shouldn't happen */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Encrypt the password if needed. */</comment>

	<switch>switch <condition>(<expr><name>areq</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>AUTH_REQ_MD5</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>crypt_pwd2</name></decl>;</decl_stmt>

				<comment type="block">/* Allocate enough space for two MD5 hashes */</comment>
				<expr_stmt><expr><name>crypt_pwd</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><literal type="number">2</literal> <operator>*</operator> <operator>(</operator><name>MD5_PASSWD_LEN</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>crypt_pwd</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
									  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>crypt_pwd2</name> <operator>=</operator> <name>crypt_pwd</name> <operator>+</operator> <name>MD5_PASSWD_LEN</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_md5_encrypt</name><argument_list>(<argument><expr><name>password</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pguser</name></name></expr></argument>,
									<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pguser</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>crypt_pwd2</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>crypt_pwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_md5_encrypt</name><argument_list>(<argument><expr><name>crypt_pwd2</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"md5"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>md5Salt</name></expr></argument>,
									<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>crypt_pwd</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>crypt_pwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>pwd_to_send</name> <operator>=</operator> <name>crypt_pwd</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>AUTH_REQ_PASSWORD</name></expr>:</case>
			<expr_stmt><expr><name>pwd_to_send</name> <operator>=</operator> <name>password</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></switch>
	<comment type="block">/* Packet has a message type as of protocol 3.0 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pversion</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pqPacketSend</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="char">'p'</literal></expr></argument>, <argument><expr><name>pwd_to_send</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>pwd_to_send</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pqPacketSend</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pwd_to_send</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>pwd_to_send</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>crypt_pwd</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>crypt_pwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Verify that the authentication request is expected, given the connection
 * parameters. This is especially important when the client wishes to
 * authenticate the server before any sensitive information is exchanged.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_expected_areq</name><parameter_list>(<parameter><decl><type><name>AuthRequest</name></type> <name>areq</name></decl></parameter>, <parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * When channel_binding=require, we must protect against two cases: (1) we
	 * must not respond to non-SASL authentication requests, which might leak
	 * information such as the client's password; and (2) even if we receive
	 * AUTH_REQ_OK, we still must ensure that channel binding has happened in
	 * order to authenticate the server.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>channel_binding</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'r'</literal></expr> <comment type="block">/* require */</comment> )</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name>areq</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>AUTH_REQ_SASL</name></expr>:</case>
			<case>case <expr><name>AUTH_REQ_SASL_CONT</name></expr>:</case>
			<case>case <expr><name>AUTH_REQ_SASL_FIN</name></expr>:</case>
				<break>break;</break>
			<case>case <expr><name>AUTH_REQ_OK</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_fe_scram_channel_bound</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sasl_state</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
									  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"channel binding required, but server authenticated client without channel binding\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
								  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"channel binding required but not supported by server's authentication request\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pg_fe_sendauth
 *		client demux routine for processing an authentication request
 *
 * The server has sent us an authentication challenge (or OK). Send an
 * appropriate response. The caller has ensured that the whole message is
 * now in the input buffer, and has already read the type and length of
 * it. We are responsible for reading any remaining extra data, specific
 * to the authentication method. 'payloadlen' is the remaining length in
 * the message.
 */</comment>
<function><type><name>int</name></type>
<name>pg_fe_sendauth</name><parameter_list>(<parameter><decl><type><name>AuthRequest</name></type> <name>areq</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>payloadlen</name></decl></parameter>, <parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>check_expected_areq</name><argument_list>(<argument><expr><name>areq</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name>areq</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>AUTH_REQ_OK</name></expr>:</case>
			<break>break;</break>

		<case>case <expr><name>AUTH_REQ_KRB4</name></expr>:</case>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"Kerberos 4 authentication not supported\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>

		<case>case <expr><name>AUTH_REQ_KRB5</name></expr>:</case>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"Kerberos 5 authentication not supported\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_GSS</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_SSPI</name></expr></argument>)</argument_list></call></expr></cpp:if>
		<case>case <expr><name>AUTH_REQ_GSS</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_SSPI</name></expr></argument>)</argument_list></call></expr></cpp:if>
			<comment type="block">/* no native SSPI, so use GSSAPI library for it */</comment>
		<case>case <expr><name>AUTH_REQ_SSPI</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>r</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>pglock_thread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If we have both GSS and SSPI support compiled in, use SSPI
				 * support by default. This is overridable by a connection
				 * string parameter. Note that when using SSPI we still leave
				 * the negotiate parameter off, since we want SSPI to use the
				 * GSSAPI kerberos protocol. For actual SSPI negotiate
				 * protocol, we use AUTH_REQ_SSPI.
				 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_GSS</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_SSPI</name></expr></argument>)</argument_list></call></expr></cpp:if>
				<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>gsslib</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>gsslib</name></name></expr></argument>, <argument><expr><literal type="string">"gssapi"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>pg_GSS_startup</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>payloadlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>pg_SSPI_startup</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>payloadlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_GSS</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_SSPI</name></expr></argument>)</argument_list></call></expr></cpp:elif>
				<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>pg_GSS_startup</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>payloadlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_GSS</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_SSPI</name></expr></argument>)</argument_list></call></expr></cpp:elif>
				<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>pg_SSPI_startup</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>payloadlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>STATUS_OK</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Error message already filled in. */</comment>
					<expr_stmt><expr><call><name>pgunlock_thread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>pgunlock_thread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>AUTH_REQ_GSS_CONT</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>r</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>pglock_thread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_GSS</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_SSPI</name></expr></argument>)</argument_list></call></expr></cpp:if>
				<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>usesspi</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>pg_SSPI_continue</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>payloadlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>pg_GSS_continue</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>payloadlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_GSS</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_SSPI</name></expr></argument>)</argument_list></call></expr></cpp:elif>
				<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>pg_GSS_continue</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>payloadlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_GSS</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_SSPI</name></expr></argument>)</argument_list></call></expr></cpp:elif>
				<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>pg_SSPI_continue</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>payloadlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>STATUS_OK</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Error message already filled in. */</comment>
					<expr_stmt><expr><call><name>pgunlock_thread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>pgunlock_thread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* defined(ENABLE_GSS) || defined(ENABLE_SSPI) */</comment>
			<comment type="block">/* No GSSAPI *or* SSPI support */</comment>
		<case>case <expr><name>AUTH_REQ_GSS</name></expr>:</case>
		<case>case <expr><name>AUTH_REQ_GSS_CONT</name></expr>:</case>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"GSSAPI authentication not supported\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* defined(ENABLE_GSS) || defined(ENABLE_SSPI) */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_SSPI</name></cpp:ifdef>
		<case>case <expr><name>AUTH_REQ_SSPI</name></expr>:</case>

			<comment type="block">/*
			 * SSPI has its own startup message so libpq can decide which
			 * method to use. Indicate to pg_SSPI_startup that we want SSPI
			 * negotiation instead of Kerberos.
			 */</comment>
			<expr_stmt><expr><call><name>pglock_thread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>pg_SSPI_startup</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>payloadlen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>STATUS_OK</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Error message already filled in. */</comment>
				<expr_stmt><expr><call><name>pgunlock_thread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>pgunlock_thread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

			<comment type="block">/*
			 * No SSPI support. However, if we have GSSAPI but not SSPI
			 * support, AUTH_REQ_SSPI will have been handled in the codepath
			 * for AUTH_REQ_GSS above, so don't duplicate the case label in
			 * that case.
			 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_GSS</name></expr></argument>)</argument_list></call></expr></cpp:if>
		<case>case <expr><name>AUTH_REQ_SSPI</name></expr>:</case>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"SSPI authentication not supported\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* !define(ENABLE_GSS) */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* ENABLE_SSPI */</comment>


		<case>case <expr><name>AUTH_REQ_CRYPT</name></expr>:</case>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"Crypt authentication not supported\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>

		<case>case <expr><name>AUTH_REQ_MD5</name></expr>:</case>
		<case>case <expr><name>AUTH_REQ_PASSWORD</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>password</name></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>password_needed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>password</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>whichhost</name></name></expr>]</index></name><operator>.</operator><name>password</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>password</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>password</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>pgpass</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>password</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>password</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
									  <argument><expr><name>PQnoPasswordSupplied</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>pg_password_sendauth</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>password</name></expr></argument>, <argument><expr><name>areq</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>STATUS_OK</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
									  <argument><expr><literal type="string">"fe_sendauth: error sending password authentication\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>AUTH_REQ_SASL</name></expr>:</case>

			<comment type="block">/*
			 * The request contains the name (as assigned by IANA) of the
			 * authentication mechanism.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>pg_SASL_init</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>payloadlen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>STATUS_OK</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* pg_SASL_init already set the error message */</comment>
				<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>AUTH_REQ_SASL_CONT</name></expr>:</case>
		<case>case <expr><name>AUTH_REQ_SASL_FIN</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sasl_state</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
								  <argument><expr><literal type="string">"fe_sendauth: invalid authentication request from server: AUTH_REQ_SASL_CONT without AUTH_REQ_SASL\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>pg_SASL_continue</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>payloadlen</name></expr></argument>,
								 <argument><expr><operator>(</operator><name>areq</name> <operator>==</operator> <name>AUTH_REQ_SASL_FIN</name><operator>)</operator></expr></argument>)</argument_list></call> <operator>!=</operator> <name>STATUS_OK</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Use error message, if set already */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
									  <argument><expr><literal type="string">"fe_sendauth: error in SASL authentication\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>AUTH_REQ_SCM_CREDS</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>pg_local_sendauth</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>STATUS_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"authentication method %u not supported\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>areq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></switch>

	<return>return <expr><name>STATUS_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * pg_fe_getauthname
 *
 * Returns a pointer to malloc'd space containing whatever name the user
 * has authenticated to the system.  If there is an error, return NULL,
 * and put a suitable error message in *errorMessage if that's not NULL.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>pg_fe_getauthname</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>errorMessage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<comment type="block">/* Microsoft recommends buffer size of UNLEN+1, where UNLEN = 256 */</comment>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>username</name><index>[<expr><literal type="number">256</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DWORD</name></type>		<name>namesize</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>username</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>uid_t</name></type>		<name>user_id</name> <init>= <expr><call><name>geteuid</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>pwdbuf</name><index>[<expr><name>BUFSIZ</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>passwd</name></name></type> <name>pwdstr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>passwd</name></name> <modifier>*</modifier></type><name>pw</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>pwerr</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Some users are using configure --enable-thread-safety-force, so we
	 * might as well do the locking within our library to protect
	 * pqGetpwuid(). In fact, application developers can use getpwuid() in
	 * their application if they use the locking call we provide, or install
	 * their own locking function using PQregisterThreadLock().
	 */</comment>
	<expr_stmt><expr><call><name>pglock_thread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><call><name>GetUserName</name><argument_list>(<argument><expr><name>username</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>namesize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>name</name> <operator>=</operator> <name>username</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>errorMessage</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"user name lookup failure: error code %lu\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>pwerr</name> <operator>=</operator> <call><name>pqGetpwuid</name><argument_list>(<argument><expr><name>user_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pwdstr</name></expr></argument>, <argument><expr><name>pwdbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pwdbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>pw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pw</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>name</name> <operator>=</operator> <name><name>pw</name><operator>-&gt;</operator><name>pw_name</name></name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>errorMessage</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>pwerr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"could not look up local user ID %d: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>user_id</name></expr></argument>,
							  <argument><expr><call><name>strerror_r</name><argument_list>(<argument><expr><name>pwerr</name></expr></argument>, <argument><expr><name>pwdbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pwdbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"local user with ID %d does not exist\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>user_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name>name</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>errorMessage</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pgunlock_thread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PQencryptPassword -- exported routine to encrypt a password with MD5
 *
 * This function is equivalent to calling PQencryptPasswordConn with
 * "md5" as the encryption method, except that this doesn't require
 * a connection object.  This function is deprecated, use
 * PQencryptPasswordConn instead.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>PQencryptPassword</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>passwd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>crypt_pwd</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>crypt_pwd</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>MD5_PASSWD_LEN</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>crypt_pwd</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_md5_encrypt</name><argument_list>(<argument><expr><name>passwd</name></expr></argument>, <argument><expr><name>user</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>user</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>crypt_pwd</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>crypt_pwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>crypt_pwd</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PQencryptPasswordConn -- exported routine to encrypt a password
 *
 * This is intended to be used by client applications that wish to send
 * commands like ALTER USER joe PASSWORD 'pwd'.  The password need not
 * be sent in cleartext if it is encrypted on the client side.  This is
 * good because it ensures the cleartext password won't end up in logs,
 * pg_stat displays, etc.  We export the function so that clients won't
 * be dependent on low-level details like whether the encryption is MD5
 * or something else.
 *
 * Arguments are a connection object, the cleartext password, the SQL
 * name of the user it is for, and a string indicating the algorithm to
 * use for encrypting the password.  If algorithm is NULL, this queries
 * the server for the current 'password_encryption' value.  If you wish
 * to avoid that, e.g. to avoid blocking, you can execute
 * 'show password_encryption' yourself before calling this function, and
 * pass it as the algorithm.
 *
 * Return value is a malloc'd string.  The client may assume the string
 * doesn't contain any special characters that would require escaping.
 * On error, an error message is stored in the connection object, and
 * returns NULL.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>PQencryptPasswordConn</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>passwd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>user</name></decl></parameter>,
					  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>algorithm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_ALGORITHM_NAME_LEN</name></cpp:macro> <cpp:value>50</cpp:value></cpp:define>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>algobuf</name><index>[<expr><name>MAX_ALGORITHM_NAME_LEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>crypt_pwd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If no algorithm was given, ask the server. */</comment>
	<if_stmt><if>if <condition>(<expr><name>algorithm</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"show password_encryption"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* PQexec() should've set conn-&gt;errorMessage already */</comment>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* PQexec() should've set conn-&gt;errorMessage already */</comment>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator> <call><name>PQnfields</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"unexpected shape of result set returned for SHOW\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>MAX_ALGORITHM_NAME_LEN</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"password_encryption value too long\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>algobuf</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>algorithm</name> <operator>=</operator> <name>algobuf</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Also accept "on" and "off" as aliases for "md5", because
	 * password_encryption was a boolean before PostgreSQL 10.  We refuse to
	 * send the password in plaintext even if it was "off".
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>algorithm</name></expr></argument>, <argument><expr><literal type="string">"on"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>algorithm</name></expr></argument>, <argument><expr><literal type="string">"off"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>algorithm</name> <operator>=</operator> <literal type="string">"md5"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Ok, now we know what algorithm to use
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>algorithm</name></expr></argument>, <argument><expr><literal type="string">"scram-sha-256"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>crypt_pwd</name> <operator>=</operator> <call><name>pg_fe_scram_build_secret</name><argument_list>(<argument><expr><name>passwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>algorithm</name></expr></argument>, <argument><expr><literal type="string">"md5"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>crypt_pwd</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>MD5_PASSWD_LEN</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>crypt_pwd</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_md5_encrypt</name><argument_list>(<argument><expr><name>passwd</name></expr></argument>, <argument><expr><name>user</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>user</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>crypt_pwd</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>crypt_pwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>crypt_pwd</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"unrecognized password encryption algorithm \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>algorithm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>crypt_pwd</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>crypt_pwd</name></expr>;</return>
</block_content>}</block></function>
</unit>
