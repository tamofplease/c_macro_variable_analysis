<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/interfaces/libpq/fe-connect.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * fe-connect.c
 *	  functions related to setting up a connection to the backend
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/interfaces/libpq/fe-connect.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/ip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/link-canary.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/scram-common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/string.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe-auth.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-int.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_config_paths.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port/pg_bswap.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"win32.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32_IE</name></cpp:ifdef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>_WIN32_IE</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_WIN32_IE</name></cpp:macro> <cpp:value>0x0500</cpp:value></cpp:define>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>near</name></cpp:ifdef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>near</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>near</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;shlobj.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MSC_VER</name></cpp:ifdef>					<comment type="block">/* mstcpip.h is missing on mingw */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mstcpip.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/socket.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netdb.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/in.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_NETINET_TCP_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/tcp.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_THREAD_SAFETY</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pthread-win32.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pthread.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LDAP</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;winldap.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<comment type="block">/* OpenLDAP deprecates RFC 1823, but we want standard conformance */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LDAP_DEPRECATED</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ldap.h&gt;</cpp:file></cpp:include>
<typedef>typedef <type><name><name>struct</name> <name>timeval</name></name></type> <name>LDAP_TIMEVAL</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>ldapServiceLookup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>purl</name></decl></parameter>, <parameter><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>options</name></decl></parameter>,
							  <parameter><decl><type><name>PQExpBuffer</name></type> <name>errorMessage</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PGPASSFILE</name></cpp:macro> <cpp:value>".pgpass"</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PGPASSFILE</name></cpp:macro> <cpp:value>"pgpass.conf"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Pre-9.0 servers will return this SQLSTATE if asked to set
 * application_name in a startup packet.  We hard-wire the value rather
 * than looking into errcodes.h since it reflects historical behavior
 * rather than that of the current code.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERRCODE_APPNAME_UNKNOWN</name></cpp:macro> <cpp:value>"42704"</cpp:value></cpp:define>

<comment type="block">/* This is part of the protocol so just define it */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERRCODE_INVALID_PASSWORD</name></cpp:macro> <cpp:value>"28P01"</cpp:value></cpp:define>
<comment type="block">/* This too */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERRCODE_CANNOT_CONNECT_NOW</name></cpp:macro> <cpp:value>"57P03"</cpp:value></cpp:define>

<comment type="block">/*
 * Cope with the various platform-specific ways to spell TCP keepalive socket
 * options.  This doesn't cover Windows, which as usual does its own thing.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TCP_KEEPIDLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* TCP_KEEPIDLE is the name of this option on Linux and *BSD */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_TCP_KEEPALIVE_IDLE</name></cpp:macro> <cpp:value>TCP_KEEPIDLE</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_TCP_KEEPALIVE_IDLE_STR</name></cpp:macro> <cpp:value>"TCP_KEEPIDLE"</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TCP_KEEPALIVE_THRESHOLD</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<comment type="block">/* TCP_KEEPALIVE_THRESHOLD is the name of this option on Solaris &gt;= 11 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_TCP_KEEPALIVE_IDLE</name></cpp:macro> <cpp:value>TCP_KEEPALIVE_THRESHOLD</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_TCP_KEEPALIVE_IDLE_STR</name></cpp:macro> <cpp:value>"TCP_KEEPALIVE_THRESHOLD"</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TCP_KEEPALIVE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__darwin__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<comment type="block">/* TCP_KEEPALIVE is the name of this option on macOS */</comment>
<comment type="block">/* Caution: Solaris has this symbol but it means something different */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_TCP_KEEPALIVE_IDLE</name></cpp:macro> <cpp:value>TCP_KEEPALIVE</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_TCP_KEEPALIVE_IDLE_STR</name></cpp:macro> <cpp:value>"TCP_KEEPALIVE"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * fall back options if they are not specified by arguments or defined
 * by environment variables
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DefaultHost</name></cpp:macro>		<cpp:value>"localhost"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DefaultTty</name></cpp:macro>		<cpp:value>""</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DefaultOption</name></cpp:macro>	<cpp:value>""</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DefaultAuthtype</name></cpp:macro>		  <cpp:value>""</cpp:value></cpp:define>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DefaultChannelBinding</name></cpp:macro>	<cpp:value>"prefer"</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DefaultChannelBinding</name></cpp:macro>	<cpp:value>"disable"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DefaultTargetSessionAttrs</name></cpp:macro>	<cpp:value>"any"</cpp:value></cpp:define>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DefaultSSLMode</name></cpp:macro> <cpp:value>"prefer"</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DefaultSSLMode</name></cpp:macro>	<cpp:value>"disable"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_GSS</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe-gssapi-common.h"</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DefaultGSSMode</name></cpp:macro> <cpp:value>"prefer"</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DefaultGSSMode</name></cpp:macro> <cpp:value>"disable"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* ----------
 * Definition of the conninfo parameters and their fallback resources.
 *
 * If Environment-Var and Compiled-in are specified as NULL, no
 * fallback is available. If after all no value can be determined
 * for an option, an error is returned.
 *
 * The value for the username is treated specially in conninfo_add_defaults.
 * If the value is not obtained any other way, the username is determined
 * by pg_fe_getauthname().
 *
 * The Label and Disp-Char entries are provided for applications that
 * want to use PQconndefaults() to create a generic database connection
 * dialog. Disp-Char is defined as follows:
 *		""		Normal input field
 *		"*"		Password field - hide value
 *		"D"		Debug option - don't show by default
 *
 * PQconninfoOptions[] is a constant static array that we use to initialize
 * a dynamically allocated working copy.  All the "val" fields in
 * PQconninfoOptions[] *must* be NULL.  In a working copy, non-null "val"
 * fields point to malloc'd strings that should be freed when the working
 * array is freed (see PQconninfoFree).
 *
 * The first part of each struct is identical to the one in libpq-fe.h,
 * which is required since we memcpy() data between the two!
 * ----------
 */</comment>
<typedef>typedef <type><struct>struct <name>_internalPQconninfoOption</name>
<block>{
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>keyword</name></decl>;</decl_stmt>		<comment type="block">/* The keyword of the option			*/</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>envvar</name></decl>;</decl_stmt>			<comment type="block">/* Fallback environment variable name	*/</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>compiled</name></decl>;</decl_stmt>		<comment type="block">/* Fallback compiled in default value	*/</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>			<comment type="block">/* Option's current value, or NULL		*/</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>label</name></decl>;</decl_stmt>			<comment type="block">/* Label for field in connect dialog	*/</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dispchar</name></decl>;</decl_stmt>		<comment type="block">/* Indicates how to display this field in a
								 * connect dialog. Values are: "" Display
								 * entered value as is "*" Password field -
								 * hide value "D"  Debug option - don't show
								 * by default */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>dispsize</name></decl>;</decl_stmt>		<comment type="block">/* Field size in characters for dialog	*/</comment>
	<comment type="block">/* ---
	 * Anything above this comment must be synchronized with
	 * PQconninfoOption in libpq-fe.h, since we memcpy() data
	 * between them!
	 * ---
	 */</comment>
	<decl_stmt><decl><type><name>off_t</name></type>		<name>connofs</name></decl>;</decl_stmt>		<comment type="block">/* Offset into PGconn struct, -1 if not there */</comment>
}</block></struct></type> <name>internalPQconninfoOption</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>internalPQconninfoOption</name></type> <name><name>PQconninfoOptions</name><index>[]</index></name> <init>= <expr><block>{
	<comment type="block">/*
	 * "authtype" is no longer used, so mark it "don't show".  We keep it in
	 * the array so as not to reject conninfo strings from old apps that might
	 * still try to set it.
	 */</comment>
	<expr><block>{<expr><literal type="string">"authtype"</literal></expr>, <expr><literal type="string">"PGAUTHTYPE"</literal></expr>, <expr><name>DefaultAuthtype</name></expr>, <expr><name>NULL</name></expr>,
	<expr><literal type="string">"Database-Authtype"</literal></expr>, <expr><literal type="string">"D"</literal></expr>, <expr><literal type="number">20</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>}</block></expr>,

	<expr><block>{<expr><literal type="string">"service"</literal></expr>, <expr><literal type="string">"PGSERVICE"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
	<expr><literal type="string">"Database-Service"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="number">20</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>}</block></expr>,

	<expr><block>{<expr><literal type="string">"user"</literal></expr>, <expr><literal type="string">"PGUSER"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
		<expr><literal type="string">"Database-User"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="number">20</literal></expr>,
	<macro><name>offsetof</name><argument_list>(<argument>struct pg_conn</argument>, <argument>pguser</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr><literal type="string">"password"</literal></expr>, <expr><literal type="string">"PGPASSWORD"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
		<expr><literal type="string">"Database-Password"</literal></expr>, <expr><literal type="string">"*"</literal></expr>, <expr><literal type="number">20</literal></expr>,
	<macro><name>offsetof</name><argument_list>(<argument>struct pg_conn</argument>, <argument>pgpass</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr><literal type="string">"passfile"</literal></expr>, <expr><literal type="string">"PGPASSFILE"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
		<expr><literal type="string">"Database-Password-File"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="number">64</literal></expr>,
	<macro><name>offsetof</name><argument_list>(<argument>struct pg_conn</argument>, <argument>pgpassfile</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr><literal type="string">"channel_binding"</literal></expr>, <expr><literal type="string">"PGCHANNELBINDING"</literal></expr>, <expr><name>DefaultChannelBinding</name></expr>, <expr><name>NULL</name></expr>,
		<expr><literal type="string">"Channel-Binding"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="number">8</literal></expr>,	<comment type="block">/* sizeof("require") == 8 */</comment>
	<macro><name>offsetof</name><argument_list>(<argument>struct pg_conn</argument>, <argument>channel_binding</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr><literal type="string">"connect_timeout"</literal></expr>, <expr><literal type="string">"PGCONNECT_TIMEOUT"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
		<expr><literal type="string">"Connect-timeout"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="number">10</literal></expr>,	<comment type="block">/* strlen(INT32_MAX) == 10 */</comment>
	<macro><name>offsetof</name><argument_list>(<argument>struct pg_conn</argument>, <argument>connect_timeout</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr><literal type="string">"dbname"</literal></expr>, <expr><literal type="string">"PGDATABASE"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
		<expr><literal type="string">"Database-Name"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="number">20</literal></expr>,
	<macro><name>offsetof</name><argument_list>(<argument>struct pg_conn</argument>, <argument>dbName</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr><literal type="string">"host"</literal></expr>, <expr><literal type="string">"PGHOST"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
		<expr><literal type="string">"Database-Host"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="number">40</literal></expr>,
	<macro><name>offsetof</name><argument_list>(<argument>struct pg_conn</argument>, <argument>pghost</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr><literal type="string">"hostaddr"</literal></expr>, <expr><literal type="string">"PGHOSTADDR"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
		<expr><literal type="string">"Database-Host-IP-Address"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="number">45</literal></expr>,
	<macro><name>offsetof</name><argument_list>(<argument>struct pg_conn</argument>, <argument>pghostaddr</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr><literal type="string">"port"</literal></expr>, <expr><literal type="string">"PGPORT"</literal></expr>, <expr><name>DEF_PGPORT_STR</name></expr>, <expr><name>NULL</name></expr>,
		<expr><literal type="string">"Database-Port"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="number">6</literal></expr>,
	<macro><name>offsetof</name><argument_list>(<argument>struct pg_conn</argument>, <argument>pgport</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr><literal type="string">"client_encoding"</literal></expr>, <expr><literal type="string">"PGCLIENTENCODING"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
		<expr><literal type="string">"Client-Encoding"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="number">10</literal></expr>,
	<macro><name>offsetof</name><argument_list>(<argument>struct pg_conn</argument>, <argument>client_encoding_initial</argument>)</argument_list></macro>}</block></expr>,

	<comment type="block">/*
	 * "tty" is no longer used either, but keep it present for backwards
	 * compatibility.
	 */</comment>
	<expr><block>{<expr><literal type="string">"tty"</literal></expr>, <expr><literal type="string">"PGTTY"</literal></expr>, <expr><name>DefaultTty</name></expr>, <expr><name>NULL</name></expr>,
		<expr><literal type="string">"Backend-Debug-TTY"</literal></expr>, <expr><literal type="string">"D"</literal></expr>, <expr><literal type="number">40</literal></expr>,
	<macro><name>offsetof</name><argument_list>(<argument>struct pg_conn</argument>, <argument>pgtty</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr><literal type="string">"options"</literal></expr>, <expr><literal type="string">"PGOPTIONS"</literal></expr>, <expr><name>DefaultOption</name></expr>, <expr><name>NULL</name></expr>,
		<expr><literal type="string">"Backend-Options"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="number">40</literal></expr>,
	<macro><name>offsetof</name><argument_list>(<argument>struct pg_conn</argument>, <argument>pgoptions</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr><literal type="string">"application_name"</literal></expr>, <expr><literal type="string">"PGAPPNAME"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
		<expr><literal type="string">"Application-Name"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="number">64</literal></expr>,
	<macro><name>offsetof</name><argument_list>(<argument>struct pg_conn</argument>, <argument>appname</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr><literal type="string">"fallback_application_name"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
		<expr><literal type="string">"Fallback-Application-Name"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="number">64</literal></expr>,
	<macro><name>offsetof</name><argument_list>(<argument>struct pg_conn</argument>, <argument>fbappname</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr><literal type="string">"keepalives"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
		<expr><literal type="string">"TCP-Keepalives"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="number">1</literal></expr>,	<comment type="block">/* should be just '0' or '1' */</comment>
	<macro><name>offsetof</name><argument_list>(<argument>struct pg_conn</argument>, <argument>keepalives</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr><literal type="string">"keepalives_idle"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
		<expr><literal type="string">"TCP-Keepalives-Idle"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="number">10</literal></expr>,	<comment type="block">/* strlen(INT32_MAX) == 10 */</comment>
	<macro><name>offsetof</name><argument_list>(<argument>struct pg_conn</argument>, <argument>keepalives_idle</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr><literal type="string">"keepalives_interval"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
		<expr><literal type="string">"TCP-Keepalives-Interval"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="number">10</literal></expr>,	<comment type="block">/* strlen(INT32_MAX) == 10 */</comment>
	<macro><name>offsetof</name><argument_list>(<argument>struct pg_conn</argument>, <argument>keepalives_interval</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr><literal type="string">"keepalives_count"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
		<expr><literal type="string">"TCP-Keepalives-Count"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="number">10</literal></expr>, <comment type="block">/* strlen(INT32_MAX) == 10 */</comment>
	<macro><name>offsetof</name><argument_list>(<argument>struct pg_conn</argument>, <argument>keepalives_count</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr><literal type="string">"tcp_user_timeout"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
		<expr><literal type="string">"TCP-User-Timeout"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="number">10</literal></expr>, <comment type="block">/* strlen(INT32_MAX) == 10 */</comment>
	<macro><name>offsetof</name><argument_list>(<argument>struct pg_conn</argument>, <argument>pgtcp_user_timeout</argument>)</argument_list></macro>}</block></expr>,

	<comment type="block">/*
	 * ssl options are allowed even without client SSL support because the
	 * client can still handle SSL modes "disable" and "allow". Other
	 * parameters have no effect on non-SSL connections, so there is no reason
	 * to exclude them since none of them are mandatory.
	 */</comment>
	<expr><block>{<expr><literal type="string">"sslmode"</literal></expr>, <expr><literal type="string">"PGSSLMODE"</literal></expr>, <expr><name>DefaultSSLMode</name></expr>, <expr><name>NULL</name></expr>,
		<expr><literal type="string">"SSL-Mode"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="number">12</literal></expr>,		<comment type="block">/* sizeof("verify-full") == 12 */</comment>
	<macro><name>offsetof</name><argument_list>(<argument>struct pg_conn</argument>, <argument>sslmode</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr><literal type="string">"sslcompression"</literal></expr>, <expr><literal type="string">"PGSSLCOMPRESSION"</literal></expr>, <expr><literal type="string">"0"</literal></expr>, <expr><name>NULL</name></expr>,
		<expr><literal type="string">"SSL-Compression"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="number">1</literal></expr>,
	<macro><name>offsetof</name><argument_list>(<argument>struct pg_conn</argument>, <argument>sslcompression</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr><literal type="string">"sslcert"</literal></expr>, <expr><literal type="string">"PGSSLCERT"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
		<expr><literal type="string">"SSL-Client-Cert"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="number">64</literal></expr>,
	<macro><name>offsetof</name><argument_list>(<argument>struct pg_conn</argument>, <argument>sslcert</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr><literal type="string">"sslkey"</literal></expr>, <expr><literal type="string">"PGSSLKEY"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
		<expr><literal type="string">"SSL-Client-Key"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="number">64</literal></expr>,
	<macro><name>offsetof</name><argument_list>(<argument>struct pg_conn</argument>, <argument>sslkey</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr><literal type="string">"sslpassword"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
		<expr><literal type="string">"SSL-Client-Key-Password"</literal></expr>, <expr><literal type="string">"*"</literal></expr>, <expr><literal type="number">20</literal></expr>,
	<macro><name>offsetof</name><argument_list>(<argument>struct pg_conn</argument>, <argument>sslpassword</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr><literal type="string">"sslrootcert"</literal></expr>, <expr><literal type="string">"PGSSLROOTCERT"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
		<expr><literal type="string">"SSL-Root-Certificate"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="number">64</literal></expr>,
	<macro><name>offsetof</name><argument_list>(<argument>struct pg_conn</argument>, <argument>sslrootcert</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr><literal type="string">"sslcrl"</literal></expr>, <expr><literal type="string">"PGSSLCRL"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
		<expr><literal type="string">"SSL-Revocation-List"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="number">64</literal></expr>,
	<macro><name>offsetof</name><argument_list>(<argument>struct pg_conn</argument>, <argument>sslcrl</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr><literal type="string">"requirepeer"</literal></expr>, <expr><literal type="string">"PGREQUIREPEER"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
		<expr><literal type="string">"Require-Peer"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="number">10</literal></expr>,
	<macro><name>offsetof</name><argument_list>(<argument>struct pg_conn</argument>, <argument>requirepeer</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr><literal type="string">"ssl_min_protocol_version"</literal></expr>, <expr><literal type="string">"PGSSLMINPROTOCOLVERSION"</literal></expr>, <expr><literal type="string">"TLSv1.2"</literal></expr>, <expr><name>NULL</name></expr>,
		<expr><literal type="string">"SSL-Minimum-Protocol-Version"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="number">8</literal></expr>,	<comment type="block">/* sizeof("TLSv1.x") == 8 */</comment>
	<macro><name>offsetof</name><argument_list>(<argument>struct pg_conn</argument>, <argument>ssl_min_protocol_version</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr><literal type="string">"ssl_max_protocol_version"</literal></expr>, <expr><literal type="string">"PGSSLMAXPROTOCOLVERSION"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
		<expr><literal type="string">"SSL-Maximum-Protocol-Version"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="number">8</literal></expr>,	<comment type="block">/* sizeof("TLSv1.x") == 8 */</comment>
	<macro><name>offsetof</name><argument_list>(<argument>struct pg_conn</argument>, <argument>ssl_max_protocol_version</argument>)</argument_list></macro>}</block></expr>,

	<comment type="block">/*
	 * As with SSL, all GSS options are exposed even in builds that don't have
	 * support.
	 */</comment>
	<expr><block>{<expr><literal type="string">"gssencmode"</literal></expr>, <expr><literal type="string">"PGGSSENCMODE"</literal></expr>, <expr><name>DefaultGSSMode</name></expr>, <expr><name>NULL</name></expr>,
		<expr><literal type="string">"GSSENC-Mode"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="number">8</literal></expr>,	<comment type="block">/* sizeof("disable") == 8 */</comment>
	<macro><name>offsetof</name><argument_list>(<argument>struct pg_conn</argument>, <argument>gssencmode</argument>)</argument_list></macro>}</block></expr>,

	<comment type="block">/* Kerberos and GSSAPI authentication support specifying the service name */</comment>
	<expr><block>{<expr><literal type="string">"krbsrvname"</literal></expr>, <expr><literal type="string">"PGKRBSRVNAME"</literal></expr>, <expr><name>PG_KRB_SRVNAM</name></expr>, <expr><name>NULL</name></expr>,
		<expr><literal type="string">"Kerberos-service-name"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="number">20</literal></expr>,
	<macro><name>offsetof</name><argument_list>(<argument>struct pg_conn</argument>, <argument>krbsrvname</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr><literal type="string">"gsslib"</literal></expr>, <expr><literal type="string">"PGGSSLIB"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
		<expr><literal type="string">"GSS-library"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="number">7</literal></expr>,	<comment type="block">/* sizeof("gssapi") == 7 */</comment>
	<macro><name>offsetof</name><argument_list>(<argument>struct pg_conn</argument>, <argument>gsslib</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr><literal type="string">"replication"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
		<expr><literal type="string">"Replication"</literal></expr>, <expr><literal type="string">"D"</literal></expr>, <expr><literal type="number">5</literal></expr>,
	<macro><name>offsetof</name><argument_list>(<argument>struct pg_conn</argument>, <argument>replication</argument>)</argument_list></macro>}</block></expr>,

	<expr><block>{<expr><literal type="string">"target_session_attrs"</literal></expr>, <expr><literal type="string">"PGTARGETSESSIONATTRS"</literal></expr>,
		<expr><name>DefaultTargetSessionAttrs</name></expr>, <expr><name>NULL</name></expr>,
		<expr><literal type="string">"Target-Session-Attrs"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="number">11</literal></expr>, <comment type="block">/* sizeof("read-write") = 11 */</comment>
	<macro><name>offsetof</name><argument_list>(<argument>struct pg_conn</argument>, <argument>target_session_attrs</argument>)</argument_list></macro>}</block></expr>,

	<comment type="block">/* Terminating entry --- MUST BE LAST */</comment>
	<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
	<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>PQEnvironmentOption</name></type> <name><name>EnvironmentOptions</name><index>[]</index></name> <init>=
<expr><block>{
	<comment type="block">/* common user-interface settings */</comment>
	<expr><block>{
		<expr><literal type="string">"PGDATESTYLE"</literal></expr>, <expr><literal type="string">"datestyle"</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"PGTZ"</literal></expr>, <expr><literal type="string">"timezone"</literal></expr>
	}</block></expr>,
	<comment type="block">/* internal performance-related settings */</comment>
	<expr><block>{
		<expr><literal type="string">"PGGEQO"</literal></expr>, <expr><literal type="string">"geqo"</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* The connection URI must start with either of the following designators: */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>uri_designator</name><index>[]</index></name> <init>= <expr><literal type="string">"postgresql://"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>short_uri_designator</name><index>[]</index></name> <init>= <expr><literal type="string">"postgres://"</literal></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>connectOptions1</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>conninfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>connectOptions2</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>connectDBStart</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>connectDBComplete</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PGPing</name></type> <name>internal_ping</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PGconn</name> <modifier>*</modifier></type><name>makeEmptyPGconn</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>fillPGconn</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>connOptions</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>freePGconn</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>closePGconn</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>release_conn_addrinfo</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sendTerminateConn</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PQconninfoOption</name> <modifier>*</modifier></type><name>conninfo_init</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>errorMessage</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PQconninfoOption</name> <modifier>*</modifier></type><name>parse_connection_string</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>conninfo</name></decl></parameter>,
												 <parameter><decl><type><name>PQExpBuffer</name></type> <name>errorMessage</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_defaults</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>uri_prefix_length</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>connstr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>recognized_connection_string</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>connstr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PQconninfoOption</name> <modifier>*</modifier></type><name>conninfo_parse</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>conninfo</name></decl></parameter>,
										<parameter><decl><type><name>PQExpBuffer</name></type> <name>errorMessage</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_defaults</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PQconninfoOption</name> <modifier>*</modifier></type><name>conninfo_array_parse</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>keywords</name></decl></parameter>,
											  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>errorMessage</name></decl></parameter>,
											  <parameter><decl><type><name>bool</name></type> <name>use_defaults</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>expand_dbname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>conninfo_add_defaults</name><parameter_list>(<parameter><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>options</name></decl></parameter>,
								  <parameter><decl><type><name>PQExpBuffer</name></type> <name>errorMessage</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PQconninfoOption</name> <modifier>*</modifier></type><name>conninfo_uri_parse</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>uri</name></decl></parameter>,
											<parameter><decl><type><name>PQExpBuffer</name></type> <name>errorMessage</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_defaults</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>conninfo_uri_parse_options</name><parameter_list>(<parameter><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>options</name></decl></parameter>,
									   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>uri</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>errorMessage</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>conninfo_uri_parse_params</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>params</name></decl></parameter>,
									  <parameter><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>connOptions</name></decl></parameter>,
									  <parameter><decl><type><name>PQExpBuffer</name></type> <name>errorMessage</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>conninfo_uri_decode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>errorMessage</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>get_hexdigit</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>digit</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>conninfo_getval</name><parameter_list>(<parameter><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>connOptions</name></decl></parameter>,
								   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>keyword</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PQconninfoOption</name> <modifier>*</modifier></type><name>conninfo_storeval</name><parameter_list>(<parameter><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>connOptions</name></decl></parameter>,
										   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>keyword</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>,
										   <parameter><decl><type><name>PQExpBuffer</name></type> <name>errorMessage</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ignoreMissing</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>uri_decode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PQconninfoOption</name> <modifier>*</modifier></type><name>conninfo_find</name><parameter_list>(<parameter><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>connOptions</name></decl></parameter>,
									   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>keyword</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>defaultNoticeReceiver</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>defaultNoticeProcessor</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>message</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>parseServiceInfo</name><parameter_list>(<parameter><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>options</name></decl></parameter>,
							 <parameter><decl><type><name>PQExpBuffer</name></type> <name>errorMessage</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>parseServiceFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>serviceFile</name></decl></parameter>,
							 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>service</name></decl></parameter>,
							 <parameter><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>options</name></decl></parameter>,
							 <parameter><decl><type><name>PQExpBuffer</name></type> <name>errorMessage</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>group_found</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>pwdfMatchesString</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>passwordFromFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hostname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbname</name></decl></parameter>,
							  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>username</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pgpassfile</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgpassfileWarning</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>default_threadlock</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>acquire</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>sslVerifyProtocolVersion</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>version</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>sslVerifyProtocolRange</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>min</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>max</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* global variable because fe-auth.c needs to access it */</comment>
<decl_stmt><decl><type><name>pgthreadlock_t</name></type> <name>pg_g_threadlock</name> <init>= <expr><name>default_threadlock</name></expr></init></decl>;</decl_stmt>


<comment type="block">/*
 *		pqDropConnection
 *
 * Close any physical connection to the server, and reset associated
 * state inside the connection object.  We don't release state that
 * would be needed to reconnect, though, nor local state that might still
 * be useful later.
 *
 * We can always flush the output buffer, since there's no longer any hope
 * of sending that data.  However, unprocessed input data might still be
 * valuable, so the caller must tell us whether to flush that or not.
 */</comment>
<function><type><name>void</name></type>
<name>pqDropConnection</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>flushInput</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Drop any SSL state */</comment>
	<expr_stmt><expr><call><name>pqsecure_close</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Close the socket itself */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name> <operator>!=</operator> <name>PGINVALID_SOCKET</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name> <operator>=</operator> <name>PGINVALID_SOCKET</name></expr>;</expr_stmt>

	<comment type="block">/* Optionally discard any unread data */</comment>
	<if_stmt><if>if <condition>(<expr><name>flushInput</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Always discard any unsent data */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>outCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Free authentication/encryption state */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_GSS</name></cpp:ifdef>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OM_uint32</name></type>	<name>min_s</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>gcred</name></name> <operator>!=</operator> <name>GSS_C_NO_CREDENTIAL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>gss_release_cred</name><argument_list>(<argument><expr><operator>&amp;</operator><name>min_s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>gcred</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>gcred</name></name> <operator>=</operator> <name>GSS_C_NO_CREDENTIAL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>gctx</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>gss_delete_sec_context</name><argument_list>(<argument><expr><operator>&amp;</operator><name>min_s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>gctx</name></name></expr></argument>, <argument><expr><name>GSS_C_NO_BUFFER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>gtarg_nam</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>gss_release_name</name><argument_list>(<argument><expr><operator>&amp;</operator><name>min_s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>gtarg_nam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>gss_SendBuffer</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>gss_SendBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>gss_SendBuffer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>gss_RecvBuffer</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>gss_RecvBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>gss_RecvBuffer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>gss_ResultBuffer</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>gss_ResultBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>gss_ResultBuffer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>gssenc</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_SSPI</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sspitarget</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sspitarget</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sspitarget</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sspicred</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FreeCredentialsHandle</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sspicred</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sspicred</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sspicred</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sspictx</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>DeleteSecurityContext</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sspictx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sspictx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sspictx</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>usesspi</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sasl_state</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * XXX: if support for more authentication mechanisms is added, this
		 * needs to call the right 'free' function.
		 */</comment>
		<expr_stmt><expr><call><name>pg_fe_scram_free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sasl_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sasl_state</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		pqDropServerData
 *
 * Clear all connection state data that was received from (or deduced about)
 * the server.  This is essential to do between connection attempts to
 * different servers, else we may incorrectly hold over some data from the
 * old server.
 *
 * It would be better to merge this into pqDropConnection, perhaps, but
 * right now we cannot because that function is called immediately on
 * detection of connection loss (cf. pqReadData, for instance).  This data
 * should be kept until we are actually starting a new connection.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pqDropServerData</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGnotify</name>   <modifier>*</modifier></type><name>notify</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgParameterStatus</name> <modifier>*</modifier></type><name>pstatus</name></decl>;</decl_stmt>

	<comment type="block">/* Forget pending notifies */</comment>
	<expr_stmt><expr><name>notify</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>notifyHead</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>notify</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGnotify</name>   <modifier>*</modifier></type><name>prev</name> <init>= <expr><name>notify</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>notify</name> <operator>=</operator> <name><name>notify</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>notifyHead</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>notifyTail</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Reset ParameterStatus data, as well as variables deduced from it */</comment>
	<expr_stmt><expr><name>pstatus</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>pstatus</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>pstatus</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>pgParameterStatus</name> <modifier>*</modifier></type><name>prev</name> <init>= <expr><name>pstatus</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>pstatus</name> <operator>=</operator> <name><name>pstatus</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pstatus</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>client_encoding</name></name> <operator>=</operator> <name>PG_SQL_ASCII</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>std_strings</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sversion</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Drop large-object lookup data */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>lobjfuncs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>lobjfuncs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>lobjfuncs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Reset assorted other per-connection state */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>last_sqlstate</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>auth_req_received</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>password_needed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>write_failed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>write_err_msg</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>write_err_msg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>write_err_msg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>be_pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>be_key</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		Connecting to a Database
 *
 * There are now six different ways a user of this API can connect to the
 * database.  Two are not recommended for use in new code, because of their
 * lack of extensibility with respect to the passing of options to the
 * backend.  These are PQsetdb and PQsetdbLogin (the former now being a macro
 * to the latter).
 *
 * If it is desired to connect in a synchronous (blocking) manner, use the
 * function PQconnectdb or PQconnectdbParams. The former accepts a string of
 * option = value pairs (or a URI) which must be parsed; the latter takes two
 * NULL terminated arrays instead.
 *
 * To connect in an asynchronous (non-blocking) manner, use the functions
 * PQconnectStart or PQconnectStartParams (which differ in the same way as
 * PQconnectdb and PQconnectdbParams) and PQconnectPoll.
 *
 * Internally, the static functions connectDBStart, connectDBComplete
 * are part of the connection procedure.
 */</comment>

<comment type="block">/*
 *		PQconnectdbParams
 *
 * establishes a connection to a postgres backend through the postmaster
 * using connection information in two arrays.
 *
 * The keywords array is defined as
 *
 *	   const char *params[] = {"option1", "option2", NULL}
 *
 * The values array is defined as
 *
 *	   const char *values[] = {"value1", "value2", NULL}
 *
 * Returns a PGconn* which is needed for all subsequent libpq calls, or NULL
 * if a memory allocation failed.
 * If the status field of the connection returned is CONNECTION_BAD,
 * then some fields may be null'ed out instead of having valid values.
 *
 * You should call PQfinish (if conn is not NULL) regardless of whether this
 * call succeeded.
 */</comment>
<function><type><name>PGconn</name> <modifier>*</modifier></type>
<name>PQconnectdbParams</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>keywords</name></decl></parameter>,
				  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>values</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>expand_dbname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name> <init>= <expr><call><name>PQconnectStartParams</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>expand_dbname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>conn</name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>CONNECTION_BAD</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>connectDBComplete</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>conn</name></expr>;</return>

</block_content>}</block></function>

<comment type="block">/*
 *		PQpingParams
 *
 * check server status, accepting parameters identical to PQconnectdbParams
 */</comment>
<function><type><name>PGPing</name></type>
<name>PQpingParams</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>keywords</name></decl></parameter>,
			 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>values</name></decl></parameter>,
			 <parameter><decl><type><name>int</name></type> <name>expand_dbname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name> <init>= <expr><call><name>PQconnectStartParams</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>expand_dbname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGPing</name></type>		<name>ret</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>internal_ping</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		PQconnectdb
 *
 * establishes a connection to a postgres backend through the postmaster
 * using connection information in a string.
 *
 * The conninfo string is either a whitespace-separated list of
 *
 *	   option = value
 *
 * definitions or a URI (refer to the documentation for details.) Value
 * might be a single value containing no whitespaces or a single quoted
 * string. If a single quote should appear anywhere in the value, it must be
 * escaped with a backslash like \'
 *
 * Returns a PGconn* which is needed for all subsequent libpq calls, or NULL
 * if a memory allocation failed.
 * If the status field of the connection returned is CONNECTION_BAD,
 * then some fields may be null'ed out instead of having valid values.
 *
 * You should call PQfinish (if conn is not NULL) regardless of whether this
 * call succeeded.
 */</comment>
<function><type><name>PGconn</name> <modifier>*</modifier></type>
<name>PQconnectdb</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>conninfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name> <init>= <expr><call><name>PQconnectStart</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>conn</name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>CONNECTION_BAD</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>connectDBComplete</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>conn</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		PQping
 *
 * check server status, accepting parameters identical to PQconnectdb
 */</comment>
<function><type><name>PGPing</name></type>
<name>PQping</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>conninfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name> <init>= <expr><call><name>PQconnectStart</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGPing</name></type>		<name>ret</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>internal_ping</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		PQconnectStartParams
 *
 * Begins the establishment of a connection to a postgres backend through the
 * postmaster using connection information in a struct.
 *
 * See comment for PQconnectdbParams for the definition of the string format.
 *
 * Returns a PGconn*.  If NULL is returned, a malloc error has occurred, and
 * you should not attempt to proceed with this connection.  If the status
 * field of the connection returned is CONNECTION_BAD, an error has
 * occurred. In this case you should call PQfinish on the result, (perhaps
 * inspecting the error message first).  Other fields of the structure may not
 * be valid if that occurs.  If the status field is not CONNECTION_BAD, then
 * this stage has succeeded - call PQconnectPoll, using select(2) to see when
 * this is necessary.
 *
 * See PQconnectPoll for more info.
 */</comment>
<function><type><name>PGconn</name> <modifier>*</modifier></type>
<name>PQconnectStartParams</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>keywords</name></decl></parameter>,
					 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>values</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>expand_dbname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>connOptions</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Allocate memory for the conn structure
	 */</comment>
	<expr_stmt><expr><name>conn</name> <operator>=</operator> <call><name>makeEmptyPGconn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>conn</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Parse the conninfo arrays
	 */</comment>
	<expr_stmt><expr><name>connOptions</name> <operator>=</operator> <call><name>conninfo_array_parse</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>values</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
									   <argument><expr><name>true</name></expr></argument>, <argument><expr><name>expand_dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>connOptions</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_BAD</name></expr>;</expr_stmt>
		<comment type="block">/* errorMessage is already set */</comment>
		<return>return <expr><name>conn</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Move option values into conn structure
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>fillPGconn</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>connOptions</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PQconninfoFree</name><argument_list>(<argument><expr><name>connOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>conn</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Free the option info - all is in conn now
	 */</comment>
	<expr_stmt><expr><call><name>PQconninfoFree</name><argument_list>(<argument><expr><name>connOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute derived options
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>connectOptions2</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>conn</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Connect to the database
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>connectDBStart</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Just in case we failed to set it in connectDBStart */</comment>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_BAD</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>conn</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		PQconnectStart
 *
 * Begins the establishment of a connection to a postgres backend through the
 * postmaster using connection information in a string.
 *
 * See comment for PQconnectdb for the definition of the string format.
 *
 * Returns a PGconn*.  If NULL is returned, a malloc error has occurred, and
 * you should not attempt to proceed with this connection.  If the status
 * field of the connection returned is CONNECTION_BAD, an error has
 * occurred. In this case you should call PQfinish on the result, (perhaps
 * inspecting the error message first).  Other fields of the structure may not
 * be valid if that occurs.  If the status field is not CONNECTION_BAD, then
 * this stage has succeeded - call PQconnectPoll, using select(2) to see when
 * this is necessary.
 *
 * See PQconnectPoll for more info.
 */</comment>
<function><type><name>PGconn</name> <modifier>*</modifier></type>
<name>PQconnectStart</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>conninfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Allocate memory for the conn structure
	 */</comment>
	<expr_stmt><expr><name>conn</name> <operator>=</operator> <call><name>makeEmptyPGconn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>conn</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Parse the conninfo string
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>connectOptions1</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>conninfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>conn</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Compute derived options
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>connectOptions2</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>conn</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Connect to the database
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>connectDBStart</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Just in case we failed to set it in connectDBStart */</comment>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_BAD</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>conn</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Move option values into conn structure
 *
 * Don't put anything cute here --- intelligence should be in
 * connectOptions2 ...
 *
 * Returns true on success. On failure, returns false and sets error message.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>fillPGconn</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>connOptions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>internalPQconninfoOption</name> <modifier>*</modifier></type><name>option</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>option</name> <operator>=</operator> <name>PQconninfoOptions</name></expr>;</init> <condition><expr><name><name>option</name><operator>-&gt;</operator><name>keyword</name></name></expr>;</condition> <incr><expr><name>option</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>option</name><operator>-&gt;</operator><name>connofs</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>conninfo_getval</name><argument_list>(<argument><expr><name>connOptions</name></expr></argument>, <argument><expr><name><name>option</name><operator>-&gt;</operator><name>keyword</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>tmp</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>connmember</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>conn</name> <operator>+</operator> <name><name>option</name><operator>-&gt;</operator><name>connofs</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>connmember</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>*</operator><name>connmember</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><operator>*</operator><name>connmember</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>connmember</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
									  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		connectOptions1
 *
 * Internal subroutine to set up connection parameters given an already-
 * created PGconn and a conninfo string.  Derived settings should be
 * processed by calling connectOptions2 next.  (We split them because
 * PQsetdbLogin overrides defaults in between.)
 *
 * Returns true if OK, false if trouble (in which case errorMessage is set
 * and so is conn-&gt;status).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>connectOptions1</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>conninfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>connOptions</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Parse the conninfo string
	 */</comment>
	<expr_stmt><expr><name>connOptions</name> <operator>=</operator> <call><name>parse_connection_string</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>connOptions</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_BAD</name></expr>;</expr_stmt>
		<comment type="block">/* errorMessage is already set */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Move option values into conn structure
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>fillPGconn</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>connOptions</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_BAD</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PQconninfoFree</name><argument_list>(<argument><expr><name>connOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Free the option info - all is in conn now
	 */</comment>
	<expr_stmt><expr><call><name>PQconninfoFree</name><argument_list>(<argument><expr><name>connOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Count the number of elements in a simple comma-separated list.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>count_comma_separated_elems</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>input</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>input</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>input</name> <operator>==</operator> <literal type="char">','</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Parse a simple comma-separated list.
 *
 * On each call, returns a malloc'd copy of the next element, and sets *more
 * to indicate whether there are any more elements in the list after this,
 * and updates *startptr to point to the next element, if any.
 *
 * On out of memory, returns NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>parse_comma_separated_list</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>startptr</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>more</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>s</name> <init>= <expr><operator>*</operator><name>startptr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Search for the end of the current element; a comma or end-of-string
	 * acts as a terminator.
	 */</comment>
	<expr_stmt><expr><name>e</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>*</operator><name>e</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>e</name> <operator>!=</operator> <literal type="char">','</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>++</operator><name>e</name></expr>;</expr_stmt></block_content></block></while>
	<expr_stmt><expr><operator>*</operator><name>more</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>e</name> <operator>==</operator> <literal type="char">','</literal><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <name>e</name> <operator>-</operator> <name>s</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>len</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>p</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>startptr</name> <operator>=</operator> <name>e</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		connectOptions2
 *
 * Compute derived connection options after absorbing all user-supplied info.
 *
 * Returns true if OK, false if trouble (in which case errorMessage is set
 * and so is conn-&gt;status).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>connectOptions2</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Allocate memory for details about each host to which we might possibly
	 * try to connect.  For that, count the number of elements in the hostaddr
	 * or host options.  If neither is given, assume one host.
	 */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>whichhost</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pghostaddr</name></name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>pghostaddr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>nconnhost</name></name> <operator>=</operator> <call><name>count_comma_separated_elems</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pghostaddr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pghost</name></name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>pghost</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>nconnhost</name></name> <operator>=</operator> <call><name>count_comma_separated_elems</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pghost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>nconnhost</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>connhost</name></name> <operator>=</operator> <operator>(</operator><name>pg_conn_host</name> <operator>*</operator><operator>)</operator>
		<call><name>calloc</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nconnhost</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pg_conn_host</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>connhost</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>oom_error</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We now have one pg_conn_host structure per possible host.  Fill in the
	 * host and hostaddr fields for each, by splitting the parameter strings.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pghostaddr</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>pghostaddr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>pghostaddr</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>more</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>conn</name><operator>-&gt;</operator><name>nconnhost</name></name> <operator>&amp;&amp;</operator> <name>more</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hostaddr</name> <operator>=</operator> <call><name>parse_comma_separated_list</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>more</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hostaddr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>oom_error</name>;</goto></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * If hostaddr was given, the array was allocated according to the
		 * number of elements in the hostaddr list, so it really should be the
		 * right size.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>more</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>==</operator> <name><name>conn</name><operator>-&gt;</operator><name>nconnhost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pghost</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>pghost</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>pghost</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>more</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>conn</name><operator>-&gt;</operator><name>nconnhost</name></name> <operator>&amp;&amp;</operator> <name>more</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>host</name> <operator>=</operator> <call><name>parse_comma_separated_list</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>more</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>host</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>oom_error</name>;</goto></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Check for wrong number of host items. */</comment>
		<if_stmt><if>if <condition>(<expr><name>more</name> <operator>||</operator> <name>i</name> <operator>!=</operator> <name><name>conn</name><operator>-&gt;</operator><name>nconnhost</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_BAD</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"could not match %d host names to %d hostaddr values\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>count_comma_separated_elems</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pghost</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nconnhost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now, for each host slot, identify the type of address spec, and fill in
	 * the default address if nothing was given.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>conn</name><operator>-&gt;</operator><name>nconnhost</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>pg_conn_host</name> <modifier>*</modifier></type><name>ch</name> <init>= <expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>ch</name><operator>-&gt;</operator><name>hostaddr</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>ch</name><operator>-&gt;</operator><name>hostaddr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>CHT_HOST_ADDRESS</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>ch</name><operator>-&gt;</operator><name>host</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>ch</name><operator>-&gt;</operator><name>host</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>CHT_HOST_NAME</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UNIX_SOCKETS</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><call><name>is_absolute_path</name><argument_list>(<argument><expr><name><name>ch</name><operator>-&gt;</operator><name>host</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>CHT_UNIX_SOCKET</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>ch</name><operator>-&gt;</operator><name>host</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>ch</name><operator>-&gt;</operator><name>host</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * This bit selects the default host location.  If you change
			 * this, see also pg_regress.
			 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UNIX_SOCKETS</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><name><name>DEFAULT_PGSOCKET_DIR</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>host</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>DEFAULT_PGSOCKET_DIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>CHT_UNIX_SOCKET</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<block>{<block_content>
				<expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>host</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>DefaultHost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>CHT_HOST_NAME</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>ch</name><operator>-&gt;</operator><name>host</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>oom_error</name>;</goto></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Next, work out the port number corresponding to each host name.
	 *
	 * Note: unlike the above for host names, this could leave the port fields
	 * as null or empty strings.  We will substitute DEF_PGPORT whenever we
	 * read such a port field.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pgport</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>pgport</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>pgport</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>more</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>conn</name><operator>-&gt;</operator><name>nconnhost</name></name> <operator>&amp;&amp;</operator> <name>more</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>port</name> <operator>=</operator> <call><name>parse_comma_separated_list</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>more</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>port</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>oom_error</name>;</goto></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * If exactly one port was given, use it for every host.  Otherwise,
		 * there must be exactly as many ports as there were hosts.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>more</name></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>conn</name><operator>-&gt;</operator><name>nconnhost</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>port</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>port</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<goto>goto <name>oom_error</name>;</goto></block_content></block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>more</name> <operator>||</operator> <name>i</name> <operator>!=</operator> <name><name>conn</name><operator>-&gt;</operator><name>nconnhost</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_BAD</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"could not match %d port numbers to %d hosts\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>count_comma_separated_elems</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgport</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nconnhost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If user name was not given, fetch it.  (Most likely, the fetch will
	 * fail, since the only way we get here is if pg_fe_getauthname() failed
	 * during conninfo_add_defaults().  But now we want an error message.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pguser</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>conn</name><operator>-&gt;</operator><name>pguser</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pguser</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pguser</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pguser</name></name> <operator>=</operator> <call><name>pg_fe_getauthname</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>pguser</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_BAD</name></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If database name was not given, default it to equal user name
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>dbName</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>conn</name><operator>-&gt;</operator><name>dbName</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>dbName</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>dbName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>dbName</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pguser</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>dbName</name></name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>oom_error</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If password was not given, try to look it up in password file.  Note
	 * that the result might be different for each host/port pair.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pgpass</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>conn</name><operator>-&gt;</operator><name>pgpass</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* If password file wasn't specified, use ~/PGPASSFILE */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pgpassfile</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>conn</name><operator>-&gt;</operator><name>pgpassfile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>homedir</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>pqGetHomeDirectory</name><argument_list>(<argument><expr><name>homedir</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>homedir</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pgpassfile</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgpassfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pgpassfile</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>pgpassfile</name></name></expr>)</condition><block type="pseudo"><block_content>
					<goto>goto <name>oom_error</name>;</goto></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgpassfile</name></name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>,
						 <argument><expr><name>homedir</name></expr></argument>, <argument><expr><name>PGPASSFILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pgpassfile</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>pgpassfile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>conn</name><operator>-&gt;</operator><name>nconnhost</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<comment type="block">/*
				 * Try to get a password for this host from file.  We use host
				 * for the hostname search key if given, else hostaddr (at
				 * least one of them is guaranteed nonempty by now).
				 */</comment>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pwhost</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>host</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>pwhost</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>pwhost</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>pwhost</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hostaddr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>password</name> <operator>=</operator>
					<call><name>passwordFromFile</name><argument_list>(<argument><expr><name>pwhost</name></expr></argument>,
									 <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>port</name></expr></argument>,
									 <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>dbName</name></name></expr></argument>,
									 <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pguser</name></name></expr></argument>,
									 <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgpassfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * validate channel_binding option
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>channel_binding</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>channel_binding</name></name></expr></argument>, <argument><expr><literal type="string">"disable"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal>
			<operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>channel_binding</name></name></expr></argument>, <argument><expr><literal type="string">"prefer"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal>
			<operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>channel_binding</name></name></expr></argument>, <argument><expr><literal type="string">"require"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_BAD</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"invalid channel_binding value: \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>channel_binding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>channel_binding</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>DefaultChannelBinding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>channel_binding</name></name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>oom_error</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * validate sslmode option
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sslmode</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sslmode</name></name></expr></argument>, <argument><expr><literal type="string">"disable"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal>
			<operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sslmode</name></name></expr></argument>, <argument><expr><literal type="string">"allow"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal>
			<operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sslmode</name></name></expr></argument>, <argument><expr><literal type="string">"prefer"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal>
			<operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sslmode</name></name></expr></argument>, <argument><expr><literal type="string">"require"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal>
			<operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sslmode</name></name></expr></argument>, <argument><expr><literal type="string">"verify-ca"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal>
			<operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sslmode</name></name></expr></argument>, <argument><expr><literal type="string">"verify-full"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_BAD</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"invalid sslmode value: \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sslmode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>USE_SSL</name></cpp:ifndef>
		<switch>switch <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sslmode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'a'</literal></expr>:</case>			<comment type="block">/* "allow" */</comment>
			<case>case <expr><literal type="char">'p'</literal></expr>:</case>			<comment type="block">/* "prefer" */</comment>

				<comment type="block">/*
				 * warn user that an SSL connection will never be negotiated
				 * since SSL was not compiled in?
				 */</comment>
				<break>break;</break>

			<case>case <expr><literal type="char">'r'</literal></expr>:</case>			<comment type="block">/* "require" */</comment>
			<case>case <expr><literal type="char">'v'</literal></expr>:</case>			<comment type="block">/* "verify-ca" or "verify-full" */</comment>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_BAD</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
								  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"sslmode value \"%s\" invalid when SSL support is not compiled in\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sslmode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></switch>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sslmode</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>DefaultSSLMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>sslmode</name></name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>oom_error</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Validate TLS protocol versions for ssl_min_protocol_version and
	 * ssl_max_protocol_version.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>sslVerifyProtocolVersion</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl_min_protocol_version</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_BAD</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"invalid ssl_min_protocol_version value: \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl_min_protocol_version</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>sslVerifyProtocolVersion</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl_max_protocol_version</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_BAD</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"invalid ssl_max_protocol_version value: \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl_max_protocol_version</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check if the range of SSL protocols defined is correct.  This is done
	 * at this early step because this is independent of the SSL
	 * implementation used, and this avoids unnecessary cycles with an
	 * already-built SSL context when the connection is being established, as
	 * it would be doomed anyway.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>sslVerifyProtocolRange</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl_min_protocol_version</name></name></expr></argument>,
								<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl_max_protocol_version</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_BAD</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"invalid SSL protocol version range\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * validate gssencmode option
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>gssencmode</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>gssencmode</name></name></expr></argument>, <argument><expr><literal type="string">"disable"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>gssencmode</name></name></expr></argument>, <argument><expr><literal type="string">"prefer"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>gssencmode</name></name></expr></argument>, <argument><expr><literal type="string">"require"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_BAD</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"invalid gssencmode value: \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>gssencmode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ENABLE_GSS</name></cpp:ifndef>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>gssencmode</name></name></expr></argument>, <argument><expr><literal type="string">"require"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_BAD</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"gssencmode value \"%s\" invalid when GSSAPI support is not compiled in\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>gssencmode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>gssencmode</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>DefaultGSSMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>gssencmode</name></name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>oom_error</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Resolve special "auto" client_encoding from the locale
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>client_encoding_initial</name></name> <operator>&amp;&amp;</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>client_encoding_initial</name></name></expr></argument>, <argument><expr><literal type="string">"auto"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>client_encoding_initial</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>client_encoding_initial</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><call><name>pg_encoding_to_char</name><argument_list>(<argument><expr><call><name>pg_get_encoding_from_locale</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>client_encoding_initial</name></name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>oom_error</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Validate target_session_attrs option.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>target_session_attrs</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>target_session_attrs</name></name></expr></argument>, <argument><expr><literal type="string">"any"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal>
			<operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>target_session_attrs</name></name></expr></argument>, <argument><expr><literal type="string">"read-write"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_BAD</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"invalid target_session_attrs value: \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>target_session_attrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Only if we get this far is it appropriate to try to connect. (We need a
	 * state flag, rather than just the boolean result of this function, in
	 * case someone tries to PQreset() the PGconn.)
	 */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>options_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>

<label><name>oom_error</name>:</label>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_BAD</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
					  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		PQconndefaults
 *
 * Construct a default connection options array, which identifies all the
 * available options and shows any default values that are available from the
 * environment etc.  On error (eg out of memory), NULL is returned.
 *
 * Using this function, an application may determine all possible options
 * and their current default values.
 *
 * NOTE: as of PostgreSQL 7.0, the returned array is dynamically allocated
 * and should be freed when no longer needed via PQconninfoFree().  (In prior
 * versions, the returned array was static, but that's not thread-safe.)
 * Pre-7.0 applications that use this function will see a small memory leak
 * until they are updated to call PQconninfoFree.
 */</comment>
<function><type><name>PQconninfoOption</name> <modifier>*</modifier></type>
<name>PQconndefaults</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>errorBuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>connOptions</name></decl>;</decl_stmt>

	<comment type="block">/* We don't actually report any errors here, but callees want a buffer */</comment>
	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errorBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQExpBufferDataBroken</name><argument_list>(<argument><expr><name>errorBuf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* out of memory already :-( */</comment>

	<expr_stmt><expr><name>connOptions</name> <operator>=</operator> <call><name>conninfo_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errorBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>connOptions</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* pass NULL errorBuf to ignore errors */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>conninfo_add_defaults</name><argument_list>(<argument><expr><name>connOptions</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PQconninfoFree</name><argument_list>(<argument><expr><name>connOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>connOptions</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errorBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>connOptions</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *		PQsetdbLogin
 *
 * establishes a connection to a postgres backend through the postmaster
 * at the specified host and port.
 *
 * returns a PGconn* which is needed for all subsequent libpq calls
 *
 * if the status field of the connection returned is CONNECTION_BAD,
 * then only the errorMessage is likely to be useful.
 * ----------------
 */</comment>
<function><type><name>PGconn</name> <modifier>*</modifier></type>
<name>PQsetdbLogin</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pghost</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pgport</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pgoptions</name></decl></parameter>,
			 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pgtty</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbName</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>login</name></decl></parameter>,
			 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pwd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Allocate memory for the conn structure
	 */</comment>
	<expr_stmt><expr><name>conn</name> <operator>=</operator> <call><name>makeEmptyPGconn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>conn</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the dbName parameter contains what looks like a connection string,
	 * parse it into conn struct using connectOptions1.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>dbName</name> <operator>&amp;&amp;</operator> <call><name>recognized_connection_string</name><argument_list>(<argument><expr><name>dbName</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>connectOptions1</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>dbName</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>conn</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Old-style path: first, parse an empty conninfo string in order to
		 * set up the same defaults that PQconnectdb() would use.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>connectOptions1</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>conn</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Insert dbName parameter value into struct */</comment>
		<if_stmt><if>if <condition>(<expr><name>dbName</name> <operator>&amp;&amp;</operator> <name><name>dbName</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>dbName</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>dbName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>dbName</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>dbName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>dbName</name></name></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>oom_error</name>;</goto></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Insert remaining parameters into struct, overriding defaults (as well
	 * as any conflicting data from dbName taken as a conninfo).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>pghost</name> <operator>&amp;&amp;</operator> <name><name>pghost</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pghost</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pghost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pghost</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>pghost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>pghost</name></name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>oom_error</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>pgport</name> <operator>&amp;&amp;</operator> <name><name>pgport</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pgport</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgport</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pgport</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>pgport</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>pgport</name></name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>oom_error</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>pgoptions</name> <operator>&amp;&amp;</operator> <name><name>pgoptions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pgoptions</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgoptions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pgoptions</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>pgoptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>pgoptions</name></name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>oom_error</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>pgtty</name> <operator>&amp;&amp;</operator> <name><name>pgtty</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pgtty</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgtty</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pgtty</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>pgtty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>pgtty</name></name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>oom_error</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>login</name> <operator>&amp;&amp;</operator> <name><name>login</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pguser</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pguser</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pguser</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>login</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>pguser</name></name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>oom_error</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>pwd</name> <operator>&amp;&amp;</operator> <name><name>pwd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pgpass</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgpass</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pgpass</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>pwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>pgpass</name></name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>oom_error</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Compute derived options
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>connectOptions2</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>conn</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Connect to the database
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>connectDBStart</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>connectDBComplete</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>conn</name></expr>;</return>

<label><name>oom_error</name>:</label>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_BAD</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
					  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>conn</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * connectNoDelay -
 * Sets the TCP_NODELAY socket option.
 * Returns 1 if successful, 0 if not.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>connectNoDelay</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>TCP_NODELAY</name></cpp:ifdef>
	<decl_stmt><decl><type><name>int</name></type>			<name>on</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>setsockopt</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name>IPPROTO_TCP</name></expr></argument>, <argument><expr><name>TCP_NODELAY</name></expr></argument>,
				   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>on</name></expr></argument>,
				   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>on</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>sebuf</name><index>[<expr><name>PG_STRERROR_R_BUFLEN</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"could not set socket to TCP no delay mode: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>SOCK_STRERROR</name><argument_list>(<argument><expr><name>SOCK_ERRNO</name></expr></argument>, <argument><expr><name>sebuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sebuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * Write currently connected IP address into host_addr (of len host_addr_len).
 * If unable to, set it to the empty string.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>getHostaddr</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>host_addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>host_addr_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_storage</name></name> <modifier>*</modifier></type><name>addr</name> <init>= <expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>raddr</name><operator>.</operator><name>addr</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>addr</name><operator>-&gt;</operator><name>ss_family</name></name> <operator>==</operator> <name>AF_INET</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pg_inet_net_ntop</name><argument_list>(<argument><expr><name>AF_INET</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator>struct <name>sockaddr_in</name> <operator>*</operator><operator>)</operator> <name>addr</name><operator>)</operator><operator>-&gt;</operator><name><name>sin_addr</name><operator>.</operator><name>s_addr</name></name></expr></argument>,
							 <argument><expr><literal type="number">32</literal></expr></argument>,
							 <argument><expr><name>host_addr</name></expr></argument>, <argument><expr><name>host_addr_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>host_addr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_IPV6</name></cpp:ifdef>
	<if type="elseif">else if <condition>(<expr><name><name>addr</name><operator>-&gt;</operator><name>ss_family</name></name> <operator>==</operator> <name>AF_INET6</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pg_inet_net_ntop</name><argument_list>(<argument><expr><name>AF_INET6</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator>struct <name>sockaddr_in6</name> <operator>*</operator><operator>)</operator> <name>addr</name><operator>)</operator><operator>-&gt;</operator><name><name>sin6_addr</name><operator>.</operator><name>s6_addr</name></name></expr></argument>,
							 <argument><expr><literal type="number">128</literal></expr></argument>,
							 <argument><expr><name>host_addr</name></expr></argument>, <argument><expr><name>host_addr_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>host_addr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>host_addr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * connectFailureMessage -
 * create a friendly error message on connection failure.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>connectFailureMessage</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>errorno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>sebuf</name><index>[<expr><name>PG_STRERROR_R_BUFLEN</name></expr>]</index></name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UNIX_SOCKETS</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><call><name>IS_AF_UNIX</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>raddr</name><operator>.</operator><name>addr</name><operator>.</operator><name>ss_family</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>service</name><index>[<expr><name>NI_MAXHOST</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_getnameinfo_all</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>raddr</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>raddr</name><operator>.</operator><name>salen</name></name></expr></argument>,
						   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
						   <argument><expr><name>service</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>service</name></expr></argument>)</argument_list></sizeof></expr></argument>,
						   <argument><expr><name>NI_NUMERICSERV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"could not connect to server: %s\n"</literal>
										<literal type="string">"\tIs the server running locally and accepting\n"</literal>
										<literal type="string">"\tconnections on Unix domain socket \"%s\"?\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>SOCK_STRERROR</name><argument_list>(<argument><expr><name>errorno</name></expr></argument>, <argument><expr><name>sebuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sebuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>service</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* HAVE_UNIX_SOCKETS */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>host_addr</name><index>[<expr><name>NI_MAXHOST</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>displayed_host</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>displayed_port</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Optionally display the network address with the hostname. This is
		 * useful to distinguish between IPv4 and IPv6 connections.
		 */</comment>
		<expr_stmt><expr><call><name>getHostaddr</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>host_addr</name></expr></argument>, <argument><expr><name>NI_MAXHOST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* To which host and port were we actually connecting? */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>whichhost</name></name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>CHT_HOST_ADDRESS</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>displayed_host</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>whichhost</name></name></expr>]</index></name><operator>.</operator><name>hostaddr</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>displayed_host</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>whichhost</name></name></expr>]</index></name><operator>.</operator><name>host</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>displayed_port</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>whichhost</name></name></expr>]</index></name><operator>.</operator><name>port</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>displayed_port</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>displayed_port</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>displayed_port</name> <operator>=</operator> <name>DEF_PGPORT_STR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If the user did not supply an IP address using 'hostaddr', and
		 * 'host' was missing or does not match our lookup, display the
		 * looked-up IP address.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>whichhost</name></name></expr>]</index></name><operator>.</operator><name>type</name> <operator>!=</operator> <name>CHT_HOST_ADDRESS</name> <operator>&amp;&amp;</operator>
			<call><name>strlen</name><argument_list>(<argument><expr><name>host_addr</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>displayed_host</name></expr></argument>, <argument><expr><name>host_addr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"could not connect to server: %s\n"</literal>
											<literal type="string">"\tIs the server running on host \"%s\" (%s) and accepting\n"</literal>
											<literal type="string">"\tTCP/IP connections on port %s?\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>SOCK_STRERROR</name><argument_list>(<argument><expr><name>errorno</name></expr></argument>, <argument><expr><name>sebuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sebuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>displayed_host</name></expr></argument>, <argument><expr><name>host_addr</name></expr></argument>,
							  <argument><expr><name>displayed_port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"could not connect to server: %s\n"</literal>
											<literal type="string">"\tIs the server running on host \"%s\" and accepting\n"</literal>
											<literal type="string">"\tTCP/IP connections on port %s?\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>SOCK_STRERROR</name><argument_list>(<argument><expr><name>errorno</name></expr></argument>, <argument><expr><name>sebuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sebuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>displayed_host</name></expr></argument>,
							  <argument><expr><name>displayed_port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Should we use keepalives?  Returns 1 if yes, 0 if no, and -1 if
 * conn-&gt;keepalives is set to a value which is not parseable as an
 * integer.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>useKeepalives</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>val</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>keepalives</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>keepalives</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ep</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ep</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><ternary><condition><expr><name>val</name> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Parse and try to interpret "value" as an integer value, and if successful,
 * store it in *result, complaining if there is any trailing garbage or an
 * overflow.  This allows any number of leading and trailing whitespaces.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>parse_int_param</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
				<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>numval</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>value</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* strtol(3) skips leading whitespaces */</comment>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>numval</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If no progress was done during the parsing or an error happened, fail.
	 * This tests properly for overflows of the result.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>value</name> <operator>==</operator> <name>end</name> <operator>||</operator> <name>errno</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>numval</name> <operator>!=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>numval</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Skip any trailing whitespace; if anything but whitespace remains before
	 * the terminating character, fail
	 */</comment>
	<while>while <condition>(<expr><operator>*</operator><name>end</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>end</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>end</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>end</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>numval</name></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>

<label><name>error</name>:</label>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
					  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"invalid integer value \"%s\" for connection option \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>value</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<comment type="block">/*
 * Set the keepalive idle timer.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>setKeepalivesIdle</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>idle</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>keepalives_idle</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_int_param</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>keepalives_idle</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>idle</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>,
						 <argument><expr><literal type="string">"keepalives_idle"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>idle</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>idle</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PG_TCP_KEEPALIVE_IDLE</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><call><name>setsockopt</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name>IPPROTO_TCP</name></expr></argument>, <argument><expr><name>PG_TCP_KEEPALIVE_IDLE</name></expr></argument>,
				   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>idle</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>idle</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>sebuf</name><index>[<expr><name>PG_STRERROR_R_BUFLEN</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"setsockopt(%s) failed: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>PG_TCP_KEEPALIVE_IDLE_STR</name></expr></argument>,
						  <argument><expr><call><name>SOCK_STRERROR</name><argument_list>(<argument><expr><name>SOCK_ERRNO</name></expr></argument>, <argument><expr><name>sebuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sebuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Set the keepalive interval.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>setKeepalivesInterval</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>interval</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>keepalives_interval</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_int_param</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>keepalives_interval</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>interval</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>,
						 <argument><expr><literal type="string">"keepalives_interval"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>interval</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>interval</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TCP_KEEPINTVL</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><call><name>setsockopt</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name>IPPROTO_TCP</name></expr></argument>, <argument><expr><name>TCP_KEEPINTVL</name></expr></argument>,
				   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>interval</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>interval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>sebuf</name><index>[<expr><name>PG_STRERROR_R_BUFLEN</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"setsockopt(%s) failed: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><literal type="string">"TCP_KEEPINTVL"</literal></expr></argument>,
						  <argument><expr><call><name>SOCK_STRERROR</name><argument_list>(<argument><expr><name>SOCK_ERRNO</name></expr></argument>, <argument><expr><name>sebuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sebuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Set the count of lost keepalive packets that will trigger a connection
 * break.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>setKeepalivesCount</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>count</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>keepalives_count</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_int_param</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>keepalives_count</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>count</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>,
						 <argument><expr><literal type="string">"keepalives_count"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TCP_KEEPCNT</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><call><name>setsockopt</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name>IPPROTO_TCP</name></expr></argument>, <argument><expr><name>TCP_KEEPCNT</name></expr></argument>,
				   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>count</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>sebuf</name><index>[<expr><name>PG_STRERROR_R_BUFLEN</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"setsockopt(%s) failed: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><literal type="string">"TCP_KEEPCNT"</literal></expr></argument>,
						  <argument><expr><call><name>SOCK_STRERROR</name><argument_list>(<argument><expr><name>SOCK_ERRNO</name></expr></argument>, <argument><expr><name>sebuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sebuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* WIN32 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIO_KEEPALIVE_VALS</name></cpp:ifdef>
<comment type="block">/*
 * Enable keepalives and set the keepalive values on Win32,
 * where they are always set in one batch.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>setKeepalivesWin32</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>tcp_keepalive</name></name></type> <name>ka</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DWORD</name></type>		<name>retsize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>idle</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>interval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>keepalives_idle</name></name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>parse_int_param</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>keepalives_idle</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>idle</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>,
						 <argument><expr><literal type="string">"keepalives_idle"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>idle</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>idle</name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <literal type="number">60</literal> <operator>*</operator> <literal type="number">60</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>		<comment type="block">/* 2 hours = default */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>keepalives_interval</name></name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>parse_int_param</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>keepalives_interval</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>interval</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>,
						 <argument><expr><literal type="string">"keepalives_interval"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>interval</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>interval</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>			<comment type="block">/* 1 second = default */</comment>

	<expr_stmt><expr><name><name>ka</name><operator>.</operator><name>onoff</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ka</name><operator>.</operator><name>keepalivetime</name></name> <operator>=</operator> <name>idle</name> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ka</name><operator>.</operator><name>keepaliveinterval</name></name> <operator>=</operator> <name>interval</name> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>WSAIoctl</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>,
				 <argument><expr><name>SIO_KEEPALIVE_VALS</name></expr></argument>,
				 <argument><expr><operator>(</operator><name>LPVOID</name><operator>)</operator> <operator>&amp;</operator><name>ka</name></expr></argument>,
				 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ka</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				 <argument><expr><name>NULL</name></expr></argument>,
				 <argument><expr><literal type="number">0</literal></expr></argument>,
				 <argument><expr><operator>&amp;</operator><name>retsize</name></expr></argument>,
				 <argument><expr><name>NULL</name></expr></argument>,
				 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call>
		<operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"WSAIoctl(SIO_KEEPALIVE_VALS) failed: %ui\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>WSAGetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* SIO_KEEPALIVE_VALS */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>

<comment type="block">/*
 * Set the TCP user timeout.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>setTCPUserTimeout</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>timeout</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pgtcp_user_timeout</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_int_param</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgtcp_user_timeout</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timeout</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>,
						 <argument><expr><literal type="string">"tcp_user_timeout"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>timeout</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>timeout</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TCP_USER_TIMEOUT</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><call><name>setsockopt</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name>IPPROTO_TCP</name></expr></argument>, <argument><expr><name>TCP_USER_TIMEOUT</name></expr></argument>,
				   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>timeout</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>timeout</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>sebuf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"setsockopt(%s) failed: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><literal type="string">"TCP_USER_TIMEOUT"</literal></expr></argument>,
						  <argument><expr><call><name>SOCK_STRERROR</name><argument_list>(<argument><expr><name>SOCK_ERRNO</name></expr></argument>, <argument><expr><name>sebuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sebuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * connectDBStart -
 *		Begin the process of making a connection to the backend.
 *
 * Returns 1 if successful, 0 if not.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>connectDBStart</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>options_valid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>connect_errReturn</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check for bad linking to backend-internal versions of src/common
	 * functions (see comments in link-canary.c for the reason we need this).
	 * Nobody but developers should see this message, so we don't bother
	 * translating it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_link_canary_is_frontend</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><literal type="string">"libpq is incorrectly linked to backend functions\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>connect_errReturn</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Ensure our buffers are empty */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>outCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Ensure errorMessage is empty, too.  PQconnectPoll will append messages
	 * to it in the process of scanning for a working server.  Thus, if we
	 * fail to connect to multiple hosts, the final error message will include
	 * details about each failure.
	 */</comment>
	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up to try to connect to the first host.  (Setting whichhost = -1 is
	 * a bit of a cheat, but PQconnectPoll will advance it to 0 before
	 * anything else looks at it.)
	 */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>whichhost</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>try_next_addr</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>try_next_host</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_NEEDED</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * The code for processing CONNECTION_NEEDED state is in PQconnectPoll(),
	 * so that it can easily be re-executed if needed again during the
	 * asynchronous startup process.  However, we must run it once here,
	 * because callers expect a success return from this routine to mean that
	 * we are in PGRES_POLLING_WRITING connection state.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PQconnectPoll</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_POLLING_WRITING</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<label><name>connect_errReturn</name>:</label>

	<comment type="block">/*
	 * If we managed to open a socket, close it immediately rather than
	 * waiting till PQfinish.  (The application cannot have gotten the socket
	 * from PQsocket yet, so this doesn't risk breaking anything.)
	 */</comment>
	<expr_stmt><expr><call><name>pqDropConnection</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_BAD</name></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *		connectDBComplete
 *
 * Block and complete a connection.
 *
 * Returns 1 on success, 0 on failure.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>connectDBComplete</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PostgresPollingStatusType</name></type> <name>flag</name> <init>= <expr><name>PGRES_POLLING_WRITING</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>time_t</name></type>		<name>finish_time</name> <init>= <expr><operator>(</operator><operator>(</operator><name>time_t</name><operator>)</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>timeout</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>last_whichhost</name> <init>= <expr><operator>-</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* certainly different from whichhost */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>addrinfo</name></name> <modifier>*</modifier></type><name>last_addr_cur</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>conn</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>CONNECTION_BAD</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Set up a time limit, if connect_timeout isn't zero.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>connect_timeout</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_int_param</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>connect_timeout</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timeout</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>,
							 <argument><expr><literal type="string">"connect_timeout"</literal></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* mark the connection as bad to report the parsing failure */</comment>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_BAD</name></expr>;</expr_stmt>
			<return>return <expr><literal type="number">0</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>timeout</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Rounding could cause connection to fail unexpectedly quickly;
			 * to prevent possibly waiting hardly-at-all, insist on at least
			 * two seconds.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>timeout</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>timeout</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>					<comment type="block">/* negative means 0 */</comment>
			<expr_stmt><expr><name>timeout</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * (Re)start the connect_timeout timer if it's active and we are
		 * considering a different host than we were last time through.  If
		 * we've already succeeded, though, needn't recalculate.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>flag</name> <operator>!=</operator> <name>PGRES_POLLING_OK</name> <operator>&amp;&amp;</operator>
			<name>timeout</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>whichhost</name></name> <operator>!=</operator> <name>last_whichhost</name> <operator>||</operator>
			 <name><name>conn</name><operator>-&gt;</operator><name>addr_cur</name></name> <operator>!=</operator> <name>last_addr_cur</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>finish_time</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>timeout</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>last_whichhost</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>whichhost</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>last_addr_cur</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>addr_cur</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Wait, if necessary.  Note that the initial state (just after
		 * PQconnectStart) is to wait for the socket to select for writing.
		 */</comment>
		<switch>switch <condition>(<expr><name>flag</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>PGRES_POLLING_OK</name></expr>:</case>

				<comment type="block">/*
				 * Reset stored error messages since we now have a working
				 * connection
				 */</comment>
				<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><literal type="number">1</literal></expr>;</return>		<comment type="block">/* success! */</comment>

			<case>case <expr><name>PGRES_POLLING_READING</name></expr>:</case>
				<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pqWaitTimed</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>finish_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* hard failure, eg select() problem, aborts everything */</comment>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_BAD</name></expr>;</expr_stmt>
					<return>return <expr><literal type="number">0</literal></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><name>PGRES_POLLING_WRITING</name></expr>:</case>
				<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pqWaitTimed</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>finish_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* hard failure, eg select() problem, aborts everything */</comment>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_BAD</name></expr>;</expr_stmt>
					<return>return <expr><literal type="number">0</literal></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>

			<default>default:</default>
				<comment type="block">/* Just in case we failed to set it in PQconnectPoll */</comment>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_BAD</name></expr>;</expr_stmt>
				<return>return <expr><literal type="number">0</literal></expr>;</return>
		</block_content>}</block></switch>

		<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>			<comment type="block">/* connect_timeout elapsed */</comment>
		<block>{<block_content>
			<comment type="block">/*
			 * Give up on current server/address, try the next one.
			 */</comment>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>try_next_addr</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_NEEDED</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Now try to advance the state machine.
		 */</comment>
		<expr_stmt><expr><name>flag</name> <operator>=</operator> <call><name>PQconnectPoll</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * This subroutine saves conn-&gt;errorMessage, which will be restored back by
 * restoreErrorMessage subroutine.  Returns false on OOM failure.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>saveErrorMessage</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>savedMessage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><name>savedMessage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>savedMessage</name></expr></argument>,
						 <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQExpBufferBroken</name><argument_list>(<argument><expr><name>savedMessage</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Clear whatever is in errorMessage now */</comment>
	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Restores saved error messages back to conn-&gt;errorMessage, prepending them
 * to whatever is in conn-&gt;errorMessage already.  (This does the right thing
 * if anything's been added to conn-&gt;errorMessage since saveErrorMessage.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>restoreErrorMessage</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>savedMessage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>savedMessage</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>, <argument><expr><name><name>savedMessage</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* If any step above hit OOM, just report that */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PQExpBufferBroken</name><argument_list>(<argument><expr><name>savedMessage</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>PQExpBufferBroken</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><name>savedMessage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *		PQconnectPoll
 *
 * Poll an asynchronous connection.
 *
 * Returns a PostgresPollingStatusType.
 * Before calling this function, use select(2) to determine when data
 * has arrived..
 *
 * You must call PQfinish whether or not this fails.
 *
 * This function and PQconnectStart are intended to allow connections to be
 * made without blocking the execution of your program on remote I/O. However,
 * there are a number of caveats:
 *
 *	 o	If you call PQtrace, ensure that the stream object into which you trace
 *		will not block.
 *	 o	If you do not supply an IP address for the remote host (i.e. you
 *		supply a host name instead) then PQconnectStart will block on
 *		gethostbyname.  You will be fine if using Unix sockets (i.e. by
 *		supplying neither a host name nor a host address).
 *	 o	If your backend wants to use Kerberos authentication then you must
 *		supply both a host name and a host address, otherwise this function
 *		may block on gethostname.
 *
 * ----------------
 */</comment>
<function><type><name>PostgresPollingStatusType</name></type>
<name>PQconnectPoll</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>reset_connection_state_machine</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>need_new_connection</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>sebuf</name><index>[<expr><name>PG_STRERROR_R_BUFLEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>optval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>savedMessage</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>conn</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>PGRES_POLLING_FAILED</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Get the new data */</comment>
	<switch>switch <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/*
			 * We really shouldn't have been polled in these two cases, but we
			 * can handle it.
			 */</comment>
		<case>case <expr><name>CONNECTION_BAD</name></expr>:</case>
			<return>return <expr><name>PGRES_POLLING_FAILED</name></expr>;</return>
		<case>case <expr><name>CONNECTION_OK</name></expr>:</case>
			<return>return <expr><name>PGRES_POLLING_OK</name></expr>;</return>

			<comment type="block">/* These are reading states */</comment>
		<case>case <expr><name>CONNECTION_AWAITING_RESPONSE</name></expr>:</case>
		<case>case <expr><name>CONNECTION_AUTH_OK</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/* Load waiting data */</comment>
				<decl_stmt><decl><type><name>int</name></type>			<name>n</name> <init>= <expr><call><name>pqReadData</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<goto>goto <name>error_return</name>;</goto></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>PGRES_POLLING_READING</name></expr>;</return></block_content></block></if></if_stmt>

				<break>break;</break>
			</block_content>}</block>

			<comment type="block">/* These are writing states, so we just proceed. */</comment>
		<case>case <expr><name>CONNECTION_STARTED</name></expr>:</case>
		<case>case <expr><name>CONNECTION_MADE</name></expr>:</case>
			<break>break;</break>

			<comment type="block">/* We allow pqSetenvPoll to decide whether to proceed. */</comment>
		<case>case <expr><name>CONNECTION_SETENV</name></expr>:</case>
			<break>break;</break>

			<comment type="block">/* Special cases: proceed without waiting. */</comment>
		<case>case <expr><name>CONNECTION_SSL_STARTUP</name></expr>:</case>
		<case>case <expr><name>CONNECTION_NEEDED</name></expr>:</case>
		<case>case <expr><name>CONNECTION_CHECK_WRITABLE</name></expr>:</case>
		<case>case <expr><name>CONNECTION_CONSUME</name></expr>:</case>
		<case>case <expr><name>CONNECTION_GSS_STARTUP</name></expr>:</case>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
								 <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"invalid connection state, probably indicative of memory corruption\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>error_return</name>;</goto>
	</block_content>}</block></switch>


<label><name>keep_going</name>:</label>						<comment type="block">/* We will come back to here until there is
								 * nothing left to do. */</comment>

	<comment type="block">/* Time to advance to next address, or next host if no more addresses? */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>try_next_addr</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>addr_cur</name></name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>addr_cur</name><operator>-&gt;</operator><name>ai_next</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>addr_cur</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>addr_cur</name><operator>-&gt;</operator><name>ai_next</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>reset_connection_state_machine</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>try_next_host</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>try_next_addr</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Time to advance to next connhost[] entry? */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>try_next_host</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>pg_conn_host</name> <modifier>*</modifier></type><name>ch</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>addrinfo</name></name></type> <name>hint</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>thisport</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>portstr</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>whichhost</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name><name>conn</name><operator>-&gt;</operator><name>nconnhost</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Oops, no more hosts.  An appropriate error message is already
			 * set up, so just set the right status.
			 */</comment>
			<goto>goto <name>error_return</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>whichhost</name></name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/* Drop any address info for previous host */</comment>
		<expr_stmt><expr><call><name>release_conn_addrinfo</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Look up info for the new host.  On failure, log the problem in
		 * conn-&gt;errorMessage, then loop around to try the next host.  (Note
		 * we don't clear try_next_host until we've succeeded.)
		 */</comment>
		<expr_stmt><expr><name>ch</name> <operator>=</operator> <operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>whichhost</name></name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/* Initialize hint structure */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hint</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hint</name><operator>.</operator><name>ai_socktype</name></name> <operator>=</operator> <name>SOCK_STREAM</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>addrlist_family</name></name> <operator>=</operator> <name><name>hint</name><operator>.</operator><name>ai_family</name></name> <operator>=</operator> <name>AF_UNSPEC</name></expr>;</expr_stmt>

		<comment type="block">/* Figure out the port number we're going to use. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>ch</name><operator>-&gt;</operator><name>port</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>ch</name><operator>-&gt;</operator><name>port</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>thisport</name> <operator>=</operator> <name>DEF_PGPORT</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_int_param</name><argument_list>(<argument><expr><name><name>ch</name><operator>-&gt;</operator><name>port</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>thisport</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"port"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>error_return</name>;</goto></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>thisport</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1</literal> <operator>||</operator> <name>thisport</name></expr></argument> &gt;</argument_list></name> <literal type="number">65535</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
								  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"invalid port number: \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name><name>ch</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>keep_going</name>;</goto>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>portstr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>portstr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>thisport</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Use pg_getaddrinfo_all() to resolve the address */</comment>
		<switch>switch <condition>(<expr><name><name>ch</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>CHT_HOST_NAME</name></expr>:</case>
				<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pg_getaddrinfo_all</name><argument_list>(<argument><expr><name><name>ch</name><operator>-&gt;</operator><name>host</name></name></expr></argument>, <argument><expr><name>portstr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hint</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>addrlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>||</operator> <operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>addrlist</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
									  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"could not translate host name \"%s\" to address: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name><name>ch</name><operator>-&gt;</operator><name>host</name></name></expr></argument>, <argument><expr><call><name>gai_strerror</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>keep_going</name>;</goto>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><name>CHT_HOST_ADDRESS</name></expr>:</case>
				<expr_stmt><expr><name><name>hint</name><operator>.</operator><name>ai_flags</name></name> <operator>=</operator> <name>AI_NUMERICHOST</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pg_getaddrinfo_all</name><argument_list>(<argument><expr><name><name>ch</name><operator>-&gt;</operator><name>hostaddr</name></name></expr></argument>, <argument><expr><name>portstr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hint</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>addrlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>||</operator> <operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>addrlist</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
									  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"could not parse network address \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name><name>ch</name><operator>-&gt;</operator><name>hostaddr</name></name></expr></argument>, <argument><expr><call><name>gai_strerror</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>keep_going</name>;</goto>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><name>CHT_UNIX_SOCKET</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UNIX_SOCKETS</name></cpp:ifdef>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>addrlist_family</name></name> <operator>=</operator> <name><name>hint</name><operator>.</operator><name>ai_family</name></name> <operator>=</operator> <name>AF_UNIX</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>UNIXSOCK_PATH</name><argument_list>(<argument><expr><name>portstr</name></expr></argument>, <argument><expr><name>thisport</name></expr></argument>, <argument><expr><name><name>ch</name><operator>-&gt;</operator><name>host</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>portstr</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>UNIXSOCK_PATH_BUFLEN</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
									  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"Unix-domain socket path \"%s\" is too long (maximum %d bytes)\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>portstr</name></expr></argument>,
									  <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>UNIXSOCK_PATH_BUFLEN</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>keep_going</name>;</goto>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * NULL hostname tells pg_getaddrinfo_all to parse the service
				 * name as a Unix-domain socket path.
				 */</comment>
				<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pg_getaddrinfo_all</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>portstr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hint</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>addrlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>||</operator> <operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>addrlist</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
									  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"could not translate Unix-domain socket path \"%s\" to address: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>portstr</name></expr></argument>, <argument><expr><call><name>gai_strerror</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>keep_going</name>;</goto>
				</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<break>break;</break>
		</block_content>}</block></switch>

		<comment type="block">/* OK, scan this addrlist for a working server address */</comment>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>addr_cur</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>addrlist</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>reset_connection_state_machine</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>try_next_host</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Reset connection state machine? */</comment>
	<if_stmt><if>if <condition>(<expr><name>reset_connection_state_machine</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * (Re) initialize our connection control variables for a set of
		 * connection attempts to a single server address.  These variables
		 * must persist across individual connection attempts, but we must
		 * reset them when we start to consider a new server.
		 */</comment>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pversion</name></name> <operator>=</operator> <call><name>PG_PROTOCOL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>send_appname</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
		<comment type="block">/* initialize these values based on SSL mode */</comment>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>allow_ssl_try</name></name> <operator>=</operator> <operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>sslmode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'d'</literal><operator>)</operator></expr>;</expr_stmt>	<comment type="block">/* "disable" */</comment>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>wait_ssl_try</name></name> <operator>=</operator> <operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>sslmode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'a'</literal><operator>)</operator></expr>;</expr_stmt> <comment type="block">/* "allow" */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_GSS</name></cpp:ifdef>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>try_gss</name></name> <operator>=</operator> <operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>gssencmode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'d'</literal><operator>)</operator></expr>;</expr_stmt>	<comment type="block">/* "disable" */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<expr_stmt><expr><name>reset_connection_state_machine</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>need_new_connection</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Force a new connection (perhaps to the same server as before)? */</comment>
	<if_stmt><if>if <condition>(<expr><name>need_new_connection</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Drop any existing connection */</comment>
		<expr_stmt><expr><call><name>pqDropConnection</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Reset all state obtained from old server */</comment>
		<expr_stmt><expr><call><name>pqDropServerData</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Drop any PGresult we might have, too */</comment>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_IDLE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>xactStatus</name></name> <operator>=</operator> <name>PQTRANS_IDLE</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pqClearAsyncResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Reset conn-&gt;status to put the state machine in the right state */</comment>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_NEEDED</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>need_new_connection</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Now try to advance the state machine for this connection */</comment>
	<switch>switch <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CONNECTION_NEEDED</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * Try to initiate a connection to one of the addresses
				 * returned by pg_getaddrinfo_all().  conn-&gt;addr_cur is the
				 * next one to try.
				 *
				 * The extra level of braces here is historical.  It's not
				 * worth reindenting this whole switch case to remove 'em.
				 */</comment>
				<block>{<block_content>
					<decl_stmt><decl><type><name><name>struct</name> <name>addrinfo</name></name> <modifier>*</modifier></type><name>addr_cur</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>addr_cur</name></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>char</name></type>		<name><name>host_addr</name><index>[<expr><name>NI_MAXHOST</name></expr>]</index></name></decl>;</decl_stmt>

					<comment type="block">/*
					 * Advance to next possible host, if we've tried all of
					 * the addresses for the current host.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>addr_cur</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>try_next_host</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<goto>goto <name>keep_going</name>;</goto>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/* Remember current address for possible error msg */</comment>
					<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>raddr</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>addr_cur</name><operator>-&gt;</operator><name>ai_addr</name></name></expr></argument>,
						   <argument><expr><name><name>addr_cur</name><operator>-&gt;</operator><name>ai_addrlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>raddr</name><operator>.</operator><name>salen</name></name> <operator>=</operator> <name><name>addr_cur</name><operator>-&gt;</operator><name>ai_addrlen</name></name></expr>;</expr_stmt>

					<comment type="block">/* set connip */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>connip</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>connip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>connip</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><call><name>getHostaddr</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>host_addr</name></expr></argument>, <argument><expr><name>NI_MAXHOST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>host_addr</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>connip</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>host_addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/*
					 * purposely ignore strdup failure; not a big problem if
					 * it fails anyway.
					 */</comment>

					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name> <operator>=</operator> <call><name>socket</name><argument_list>(<argument><expr><name><name>addr_cur</name><operator>-&gt;</operator><name>ai_family</name></name></expr></argument>, <argument><expr><name>SOCK_STREAM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name> <operator>==</operator> <name>PGINVALID_SOCKET</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * Silently ignore socket() failure if we have more
						 * addresses to try; this reduces useless chatter in
						 * cases where the address list includes both IPv4 and
						 * IPv6 but kernel only accepts one family.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name><name>addr_cur</name><operator>-&gt;</operator><name>ai_next</name></name> <operator>!=</operator> <name>NULL</name> <operator>||</operator>
							<name><name>conn</name><operator>-&gt;</operator><name>whichhost</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>conn</name><operator>-&gt;</operator><name>nconnhost</name></name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>try_next_addr</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<goto>goto <name>keep_going</name>;</goto>
						</block_content>}</block></if></if_stmt>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
										  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"could not create socket: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><call><name>SOCK_STRERROR</name><argument_list>(<argument><expr><name>SOCK_ERRNO</name></expr></argument>, <argument><expr><name>sebuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sebuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<goto>goto <name>error_return</name>;</goto>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * Select socket options: no delay of outgoing data for
					 * TCP sockets, nonblock mode, close-on-exec.  Try the
					 * next address if any of this fails.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_AF_UNIX</name><argument_list>(<argument><expr><name><name>addr_cur</name><operator>-&gt;</operator><name>ai_family</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>connectNoDelay</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* error message already created */</comment>
							<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>try_next_addr</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<goto>goto <name>keep_going</name>;</goto>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_set_noblock</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
										  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"could not set socket to nonblocking mode: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><call><name>SOCK_STRERROR</name><argument_list>(<argument><expr><name>SOCK_ERRNO</name></expr></argument>, <argument><expr><name>sebuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sebuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>try_next_addr</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<goto>goto <name>keep_going</name>;</goto>
					</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>F_SETFD</name></cpp:ifdef>
					<if_stmt><if>if <condition>(<expr><call><name>fcntl</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name>F_SETFD</name></expr></argument>, <argument><expr><name>FD_CLOEXEC</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
										  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"could not set socket to close-on-exec mode: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><call><name>SOCK_STRERROR</name><argument_list>(<argument><expr><name>SOCK_ERRNO</name></expr></argument>, <argument><expr><name>sebuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sebuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>try_next_addr</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<goto>goto <name>keep_going</name>;</goto>
					</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* F_SETFD */</comment>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_AF_UNIX</name><argument_list>(<argument><expr><name><name>addr_cur</name><operator>-&gt;</operator><name>ai_family</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
						<decl_stmt><decl><type><name>int</name></type>			<name>on</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
						<decl_stmt><decl><type><name>int</name></type>			<name>usekeepalives</name> <init>= <expr><call><name>useKeepalives</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>int</name></type>			<name>err</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><name>usekeepalives</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
												 <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"keepalives parameter must be an integer\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>err</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
						</block_content>}</block></if>
						<if type="elseif">else if <condition>(<expr><name>usekeepalives</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* Do nothing */</comment>
						</block_content>}</block></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
						<if type="elseif">else if <condition>(<expr><call><name>setsockopt</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>,
											<argument><expr><name>SOL_SOCKET</name></expr></argument>, <argument><expr><name>SO_KEEPALIVE</name></expr></argument>,
											<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>on</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>on</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
											  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"setsockopt(%s) failed: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><literal type="string">"SO_KEEPALIVE"</literal></expr></argument>,
											  <argument><expr><call><name>SOCK_STRERROR</name><argument_list>(<argument><expr><name>SOCK_ERRNO</name></expr></argument>, <argument><expr><name>sebuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sebuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>err</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
						</block_content>}</block></if>
						<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>setKeepalivesIdle</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call>
								 <operator>||</operator> <operator>!</operator><call><name>setKeepalivesInterval</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call>
								 <operator>||</operator> <operator>!</operator><call><name>setKeepalivesCount</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>err</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* WIN32 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIO_KEEPALIVE_VALS</name></cpp:ifdef>
						<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>setKeepalivesWin32</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>err</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* SIO_KEEPALIVE_VALS */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>
						<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>setTCPUserTimeout</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>err</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>try_next_addr</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<goto>goto <name>keep_going</name>;</goto>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*----------
					 * We have three methods of blocking SIGPIPE during
					 * send() calls to this socket:
					 *
					 *	- setsockopt(sock, SO_NOSIGPIPE)
					 *	- send(sock, ..., MSG_NOSIGNAL)
					 *	- setting the signal mask to SIG_IGN during send()
					 *
					 * The third method requires three syscalls per send,
					 * so we prefer either of the first two, but they are
					 * less portable.  The state is tracked in the following
					 * members of PGconn:
					 *
					 * conn-&gt;sigpipe_so		- we have set up SO_NOSIGPIPE
					 * conn-&gt;sigpipe_flag	- we're specifying MSG_NOSIGNAL
					 *
					 * If we can use SO_NOSIGPIPE, then set sigpipe_so here
					 * and we're done.  Otherwise, set sigpipe_flag so that
					 * we will try MSG_NOSIGNAL on sends.  If we get an error
					 * with MSG_NOSIGNAL, we'll clear that flag and revert to
					 * signal masking.
					 *----------
					 */</comment>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sigpipe_so</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MSG_NOSIGNAL</name></cpp:ifdef>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sigpipe_flag</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sigpipe_flag</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* MSG_NOSIGNAL */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SO_NOSIGPIPE</name></cpp:ifdef>
					<expr_stmt><expr><name>optval</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>setsockopt</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name>SOL_SOCKET</name></expr></argument>, <argument><expr><name>SO_NOSIGPIPE</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>optval</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>optval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sigpipe_so</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sigpipe_flag</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* SO_NOSIGPIPE */</comment>

					<comment type="block">/*
					 * Start/make connection.  This should not block, since we
					 * are in nonblock mode.  If it does, well, too bad.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>connect</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name><name>addr_cur</name><operator>-&gt;</operator><name>ai_addr</name></name></expr></argument>,
								<argument><expr><name><name>addr_cur</name><operator>-&gt;</operator><name>ai_addrlen</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>SOCK_ERRNO</name> <operator>==</operator> <name>EINPROGRESS</name> <operator>||</operator>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
							<name>SOCK_ERRNO</name> <operator>==</operator> <name>EWOULDBLOCK</name> <operator>||</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
							<name>SOCK_ERRNO</name> <operator>==</operator> <name>EINTR</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/*
							 * This is fine - we're in non-blocking mode, and
							 * the connection is in progress.  Tell caller to
							 * wait for write-ready on socket.
							 */</comment>
							<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_STARTED</name></expr>;</expr_stmt>
							<return>return <expr><name>PGRES_POLLING_WRITING</name></expr>;</return>
						</block_content>}</block></if></if_stmt>
						<comment type="block">/* otherwise, trouble */</comment>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/*
						 * Hm, we're connected already --- seems the "nonblock
						 * connection" wasn't.  Advance the state machine and
						 * go do the next stuff.
						 */</comment>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_STARTED</name></expr>;</expr_stmt>
						<goto>goto <name>keep_going</name>;</goto>
					</block_content>}</block></else></if_stmt>

					<comment type="block">/*
					 * This connection failed.  Add the error report to
					 * conn-&gt;errorMessage, then try the next address if any.
					 */</comment>
					<expr_stmt><expr><call><name>connectFailureMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>SOCK_ERRNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>try_next_addr</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<goto>goto <name>keep_going</name>;</goto>
				</block_content>}</block>
			</block_content>}</block>

		<case>case <expr><name>CONNECTION_STARTED</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ACCEPT_TYPE_ARG3</name></type> <name>optlen</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>optval</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * Write ready, since we've made it here, so the connection
				 * has been made ... or has failed.
				 */</comment>

				<comment type="block">/*
				 * Now check (using getsockopt) that there is not an error
				 * state waiting for us on the socket.
				 */</comment>

				<if_stmt><if>if <condition>(<expr><call><name>getsockopt</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name>SOL_SOCKET</name></expr></argument>, <argument><expr><name>SO_ERROR</name></expr></argument>,
							   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>optval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>optlen</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
									  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"could not get socket error status: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>SOCK_STRERROR</name><argument_list>(<argument><expr><name>SOCK_ERRNO</name></expr></argument>, <argument><expr><name>sebuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sebuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>error_return</name>;</goto>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>optval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * When using a nonblocking connect, we will typically see
					 * connect failures at this point, so provide a friendly
					 * error message.
					 */</comment>
					<expr_stmt><expr><call><name>connectFailureMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>optval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * Try the next address if any, just as in the case where
					 * connect() returned failure immediately.
					 */</comment>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>try_next_addr</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<goto>goto <name>keep_going</name>;</goto>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Fill in the client address */</comment>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>laddr</name><operator>.</operator><name>salen</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>laddr</name><operator>.</operator><name>addr</name></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>getsockname</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>,
								<argument><expr><operator>(</operator>struct <name>sockaddr</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>laddr</name><operator>.</operator><name>addr</name></name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>laddr</name><operator>.</operator><name>salen</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
									  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"could not get client address from socket: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>SOCK_STRERROR</name><argument_list>(<argument><expr><name>SOCK_ERRNO</name></expr></argument>, <argument><expr><name>sebuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sebuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>error_return</name>;</goto>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Make sure we can write before advancing to next step.
				 */</comment>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_MADE</name></expr>;</expr_stmt>
				<return>return <expr><name>PGRES_POLLING_WRITING</name></expr>;</return>
			</block_content>}</block>

		<case>case <expr><name>CONNECTION_MADE</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>startpacket</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>packetlen</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * Implement requirepeer check, if requested and it's a
				 * Unix-domain socket.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>requirepeer</name></name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>requirepeer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator>
					<call><name>IS_AF_UNIX</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>raddr</name><operator>.</operator><name>addr</name><operator>.</operator><name>ss_family</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
					<decl_stmt><decl><type><name>char</name></type>		<name><name>pwdbuf</name><index>[<expr><name>BUFSIZ</name></expr>]</index></name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name><name>struct</name> <name>passwd</name></name></type> <name>pass_buf</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name><name>struct</name> <name>passwd</name></name> <modifier>*</modifier></type><name>pass</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>passerr</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<decl_stmt><decl><type><name>uid_t</name></type>		<name>uid</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>gid_t</name></type>		<name>gid</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>getpeereid</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>uid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * Provide special error message if getpeereid is a
						 * stub
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOSYS</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
												 <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"requirepeer parameter is not supported on this platform\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
											  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"could not get peer credentials: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><call><name>strerror_r</name><argument_list>(<argument><expr><name>errno</name></expr></argument>, <argument><expr><name>sebuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sebuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
						<goto>goto <name>error_return</name>;</goto>
					</block_content>}</block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
					<expr_stmt><expr><name>passerr</name> <operator>=</operator> <call><name>pqGetpwuid</name><argument_list>(<argument><expr><name>uid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pass_buf</name></expr></argument>, <argument><expr><name>pwdbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pwdbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>pass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>pass</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>passerr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
											  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"could not look up local user ID %d: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>uid</name></expr></argument>,
											  <argument><expr><call><name>strerror_r</name><argument_list>(<argument><expr><name>passerr</name></expr></argument>, <argument><expr><name>sebuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sebuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
											  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"local user with ID %d does not exist\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>uid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
						<goto>goto <name>error_return</name>;</goto>
					</block_content>}</block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>pass</name><operator>-&gt;</operator><name>pw_name</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>requirepeer</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
										  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"requirepeer specifies \"%s\", but actual peer user name is \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>requirepeer</name></name></expr></argument>, <argument><expr><name><name>pass</name><operator>-&gt;</operator><name>pw_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<goto>goto <name>error_return</name>;</goto>
					</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* WIN32 */</comment>
					<comment type="block">/* should have failed with ENOSYS above */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>IS_AF_UNIX</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>raddr</name><operator>.</operator><name>addr</name><operator>.</operator><name>ss_family</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Don't request SSL or GSSAPI over Unix sockets */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>allow_ssl_try</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_GSS</name></cpp:ifdef>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>try_gss</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_GSS</name></cpp:ifdef>

				<comment type="block">/*
				 * If GSSAPI encryption is enabled, then call
				 * pg_GSS_have_cred_cache() which will return true if we can
				 * acquire credentials (and give us a handle to use in
				 * conn-&gt;gcred), and then send a packet to the server asking
				 * for GSSAPI Encryption (and skip past SSL negotiation and
				 * regular startup below).
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>try_gss</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>gctx</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>try_gss</name></name> <operator>=</operator> <call><name>pg_GSS_have_cred_cache</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>gcred</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>try_gss</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>gctx</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ProtocolVersion</name></type> <name>pv</name> <init>= <expr><call><name>pg_hton32</name><argument_list>(<argument><expr><name>NEGOTIATE_GSS_CODE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>pqPacketSend</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pv</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pv</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <name>STATUS_OK</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
										  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"could not send GSSAPI negotiation packet: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><call><name>SOCK_STRERROR</name><argument_list>(<argument><expr><name>SOCK_ERRNO</name></expr></argument>, <argument><expr><name>sebuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sebuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<goto>goto <name>error_return</name>;</goto>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/* Ok, wait for response */</comment>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_GSS_STARTUP</name></expr>;</expr_stmt>
					<return>return <expr><name>PGRES_POLLING_READING</name></expr>;</return>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>gctx</name></name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>gssencmode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'r'</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
										 <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"GSSAPI encryption required but was impossible (possibly no credential cache, no server support, or using a local socket)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>error_return</name>;</goto>
				</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>

				<comment type="block">/*
				 * If SSL is enabled and we haven't already got encryption of
				 * some sort running, request SSL instead of sending the
				 * startup message.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>allow_ssl_try</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>wait_ssl_try</name></name> <operator>&amp;&amp;</operator>
					<operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>ssl_in_use</name></name>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_GSS</name></cpp:ifdef>
					<operator>&amp;&amp;</operator> <operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>gssenc</name></name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ProtocolVersion</name></type> <name>pv</name></decl>;</decl_stmt>

					<comment type="block">/*
					 * Send the SSL request packet.
					 *
					 * Theoretically, this could block, but it really
					 * shouldn't since we only got here if the socket is
					 * write-ready.
					 */</comment>
					<expr_stmt><expr><name>pv</name> <operator>=</operator> <call><name>pg_hton32</name><argument_list>(<argument><expr><name>NEGOTIATE_SSL_CODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>pqPacketSend</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pv</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pv</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <name>STATUS_OK</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
										  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"could not send SSL negotiation packet: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><call><name>SOCK_STRERROR</name><argument_list>(<argument><expr><name>SOCK_ERRNO</name></expr></argument>, <argument><expr><name>sebuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sebuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<goto>goto <name>error_return</name>;</goto>
					</block_content>}</block></if></if_stmt>
					<comment type="block">/* Ok, wait for response */</comment>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_SSL_STARTUP</name></expr>;</expr_stmt>
					<return>return <expr><name>PGRES_POLLING_READING</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_SSL */</comment>

				<comment type="block">/*
				 * Build the startup packet.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pversion</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>startpacket</name> <operator>=</operator> <call><name>pqBuildStartupPacket3</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>packetlen</name></expr></argument>,
														<argument><expr><name>EnvironmentOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>startpacket</name> <operator>=</operator> <call><name>pqBuildStartupPacket2</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>packetlen</name></expr></argument>,
														<argument><expr><name>EnvironmentOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>startpacket</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * will not appendbuffer here, since it's likely to also
					 * run out of memory
					 */</comment>
					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
									  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>error_return</name>;</goto>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Send the startup packet.
				 *
				 * Theoretically, this could block, but it really shouldn't
				 * since we only got here if the socket is write-ready.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>pqPacketSend</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>startpacket</name></expr></argument>, <argument><expr><name>packetlen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>STATUS_OK</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
									  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"could not send startup packet: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>SOCK_STRERROR</name><argument_list>(<argument><expr><name>SOCK_ERRNO</name></expr></argument>, <argument><expr><name>sebuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sebuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>startpacket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>error_return</name>;</goto>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>startpacket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_AWAITING_RESPONSE</name></expr>;</expr_stmt>
				<return>return <expr><name>PGRES_POLLING_READING</name></expr>;</return>
			</block_content>}</block>

			<comment type="block">/*
			 * Handle SSL negotiation: wait for postmaster messages and
			 * respond as necessary.
			 */</comment>
		<case>case <expr><name>CONNECTION_SSL_STARTUP</name></expr>:</case>
			<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
				<decl_stmt><decl><type><name>PostgresPollingStatusType</name></type> <name>pollres</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * On first time through, get the postmaster's response to our
				 * SSL negotiation packet.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>ssl_in_use</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * We use pqReadData here since it has the logic to
					 * distinguish no-data-yet from connection closure. Since
					 * conn-&gt;ssl isn't set, a plain recv() will occur.
					 */</comment>
					<decl_stmt><decl><type><name>char</name></type>		<name>SSLok</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>rdresult</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>rdresult</name> <operator>=</operator> <call><name>pqReadData</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>rdresult</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* errorMessage is already filled in */</comment>
						<goto>goto <name>error_return</name>;</goto>
					</block_content>}</block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name>rdresult</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* caller failed to wait for data */</comment>
						<return>return <expr><name>PGRES_POLLING_READING</name></expr>;</return>
					</block_content>}</block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>pqGetc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>SSLok</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* should not happen really */</comment>
						<return>return <expr><name>PGRES_POLLING_READING</name></expr>;</return>
					</block_content>}</block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name>SSLok</name> <operator>==</operator> <literal type="char">'S'</literal></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* mark byte consumed */</comment>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr>;</expr_stmt>
						<comment type="block">/* Set up global SSL state if required */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>pqsecure_initialize</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<goto>goto <name>error_return</name>;</goto></block_content></block></if></if_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name>SSLok</name> <operator>==</operator> <literal type="char">'N'</literal></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* mark byte consumed */</comment>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr>;</expr_stmt>
						<comment type="block">/* OK to do without SSL? */</comment>
						<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sslmode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'r'</literal> <operator>||</operator>	<comment type="block">/* "require" */</comment>
							<name><name>conn</name><operator>-&gt;</operator><name>sslmode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'v'</literal></expr>)</condition>	<comment type="block">/* "verify-ca" or
														 * "verify-full" */</comment>
						<block>{<block_content>
							<comment type="block">/* Require SSL, but server does not want it */</comment>
							<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
												 <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"server does not support SSL, but SSL was required\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<goto>goto <name>error_return</name>;</goto>
						</block_content>}</block></if></if_stmt>
						<comment type="block">/* Otherwise, proceed with normal startup */</comment>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>allow_ssl_try</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<comment type="block">/* We can proceed using this connection */</comment>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_MADE</name></expr>;</expr_stmt>
						<return>return <expr><name>PGRES_POLLING_WRITING</name></expr>;</return>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name>SSLok</name> <operator>==</operator> <literal type="char">'E'</literal></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * Server failure of some sort, such as failure to
						 * fork a backend process.  We need to process and
						 * report the error message, which might be formatted
						 * according to either protocol 2 or protocol 3.
						 * Rather than duplicate the code for that, we flip
						 * into AWAITING_RESPONSE state and let the code there
						 * deal with it.  Note we have *not* consumed the "E"
						 * byte here.
						 */</comment>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_AWAITING_RESPONSE</name></expr>;</expr_stmt>
						<goto>goto <name>keep_going</name>;</goto>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
										  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"received invalid response to SSL negotiation: %c\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>SSLok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<goto>goto <name>error_return</name>;</goto>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Begin or continue the SSL negotiation process.
				 */</comment>
				<expr_stmt><expr><name>pollres</name> <operator>=</operator> <call><name>pqsecure_open_client</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>pollres</name> <operator>==</operator> <name>PGRES_POLLING_OK</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * At this point we should have no data already buffered.
					 * If we do, it was received before we performed the SSL
					 * handshake, so it wasn't encrypted and indeed may have
					 * been injected by a man-in-the-middle.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>!=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
											 <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"received unencrypted data after SSL response\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<goto>goto <name>error_return</name>;</goto>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/* SSL handshake done, ready to send startup packet */</comment>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_MADE</name></expr>;</expr_stmt>
					<return>return <expr><name>PGRES_POLLING_WRITING</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>pollres</name> <operator>==</operator> <name>PGRES_POLLING_FAILED</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Failed ... if sslmode is "prefer" then do a non-SSL
					 * retry
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sslmode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'p'</literal> <comment type="block">/* "prefer" */</comment>
						<operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>allow_ssl_try</name></name>	<comment type="block">/* redundant? */</comment>
						<operator>&amp;&amp;</operator> <operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>wait_ssl_try</name></name></expr>)</condition> <comment type="block">/* redundant? */</comment>
					<block>{<block_content>
						<comment type="block">/* only retry once */</comment>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>allow_ssl_try</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>need_new_connection</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<goto>goto <name>keep_going</name>;</goto>
					</block_content>}</block></if></if_stmt>
					<comment type="block">/* Else it's a hard failure */</comment>
					<goto>goto <name>error_return</name>;</goto>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* Else, return POLLING_READING or POLLING_WRITING status */</comment>
				<return>return <expr><name>pollres</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* !USE_SSL */</comment>
				<comment type="block">/* can't get here */</comment>
				<goto>goto <name>error_return</name>;</goto>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_SSL */</comment>
			</block_content>}</block>

		<case>case <expr><name>CONNECTION_GSS_STARTUP</name></expr>:</case>
			<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_GSS</name></cpp:ifdef>
				<decl_stmt><decl><type><name>PostgresPollingStatusType</name></type> <name>pollres</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * If we haven't yet, get the postmaster's response to our
				 * negotiation packet
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>try_gss</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>gctx</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name></type>		<name>gss_ok</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>rdresult</name> <init>= <expr><call><name>pqReadData</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>rdresult</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<comment type="block">/* pqReadData fills in error message */</comment>
						<goto>goto <name>error_return</name>;</goto></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><name>rdresult</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<comment type="block">/* caller failed to wait for data */</comment>
						<return>return <expr><name>PGRES_POLLING_READING</name></expr>;</return></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>pqGetc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>gss_ok</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<comment type="block">/* shouldn't happen... */</comment>
						<return>return <expr><name>PGRES_POLLING_READING</name></expr>;</return></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name>gss_ok</name> <operator>==</operator> <literal type="char">'E'</literal></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * Server failure of some sort.  Assume it's a
						 * protocol version support failure, and let's see if
						 * we can't recover (if it's not, we'll get a better
						 * error message on retry).  Server gets fussy if we
						 * don't hang up the socket, though.
						 */</comment>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>try_gss</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>need_new_connection</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<goto>goto <name>keep_going</name>;</goto>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/* mark byte consumed */</comment>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>gss_ok</name> <operator>==</operator> <literal type="char">'N'</literal></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* Server doesn't want GSSAPI; fall back if we can */</comment>
						<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>gssencmode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'r'</literal></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
												 <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"server doesn't support GSSAPI encryption, but it was required\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<goto>goto <name>error_return</name>;</goto>
						</block_content>}</block></if></if_stmt>

						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>try_gss</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<comment type="block">/* We can proceed using this connection */</comment>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_MADE</name></expr>;</expr_stmt>
						<return>return <expr><name>PGRES_POLLING_WRITING</name></expr>;</return>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name>gss_ok</name> <operator>!=</operator> <literal type="char">'G'</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
										  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"received invalid response to GSSAPI negotiation: %c\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>gss_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<goto>goto <name>error_return</name>;</goto>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Begin or continue GSSAPI negotiation */</comment>
				<expr_stmt><expr><name>pollres</name> <operator>=</operator> <call><name>pqsecure_open_gss</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>pollres</name> <operator>==</operator> <name>PGRES_POLLING_OK</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * At this point we should have no data already buffered.
					 * If we do, it was received before we performed the GSS
					 * handshake, so it wasn't encrypted and indeed may have
					 * been injected by a man-in-the-middle.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>!=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
											 <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"received unencrypted data after GSSAPI encryption response\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<goto>goto <name>error_return</name>;</goto>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/* All set for startup packet */</comment>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_MADE</name></expr>;</expr_stmt>
					<return>return <expr><name>PGRES_POLLING_WRITING</name></expr>;</return>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>pollres</name> <operator>==</operator> <name>PGRES_POLLING_FAILED</name> <operator>&amp;&amp;</operator>
						 <name><name>conn</name><operator>-&gt;</operator><name>gssencmode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'p'</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * We failed, but we can retry on "prefer".  Have to drop
					 * the current connection to do so, though.
					 */</comment>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>try_gss</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>need_new_connection</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<goto>goto <name>keep_going</name>;</goto>
				</block_content>}</block></if></if_stmt>
				<return>return <expr><name>pollres</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* !ENABLE_GSS */</comment>
				<comment type="block">/* unreachable */</comment>
				<goto>goto <name>error_return</name>;</goto>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* ENABLE_GSS */</comment>
			</block_content>}</block>

			<comment type="block">/*
			 * Handle authentication exchange: wait for postmaster messages
			 * and respond as necessary.
			 */</comment>
		<case>case <expr><name>CONNECTION_AWAITING_RESPONSE</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name></type>		<name>beresp</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>msgLength</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>avail</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>AuthRequest</name></type> <name>areq</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>res</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * Scan the message from current point (note that if we find
				 * the message is incomplete, we will return without advancing
				 * inStart, and resume here next time).
				 */</comment>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name></expr>;</expr_stmt>

				<comment type="block">/* Read type byte */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>pqGetc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>beresp</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* We'll come back when there is more data */</comment>
					<return>return <expr><name>PGRES_POLLING_READING</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Validate message type: we expect only an authentication
				 * request or an error here.  Anything else probably means
				 * it's not Postgres on the other end at all.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>beresp</name> <operator>==</operator> <literal type="char">'R'</literal> <operator>||</operator> <name>beresp</name> <operator>==</operator> <literal type="char">'E'</literal><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
									  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"expected authentication request from server, but received %c\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>beresp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>error_return</name>;</goto>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pversion</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Read message length word */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>pqGetInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgLength</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* We'll come back when there is more data */</comment>
						<return>return <expr><name>PGRES_POLLING_READING</name></expr>;</return>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* Set phony message length to disable checks below */</comment>
					<expr_stmt><expr><name>msgLength</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<comment type="block">/*
				 * Try to validate message length before using it.
				 * Authentication requests can't be very large, although GSS
				 * auth requests may not be that small.  Errors can be a
				 * little larger, but not huge.  If we see a large apparent
				 * length in an error, it means we're really talking to a
				 * pre-3.0-protocol server; cope.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>beresp</name> <operator>==</operator> <literal type="char">'R'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>msgLength</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">8</literal> <operator>||</operator> <name>msgLength</name></expr></argument> &gt;</argument_list></name> <literal type="number">2000</literal><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
									  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"expected authentication request from server, but received %c\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>beresp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>error_return</name>;</goto>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>beresp</name> <operator>==</operator> <literal type="char">'E'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>msgLength</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">8</literal> <operator>||</operator> <name>msgLength</name></expr></argument> &gt;</argument_list></name> <literal type="number">30000</literal><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Handle error from a pre-3.0 server */</comment>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* reread data */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>pqGets_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* We'll come back when there is more data */</comment>
						<return>return <expr><name>PGRES_POLLING_READING</name></expr>;</return>
					</block_content>}</block></if></if_stmt>
					<comment type="block">/* OK, we read the message; mark data consumed */</comment>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr>;</expr_stmt>

					<comment type="block">/*
					 * The postmaster typically won't end its message with a
					 * newline, so add one to conform to libpq conventions.
					 */</comment>
					<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * If we tried to open the connection in 3.0 protocol,
					 * fall back to 2.0 protocol.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pversion</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pversion</name></name> <operator>=</operator> <call><name>PG_PROTOCOL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>need_new_connection</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<goto>goto <name>keep_going</name>;</goto>
					</block_content>}</block></if></if_stmt>

					<goto>goto <name>error_return</name>;</goto>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Can't process if message body isn't all here yet.
				 *
				 * (In protocol 2.0 case, we are assuming messages carry at
				 * least 4 bytes of data.)
				 */</comment>
				<expr_stmt><expr><name>msgLength</name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>avail</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name> <operator>-</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>avail</name> <operator>&lt;</operator> <name>msgLength</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Before returning, try to enlarge the input buffer if
					 * needed to hold the whole message; see notes in
					 * pqParseInput3.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>pqCheckInBufferSpace</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>+</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name>msgLength</name></expr></argument>,
											 <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<goto>goto <name>error_return</name>;</goto></block_content></block></if></if_stmt>
					<comment type="block">/* We'll come back when there is more data */</comment>
					<return>return <expr><name>PGRES_POLLING_READING</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Handle errors. */</comment>
				<if_stmt><if>if <condition>(<expr><name>beresp</name> <operator>==</operator> <literal type="char">'E'</literal></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pversion</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>pqGetErrorNotice3</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* We'll come back when there is more data */</comment>
							<return>return <expr><name>PGRES_POLLING_READING</name></expr>;</return>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>pqGets_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* We'll come back when there is more data */</comment>
							<return>return <expr><name>PGRES_POLLING_READING</name></expr>;</return>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></else></if_stmt>
					<comment type="block">/* OK, we read the message; mark data consumed */</comment>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr>;</expr_stmt>

					<comment type="block">/* Check to see if we should mention pgpassfile */</comment>
					<expr_stmt><expr><call><name>pgpassfileWarning</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_GSS</name></cpp:ifdef>

					<comment type="block">/*
					 * If gssencmode is "prefer" and we're using GSSAPI, retry
					 * without it.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>gssenc</name></name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>gssencmode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'p'</literal></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* only retry once */</comment>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>try_gss</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>need_new_connection</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<goto>goto <name>keep_going</name>;</goto>
					</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>

					<comment type="block">/*
					 * if sslmode is "allow" and we haven't tried an SSL
					 * connection already, then retry with an SSL connection
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sslmode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'a'</literal> <comment type="block">/* "allow" */</comment>
						<operator>&amp;&amp;</operator> <operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>ssl_in_use</name></name>
						<operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>allow_ssl_try</name></name>
						<operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>wait_ssl_try</name></name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* only retry once */</comment>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>wait_ssl_try</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>need_new_connection</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<goto>goto <name>keep_going</name>;</goto>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * if sslmode is "prefer" and we're in an SSL connection,
					 * then do a non-SSL retry
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sslmode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'p'</literal> <comment type="block">/* "prefer" */</comment>
						<operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>ssl_in_use</name></name>
						<operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>allow_ssl_try</name></name>	<comment type="block">/* redundant? */</comment>
						<operator>&amp;&amp;</operator> <operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>wait_ssl_try</name></name></expr>)</condition> <comment type="block">/* redundant? */</comment>
					<block>{<block_content>
						<comment type="block">/* only retry once */</comment>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>allow_ssl_try</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>need_new_connection</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<goto>goto <name>keep_going</name>;</goto>
					</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

					<goto>goto <name>error_return</name>;</goto>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* It is an authentication request. */</comment>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>auth_req_received</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<comment type="block">/* Get the type of request. */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>pqGetInt</name><argument_list>(<argument><expr><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>areq</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* We'll come back when there are more data */</comment>
					<return>return <expr><name>PGRES_POLLING_READING</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>msgLength</name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

				<comment type="block">/*
				 * Ensure the password salt is in the input buffer, if it's an
				 * MD5 request.  All the other authentication methods that
				 * contain extra data in the authentication request are only
				 * supported in protocol version 3, in which case we already
				 * read the whole message above.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>areq</name> <operator>==</operator> <name>AUTH_REQ_MD5</name> <operator>&amp;&amp;</operator> <call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pversion</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>msgLength</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

					<expr_stmt><expr><name>avail</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name> <operator>-</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>avail</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * Before returning, try to enlarge the input buffer
						 * if needed to hold the whole message; see notes in
						 * pqParseInput3.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>pqCheckInBufferSpace</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>+</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <literal type="number">4</literal></expr></argument>,
												 <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<goto>goto <name>error_return</name>;</goto></block_content></block></if></if_stmt>
						<comment type="block">/* We'll come back when there is more data */</comment>
						<return>return <expr><name>PGRES_POLLING_READING</name></expr>;</return>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Process the rest of the authentication request message, and
				 * respond to it if necessary.
				 *
				 * Note that conn-&gt;pghost must be non-NULL if we are going to
				 * avoid the Kerberos code doing a hostname look-up.
				 */</comment>
				<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pg_fe_sendauth</name><argument_list>(<argument><expr><name>areq</name></expr></argument>, <argument><expr><name>msgLength</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* OK, we have processed the message; mark data consumed */</comment>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
					<goto>goto <name>error_return</name>;</goto></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Just make sure that any data sent by pg_fe_sendauth is
				 * flushed out.  Although this theoretically could block, it
				 * really shouldn't since we don't send large auth responses.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>pqFlush</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<goto>goto <name>error_return</name>;</goto></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>areq</name> <operator>==</operator> <name>AUTH_REQ_OK</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* We are done with authentication exchange */</comment>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_AUTH_OK</name></expr>;</expr_stmt>

					<comment type="block">/*
					 * Set asyncStatus so that PQgetResult will think that
					 * what comes back next is the result of a query.  See
					 * below.
					 */</comment>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_BUSY</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Look to see if we have more data yet. */</comment>
				<goto>goto <name>keep_going</name>;</goto>
			</block_content>}</block>

		<case>case <expr><name>CONNECTION_AUTH_OK</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * Now we expect to hear from the backend. A ReadyForQuery
				 * message indicates that startup is successful, but we might
				 * also get an Error message indicating failure. (Notice
				 * messages indicating nonfatal warnings are also allowed by
				 * the protocol, as are ParameterStatus and BackendKeyData
				 * messages.) Easiest way to handle this is to let
				 * PQgetResult() read the messages. We just have to fake it
				 * out about the state of the connection, by setting
				 * asyncStatus = PGASYNC_BUSY (done above).
				 */</comment>

				<if_stmt><if>if <condition>(<expr><call><name>PQisBusy</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>PGRES_POLLING_READING</name></expr>;</return></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * NULL return indicating we have gone to IDLE state is
				 * expected
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>resultStatus</name></name> <operator>!=</operator> <name>PGRES_FATAL_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
											 <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"unexpected message from server during startup\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>send_appname</name></name> <operator>&amp;&amp;</operator>
							 <operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>appname</name></name> <operator>||</operator> <name><name>conn</name><operator>-&gt;</operator><name>fbappname</name></name><operator>)</operator></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * If we tried to send application_name, check to see
						 * if the error is about that --- pre-9.0 servers will
						 * reject it at this stage of the process.  If so,
						 * close the connection and retry without sending
						 * application_name.  We could possibly get a false
						 * SQLSTATE match here and retry uselessly, but there
						 * seems no great harm in that; we'll just get the
						 * same error again if it's unrelated.
						 */</comment>
						<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlstate</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>sqlstate</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_SQLSTATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>sqlstate</name> <operator>&amp;&amp;</operator>
							<call><name>strcmp</name><argument_list>(<argument><expr><name>sqlstate</name></expr></argument>, <argument><expr><name>ERRCODE_APPNAME_UNKNOWN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>send_appname</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
							<expr_stmt><expr><name>need_new_connection</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<goto>goto <name>keep_going</name>;</goto>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * if the resultStatus is FATAL, then conn-&gt;errorMessage
					 * already has a copy of the error; needn't copy it back.
					 * But add a newline if it's not there already, since
					 * postmaster error messages may not have one.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name><operator>.</operator><name>len</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator>
						<name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name><operator>.</operator><name>data</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name><operator>.</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>error_return</name>;</goto>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Fire up post-connection housekeeping if needed */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pversion</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_SETENV</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>setenv_state</name></name> <operator>=</operator> <name>SETENV_STATE_CLIENT_ENCODING_SEND</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>next_eo</name></name> <operator>=</operator> <name>EnvironmentOptions</name></expr>;</expr_stmt>
					<return>return <expr><name>PGRES_POLLING_WRITING</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Almost there now ... */</comment>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_CHECK_TARGET</name></expr>;</expr_stmt>
				<goto>goto <name>keep_going</name>;</goto>
			</block_content>}</block>

		<case>case <expr><name>CONNECTION_CHECK_TARGET</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * If a read-write connection is required, see if we have one.
				 *
				 * Servers before 7.4 lack the transaction_read_only GUC, but
				 * by the same token they don't have any read-only mode, so we
				 * may just skip the test in that case.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">70400</literal> <operator>&amp;&amp;</operator>
					<name><name>conn</name><operator>-&gt;</operator><name>target_session_attrs</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
					<call><name>strcmp</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>target_session_attrs</name></name></expr></argument>, <argument><expr><literal type="string">"read-write"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Save existing error messages across the PQsendQuery
					 * attempt.  This is necessary because PQsendQuery is
					 * going to reset conn-&gt;errorMessage, so we would lose
					 * error messages related to previous hosts we have tried
					 * and failed to connect to.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>saveErrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>savedMessage</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<goto>goto <name>error_return</name>;</goto></block_content></block></if></if_stmt>

					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_OK</name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQsendQuery</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
									 <argument><expr><literal type="string">"SHOW transaction_read_only"</literal></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>restoreErrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>savedMessage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<goto>goto <name>error_return</name>;</goto>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_CHECK_WRITABLE</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>restoreErrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>savedMessage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>PGRES_POLLING_READING</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* We can release the address list now. */</comment>
				<expr_stmt><expr><call><name>release_conn_addrinfo</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* We are open for business! */</comment>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_OK</name></expr>;</expr_stmt>
				<return>return <expr><name>PGRES_POLLING_OK</name></expr>;</return>
			</block_content>}</block>

		<case>case <expr><name>CONNECTION_SETENV</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * Do post-connection housekeeping (only needed in protocol
				 * 2.0).
				 *
				 * We pretend that the connection is OK for the duration of
				 * these queries.
				 */</comment>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_OK</name></expr>;</expr_stmt>

				<switch>switch <condition>(<expr><call><name>pqSetenvPoll</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>PGRES_POLLING_OK</name></expr>:</case>	<comment type="block">/* Success */</comment>
						<break>break;</break>

					<case>case <expr><name>PGRES_POLLING_READING</name></expr>:</case> <comment type="block">/* Still going */</comment>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_SETENV</name></expr>;</expr_stmt>
						<return>return <expr><name>PGRES_POLLING_READING</name></expr>;</return>

					<case>case <expr><name>PGRES_POLLING_WRITING</name></expr>:</case> <comment type="block">/* Still going */</comment>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_SETENV</name></expr>;</expr_stmt>
						<return>return <expr><name>PGRES_POLLING_WRITING</name></expr>;</return>

					<default>default:</default>
						<goto>goto <name>error_return</name>;</goto>
				</block_content>}</block></switch>

				<comment type="block">/* Almost there now ... */</comment>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_CHECK_TARGET</name></expr>;</expr_stmt>
				<goto>goto <name>keep_going</name>;</goto>
			</block_content>}</block>

		<case>case <expr><name>CONNECTION_CONSUME</name></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_OK</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQconsumeInput</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<goto>goto <name>error_return</name>;</goto></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>PQisBusy</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_CONSUME</name></expr>;</expr_stmt>
					<return>return <expr><name>PGRES_POLLING_READING</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Call PQgetResult() again to consume NULL result.
				 */</comment>
				<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_CONSUME</name></expr>;</expr_stmt>
					<goto>goto <name>keep_going</name>;</goto>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* We can release the address list now. */</comment>
				<expr_stmt><expr><call><name>release_conn_addrinfo</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* We are open for business! */</comment>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_OK</name></expr>;</expr_stmt>
				<return>return <expr><name>PGRES_POLLING_OK</name></expr>;</return>
			</block_content>}</block>
		<case>case <expr><name>CONNECTION_CHECK_WRITABLE</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>displayed_host</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>displayed_port</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>saveErrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>savedMessage</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<goto>goto <name>error_return</name>;</goto></block_content></block></if></if_stmt>

				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_OK</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQconsumeInput</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>restoreErrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>savedMessage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>error_return</name>;</goto>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>PQisBusy</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_CHECK_WRITABLE</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>restoreErrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>savedMessage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>PGRES_POLLING_READING</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_TUPLES_OK</name><operator>)</operator> <operator>&amp;&amp;</operator>
					<call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="string">"on"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* Not writable; fail this connection. */</comment>
						<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>restoreErrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>savedMessage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/* Append error report to conn-&gt;errorMessage. */</comment>
						<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>whichhost</name></name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>CHT_HOST_ADDRESS</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>displayed_host</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>whichhost</name></name></expr>]</index></name><operator>.</operator><name>hostaddr</name></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><name>displayed_host</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>whichhost</name></name></expr>]</index></name><operator>.</operator><name>host</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
						<expr_stmt><expr><name>displayed_port</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>whichhost</name></name></expr>]</index></name><operator>.</operator><name>port</name></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>displayed_port</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>displayed_port</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>displayed_port</name> <operator>=</operator> <name>DEF_PGPORT_STR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
										  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"could not make a writable "</literal>
														<literal type="string">"connection to server "</literal>
														<literal type="string">"\"%s:%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>displayed_host</name></expr></argument>, <argument><expr><name>displayed_port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/* Close connection politely. */</comment>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_OK</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>sendTerminateConn</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/*
						 * Try next host if any, but we don't want to consider
						 * additional addresses for this host.
						 */</comment>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>try_next_host</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<goto>goto <name>keep_going</name>;</goto>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/* Session is read-write, so we're good. */</comment>
					<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>savedMessage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * Finish reading any remaining messages before being
					 * considered as ready.
					 */</comment>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_CONSUME</name></expr>;</expr_stmt>
					<goto>goto <name>keep_going</name>;</goto>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Something went wrong with "SHOW transaction_read_only". We
				 * should try next addresses.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>restoreErrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>savedMessage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Append error report to conn-&gt;errorMessage. */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>whichhost</name></name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>CHT_HOST_ADDRESS</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>displayed_host</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>whichhost</name></name></expr>]</index></name><operator>.</operator><name>hostaddr</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>displayed_host</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>whichhost</name></name></expr>]</index></name><operator>.</operator><name>host</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name>displayed_port</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>whichhost</name></name></expr>]</index></name><operator>.</operator><name>port</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>displayed_port</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>displayed_port</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>displayed_port</name> <operator>=</operator> <name>DEF_PGPORT_STR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
								  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"test \"SHOW transaction_read_only\" failed "</literal>
												<literal type="string">"on server \"%s:%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>displayed_host</name></expr></argument>, <argument><expr><name>displayed_port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Close connection politely. */</comment>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_OK</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>sendTerminateConn</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Try next address */</comment>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>try_next_addr</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<goto>goto <name>keep_going</name>;</goto>
			</block_content>}</block>

		<default>default:</default>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"invalid connection state %d, "</literal>
											<literal type="string">"probably indicative of memory corruption\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>error_return</name>;</goto>
	</block_content>}</block></switch>

	<comment type="block">/* Unreachable */</comment>

<label><name>error_return</name>:</label>

	<comment type="block">/*
	 * We used to close the socket at this point, but that makes it awkward
	 * for those above us if they wish to remove this socket from their own
	 * records (an fd_set for example).  We'll just have this socket closed
	 * when PQfinish is called (which is compulsory even after an error, since
	 * the connection structure must be freed).
	 */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_BAD</name></expr>;</expr_stmt>
	<return>return <expr><name>PGRES_POLLING_FAILED</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * internal_ping
 *		Determine if a server is running and if we can connect to it.
 *
 * The argument is a connection that's been started, but not completed.
 */</comment>
<function><type><specifier>static</specifier> <name>PGPing</name></type>
<name>internal_ping</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Say "no attempt" if we never got to PQconnectPoll */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name> <operator>||</operator> <operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>options_valid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>PQPING_NO_ATTEMPT</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Attempt to complete the connection */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>CONNECTION_BAD</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>connectDBComplete</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Definitely OK if we succeeded */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>CONNECTION_BAD</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>PQPING_OK</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Here begins the interesting part of "ping": determine the cause of the
	 * failure in sufficient detail to decide what to return.  We do not want
	 * to report that the server is not up just because we didn't have a valid
	 * password, for example.  In fact, any sort of authentication request
	 * implies the server is up.  (We need this check since the libpq side of
	 * things might have pulled the plug on the connection before getting an
	 * error as such from the postmaster.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>auth_req_received</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>PQPING_OK</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we failed to get any ERROR response from the postmaster, report
	 * PQPING_NO_RESPONSE.  This result could be somewhat misleading for a
	 * pre-7.4 server, since it won't send back a SQLSTATE, but those are long
	 * out of support.  Another corner case where the server could return a
	 * failure without a SQLSTATE is fork failure, but PQPING_NO_RESPONSE
	 * isn't totally unreasonable for that anyway.  We expect that every other
	 * failure case in a modern server will produce a report with a SQLSTATE.
	 *
	 * NOTE: whenever we get around to making libpq generate SQLSTATEs for
	 * client-side errors, we should either not store those into
	 * last_sqlstate, or add an extra flag so we can tell client-side errors
	 * apart from server-side ones.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>last_sqlstate</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>PQPING_NO_RESPONSE</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Report PQPING_REJECT if server says it's not accepting connections. (We
	 * distinguish this case mainly for the convenience of pg_ctl.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>last_sqlstate</name></name></expr></argument>, <argument><expr><name>ERRCODE_CANNOT_CONNECT_NOW</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>PQPING_REJECT</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Any other SQLSTATE can be taken to indicate that the server is up.
	 * Presumably it didn't like our username, password, or database name; or
	 * perhaps it had some transient failure, but that should not be taken as
	 * meaning "it's down".
	 */</comment>
	<return>return <expr><name>PQPING_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * makeEmptyPGconn
 *	 - create a PGconn data structure with (as yet) no interesting data
 */</comment>
<function><type><specifier>static</specifier> <name>PGconn</name> <modifier>*</modifier></type>
<name>makeEmptyPGconn</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>

	<comment type="block">/*
	 * Make sure socket support is up and running in this process.
	 *
	 * Note: the Windows documentation says that we should eventually do a
	 * matching WSACleanup() call, but experience suggests that that is at
	 * least as likely to cause problems as fix them.  So we don't.
	 */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>wsastartup_done</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>wsastartup_done</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WSADATA</name></type>		<name>wsaData</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>WSAStartup</name><argument_list>(<argument><expr><call><name>MAKEWORD</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>wsaData</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>wsastartup_done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Forget any earlier error */</comment>
	<expr_stmt><expr><call><name>WSASetLastError</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>

	<expr_stmt><expr><name>conn</name> <operator>=</operator> <operator>(</operator><name>PGconn</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PGconn</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>conn</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>conn</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Zero all pointers and booleans */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PGconn</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* install default notice hooks */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>noticeHooks</name><operator>.</operator><name>noticeRec</name></name> <operator>=</operator> <name>defaultNoticeReceiver</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>noticeHooks</name><operator>.</operator><name>noticeProc</name></name> <operator>=</operator> <name>defaultNoticeProcessor</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_BAD</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_IDLE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>xactStatus</name></name> <operator>=</operator> <name>PQTRANS_IDLE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>options_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>nonblocking</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>setenv_state</name></name> <operator>=</operator> <name>SETENV_STATE_IDLE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>client_encoding</name></name> <operator>=</operator> <name>PG_SQL_ASCII</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>std_strings</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* unless server says differently */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>verbosity</name></name> <operator>=</operator> <name>PQERRORS_DEFAULT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>show_context</name></name> <operator>=</operator> <name>PQSHOW_CONTEXT_ERRORS</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name> <operator>=</operator> <name>PGINVALID_SOCKET</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We try to send at least 8K at a time, which is the usual size of pipe
	 * buffers on Unix systems.  That way, when we are sending a large amount
	 * of data, we avoid incurring extra kernel context swaps for partial
	 * bufferloads.  The output buffer is initially made 16K in size, and we
	 * try to dump it after accumulating 8K.
	 *
	 * With the same goal of minimizing context swaps, the input buffer will
	 * be enlarged anytime it has less than 8K free, so we initially allocate
	 * twice that.
	 */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inBufSize</name></name> <operator>=</operator> <literal type="number">16</literal> <operator>*</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inBuffer</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>inBufSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>outBufSize</name></name> <operator>=</operator> <literal type="number">16</literal> <operator>*</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>outBufSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>rowBufLen</name></name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>rowBuf</name></name> <operator>=</operator> <operator>(</operator><name>PGdataValue</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>rowBufLen</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGdataValue</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>workBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>inBuffer</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<name><name>conn</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<name><name>conn</name><operator>-&gt;</operator><name>rowBuf</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<call><name>PQExpBufferBroken</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>PQExpBufferBroken</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>workBuffer</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* out of memory already :-( */</comment>
		<expr_stmt><expr><call><name>freePGconn</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>conn</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>conn</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * freePGconn
 *	 - free an idle (closed) PGconn data structure
 *
 * NOTE: this should not overlap any functionality with closePGconn().
 * Clearing/resetting of transient state belongs there; what we do here is
 * release data that is to be held for the life of the PGconn structure.
 * If a value ought to be cleared/freed during PQreset(), do it there not here.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>freePGconn</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* let any event procs clean up their state data */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>conn</name><operator>-&gt;</operator><name>nEvents</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGEventConnDestroy</name></type> <name>evt</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>evt</name><operator>.</operator><name>conn</name></name> <operator>=</operator> <name>conn</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name><name>conn</name><operator>-&gt;</operator><name>events</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>proc</name><argument_list>(<argument><expr><name>PGEVT_CONNDESTROY</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>evt</name></expr></argument>,
									<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>events</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>passThrough</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>events</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* clean up pg_conn_host structures */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>connhost</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>conn</name><operator>-&gt;</operator><name>nconnhost</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>host</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hostaddr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hostaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>port</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>password</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>explicit_bzero</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>password</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>password</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>password</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>connhost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>client_encoding_initial</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>client_encoding_initial</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>events</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>events</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pghost</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pghost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pghostaddr</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pghostaddr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pgport</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgport</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pgtty</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgtty</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>connect_timeout</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>connect_timeout</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pgtcp_user_timeout</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgtcp_user_timeout</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pgoptions</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgoptions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>appname</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>appname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>fbappname</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>fbappname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>dbName</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>dbName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>replication</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>replication</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pguser</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pguser</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pgpass</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>explicit_bzero</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgpass</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgpass</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgpass</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pgpassfile</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgpassfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>channel_binding</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>channel_binding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>keepalives</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>keepalives</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>keepalives_idle</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>keepalives_idle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>keepalives_interval</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>keepalives_interval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>keepalives_count</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>keepalives_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sslmode</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sslmode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sslcert</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sslcert</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sslkey</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sslkey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sslpassword</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>explicit_bzero</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sslpassword</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sslpassword</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sslpassword</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sslrootcert</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sslrootcert</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sslcrl</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sslcrl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sslcompression</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sslcompression</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>requirepeer</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>requirepeer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>ssl_min_protocol_version</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl_min_protocol_version</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>ssl_max_protocol_version</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl_max_protocol_version</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>gssencmode</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>gssencmode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>krbsrvname</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>krbsrvname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>gsslib</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>gsslib</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>connip</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>connip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* Note that conn-&gt;Pfdebug is not ours to close or free */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>last_query</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>last_query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>write_err_msg</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>write_err_msg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>inBuffer</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>inBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>outBuffer</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>outBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>rowBuf</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>rowBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>target_session_attrs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>target_session_attrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>workBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * release_conn_addrinfo
 *	 - Free any addrinfo list in the PGconn.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>release_conn_addrinfo</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>addrlist</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_freeaddrinfo_all</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>addrlist_family</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>addrlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>addrlist</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>addr_cur</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* for safety */</comment>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * sendTerminateConn
 *	 - Send a terminate message to backend.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sendTerminateConn</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Note that the protocol doesn't allow us to send Terminate messages
	 * during the startup phase.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name> <operator>!=</operator> <name>PGINVALID_SOCKET</name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>CONNECTION_OK</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Try to send "close connection" message to backend. Ignore any
		 * error.
		 */</comment>
		<expr_stmt><expr><call><name>pqPutMsgStart</name><argument_list>(<argument><expr><literal type="char">'X'</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pqPutMsgEnd</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pqFlush</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * closePGconn
 *	 - properly close a connection to the backend
 *
 * This should reset or release all transient state, but NOT the connection
 * parameters.  On exit, the PGconn should be in condition to start a fresh
 * connection with the same parameters (see PQreset()).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>closePGconn</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If possible, send Terminate message to close the connection politely.
	 */</comment>
	<expr_stmt><expr><call><name>sendTerminateConn</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Must reset the blocking status so a possible reconnect will work.
	 *
	 * Don't call PQsetnonblocking() because it will fail if it's unable to
	 * flush the connection.
	 */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>nonblocking</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Close the connection, reset all transient state, flush I/O buffers.
	 */</comment>
	<expr_stmt><expr><call><name>pqDropConnection</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_BAD</name></expr>;</expr_stmt>	<comment type="block">/* Well, not really _bad_ - just absent */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_IDLE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>xactStatus</name></name> <operator>=</operator> <name>PQTRANS_IDLE</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqClearAsyncResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* deallocate result */</comment>
	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>release_conn_addrinfo</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reset all state obtained from server, too */</comment>
	<expr_stmt><expr><call><name>pqDropServerData</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PQfinish: properly close a connection to the backend. Also frees
 * the PGconn data structure so it shouldn't be re-used after this.
 */</comment>
<function><type><name>void</name></type>
<name>PQfinish</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>conn</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>closePGconn</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>freePGconn</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PQreset: resets the connection to the backend by closing the
 * existing connection and creating a new one.
 */</comment>
<function><type><name>void</name></type>
<name>PQreset</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>conn</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>closePGconn</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>connectDBStart</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>connectDBComplete</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Notify event procs of successful reset.  We treat an event proc
			 * failure as disabling the connection ... good idea?
			 */</comment>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>conn</name><operator>-&gt;</operator><name>nEvents</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PGEventConnReset</name></type> <name>evt</name></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>evt</name><operator>.</operator><name>conn</name></name> <operator>=</operator> <name>conn</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>events</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>proc</name><argument_list>(<argument><expr><name>PGEVT_CONNRESET</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>evt</name></expr></argument>,
										  <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>events</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>passThrough</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_BAD</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
									  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"PGEventProc \"%s\" failed during PGEVT_CONNRESET event\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>events</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * PQresetStart:
 * resets the connection to the backend
 * closes the existing connection and makes a new one
 * Returns 1 on success, 0 on failure.
 */</comment>
<function><type><name>int</name></type>
<name>PQresetStart</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>conn</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>closePGconn</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><call><name>connectDBStart</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PQresetPoll:
 * resets the connection to the backend
 * closes the existing connection and makes a new one
 */</comment>
<function><type><name>PostgresPollingStatusType</name></type>
<name>PQresetPoll</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>conn</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PostgresPollingStatusType</name></type> <name>status</name> <init>= <expr><call><name>PQconnectPoll</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>PGRES_POLLING_OK</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Notify event procs of successful reset.  We treat an event proc
			 * failure as disabling the connection ... good idea?
			 */</comment>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>conn</name><operator>-&gt;</operator><name>nEvents</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PGEventConnReset</name></type> <name>evt</name></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>evt</name><operator>.</operator><name>conn</name></name> <operator>=</operator> <name>conn</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>events</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>proc</name><argument_list>(<argument><expr><name>PGEVT_CONNRESET</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>evt</name></expr></argument>,
										  <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>events</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>passThrough</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_BAD</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
									  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"PGEventProc \"%s\" failed during PGEVT_CONNRESET event\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>events</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>PGRES_POLLING_FAILED</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>status</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>PGRES_POLLING_FAILED</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PQgetCancel: get a PGcancel structure corresponding to a connection.
 *
 * A copy is needed to be able to cancel a running query from a different
 * thread. If the same structure is used all structure members would have
 * to be individually locked (if the entire structure was locked, it would
 * be impossible to cancel a synchronous query because the structure would
 * have to stay locked for the duration of the query).
 */</comment>
<function><type><name>PGcancel</name> <modifier>*</modifier></type>
<name>PQgetCancel</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGcancel</name>   <modifier>*</modifier></type><name>cancel</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name> <operator>==</operator> <name>PGINVALID_SOCKET</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>cancel</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PGcancel</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>cancel</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cancel</name><operator>-&gt;</operator><name>raddr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>raddr</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SockAddr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cancel</name><operator>-&gt;</operator><name>be_pid</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>be_pid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cancel</name><operator>-&gt;</operator><name>be_key</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>be_key</name></name></expr>;</expr_stmt>

	<return>return <expr><name>cancel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* PQfreeCancel: free a cancel structure */</comment>
<function><type><name>void</name></type>
<name>PQfreeCancel</name><parameter_list>(<parameter><decl><type><name>PGcancel</name> <modifier>*</modifier></type><name>cancel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>cancel</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>cancel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * PQcancel and PQrequestCancel: attempt to request cancellation of the
 * current operation.
 *
 * The return value is true if the cancel request was successfully
 * dispatched, false if not (in which case an error message is available).
 * Note: successful dispatch is no guarantee that there will be any effect at
 * the backend.  The application must read the operation result as usual.
 *
 * CAUTION: we want this routine to be safely callable from a signal handler
 * (for example, an application might want to call it in a SIGINT handler).
 * This means we cannot use any C library routine that might be non-reentrant.
 * malloc/free are often non-reentrant, and anything that might call them is
 * just as dangerous.  We avoid sprintf here for that reason.  Building up
 * error messages with strcpy/strcat is tedious but should be quite safe.
 * We also save/restore errno in case the signal handler support doesn't.
 *
 * internal_cancel() is an internal helper function to make code-sharing
 * between the two versions of the cancel function possible.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>internal_cancel</name><parameter_list>(<parameter><decl><type><name>SockAddr</name> <modifier>*</modifier></type><name>raddr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>be_pid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>be_key</name></decl></parameter>,
				<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>errbuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>errbufsize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>SOCK_ERRNO</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgsocket</name></type>	<name>tmpsock</name> <init>= <expr><name>PGINVALID_SOCKET</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxlen</name></decl>;</decl_stmt>
	<struct>struct
	<block>{
		<decl_stmt><decl><type><name>uint32</name></type>		<name>packetlen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CancelRequestPacket</name></type> <name>cp</name></decl>;</decl_stmt>
	}</block>			<decl><name>crp</name></decl>;</struct>

	<comment type="block">/*
	 * We need to open a temporary connection to the postmaster. Do this with
	 * only kernel calls.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>tmpsock</name> <operator>=</operator> <call><name>socket</name><argument_list>(<argument><expr><name><name>raddr</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>ss_family</name></name></expr></argument>, <argument><expr><name>SOCK_STREAM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>PGINVALID_SOCKET</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><literal type="string">"PQcancel() -- socket() failed: "</literal></expr></argument>, <argument><expr><name>errbufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>cancel_errReturn</name>;</goto>
	</block_content>}</block></if></if_stmt>
<label><name>retry3</name>:</label>
	<if_stmt><if>if <condition>(<expr><call><name>connect</name><argument_list>(<argument><expr><name>tmpsock</name></expr></argument>, <argument><expr><operator>(</operator>struct <name>sockaddr</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>raddr</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>,
				<argument><expr><name><name>raddr</name><operator>-&gt;</operator><name>salen</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>SOCK_ERRNO</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/* Interrupted system call - we'll just try again */</comment>
			<goto>goto <name>retry3</name>;</goto></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><literal type="string">"PQcancel() -- connect() failed: "</literal></expr></argument>, <argument><expr><name>errbufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>cancel_errReturn</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We needn't set nonblocking I/O or NODELAY options here.
	 */</comment>

	<comment type="block">/* Create and send the cancel request packet. */</comment>

	<expr_stmt><expr><name><name>crp</name><operator>.</operator><name>packetlen</name></name> <operator>=</operator> <call><name>pg_hton32</name><argument_list>(<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>crp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>crp</name><operator>.</operator><name>cp</name><operator>.</operator><name>cancelRequestCode</name></name> <operator>=</operator> <operator>(</operator><name>MsgType</name><operator>)</operator> <call><name>pg_hton32</name><argument_list>(<argument><expr><name>CANCEL_REQUEST_CODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>crp</name><operator>.</operator><name>cp</name><operator>.</operator><name>backendPID</name></name> <operator>=</operator> <call><name>pg_hton32</name><argument_list>(<argument><expr><name>be_pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>crp</name><operator>.</operator><name>cp</name><operator>.</operator><name>cancelAuthCode</name></name> <operator>=</operator> <call><name>pg_hton32</name><argument_list>(<argument><expr><name>be_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>retry4</name>:</label>
	<if_stmt><if>if <condition>(<expr><call><name>send</name><argument_list>(<argument><expr><name>tmpsock</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>crp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>crp</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>(</operator><name>int</name><operator>)</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>crp</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>SOCK_ERRNO</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/* Interrupted system call - we'll just try again */</comment>
			<goto>goto <name>retry4</name>;</goto></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><literal type="string">"PQcancel() -- send() failed: "</literal></expr></argument>, <argument><expr><name>errbufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>cancel_errReturn</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Wait for the postmaster to close the connection, which indicates that
	 * it's processed the request.  Without this delay, we might issue another
	 * command only to find that our cancel zaps that command instead of the
	 * one we thought we were canceling.  Note we don't actually expect this
	 * read to obtain any data, we are just waiting for EOF to be signaled.
	 */</comment>
<label><name>retry5</name>:</label>
	<if_stmt><if>if <condition>(<expr><call><name>recv</name><argument_list>(<argument><expr><name>tmpsock</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>crp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>SOCK_ERRNO</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/* Interrupted system call - we'll just try again */</comment>
			<goto>goto <name>retry5</name>;</goto></block_content></block></if></if_stmt>
		<comment type="block">/* we ignore other error conditions */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* All done */</comment>
	<expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name>tmpsock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SOCK_ERRNO_SET</name><argument_list>(<argument><expr><name>save_errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>

<label><name>cancel_errReturn</name>:</label>

	<comment type="block">/*
	 * Make sure we don't overflow the error buffer. Leave space for the \n at
	 * the end, and for the terminating zero.
	 */</comment>
	<expr_stmt><expr><name>maxlen</name> <operator>=</operator> <name>errbufsize</name> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>maxlen</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We can't invoke strerror here, since it's not signal-safe.  Settle
		 * for printing the decimal value of errno.  Even that has to be done
		 * the hard way.
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>val</name> <init>= <expr><name>SOCK_ERRNO</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>bufp</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>bufp</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>bufp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<do>do
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>--</operator><name>bufp</name><operator>)</operator> <operator>=</operator> <operator>(</operator><name>val</name> <operator>%</operator> <literal type="number">10</literal><operator>)</operator> <operator>+</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>val</name> <operator>/=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
		</block_content>}</block> while <condition>(<expr><name>val</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>
		<expr_stmt><expr><name>bufp</name> <operator>-=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bufp</name></expr></argument>, <argument><expr><literal type="string">"error "</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strncat</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>bufp</name></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>tmpsock</name> <operator>!=</operator> <name>PGINVALID_SOCKET</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name>tmpsock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>SOCK_ERRNO_SET</name><argument_list>(<argument><expr><name>save_errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PQcancel: request query cancel
 *
 * Returns true if able to send the cancel request, false if not.
 *
 * On failure, an error message is stored in *errbuf, which must be of size
 * errbufsize (recommended size is 256 bytes).  *errbuf is not changed on
 * success return.
 */</comment>
<function><type><name>int</name></type>
<name>PQcancel</name><parameter_list>(<parameter><decl><type><name>PGcancel</name> <modifier>*</modifier></type><name>cancel</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>errbuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>errbufsize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cancel</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><literal type="string">"PQcancel() -- no cancel object supplied"</literal></expr></argument>, <argument><expr><name>errbufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>internal_cancel</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cancel</name><operator>-&gt;</operator><name>raddr</name></name></expr></argument>, <argument><expr><name><name>cancel</name><operator>-&gt;</operator><name>be_pid</name></name></expr></argument>, <argument><expr><name><name>cancel</name><operator>-&gt;</operator><name>be_key</name></name></expr></argument>,
						   <argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>errbufsize</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PQrequestCancel: old, not thread-safe function for requesting query cancel
 *
 * Returns true if able to send the cancel request, false if not.
 *
 * On failure, the error message is saved in conn-&gt;errorMessage; this means
 * that this can't be used when there might be other active operations on
 * the connection object.
 *
 * NOTE: error messages will be cut off at the current size of the
 * error message buffer, since we dare not try to expand conn-&gt;errorMessage!
 */</comment>
<function><type><name>int</name></type>
<name>PQrequestCancel</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>r</name></decl>;</decl_stmt>

	<comment type="block">/* Check we have an open connection */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name> <operator>==</operator> <name>PGINVALID_SOCKET</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name><operator>.</operator><name>data</name></name></expr></argument>,
				<argument><expr><literal type="string">"PQrequestCancel() -- connection is not open\n"</literal></expr></argument>,
				<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name><operator>.</operator><name>maxlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>internal_cancel</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>raddr</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>be_pid</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>be_key</name></name></expr></argument>,
						<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name><operator>.</operator><name>maxlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>r</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * pqPacketSend() -- convenience routine to send a message to server.
 *
 * pack_type: the single-byte message type code.  (Pass zero for startup
 * packets, which have no message type code.)
 *
 * buf, buf_len: contents of message.  The given length includes only what
 * is in buf; the message type and message length fields are added here.
 *
 * RETURNS: STATUS_ERROR if the write fails, STATUS_OK otherwise.
 * SIDE_EFFECTS: may block.
 *
 * Note: all messages sent with this routine have a length word, whether
 * it's protocol 2.0 or 3.0.
 */</comment>
<function><type><name>int</name></type>
<name>pqPacketSend</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>pack_type</name></decl></parameter>,
			 <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>buf_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Start the message. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pqPutMsgStart</name><argument_list>(<argument><expr><name>pack_type</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Send the message body. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pqPutnchar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_len</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Finish the message. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pqPutMsgEnd</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Flush to ensure backend gets it. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pqFlush</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LDAP</name></cpp:ifdef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LDAP_URL</name></cpp:macro>	<cpp:value>"ldap://"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LDAP_DEF_PORT</name></cpp:macro>	<cpp:value>389</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PGLDAP_TIMEOUT</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ld_is_sp_tab</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x) == ' ' || (x) == '\t')</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ld_is_nl_cr</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x) == '\r' || (x) == '\n')</cpp:value></cpp:define>


<comment type="block">/*
 *		ldapServiceLookup
 *
 * Search the LDAP URL passed as first argument, treat the result as a
 * string of connection options that are parsed and added to the array of
 * options passed as second argument.
 *
 * LDAP URLs must conform to RFC 1959 without escape sequences.
 *	ldap://host:port/dn?attributes?scope?filter?extensions
 *
 * Returns
 *	0 if the lookup was successful,
 *	1 if the connection to the LDAP server could be established but
 *	  the search was unsuccessful,
 *	2 if a connection could not be established, and
 *	3 if a fatal error occurred.
 *
 * An error message is returned in the third argument for return codes 1 and 3.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ldapServiceLookup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>purl</name></decl></parameter>, <parameter><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>options</name></decl></parameter>,
				  <parameter><decl><type><name>PQExpBuffer</name></type> <name>errorMessage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>port</name> <init>= <expr><name>LDAP_DEF_PORT</name></expr></init></decl>,
				<decl><type ref="prev"/><name>scope</name></decl>,
				<decl><type ref="prev"/><name>rc</name></decl>,
				<decl><type ref="prev"/><name>size</name></decl>,
				<decl><type ref="prev"/><name>state</name></decl>,
				<decl><type ref="prev"/><name>oldstate</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<decl_stmt><decl><type><name>int</name></type>			<name>msgid</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found_keyword</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>url</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>hostname</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>portstr</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>endptr</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>dn</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>scopestr</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>filter</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>result</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>p1</name> <init>= <expr><name>NULL</name></expr></init></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>optname</name> <init>= <expr><name>NULL</name></expr></init></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>optval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name><name>attrs</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LDAP</name>	   <modifier>*</modifier></type><name>ld</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LDAPMessage</name> <modifier>*</modifier></type><name>res</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>berval</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LDAP_TIMEVAL</name></type> <name>time</name> <init>= <expr><block>{<expr><name>PGLDAP_TIMEOUT</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>url</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>purl</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>, <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">3</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Parse URL components, check for correctness.  Basically, url has '\0'
	 * placed at component boundaries and variables are pointed at each
	 * component.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr><name>LDAP_URL</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>LDAP_URL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"invalid LDAP URL \"%s\": scheme must be ldap://\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>purl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">3</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* hostname */</comment>
	<expr_stmt><expr><name>hostname</name> <operator>=</operator> <name>url</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>LDAP_URL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>hostname</name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* no hostname? */</comment>
		<expr_stmt><expr><name>hostname</name> <operator>=</operator> <name>DefaultHost</name></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* the default */</comment>

	<comment type="block">/* dn, "distinguished name" */</comment>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>url</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>LDAP_URL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><operator>(</operator><name>p</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <operator>*</operator><operator>(</operator><name>p</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"invalid LDAP URL \"%s\": missing distinguished name\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>purl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">3</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>					<comment type="block">/* terminate hostname */</comment>
	<expr_stmt><expr><name>dn</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* attribute */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>dn</name></expr></argument>, <argument><expr><literal type="char">'?'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><operator>(</operator><name>p</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <operator>*</operator><operator>(</operator><name>p</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"invalid LDAP URL \"%s\": must have exactly one attribute\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>purl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">3</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* scope */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name><name>attrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="char">'?'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><operator>(</operator><name>p</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <operator>*</operator><operator>(</operator><name>p</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>, <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"invalid LDAP URL \"%s\": must have search scope (base/one/sub)\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>purl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">3</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>scopestr</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* filter */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>scopestr</name></expr></argument>, <argument><expr><literal type="char">'?'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><operator>(</operator><name>p</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <operator>*</operator><operator>(</operator><name>p</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"invalid LDAP URL \"%s\": no filter\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>purl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">3</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>filter</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>filter</name></expr></argument>, <argument><expr><literal type="char">'?'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* port number? */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p1</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>hostname</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>long</name></type>		<name>lport</name></decl>;</decl_stmt>

		<expr_stmt><expr><operator>*</operator><name>p1</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>portstr</name> <operator>=</operator> <name>p1</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>lport</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>portstr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>portstr</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <operator>*</operator><name>endptr</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>||</operator> <name>errno</name> <operator>||</operator> <name><name>lport</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>lport</name></expr></argument> &gt;</argument_list></name> <literal type="number">65535</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"invalid LDAP URL \"%s\": invalid port number\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>purl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><literal type="number">3</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>port</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>lport</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Allow only one attribute */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>attrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"invalid LDAP URL \"%s\": must have exactly one attribute\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>purl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">3</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* set scope */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>scopestr</name></expr></argument>, <argument><expr><literal type="string">"base"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>scope</name> <operator>=</operator> <name>LDAP_SCOPE_BASE</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>scopestr</name></expr></argument>, <argument><expr><literal type="string">"one"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>scope</name> <operator>=</operator> <name>LDAP_SCOPE_ONELEVEL</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>scopestr</name></expr></argument>, <argument><expr><literal type="string">"sub"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>scope</name> <operator>=</operator> <name>LDAP_SCOPE_SUBTREE</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>, <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"invalid LDAP URL \"%s\": must have search scope (base/one/sub)\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>purl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">3</literal></expr>;</return>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* initialize LDAP structure */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ld</name> <operator>=</operator> <call><name>ldap_init</name><argument_list>(<argument><expr><name>hostname</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"could not create LDAP structure\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">3</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Perform an explicit anonymous bind.
	 *
	 * LDAP does not require that an anonymous bind is performed explicitly,
	 * but we want to distinguish between the case where LDAP bind does not
	 * succeed within PGLDAP_TIMEOUT seconds (return 2 to continue parsing the
	 * service control file) and the case where querying the LDAP server fails
	 * (return 1 to end parsing).
	 *
	 * Unfortunately there is no way of setting a timeout that works for both
	 * Windows and OpenLDAP.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<comment type="block">/* the nonstandard ldap_connect function performs an anonymous bind */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ldap_connect</name><argument_list>(<argument><expr><name>ld</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>time</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>LDAP_SUCCESS</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* error or timeout in ldap_connect */</comment>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ldap_unbind</name><argument_list>(<argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">2</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* !WIN32 */</comment>
	<comment type="block">/* in OpenLDAP, use the LDAP_OPT_NETWORK_TIMEOUT option */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ldap_set_option</name><argument_list>(<argument><expr><name>ld</name></expr></argument>, <argument><expr><name>LDAP_OPT_NETWORK_TIMEOUT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>time</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>LDAP_SUCCESS</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ldap_unbind</name><argument_list>(<argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">3</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* anonymous bind */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>msgid</name> <operator>=</operator> <call><name>ldap_simple_bind</name><argument_list>(<argument><expr><name>ld</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* error or network timeout */</comment>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ldap_unbind</name><argument_list>(<argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">2</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* wait some time for the connection to succeed */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>ldap_result</name><argument_list>(<argument><expr><name>ld</name></expr></argument>, <argument><expr><name>msgid</name></expr></argument>, <argument><expr><name>LDAP_MSG_ALL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>time</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator>
		<name>res</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* error or timeout */</comment>
		<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ldap_msgfree</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ldap_unbind</name><argument_list>(<argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">2</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>ldap_msgfree</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* reset timeout */</comment>
	<expr_stmt><expr><name><name>time</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>ldap_set_option</name><argument_list>(<argument><expr><name>ld</name></expr></argument>, <argument><expr><name>LDAP_OPT_NETWORK_TIMEOUT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>time</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>LDAP_SUCCESS</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ldap_unbind</name><argument_list>(<argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">3</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>

	<comment type="block">/* search */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>ldap_search_st</name><argument_list>(<argument><expr><name>ld</name></expr></argument>, <argument><expr><name>dn</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>filter</name></expr></argument>, <argument><expr><name>attrs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>time</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call><operator>)</operator>
		<operator>!=</operator> <name>LDAP_SUCCESS</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ldap_msgfree</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"lookup on LDAP server failed: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>ldap_err2string</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ldap_unbind</name><argument_list>(<argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* complain if there was not exactly one result */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>ldap_count_entries</name><argument_list>(<argument><expr><name>ld</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
						  <argument><expr><ternary><condition><expr><name>rc</name></expr> ?</condition><then> <expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"more than one entry found on LDAP lookup\n"</literal></expr></argument>)</argument_list></call></expr>
						  </then><else>: <expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"no entry found on LDAP lookup\n"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ldap_msgfree</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ldap_unbind</name><argument_list>(<argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* get entry */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <call><name>ldap_first_entry</name><argument_list>(<argument><expr><name>ld</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* should never happen */</comment>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"no entry found on LDAP lookup\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ldap_msgfree</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ldap_unbind</name><argument_list>(<argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* get values */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>values</name> <operator>=</operator> <call><name>ldap_get_values_len</name><argument_list>(<argument><expr><name>ld</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>attrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"attribute has no values on LDAP lookup\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ldap_msgfree</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ldap_unbind</name><argument_list>(<argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ldap_msgfree</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"attribute has no values on LDAP lookup\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ldap_value_free_len</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ldap_unbind</name><argument_list>(<argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* concatenate values into a single string with newline terminators */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>					<comment type="block">/* for the trailing null */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>values</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>bv_len</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>result</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ldap_value_free_len</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ldap_unbind</name><argument_list>(<argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">3</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>bv_val</name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>bv_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> <operator>+=</operator> <name><name>values</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>bv_len</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><operator>(</operator><name>p</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ldap_value_free_len</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ldap_unbind</name><argument_list>(<argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* parse result string */</comment>
	<expr_stmt><expr><name>oldstate</name> <operator>=</operator> <name>state</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>result</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><operator>++</operator><name>p</name></expr></incr>)</control>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name>state</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="number">0</literal></expr>:</case>				<comment type="block">/* between entries */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ld_is_sp_tab</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ld_is_nl_cr</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>optname</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">1</literal></expr>:</case>				<comment type="block">/* in option name */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>ld_is_sp_tab</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><call><name>ld_is_nl_cr</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
									  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"missing \"=\" after \"%s\" in connection info string\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>optname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><literal type="number">3</literal></expr>;</return>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">2</literal></expr>:</case>				<comment type="block">/* after option name */</comment>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>ld_is_sp_tab</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
									  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"missing \"=\" after \"%s\" in connection info string\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>optname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><literal type="number">3</literal></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">3</literal></expr>:</case>				<comment type="block">/* before option value */</comment>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\''</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>optval</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>p1</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><call><name>ld_is_nl_cr</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>optval</name> <operator>=</operator> <name>optname</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>optname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* empty */</comment>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>ld_is_sp_tab</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>optval</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">4</literal></expr>:</case>				<comment type="block">/* in unquoted option value */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>ld_is_sp_tab</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ld_is_nl_cr</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">5</literal></expr>:</case>				<comment type="block">/* in quoted option value */</comment>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\''</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><operator>*</operator><name>p1</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <literal type="number">6</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><operator>(</operator><name>p1</name><operator>++</operator><operator>)</operator> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">6</literal></expr>:</case>				<comment type="block">/* in quoted option value after escape */</comment>
				<expr_stmt><expr><operator>*</operator><operator>(</operator><name>p1</name><operator>++</operator><operator>)</operator> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>state</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>oldstate</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>found_keyword</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>options</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>keyword</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>options</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>keyword</name></expr></argument>, <argument><expr><name>optname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>options</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>val</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>options</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>val</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>optval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>options</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>val</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
											  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<return>return <expr><literal type="number">3</literal></expr>;</return>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name>found_keyword</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found_keyword</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
								  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"invalid connection option \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>optname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><literal type="number">1</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>optname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>optval</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>oldstate</name> <operator>=</operator> <name>state</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <literal type="number">5</literal> <operator>||</operator> <name>state</name> <operator>==</operator> <literal type="number">6</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"unterminated quoted string in connection info string\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">3</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_LDAP */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXBUFSIZE</name></cpp:macro> <cpp:value>256</cpp:value></cpp:define>

<comment type="block">/*
 * parseServiceInfo: if a service name has been given, look it up and absorb
 * connection options from it into *options.
 *
 * Returns 0 on success, nonzero on failure.  On failure, if errorMessage
 * isn't null, also store an error message there.  (Note: the only reason
 * this function and related ones don't dump core on errorMessage == NULL
 * is the undocumented fact that printfPQExpBuffer does nothing when passed
 * a null PQExpBuffer pointer.)
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>parseServiceInfo</name><parameter_list>(<parameter><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>options</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>errorMessage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>service</name> <init>= <expr><call><name>conninfo_getval</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><literal type="string">"service"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>serviceFile</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>env</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>group_found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_buf</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We have to special-case the environment variable PGSERVICE here, since
	 * this is and should be called before inserting environment defaults for
	 * other connection options.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>service</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>service</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGSERVICE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* If no service name given, nothing to do */</comment>
	<if_stmt><if>if <condition>(<expr><name>service</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Try PGSERVICEFILE if specified, else try ~/.pg_service.conf (if that
	 * exists).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>env</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGSERVICEFILE"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>serviceFile</name></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>serviceFile</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>homedir</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pqGetHomeDirectory</name><argument_list>(<argument><expr><name>homedir</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>homedir</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>next_file</name>;</goto></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>serviceFile</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>homedir</name></expr></argument>, <argument><expr><literal type="string">".pg_service.conf"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>serviceFile</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>next_file</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>parseServiceFile</name><argument_list>(<argument><expr><name>serviceFile</name></expr></argument>, <argument><expr><name>service</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>errorMessage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>group_found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>group_found</name> <operator>||</operator> <name>status</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>status</name></expr>;</return></block_content></block></if></if_stmt>

<label><name>next_file</name>:</label>

	<comment type="block">/*
	 * This could be used by any application so we can't use the binary
	 * location to find our config files.
	 */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>serviceFile</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/pg_service.conf"</literal></expr></argument>,
			 <argument><expr><ternary><condition><expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGSYSCONFDIR"</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGSYSCONFDIR"</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>SYSCONFDIR</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>serviceFile</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>last_file</name>;</goto></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>parseServiceFile</name><argument_list>(<argument><expr><name>serviceFile</name></expr></argument>, <argument><expr><name>service</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>errorMessage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>group_found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>status</name></expr>;</return></block_content></block></if></if_stmt>

<label><name>last_file</name>:</label>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>group_found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"definition of service \"%s\" not found\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>service</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">3</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>parseServiceFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>serviceFile</name></decl></parameter>,
				 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>service</name></decl></parameter>,
				 <parameter><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>options</name></decl></parameter>,
				 <parameter><decl><type><name>PQExpBuffer</name></type> <name>errorMessage</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>group_found</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>linenr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>MAXBUFSIZE</name></expr>]</index></name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>serviceFile</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>, <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"service file \"%s\" not found\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>serviceFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>line</name> <operator>=</operator> <call><name>fgets</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>linenr</name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"line %d too long in service file \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>linenr</name></expr></argument>,
							  <argument><expr><name>serviceFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><literal type="number">2</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* ignore whitespace at end of line, especially the newline */</comment>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>line</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>line</name><index>[<expr><operator>--</operator><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></while>

		<comment type="block">/* ignore leading whitespace too */</comment>
		<while>while <condition>(<expr><operator>*</operator><name>line</name> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>line</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>line</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

		<comment type="block">/* ignore comments and empty lines */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>line</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <name><name>line</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'#'</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Check for right groupname */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>line</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'['</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>group_found</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* group info already read */</comment>
				<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><literal type="number">0</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>line</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>service</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>service</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<name><name>line</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>service</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">']'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>group_found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>group_found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>group_found</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Finally, we are in the right group and can parse the line
				 */</comment>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>key</name></decl>,
						   <decl><type ref="prev"><modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>found_keyword</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LDAP</name></cpp:ifdef>
				<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"ldap"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>rc</name> <init>= <expr><call><name>ldapServiceLookup</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>errorMessage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<comment type="block">/* if rc = 2, go on reading for fallback */</comment>
					<switch>switch <condition>(<expr><name>rc</name></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><literal type="number">0</literal></expr>:</case>
							<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<return>return <expr><literal type="number">0</literal></expr>;</return>
						<case>case <expr><literal type="number">1</literal></expr>:</case>
						<case>case <expr><literal type="number">3</literal></expr>:</case>
							<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<return>return <expr><literal type="number">3</literal></expr>;</return>
						<case>case <expr><literal type="number">2</literal></expr>:</case>
							<continue>continue;</continue>
					</block_content>}</block></switch>
				</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

				<expr_stmt><expr><name>key</name> <operator>=</operator> <name>line</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
									  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"syntax error in service file \"%s\", line %d\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>serviceFile</name></expr></argument>,
									  <argument><expr><name>linenr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><literal type="number">3</literal></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><operator>*</operator><name>val</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="string">"service"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
									  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"nested service specifications not supported in service file \"%s\", line %d\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>serviceFile</name></expr></argument>,
									  <argument><expr><name>linenr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><literal type="number">3</literal></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Set the parameter --- but don't override any previous
				 * explicit setting.
				 */</comment>
				<expr_stmt><expr><name>found_keyword</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>options</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>keyword</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>options</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>keyword</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name><name>options</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>val</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>options</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>val</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>options</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>val</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
											  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<return>return <expr><literal type="number">3</literal></expr>;</return>
						</block_content>}</block></if></if_stmt>
						<expr_stmt><expr><name>found_keyword</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found_keyword</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
									  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"syntax error in service file \"%s\", line %d\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>serviceFile</name></expr></argument>,
									  <argument><expr><name>linenr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><literal type="number">3</literal></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *		PQconninfoParse
 *
 * Parse a string like PQconnectdb() would do and return the
 * resulting connection options array.  NULL is returned on failure.
 * The result contains only options specified directly in the string,
 * not any possible default values.
 *
 * If errmsg isn't NULL, *errmsg is set to NULL on success, or a malloc'd
 * string on failure (use PQfreemem to free it).  In out-of-memory conditions
 * both *errmsg and the result could be NULL.
 *
 * NOTE: the returned array is dynamically allocated and should
 * be freed when no longer needed via PQconninfoFree().
 */</comment>
<function><type><name>PQconninfoOption</name> <modifier>*</modifier></type>
<name>PQconninfoParse</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>conninfo</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>errmsg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>errorBuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>connOptions</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>errmsg</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>errmsg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>			<comment type="block">/* default */</comment>
	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errorBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQExpBufferDataBroken</name><argument_list>(<argument><expr><name>errorBuf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* out of memory already :-( */</comment>
	<expr_stmt><expr><name>connOptions</name> <operator>=</operator> <call><name>parse_connection_string</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errorBuf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>connOptions</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>errmsg</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>errmsg</name> <operator>=</operator> <name><name>errorBuf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errorBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>connOptions</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Build a working copy of the constant PQconninfoOptions array.
 */</comment>
<function><type><specifier>static</specifier> <name>PQconninfoOption</name> <modifier>*</modifier></type>
<name>conninfo_init</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>errorMessage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>options</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>opt_dest</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>internalPQconninfoOption</name> <modifier>*</modifier></type><name>cur_opt</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Get enough memory for all options in PQconninfoOptions, even if some
	 * end up being filtered out.
	 */</comment>
	<expr_stmt><expr><name>options</name> <operator>=</operator> <operator>(</operator><name>PQconninfoOption</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PQconninfoOption</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PQconninfoOptions</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>PQconninfoOptions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>options</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>opt_dest</name> <operator>=</operator> <name>options</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>cur_opt</name> <operator>=</operator> <name>PQconninfoOptions</name></expr>;</init> <condition><expr><name><name>cur_opt</name><operator>-&gt;</operator><name>keyword</name></name></expr>;</condition> <incr><expr><name>cur_opt</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* Only copy the public part of the struct, not the full internal */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>opt_dest</name></expr></argument>, <argument><expr><name>cur_opt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PQconninfoOption</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>opt_dest</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>opt_dest</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PQconninfoOption</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>options</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Connection string parser
 *
 * Returns a malloc'd PQconninfoOption array, if parsing is successful.
 * Otherwise, NULL is returned and an error message is left in errorMessage.
 *
 * If use_defaults is true, default values are filled in (from a service file,
 * environment variables, etc).
 */</comment>
<function><type><specifier>static</specifier> <name>PQconninfoOption</name> <modifier>*</modifier></type>
<name>parse_connection_string</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>connstr</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>errorMessage</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>use_defaults</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Parse as URI if connection string matches URI prefix */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>uri_prefix_length</name><argument_list>(<argument><expr><name>connstr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>conninfo_uri_parse</name><argument_list>(<argument><expr><name>connstr</name></expr></argument>, <argument><expr><name>errorMessage</name></expr></argument>, <argument><expr><name>use_defaults</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Parse as default otherwise */</comment>
	<return>return <expr><call><name>conninfo_parse</name><argument_list>(<argument><expr><name>connstr</name></expr></argument>, <argument><expr><name>errorMessage</name></expr></argument>, <argument><expr><name>use_defaults</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Checks if connection string starts with either of the valid URI prefix
 * designators.
 *
 * Returns the URI prefix length, 0 if the string doesn't contain a URI prefix.
 *
 * XXX this is duplicated in psql/common.c.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>uri_prefix_length</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>connstr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>connstr</name></expr></argument>, <argument><expr><name>uri_designator</name></expr></argument>,
				<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uri_designator</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>uri_designator</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>connstr</name></expr></argument>, <argument><expr><name>short_uri_designator</name></expr></argument>,
				<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>short_uri_designator</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>short_uri_designator</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Recognized connection string either starts with a valid URI prefix or
 * contains a "=" in it.
 *
 * Must be consistent with parse_connection_string: anything for which this
 * returns true should at least look like it's parseable by that routine.
 *
 * XXX this is duplicated in psql/common.c
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>recognized_connection_string</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>connstr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>uri_prefix_length</name><argument_list>(<argument><expr><name>connstr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>connstr</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine for parse_connection_string
 *
 * Deal with a string containing key=value pairs.
 */</comment>
<function><type><specifier>static</specifier> <name>PQconninfoOption</name> <modifier>*</modifier></type>
<name>conninfo_parse</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>conninfo</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>errorMessage</name></decl></parameter>,
			   <parameter><decl><type><name>bool</name></type> <name>use_defaults</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cp2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>options</name></decl>;</decl_stmt>

	<comment type="block">/* Make a working copy of PQconninfoOptions */</comment>
	<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>conninfo_init</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>options</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Need a modifiable copy of the input string */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>buf</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PQconninfoFree</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>cp</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>*</operator><name>cp</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Skip blanks before the parameter name */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Get the parameter name */</comment>
		<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>*</operator><name>cp</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
				<while>while <condition>(<expr><operator>*</operator><name>cp</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></while>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>

		<comment type="block">/* Check that there is a following '=' */</comment>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">'='</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"missing \"=\" after \"%s\" in connection info string\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>pname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PQconninfoFree</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

		<comment type="block">/* Skip blanks after the '=' */</comment>
		<while>while <condition>(<expr><operator>*</operator><name>cp</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>

		<comment type="block">/* Get the parameter value */</comment>
		<expr_stmt><expr><name>pval</name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">'\''</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>cp2</name> <operator>=</operator> <name>pval</name></expr>;</expr_stmt>
			<while>while <condition>(<expr><operator>*</operator><name>cp</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>*</operator><name>cp2</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>cp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>cp2</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>cp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></while>
			<expr_stmt><expr><operator>*</operator><name>cp2</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>cp2</name> <operator>=</operator> <name>pval</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
			<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
									  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"unterminated quoted string in connection info string\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>PQconninfoFree</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>NULL</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>*</operator><name>cp2</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>cp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'\''</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><operator>*</operator><name>cp2</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><operator>*</operator><name>cp2</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>cp</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Now that we have the name and the value, store the record.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>conninfo_storeval</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><name>pname</name></expr></argument>, <argument><expr><name>pval</name></expr></argument>, <argument><expr><name>errorMessage</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PQconninfoFree</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Done with the modifiable input string */</comment>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Add in defaults if the caller wants that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>use_defaults</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>conninfo_add_defaults</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><name>errorMessage</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PQconninfoFree</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>options</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Conninfo array parser routine
 *
 * If successful, a malloc'd PQconninfoOption array is returned.
 * If not successful, NULL is returned and an error message is
 * left in errorMessage.
 * Defaults are supplied (from a service file, environment variables, etc)
 * for unspecified options, but only if use_defaults is true.
 *
 * If expand_dbname is non-zero, and the value passed for the first occurrence
 * of "dbname" keyword is a connection string (as indicated by
 * recognized_connection_string) then parse and process it, overriding any
 * previously processed conflicting keywords. Subsequent keywords will take
 * precedence, however. In-tree programs generally specify expand_dbname=true,
 * so command-line arguments naming a database can use a connection string.
 * Some code acquires arbitrary database names from known-literal sources like
 * PQdb(), PQconninfoParse() and pg_database.datname.  When connecting to such
 * a database, in-tree code first wraps the name in a connection string.
 */</comment>
<function><type><specifier>static</specifier> <name>PQconninfoOption</name> <modifier>*</modifier></type>
<name>conninfo_array_parse</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>keywords</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>values</name></decl></parameter>,
					 <parameter><decl><type><name>PQExpBuffer</name></type> <name>errorMessage</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_defaults</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>expand_dbname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>options</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>dbname_options</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>option</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If expand_dbname is non-zero, check keyword "dbname" to see if val is
	 * actually a recognized connection string.
	 */</comment>
	<while>while <condition>(<expr><name>expand_dbname</name> <operator>&amp;&amp;</operator> <name><name>keywords</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pname</name> <init>= <expr><name><name>keywords</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pvalue</name> <init>= <expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* first find "dbname" if any */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>pname</name></expr></argument>, <argument><expr><literal type="string">"dbname"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pvalue</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If value is a connection string, parse it, but do not use
			 * defaults here -- those get picked up later. We only want to
			 * override for those parameters actually passed.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>recognized_connection_string</name><argument_list>(<argument><expr><name>pvalue</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>dbname_options</name> <operator>=</operator> <call><name>parse_connection_string</name><argument_list>(<argument><expr><name>pvalue</name></expr></argument>, <argument><expr><name>errorMessage</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>dbname_options</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><operator>++</operator><name>i</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Make a working copy of PQconninfoOptions */</comment>
	<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>conninfo_init</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>options</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PQconninfoFree</name><argument_list>(<argument><expr><name>dbname_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Parse the keywords/values arrays */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name><name>keywords</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pname</name> <init>= <expr><name><name>keywords</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pvalue</name> <init>= <expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>pvalue</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>pvalue</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Search for the param record */</comment>
			<for>for <control>(<init><expr><name>option</name> <operator>=</operator> <name>options</name></expr>;</init> <condition><expr><name><name>option</name><operator>-&gt;</operator><name>keyword</name></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>option</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>option</name><operator>-&gt;</operator><name>keyword</name></name></expr></argument>, <argument><expr><name>pname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block></for>

			<comment type="block">/* Check for invalid connection option */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>option</name><operator>-&gt;</operator><name>keyword</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
								  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"invalid connection option \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>pname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PQconninfoFree</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PQconninfoFree</name><argument_list>(<argument><expr><name>dbname_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * If we are on the first dbname parameter, and we have a parsed
			 * connection string, copy those parameters across, overriding any
			 * existing previous settings.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>pname</name></expr></argument>, <argument><expr><literal type="string">"dbname"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>dbname_options</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>str_option</name></decl>;</decl_stmt>

				<for>for <control>(<init><expr><name>str_option</name> <operator>=</operator> <name>dbname_options</name></expr>;</init> <condition><expr><name><name>str_option</name><operator>-&gt;</operator><name>keyword</name></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>str_option</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>str_option</name><operator>-&gt;</operator><name>val</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>int</name></type>			<name>k</name></decl>;</decl_stmt>

						<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>options</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>keyword</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
						<block>{<block_content>
							<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>options</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>keyword</name></expr></argument>, <argument><expr><name><name>str_option</name><operator>-&gt;</operator><name>keyword</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
							<block>{<block_content>
								<if_stmt><if>if <condition>(<expr><name><name>options</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>val</name></expr>)</condition><block type="pseudo"><block_content>
									<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>options</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
								<expr_stmt><expr><name><name>options</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>val</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name><name>str_option</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>options</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>val</name></expr>)</condition>
								<block>{<block_content>
									<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
													  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									<expr_stmt><expr><call><name>PQconninfoFree</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									<expr_stmt><expr><call><name>PQconninfoFree</name><argument_list>(<argument><expr><name>dbname_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									<return>return <expr><name>NULL</name></expr>;</return>
								</block_content>}</block></if></if_stmt>
								<break>break;</break>
							</block_content>}</block></if></if_stmt>
						</block_content>}</block></for>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>

				<comment type="block">/*
				 * Forget the parsed connection string, so that any subsequent
				 * dbname parameters will not be expanded.
				 */</comment>
				<expr_stmt><expr><call><name>PQconninfoFree</name><argument_list>(<argument><expr><name>dbname_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>dbname_options</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Store the value, overriding previous settings
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>option</name><operator>-&gt;</operator><name>val</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>option</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>option</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>pvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>option</name><operator>-&gt;</operator><name>val</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
									  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>PQconninfoFree</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>PQconninfoFree</name><argument_list>(<argument><expr><name>dbname_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>NULL</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><operator>++</operator><name>i</name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>PQconninfoFree</name><argument_list>(<argument><expr><name>dbname_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Add in defaults if the caller wants that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>use_defaults</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>conninfo_add_defaults</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><name>errorMessage</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PQconninfoFree</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>options</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add the default values for any unspecified options to the connection
 * options array.
 *
 * Defaults are obtained from a service file, environment variables, etc.
 *
 * Returns true if successful, otherwise false; errorMessage, if supplied,
 * is filled in upon failure.  Note that failure to locate a default value
 * is not an error condition here --- we just leave the option's value as
 * NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>conninfo_add_defaults</name><parameter_list>(<parameter><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>options</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>errorMessage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>option</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If there's a service spec, use it to obtain any not-explicitly-given
	 * parameters.  Ignore error if no error message buffer is passed because
	 * there is no way to pass back the failure message.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>parseServiceInfo</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><name>errorMessage</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errorMessage</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Get the fallback resources for parameters not specified in the conninfo
	 * string nor the service.
	 */</comment>
	<for>for <control>(<init><expr><name>option</name> <operator>=</operator> <name>options</name></expr>;</init> <condition><expr><name><name>option</name><operator>-&gt;</operator><name>keyword</name></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>option</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>option</name><operator>-&gt;</operator><name>val</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* Value was in conninfo or service */</comment>

		<comment type="block">/*
		 * Try to get the environment variable fallback
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>option</name><operator>-&gt;</operator><name>envvar</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>tmp</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><name><name>option</name><operator>-&gt;</operator><name>envvar</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>option</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>option</name><operator>-&gt;</operator><name>val</name></name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>errorMessage</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
										  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Interpret the deprecated PGREQUIRESSL environment variable.  Per
		 * tradition, translate values starting with "1" to sslmode=require,
		 * and ignore other values.  Given both PGREQUIRESSL=1 and PGSSLMODE,
		 * PGSSLMODE takes precedence; the opposite was true before v9.3.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>option</name><operator>-&gt;</operator><name>keyword</name></name></expr></argument>, <argument><expr><literal type="string">"sslmode"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>requiresslenv</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGREQUIRESSL"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>requiresslenv</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>requiresslenv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'1'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>option</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><literal type="string">"require"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>option</name><operator>-&gt;</operator><name>val</name></name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>errorMessage</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
										  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * No environment variable specified or the variable isn't set - try
		 * compiled-in default
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>option</name><operator>-&gt;</operator><name>compiled</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>option</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name><name>option</name><operator>-&gt;</operator><name>compiled</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>option</name><operator>-&gt;</operator><name>val</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>errorMessage</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
									  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Special handling for "user" option.  Note that if pg_fe_getauthname
		 * fails, we just leave the value as NULL; there's no need for this to
		 * be an error condition if the caller provides a user name.  The only
		 * reason we do this now at all is so that callers of PQconndefaults
		 * will see a correct default (barring error, of course).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>option</name><operator>-&gt;</operator><name>keyword</name></name></expr></argument>, <argument><expr><literal type="string">"user"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>option</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <call><name>pg_fe_getauthname</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine for parse_connection_string
 *
 * Deal with a URI connection string.
 */</comment>
<function><type><specifier>static</specifier> <name>PQconninfoOption</name> <modifier>*</modifier></type>
<name>conninfo_uri_parse</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>uri</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>errorMessage</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>use_defaults</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>options</name></decl>;</decl_stmt>

	<comment type="block">/* Make a working copy of PQconninfoOptions */</comment>
	<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>conninfo_init</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>options</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>conninfo_uri_parse_options</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><name>uri</name></expr></argument>, <argument><expr><name>errorMessage</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PQconninfoFree</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Add in defaults if the caller wants that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>use_defaults</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>conninfo_add_defaults</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><name>errorMessage</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PQconninfoFree</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>options</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * conninfo_uri_parse_options
 *		Actual URI parser.
 *
 * If successful, returns true while the options array is filled with parsed
 * options from the URI.
 * If not successful, returns false and fills errorMessage accordingly.
 *
 * Parses the connection URI string in 'uri' according to the URI syntax (RFC
 * 3986):
 *
 * postgresql://[user[:password]@][netloc][:port][/dbname][?param1=value1&amp;...]
 *
 * where "netloc" is a hostname, an IPv4 address, or an IPv6 address surrounded
 * by literal square brackets.  As an extension, we also allow multiple
 * netloc[:port] specifications, separated by commas:
 *
 * postgresql://[user[:password]@][netloc][:port][,...][/dbname][?param1=value1&amp;...]
 *
 * Any of the URI parts might use percent-encoding (%xy).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>conninfo_uri_parse_options</name><parameter_list>(<parameter><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>options</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>uri</name></decl></parameter>,
						   <parameter><decl><type><name>PQExpBuffer</name></type> <name>errorMessage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>prefix_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>prevchar</name> <init>= <expr><literal type="char">'\0'</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>user</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>host</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>retval</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>hostbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>portbuf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hostbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>portbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQExpBufferDataBroken</name><argument_list>(<argument><expr><name>hostbuf</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PQExpBufferDataBroken</name><argument_list>(<argument><expr><name>portbuf</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>cleanup</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* need a modifiable copy of the input URI */</comment>
	<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>cleanup</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>start</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

	<comment type="block">/* Skip the URI prefix */</comment>
	<expr_stmt><expr><name>prefix_len</name> <operator>=</operator> <call><name>uri_prefix_length</name><argument_list>(<argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>prefix_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Should never happen */</comment>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"invalid URI propagated to internal parser routine: \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>cleanup</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>start</name> <operator>+=</operator> <name>prefix_len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>

	<comment type="block">/* Look ahead for possible user credentials designator */</comment>
	<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'@'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block></while>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'@'</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Found username/password designator, so URI should be of the form
		 * "scheme://user[:password]@[netloc]".
		 */</comment>
		<expr_stmt><expr><name>user</name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>p</name> <operator>=</operator> <name>user</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">':'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'@'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block></while>

		<comment type="block">/* Save last char and cut off at end of user name */</comment>
		<expr_stmt><expr><name>prevchar</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>user</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>conninfo_storeval</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><literal type="string">"user"</literal></expr></argument>, <argument><expr><name>user</name></expr></argument>,
							   <argument><expr><name>errorMessage</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>prevchar</name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>password</name> <init>= <expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

			<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'@'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block></while>
			<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>password</name> <operator>&amp;&amp;</operator>
				<operator>!</operator><call><name>conninfo_storeval</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><literal type="string">"password"</literal></expr></argument>, <argument><expr><name>password</name></expr></argument>,
								   <argument><expr><name>errorMessage</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Advance past end of parsed user name or password token */</comment>
		<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * No username/password designator found.  Reset to start of URI.
		 */</comment>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * There may be multiple netloc[:port] pairs, each separated from the next
	 * by a comma.  When we initially enter this loop, "p" has been
	 * incremented past optional URI credential information at this point and
	 * now points at the "netloc" part of the URI.  On subsequent loop
	 * iterations, "p" has been incremented past the comma separator and now
	 * points at the start of the next "netloc".
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * Look for IPv6 address.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'['</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>host</name> <operator>=</operator> <operator>++</operator><name>p</name></expr>;</expr_stmt>
			<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">']'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block></while>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>p</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
								  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"end of string reached when looking for matching \"]\" in IPv6 host address in URI: \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>cleanup</name>;</goto>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>host</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
								  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"IPv6 host address may not be empty in URI: \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>cleanup</name>;</goto>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Cut off the bracket and advance */</comment>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><name>p</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

			<comment type="block">/*
			 * The address may be followed by a port specifier or a slash or a
			 * query or a separator comma.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">':'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'/'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'?'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">','</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
								  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"unexpected character \"%c\" at position %d in URI (expected \":\" or \"/\"): \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>p</name> <operator>-</operator> <name>buf</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>cleanup</name>;</goto>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* not an IPv6 address: DNS-named or IPv4 netloc */</comment>
			<expr_stmt><expr><name>host</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Look for port specifier (colon) or end of host specifier
			 * (slash) or query (question mark) or host separator (comma).
			 */</comment>
			<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">':'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'/'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'?'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">','</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block></while>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Save the hostname terminator before we null it */</comment>
		<expr_stmt><expr><name>prevchar</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hostbuf</name></expr></argument>, <argument><expr><name>host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>prevchar</name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>port</name> <init>= <expr><operator>++</operator><name>p</name></expr></init></decl>;</decl_stmt> <comment type="block">/* advance past host terminator */</comment>

			<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'/'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'?'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">','</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block></while>

			<expr_stmt><expr><name>prevchar</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>portbuf</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>prevchar</name> <operator>!=</operator> <literal type="char">','</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt>					<comment type="block">/* advance past comma separator */</comment>
		<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hostbuf</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>portbuf</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Save final values for host and port. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PQExpBufferDataBroken</name><argument_list>(<argument><expr><name>hostbuf</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PQExpBufferDataBroken</name><argument_list>(<argument><expr><name>portbuf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>hostbuf</name><operator>.</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>conninfo_storeval</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><literal type="string">"host"</literal></expr></argument>, <argument><expr><name><name>hostbuf</name><operator>.</operator><name>data</name></name></expr></argument>,
						   <argument><expr><name>errorMessage</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>portbuf</name><operator>.</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>conninfo_storeval</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><literal type="string">"port"</literal></expr></argument>, <argument><expr><name><name>portbuf</name><operator>.</operator><name>data</name></name></expr></argument>,
						   <argument><expr><name>errorMessage</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>prevchar</name> <operator>&amp;&amp;</operator> <name>prevchar</name> <operator>!=</operator> <literal type="char">'?'</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbname</name> <init>= <expr><operator>++</operator><name>p</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* advance past host terminator */</comment>

		<comment type="block">/* Look for query parameters */</comment>
		<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'?'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block></while>

		<expr_stmt><expr><name>prevchar</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * Avoid setting dbname to an empty string, as it forces the default
		 * value (username) and ignores $PGDATABASE, as opposed to not setting
		 * it at all.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>dbname</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>conninfo_storeval</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><literal type="string">"dbname"</literal></expr></argument>, <argument><expr><name>dbname</name></expr></argument>,
							   <argument><expr><name>errorMessage</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>prevchar</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt>					<comment type="block">/* advance past terminator */</comment>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>conninfo_uri_parse_params</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>errorMessage</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* everything parsed okay */</comment>
	<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hostbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>portbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Connection URI parameters parser routine
 *
 * If successful, returns true while connOptions is filled with parsed
 * parameters.  Otherwise, returns false and fills errorMessage appropriately.
 *
 * Destructively modifies 'params' buffer.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>conninfo_uri_parse_params</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>params</name></decl></parameter>,
						  <parameter><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>connOptions</name></decl></parameter>,
						  <parameter><decl><type><name>PQExpBuffer</name></type> <name>errorMessage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<while>while <condition>(<expr><operator>*</operator><name>params</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>keyword</name> <init>= <expr><name>params</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name> <init>= <expr><name>params</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>malloced</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Scan the params string for '=' and '&amp;', marking the end of keyword
		 * and value respectively.
		 */</comment>
		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Was there '=' already? */</comment>
				<if_stmt><if>if <condition>(<expr><name>value</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
									  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"extra key/value separator \"=\" in URI query parameter: \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>keyword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* Cut off keyword, advance to value */</comment>
				<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>value</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'&amp;'</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * If not at the end, cut off value and advance; leave p
				 * pointing to start of the next parameter, if any.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<comment type="block">/* Was there '=' at all? */</comment>
				<if_stmt><if>if <condition>(<expr><name>value</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
									  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"missing key/value separator \"=\" in URI query parameter: \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>keyword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* Got keyword and value, go process them. */</comment>
				<break>break;</break>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block></else></if_stmt>			<comment type="block">/* Advance over all other bytes. */</comment>
		</block_content>}</block></for>

		<expr_stmt><expr><name>keyword</name> <operator>=</operator> <call><name>conninfo_uri_decode</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>, <argument><expr><name>errorMessage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>keyword</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* conninfo_uri_decode already set an error message */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>conninfo_uri_decode</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>errorMessage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>value</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* conninfo_uri_decode already set an error message */</comment>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>malloced</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Special keyword handling for improved JDBC compatibility.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>, <argument><expr><literal type="string">"ssl"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>malloced</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>keyword</name> <operator>=</operator> <literal type="string">"sslmode"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>value</name> <operator>=</operator> <literal type="string">"require"</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Store the value if the corresponding option exists; ignore
		 * otherwise.  At this point both keyword and value are not
		 * URI-encoded.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>conninfo_storeval</name><argument_list>(<argument><expr><name>connOptions</name></expr></argument>, <argument><expr><name>keyword</name></expr></argument>, <argument><expr><name>value</name></expr></argument>,
							   <argument><expr><name>errorMessage</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Insert generic message if conninfo_storeval didn't give one. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>errorMessage</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
								  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"invalid URI query parameter: \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>keyword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* And fail. */</comment>
			<if_stmt><if>if <condition>(<expr><name>malloced</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>malloced</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Proceed to next key=value pair, if any */</comment>
		<expr_stmt><expr><name>params</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Connection URI decoder routine
 *
 * If successful, returns the malloc'd decoded string.
 * If not successful, returns NULL and fills errorMessage accordingly.
 *
 * The string is decoded by replacing any percent-encoded tokens with
 * corresponding characters, while preserving any non-encoded characters.  A
 * percent-encoded token is a character triplet: a percent sign, followed by a
 * pair of hexadecimal digits (0-9A-F), where lower- and upper-case letters are
 * treated identically.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>conninfo_uri_decode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>errorMessage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>q</name> <init>= <expr><name>str</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>, <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>q</name> <operator>!=</operator> <literal type="char">'%'</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* copy and check for NUL terminator */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>*</operator><operator>(</operator><name>p</name><operator>++</operator><operator>)</operator> <operator>=</operator> <operator>*</operator><operator>(</operator><name>q</name><operator>++</operator><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>hi</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>lo</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>c</name></decl>;</decl_stmt>

			<expr_stmt><expr><operator>++</operator><name>q</name></expr>;</expr_stmt>				<comment type="block">/* skip the percent sign itself */</comment>

			<comment type="block">/*
			 * Possible EOL will be caught by the first call to
			 * get_hexdigit(), so we never dereference an invalid q pointer.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>get_hexdigit</name><argument_list>(<argument><expr><operator>*</operator><name>q</name><operator>++</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>hi</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>get_hexdigit</name><argument_list>(<argument><expr><operator>*</operator><name>q</name><operator>++</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>lo</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
								  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"invalid percent-encoded token: \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>hi</name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>|</operator> <name>lo</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
								  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"forbidden value %%00 in percent-encoded value: \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><name>p</name><operator>++</operator><operator>)</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert hexadecimal digit character to its integer value.
 *
 * If successful, returns true and value is filled with digit's base 16 value.
 * If not successful, returns false.
 *
 * Lower- and upper-case letters in the range A-F are treated identically.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>get_hexdigit</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>digit</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><literal type="char">'0'</literal> <operator>&lt;=</operator> <name>digit</name> <operator>&amp;&amp;</operator> <name>digit</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name>digit</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><literal type="char">'A'</literal> <operator>&lt;=</operator> <name>digit</name> <operator>&amp;&amp;</operator> <name>digit</name> <operator>&lt;=</operator> <literal type="char">'F'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name>digit</name> <operator>-</operator> <literal type="char">'A'</literal> <operator>+</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><literal type="char">'a'</literal> <operator>&lt;=</operator> <name>digit</name> <operator>&amp;&amp;</operator> <name>digit</name> <operator>&lt;=</operator> <literal type="char">'f'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name>digit</name> <operator>-</operator> <literal type="char">'a'</literal> <operator>+</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find an option value corresponding to the keyword in the connOptions array.
 *
 * If successful, returns a pointer to the corresponding option's value.
 * If not successful, returns NULL.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>conninfo_getval</name><parameter_list>(<parameter><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>connOptions</name></decl></parameter>,
				<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>keyword</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>option</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>option</name> <operator>=</operator> <call><name>conninfo_find</name><argument_list>(<argument><expr><name>connOptions</name></expr></argument>, <argument><expr><name>keyword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><ternary><condition><expr><name>option</name></expr> ?</condition><then> <expr><name><name>option</name><operator>-&gt;</operator><name>val</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Store a (new) value for an option corresponding to the keyword in
 * connOptions array.
 *
 * If uri_decode is true, the value is URI-decoded.  The keyword is always
 * assumed to be non URI-encoded.
 *
 * If successful, returns a pointer to the corresponding PQconninfoOption,
 * which value is replaced with a strdup'd copy of the passed value string.
 * The existing value for the option is free'd before replacing, if any.
 *
 * If not successful, returns NULL and fills errorMessage accordingly.
 * However, if the reason of failure is an invalid keyword being passed and
 * ignoreMissing is true, errorMessage will be left untouched.
 */</comment>
<function><type><specifier>static</specifier> <name>PQconninfoOption</name> <modifier>*</modifier></type>
<name>conninfo_storeval</name><parameter_list>(<parameter><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>connOptions</name></decl></parameter>,
				  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>keyword</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>,
				  <parameter><decl><type><name>PQExpBuffer</name></type> <name>errorMessage</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ignoreMissing</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>uri_decode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>option</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>value_copy</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * For backwards compatibility, requiressl=1 gets translated to
	 * sslmode=require, and requiressl=0 gets translated to sslmode=prefer
	 * (which is the default for sslmode).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>, <argument><expr><literal type="string">"requiressl"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>keyword</name> <operator>=</operator> <literal type="string">"sslmode"</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>value</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'1'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>value</name> <operator>=</operator> <literal type="string">"require"</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>value</name> <operator>=</operator> <literal type="string">"prefer"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>option</name> <operator>=</operator> <call><name>conninfo_find</name><argument_list>(<argument><expr><name>connOptions</name></expr></argument>, <argument><expr><name>keyword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>option</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ignoreMissing</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"invalid connection option \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>keyword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>uri_decode</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>value_copy</name> <operator>=</operator> <call><name>conninfo_uri_decode</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>errorMessage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>value_copy</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/* conninfo_uri_decode already set an error message */</comment>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>value_copy</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>value_copy</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>, <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>option</name><operator>-&gt;</operator><name>val</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>option</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>option</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <name>value_copy</name></expr>;</expr_stmt>

	<return>return <expr><name>option</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find a PQconninfoOption option corresponding to the keyword in the
 * connOptions array.
 *
 * If successful, returns a pointer to the corresponding PQconninfoOption
 * structure.
 * If not successful, returns NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>PQconninfoOption</name> <modifier>*</modifier></type>
<name>conninfo_find</name><parameter_list>(<parameter><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>connOptions</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>keyword</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>option</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>option</name> <operator>=</operator> <name>connOptions</name></expr>;</init> <condition><expr><name><name>option</name><operator>-&gt;</operator><name>keyword</name></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>option</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>option</name><operator>-&gt;</operator><name>keyword</name></name></expr></argument>, <argument><expr><name>keyword</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>option</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Return the connection options used for the connection
 */</comment>
<function><type><name>PQconninfoOption</name> <modifier>*</modifier></type>
<name>PQconninfo</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>errorBuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>connOptions</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>conn</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* We don't actually report any errors here, but callees want a buffer */</comment>
	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errorBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQExpBufferDataBroken</name><argument_list>(<argument><expr><name>errorBuf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* out of memory already :-( */</comment>

	<expr_stmt><expr><name>connOptions</name> <operator>=</operator> <call><name>conninfo_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errorBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>connOptions</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>internalPQconninfoOption</name> <modifier>*</modifier></type><name>option</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>option</name> <operator>=</operator> <name>PQconninfoOptions</name></expr>;</init> <condition><expr><name><name>option</name><operator>-&gt;</operator><name>keyword</name></name></expr>;</condition> <incr><expr><name>option</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>connmember</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>option</name><operator>-&gt;</operator><name>connofs</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>connmember</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>conn</name> <operator>+</operator> <name><name>option</name><operator>-&gt;</operator><name>connofs</name></name><operator>)</operator></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>connmember</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>conninfo_storeval</name><argument_list>(<argument><expr><name>connOptions</name></expr></argument>, <argument><expr><name><name>option</name><operator>-&gt;</operator><name>keyword</name></name></expr></argument>, <argument><expr><operator>*</operator><name>connmember</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>errorBuf</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errorBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>connOptions</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>PQconninfoFree</name><parameter_list>(<parameter><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>connOptions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>option</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>connOptions</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>option</name> <operator>=</operator> <name>connOptions</name></expr>;</init> <condition><expr><name><name>option</name><operator>-&gt;</operator><name>keyword</name></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>option</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>option</name><operator>-&gt;</operator><name>val</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>option</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>connOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* =========== accessor functions for PGconn ========= */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>PQdb</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name><name>conn</name><operator>-&gt;</operator><name>dbName</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>PQuser</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name><name>conn</name><operator>-&gt;</operator><name>pguser</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>PQpass</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>password</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>connhost</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>password</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>whichhost</name></name></expr>]</index></name><operator>.</operator><name>password</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>password</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>password</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>pgpass</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* Historically we've returned "" not NULL for no password specified */</comment>
	<if_stmt><if>if <condition>(<expr><name>password</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>password</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>password</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>PQhost</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>connhost</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Return the verbatim host value provided by user, or hostaddr in its
		 * lack.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>whichhost</name></name></expr>]</index></name><operator>.</operator><name>host</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>whichhost</name></name></expr>]</index></name><operator>.</operator><name><name>host</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>whichhost</name></name></expr>]</index></name><operator>.</operator><name>host</name></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>whichhost</name></name></expr>]</index></name><operator>.</operator><name>hostaddr</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				 <name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>whichhost</name></name></expr>]</index></name><operator>.</operator><name><name>hostaddr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>whichhost</name></name></expr>]</index></name><operator>.</operator><name>hostaddr</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="string">""</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>PQhostaddr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Return the parsed IP address */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>connhost</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>connip</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>conn</name><operator>-&gt;</operator><name>connip</name></name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><literal type="string">""</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>PQport</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>connhost</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>whichhost</name></name></expr>]</index></name><operator>.</operator><name>port</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><literal type="string">""</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>PQtty</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name><name>conn</name><operator>-&gt;</operator><name>pgtty</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>PQoptions</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name><name>conn</name><operator>-&gt;</operator><name>pgoptions</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ConnStatusType</name></type>
<name>PQstatus</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>CONNECTION_BAD</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>PGTransactionStatusType</name></type>
<name>PQtransactionStatus</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name> <operator>||</operator> <name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>CONNECTION_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>PQTRANS_UNKNOWN</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>!=</operator> <name>PGASYNC_IDLE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>PQTRANS_ACTIVE</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name><name>conn</name><operator>-&gt;</operator><name>xactStatus</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>PQparameterStatus</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>paramName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>pgParameterStatus</name> <modifier>*</modifier></type><name>pstatus</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name> <operator>||</operator> <operator>!</operator><name>paramName</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<for>for <control>(<init><expr><name>pstatus</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>pstatus</name></name></expr>;</init> <condition><expr><name>pstatus</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>pstatus</name> <operator>=</operator> <name><name>pstatus</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>pstatus</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>paramName</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>pstatus</name><operator>-&gt;</operator><name>value</name></name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>PQprotocolVersion</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>CONNECTION_BAD</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pversion</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>PQserverVersion</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>CONNECTION_BAD</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name><name>conn</name><operator>-&gt;</operator><name>sversion</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>PQagVersion</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>CONNECTION_BAD</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name><name>conn</name><operator>-&gt;</operator><name>agversion</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>PQerrorMessage</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"connection pointer is NULL\n"</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * In Windows, socket values are unsigned, and an invalid socket value
 * (INVALID_SOCKET) is ~0, which equals -1 in comparisons (with no compiler
 * warning). Ideally we would return an unsigned value for PQsocket() on
 * Windows, but that would cause the function's return value to differ from
 * Unix, so we just return -1 for invalid sockets.
 * http://msdn.microsoft.com/en-us/library/windows/desktop/cc507522%28v=vs.85%29.aspx
 * http://stackoverflow.com/questions/10817252/why-is-invalid-socket-defined-as-0-in-winsock2-h-c
 */</comment>
<function><type><name>int</name></type>
<name>PQsocket</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><ternary><condition><expr><operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name> <operator>!=</operator> <name>PGINVALID_SOCKET</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>PQbackendPID</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name> <operator>||</operator> <name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>CONNECTION_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name><name>conn</name><operator>-&gt;</operator><name>be_pid</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>PQconnectionNeedsPassword</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>password</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>password</name> <operator>=</operator> <call><name>PQpass</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>password_needed</name></name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>password</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>password</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>PQconnectionUsedPassword</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>password_needed</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>PQclientEncoding</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name> <operator>||</operator> <name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>CONNECTION_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name><name>conn</name><operator>-&gt;</operator><name>client_encoding</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>PQsetClientEncoding</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>encoding</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>qbuf</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>query</name><index>[]</index></name> <init>= <expr><literal type="string">"set client_encoding to '%s'"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>status</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name> <operator>||</operator> <name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>CONNECTION_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>encoding</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Resolve special "auto" value from the locale */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><literal type="string">"auto"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>encoding</name> <operator>=</operator> <call><name>pg_encoding_to_char</name><argument_list>(<argument><expr><call><name>pg_get_encoding_from_locale</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* check query buffer overflow */</comment>
	<if_stmt><if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>qbuf</name></expr></argument>)</argument_list></sizeof> <operator>&lt;</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* ok, now send a query */</comment>
	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>qbuf</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>qbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>resultStatus</name></name> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>status</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * In protocol 2 we have to assume the setting will stick, and adjust
		 * our state immediately.  In protocol 3 and up we can rely on the
		 * backend to report the parameter value, and we'll change state at
		 * that time.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pversion</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pqSaveParameterStatus</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"client_encoding"</literal></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>status</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>				<comment type="block">/* everything is ok */</comment>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>PGVerbosity</name></type>
<name>PQsetErrorVerbosity</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>PGVerbosity</name></type> <name>verbosity</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGVerbosity</name></type> <name>old</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>PQERRORS_DEFAULT</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>old</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>verbosity</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>verbosity</name></name> <operator>=</operator> <name>verbosity</name></expr>;</expr_stmt>
	<return>return <expr><name>old</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>PGContextVisibility</name></type>
<name>PQsetErrorContextVisibility</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>PGContextVisibility</name></type> <name>show_context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGContextVisibility</name></type> <name>old</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>PQSHOW_CONTEXT_ERRORS</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>old</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>show_context</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>show_context</name></name> <operator>=</operator> <name>show_context</name></expr>;</expr_stmt>
	<return>return <expr><name>old</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>PQtrace</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>debug_port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>conn</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>PQuntrace</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>Pfdebug</name></name> <operator>=</operator> <name>debug_port</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>PQuntrace</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>conn</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>Pfdebug</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>Pfdebug</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>Pfdebug</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>PQnoticeReceiver</name></type>
<name>PQsetNoticeReceiver</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>PQnoticeReceiver</name></type> <name>proc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQnoticeReceiver</name></type> <name>old</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>conn</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>old</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>noticeHooks</name><operator>.</operator><name>noticeRec</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>proc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>noticeHooks</name><operator>.</operator><name>noticeRec</name></name> <operator>=</operator> <name>proc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>noticeHooks</name><operator>.</operator><name>noticeRecArg</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>old</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>PQnoticeProcessor</name></type>
<name>PQsetNoticeProcessor</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>PQnoticeProcessor</name></type> <name>proc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQnoticeProcessor</name></type> <name>old</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>conn</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>old</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>noticeHooks</name><operator>.</operator><name>noticeProc</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>proc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>noticeHooks</name><operator>.</operator><name>noticeProc</name></name> <operator>=</operator> <name>proc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>noticeHooks</name><operator>.</operator><name>noticeProcArg</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>old</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * The default notice message receiver just gets the standard notice text
 * and sends it to the notice processor.  This two-level setup exists
 * mostly for backwards compatibility; perhaps we should deprecate use of
 * PQsetNoticeProcessor?
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>defaultNoticeReceiver</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>arg</name></expr>;</expr_stmt>					<comment type="block">/* not used */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>noticeHooks</name><operator>.</operator><name>noticeProc</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>res</name><operator>-&gt;</operator><name>noticeHooks</name><operator>.</operator><name>noticeProc</name></name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>noticeHooks</name><operator>.</operator><name>noticeProcArg</name></name></expr></argument>,
									<argument><expr><call><name>PQresultErrorMessage</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * The default notice message processor just prints the
 * message on stderr.  Applications can override this if they
 * want the messages to go elsewhere (a window, for example).
 * Note that simply discarding notices is probably a bad idea.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>defaultNoticeProcessor</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>arg</name></expr>;</expr_stmt>					<comment type="block">/* not used */</comment>
	<comment type="block">/* Note: we expect the supplied string to end with a newline already. */</comment>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * returns a pointer to the next token or NULL if the current
 * token doesn't match
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>pwdfMatchesString</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ttok</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>bslash</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>token</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>tbuf</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ttok</name> <operator>=</operator> <name>token</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>tbuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal> <operator>&amp;&amp;</operator> <name><name>tbuf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>tbuf</name> <operator>+</operator> <literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
	<while>while <condition>(<expr><operator>*</operator><name>tbuf</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>tbuf</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>bslash</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>tbuf</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>bslash</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>tbuf</name> <operator>==</operator> <literal type="char">':'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>ttok</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>bslash</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>tbuf</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>bslash</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ttok</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>tbuf</name> <operator>==</operator> <operator>*</operator><name>ttok</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>tbuf</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>ttok</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Get a password from the password file. Return value is malloc'd. */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>passwordFromFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hostname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbname</name></decl></parameter>,
				 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>username</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pgpassfile</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>dbname</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>dbname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>username</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>username</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* 'localhost' matches pghost of '' or the default socket directory */</comment>
	<if_stmt><if>if <condition>(<expr><name>hostname</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>hostname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>hostname</name> <operator>=</operator> <name>DefaultHost</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>is_absolute_path</name><argument_list>(<argument><expr><name>hostname</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

		<comment type="block">/*
		 * We should probably use canonicalize_path(), but then we have to
		 * bring path.c into libpq, and it doesn't seem worth it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>hostname</name></expr></argument>, <argument><expr><name>DEFAULT_PGSOCKET_DIR</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>hostname</name> <operator>=</operator> <name>DefaultHost</name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>port</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>port</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>port</name> <operator>=</operator> <name>DEF_PGPORT_STR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* If password file cannot be opened, ignore it. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>pgpassfile</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>stat_buf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"WARNING: password file \"%s\" is not a plain file\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>pgpassfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If password file is insecure, alert the user and ignore it. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stat_buf</name><operator>.</operator><name>st_mode</name></name> <operator>&amp;</operator> <operator>(</operator><name>S_IRWXG</name> <operator>|</operator> <name>S_IRWXO</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"WARNING: password file \"%s\" has group or world access; permissions should be u=rw (0600) or less\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>pgpassfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

	<comment type="block">/*
	 * On Win32, the directory is protected, so we don't have to check the
	 * file.
	 */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>pgpassfile</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Use an expansible buffer to accommodate any reasonable line length */</comment>
	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>!</operator><call><name>feof</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ferror</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Make sure there's a reasonable amount of room in the buffer */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>enlargePQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* Read some data, appending it to what we already have */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name> <operator>+</operator> <name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>maxlen</name></name> <operator>-</operator> <name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>buf</name><operator>.</operator><name>len</name></name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name> <operator>+</operator> <name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If we don't yet have a whole line, loop around to read more */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>buf</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>buf</name><operator>.</operator><name>data</name><index>[<expr><name><name>buf</name><operator>.</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>feof</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* ignore comments */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>.</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'#'</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>t</name> <init>= <expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

			<comment type="block">/* strip trailing newline and carriage return */</comment>
			<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>pg_strip_crlf</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<operator>(</operator><name>t</name> <operator>=</operator> <call><name>pwdfMatchesString</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>hostname</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				<operator>(</operator><name>t</name> <operator>=</operator> <call><name>pwdfMatchesString</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				<operator>(</operator><name>t</name> <operator>=</operator> <call><name>pwdfMatchesString</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>dbname</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				<operator>(</operator><name>t</name> <operator>=</operator> <call><name>pwdfMatchesString</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>username</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Found a match. */</comment>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ret</name></decl>,
						   <decl><type ref="prev"><modifier>*</modifier></type><name>p1</name></decl>,
						   <decl><type ref="prev"><modifier>*</modifier></type><name>p2</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>explicit_bzero</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>maxlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Out of memory. XXX: an error message would be nice. */</comment>
					<return>return <expr><name>NULL</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* De-escape password. */</comment>
				<for>for <control>(<init><expr><name>p1</name> <operator>=</operator> <name>p2</name> <operator>=</operator> <name>ret</name></expr>;</init> <condition><expr><operator>*</operator><name>p1</name> <operator>!=</operator> <literal type="char">':'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p1</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><operator>++</operator><name>p1</name></expr><operator>,</operator> <expr><operator>++</operator><name>p2</name></expr></incr>)</control>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p1</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name><name>p1</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>++</operator><name>p1</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><operator>*</operator><name>p2</name> <operator>=</operator> <operator>*</operator><name>p1</name></expr>;</expr_stmt>
				</block_content>}</block></for>
				<expr_stmt><expr><operator>*</operator><name>p2</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

				<return>return <expr><name>ret</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* No match, reset buffer to prepare for next line. */</comment>
		<expr_stmt><expr><name><name>buf</name><operator>.</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>explicit_bzero</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>maxlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *	If the connection failed due to bad password, we should mention
 *	if we got the password from the pgpassfile.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgpassfileWarning</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* If it was 'invalid authorization', add pgpassfile mention */</comment>
	<comment type="block">/* only works with &gt;= 9.0 servers */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>password_needed</name></name> <operator>&amp;&amp;</operator>
		<name><name>conn</name><operator>-&gt;</operator><name>connhost</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>whichhost</name></name></expr>]</index></name><operator>.</operator><name>password</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<name><name>conn</name><operator>-&gt;</operator><name>result</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlstate</name> <init>= <expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name></expr></argument>,
												  <argument><expr><name>PG_DIAG_SQLSTATE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>sqlstate</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>sqlstate</name></expr></argument>, <argument><expr><name>ERRCODE_INVALID_PASSWORD</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"password retrieved from file \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgpassfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check if the SSL procotol value given in input is valid or not.
 * This is used as a sanity check routine for the connection parameters
 * ssl_min_protocol_version and ssl_max_protocol_version.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>sslVerifyProtocolVersion</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>version</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * An empty string and a NULL value are considered valid as it is
	 * equivalent to ignoring the parameter.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>version</name> <operator>||</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>version</name></expr></argument>, <argument><expr><literal type="string">"TLSv1"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>version</name></expr></argument>, <argument><expr><literal type="string">"TLSv1.1"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>version</name></expr></argument>, <argument><expr><literal type="string">"TLSv1.2"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>version</name></expr></argument>, <argument><expr><literal type="string">"TLSv1.3"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* anything else is wrong */</comment>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Ensure that the SSL protocol range given in input is correct.  The check
 * is performed on the input string to keep it TLS backend agnostic.  Input
 * to this function is expected verified with sslVerifyProtocolVersion().
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>sslVerifyProtocolRange</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>min</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>max</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>sslVerifyProtocolVersion</name><argument_list>(<argument><expr><name>min</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		   <call><name>sslVerifyProtocolVersion</name><argument_list>(<argument><expr><name>max</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If at least one of the bounds is not set, the range is valid */</comment>
	<if_stmt><if>if <condition>(<expr><name>min</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>max</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>min</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>max</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the minimum version is the lowest one we accept, then all options
	 * for the maximum are valid.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>min</name></expr></argument>, <argument><expr><literal type="string">"TLSv1"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The minimum bound is valid, and cannot be TLSv1, so using TLSv1 for the
	 * maximum is incorrect.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>max</name></expr></argument>, <argument><expr><literal type="string">"TLSv1"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * At this point we know that we have a mix of TLSv1.1 through 1.3
	 * versions.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>min</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Obtain user's home directory, return in given buffer
 *
 * On Unix, this actually returns the user's home directory.  On Windows
 * it returns the PostgreSQL-specific application data folder.
 *
 * This is essentially the same as get_home_path(), but we don't use that
 * because we don't want to pull path.c into libpq (it pollutes application
 * namespace).
 *
 * Returns true on success, false on failure to obtain the directory name.
 *
 * CAUTION: although in most situations failure is unexpected, there are users
 * who like to run applications in a home-directory-less environment.  On
 * failure, you almost certainly DO NOT want to report an error.  Just act as
 * though whatever file you were hoping to find in the home directory isn't
 * there (which it isn't).
 */</comment>
<function><type><name>bool</name></type>
<name>pqGetHomeDirectory</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bufsize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>pwdbuf</name><index>[<expr><name>BUFSIZ</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>passwd</name></name></type> <name>pwdstr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>passwd</name></name> <modifier>*</modifier></type><name>pwd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pqGetpwuid</name><argument_list>(<argument><expr><call><name>geteuid</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>pwdstr</name></expr></argument>, <argument><expr><name>pwdbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pwdbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>pwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pwd</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>pwd</name><operator>-&gt;</operator><name>pw_dir</name></name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>tmppath</name><index>[<expr><name>MAX_PATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ZeroMemory</name><argument_list>(<argument><expr><name>tmppath</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tmppath</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>SHGetFolderPath</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>CSIDL_APPDATA</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tmppath</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>S_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>, <argument><expr><literal type="string">"%s/postgresql"</literal></expr></argument>, <argument><expr><name>tmppath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * To keep the API consistent, the locking stubs are always provided, even
 * if they are not required.
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>default_threadlock</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>acquire</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_THREAD_SAFETY</name></cpp:ifdef>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<decl_stmt><decl><type><specifier>static</specifier> <name>pthread_mutex_t</name></type> <name>singlethread_lock</name> <init>= <expr><name>PTHREAD_MUTEX_INITIALIZER</name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><specifier>static</specifier> <name>pthread_mutex_t</name></type> <name>singlethread_lock</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>mutex_initlock</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>singlethread_lock</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<while>while <condition>(<expr><call><name>InterlockedExchange</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mutex_initlock</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			 <comment type="block">/* loop, another thread own the lock */</comment> <empty_stmt>;</empty_stmt></block_content></block></while>
		<if_stmt><if>if <condition>(<expr><name>singlethread_lock</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pthread_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>singlethread_lock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PGTHREAD_ERROR</name><argument_list>(<argument><expr><literal type="string">"failed to initialize mutex"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>InterlockedExchange</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mutex_initlock</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if_stmt><if>if <condition>(<expr><name>acquire</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>singlethread_lock</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PGTHREAD_ERROR</name><argument_list>(<argument><expr><literal type="string">"failed to lock mutex"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>singlethread_lock</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PGTHREAD_ERROR</name><argument_list>(<argument><expr><literal type="string">"failed to unlock mutex"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>pgthreadlock_t</name></type>
<name>PQregisterThreadLock</name><parameter_list>(<parameter><decl><type><name>pgthreadlock_t</name></type> <name>newhandler</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pgthreadlock_t</name></type> <name>prev</name> <init>= <expr><name>pg_g_threadlock</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>newhandler</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>pg_g_threadlock</name> <operator>=</operator> <name>newhandler</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>pg_g_threadlock</name> <operator>=</operator> <name>default_threadlock</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>prev</name></expr>;</return>
</block_content>}</block></function>
</unit>
