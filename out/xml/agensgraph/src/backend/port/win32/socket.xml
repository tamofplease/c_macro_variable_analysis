<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/port/win32/socket.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * socket.c
 *	  Microsoft Windows Win32 Socket Functions
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *	  src/backend/port/win32/socket.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Indicate if pgwin32_recv() and pgwin32_send() should operate
 * in non-blocking mode.
 *
 * Since the socket emulation layer always sets the actual socket to
 * non-blocking mode in order to be able to deliver signals, we must
 * specify this in a separate flag if we actually need non-blocking
 * operation.
 *
 * This flag changes the behaviour *globally* for all socket operations,
 * so it should only be set for very short periods of time.
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>pgwin32_noblock</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* Undef the macros defined in win32.h, so we can access system functions */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>socket</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>bind</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>listen</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>accept</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>connect</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>select</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>recv</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>send</name></cpp:undef>

<comment type="block">/*
 * Blocking socket functions implemented so they listen on both
 * the socket and the signal event, required for signal handling.
 */</comment>

<comment type="block">/*
 * Convert the last socket error code into errno
 *
 * Note: where there is a direct correspondence between a WSAxxx error code
 * and a Berkeley error symbol, this mapping is actually a no-op, because
 * in win32.h we redefine the network-related Berkeley error symbols to have
 * the values of their WSAxxx counterparts.  The point of the switch is
 * mostly to translate near-miss error codes into something that's sensible
 * in the Berkeley universe.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>TranslateSocketError</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><call><name>WSAGetLastError</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>WSAEINVAL</name></expr>:</case>
		<case>case <expr><name>WSANOTINITIALISED</name></expr>:</case>
		<case>case <expr><name>WSAEINVALIDPROVIDER</name></expr>:</case>
		<case>case <expr><name>WSAEINVALIDPROCTABLE</name></expr>:</case>
		<case>case <expr><name>WSAEDESTADDRREQ</name></expr>:</case>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EINVAL</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>WSAEINPROGRESS</name></expr>:</case>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EINPROGRESS</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>WSAEFAULT</name></expr>:</case>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EFAULT</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>WSAEISCONN</name></expr>:</case>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EISCONN</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>WSAEMSGSIZE</name></expr>:</case>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EMSGSIZE</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>WSAEAFNOSUPPORT</name></expr>:</case>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EAFNOSUPPORT</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>WSAEMFILE</name></expr>:</case>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EMFILE</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>WSAENOBUFS</name></expr>:</case>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOBUFS</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>WSAEPROTONOSUPPORT</name></expr>:</case>
		<case>case <expr><name>WSAEPROTOTYPE</name></expr>:</case>
		<case>case <expr><name>WSAESOCKTNOSUPPORT</name></expr>:</case>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EPROTONOSUPPORT</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>WSAECONNABORTED</name></expr>:</case>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ECONNABORTED</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>WSAECONNREFUSED</name></expr>:</case>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ECONNREFUSED</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>WSAECONNRESET</name></expr>:</case>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ECONNRESET</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>WSAEINTR</name></expr>:</case>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EINTR</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>WSAENOTSOCK</name></expr>:</case>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOTSOCK</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>WSAEOPNOTSUPP</name></expr>:</case>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EOPNOTSUPP</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>WSAEWOULDBLOCK</name></expr>:</case>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EWOULDBLOCK</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>WSAEACCES</name></expr>:</case>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EACCES</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>WSAEADDRINUSE</name></expr>:</case>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EADDRINUSE</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>WSAEADDRNOTAVAIL</name></expr>:</case>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EADDRNOTAVAIL</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>WSAEHOSTUNREACH</name></expr>:</case>
		<case>case <expr><name>WSAEHOSTDOWN</name></expr>:</case>
		<case>case <expr><name>WSAHOST_NOT_FOUND</name></expr>:</case>
		<case>case <expr><name>WSAENETDOWN</name></expr>:</case>
		<case>case <expr><name>WSAENETUNREACH</name></expr>:</case>
		<case>case <expr><name>WSAENETRESET</name></expr>:</case>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EHOSTUNREACH</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>WSAENOTCONN</name></expr>:</case>
		<case>case <expr><name>WSAESHUTDOWN</name></expr>:</case>
		<case>case <expr><name>WSAEDISCON</name></expr>:</case>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOTCONN</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"unrecognized win32 socket error code: %d"</literal></expr></argument>, <argument><expr><call><name>WSAGetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EINVAL</name></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pgwin32_poll_signals</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>UNBLOCKED_SIGNAL_QUEUE</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pgwin32_dispatch_queued_signals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EINTR</name></expr>;</expr_stmt>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>isDataGram</name><parameter_list>(<parameter><decl><type><name>SOCKET</name></type> <name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>typelen</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>getsockopt</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>SOL_SOCKET</name></expr></argument>, <argument><expr><name>SO_TYPE</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typelen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><ternary><condition><expr><operator>(</operator><name>type</name> <operator>==</operator> <name>SOCK_DGRAM</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pgwin32_waitforsinglesocket</name><parameter_list>(<parameter><decl><type><name>SOCKET</name></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>what</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>HANDLE</name></type> <name>waitevent</name> <init>= <expr><name>INVALID_HANDLE_VALUE</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>SOCKET</name></type> <name>current_socket</name> <init>= <expr><name>INVALID_SOCKET</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>isUDP</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HANDLE</name></type>		<name><name>events</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>r</name></decl>;</decl_stmt>

	<comment type="block">/* Create an event object just once and use it on all future calls */</comment>
	<if_stmt><if>if <condition>(<expr><name>waitevent</name> <operator>==</operator> <name>INVALID_HANDLE_VALUE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>waitevent</name> <operator>=</operator> <call><name>CreateEvent</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>waitevent</name> <operator>==</operator> <name>INVALID_HANDLE_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"could not create socket waiting event: error code %lu"</literal></expr></argument>, <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>ResetEvent</name><argument_list>(<argument><expr><name>waitevent</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"could not reset socket waiting event: error code %lu"</literal></expr></argument>, <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Track whether socket is UDP or not.  (NB: most likely, this is both
	 * useless and wrong; there is no reason to think that the behavior of
	 * WSAEventSelect is different for TCP and UDP.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>current_socket</name> <operator>!=</operator> <name>s</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>isUDP</name> <operator>=</operator> <call><name>isDataGram</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>current_socket</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Attach event to socket.  NOTE: we must detach it again before
	 * returning, since other bits of code may try to attach other events to
	 * the socket.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>WSAEventSelect</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>waitevent</name></expr></argument>, <argument><expr><name>what</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>TranslateSocketError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>events</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>pgwin32_signal_event</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>events</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>waitevent</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Just a workaround of unknown locking problem with writing in UDP socket
	 * under high load: Client's pgsql backend sleeps infinitely in
	 * WaitForMultipleObjectsEx, pgstat process sleeps in pgwin32_select().
	 * So, we will wait with small timeout(0.1 sec) and if socket is still
	 * blocked, try WSASend (see comments in pgwin32_select) and wait again.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>what</name> <operator>&amp;</operator> <name>FD_WRITE</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>isUDP</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>WaitForMultipleObjectsEx</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>events</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>WAIT_TIMEOUT</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name></type>		<name>c</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>WSABUF</name></type>		<name>buf</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>DWORD</name></type>		<name>sent</name></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>buf</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <operator>&amp;</operator><name>c</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>buf</name><operator>.</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

				<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>WSASend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>sent</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>		<comment type="block">/* Completed - means things are fine! */</comment>
				<block>{<block_content>
					<expr_stmt><expr><call><name>WSAEventSelect</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><literal type="number">1</literal></expr>;</return>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><call><name>WSAGetLastError</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>WSAEWOULDBLOCK</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>TranslateSocketError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>WSAEventSelect</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><literal type="number">0</literal></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<break>break;</break></block_content></block></else></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>WaitForMultipleObjectsEx</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>events</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>WSAEventSelect</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>WAIT_OBJECT_0</name> <operator>||</operator> <name>r</name> <operator>==</operator> <name>WAIT_IO_COMPLETION</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pgwin32_dispatch_queued_signals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EINTR</name></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>WAIT_OBJECT_0</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>WAIT_TIMEOUT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EWOULDBLOCK</name></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"unrecognized return value from WaitForMultipleObjects: %d (error code %lu)"</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create a socket, setting it to overlapped and non-blocking
 */</comment>
<function><type><name>SOCKET</name></type>
<name>pgwin32_socket</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>af</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>protocol</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SOCKET</name></type>		<name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>on</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>WSASocket</name><argument_list>(<argument><expr><name>af</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>protocol</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>WSA_FLAG_OVERLAPPED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>INVALID_SOCKET</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>TranslateSocketError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>INVALID_SOCKET</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ioctlsocket</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>FIONBIO</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>on</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>TranslateSocketError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>INVALID_SOCKET</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<return>return <expr><name>s</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pgwin32_bind</name><parameter_list>(<parameter><decl><type><name>SOCKET</name></type> <name>s</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>sockaddr</name></name> <modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>addrlen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>bind</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>addrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>TranslateSocketError</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pgwin32_listen</name><parameter_list>(<parameter><decl><type><name>SOCKET</name></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>backlog</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>listen</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>backlog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>TranslateSocketError</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>SOCKET</name></type>
<name>pgwin32_accept</name><parameter_list>(<parameter><decl><type><name>SOCKET</name></type> <name>s</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>sockaddr</name></name> <modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>addrlen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SOCKET</name></type>		<name>rs</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Poll for signals, but don't return with EINTR, since we don't handle
	 * that in pqcomm.c
	 */</comment>
	<expr_stmt><expr><call><name>pgwin32_poll_signals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rs</name> <operator>=</operator> <call><name>WSAAccept</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>addrlen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rs</name> <operator>==</operator> <name>INVALID_SOCKET</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>TranslateSocketError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>INVALID_SOCKET</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>rs</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* No signal delivery during connect. */</comment>
<function><type><name>int</name></type>
<name>pgwin32_connect</name><parameter_list>(<parameter><decl><type><name>SOCKET</name></type> <name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>sockaddr</name></name> <modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>addrlen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>r</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>WSAConnect</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>addrlen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>WSAGetLastError</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>WSAEWOULDBLOCK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>TranslateSocketError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><call><name>pgwin32_waitforsinglesocket</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>FD_CONNECT</name></expr></argument>, <argument><expr><name>INFINITE</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Loop endlessly as long as we are just delivering signals */</comment>
	</block_content>}</block></while>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pgwin32_recv</name><parameter_list>(<parameter><decl><type><name>SOCKET</name></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WSABUF</name></type>		<name>wbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>r</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DWORD</name></type>		<name>b</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DWORD</name></type>		<name>flags</name> <init>= <expr><name>f</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pgwin32_poll_signals</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>wbuf</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>wbuf</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>WSARecv</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wbuf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>SOCKET_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>b</name></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* success */</comment>

	<if_stmt><if>if <condition>(<expr><call><name>WSAGetLastError</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>WSAEWOULDBLOCK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>TranslateSocketError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>pgwin32_noblock</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * No data received, and we are in "emulated non-blocking mode", so
		 * return indicating that we'd block if we were to continue.
		 */</comment>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EWOULDBLOCK</name></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We're in blocking mode, so wait for data */</comment>

	<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <literal type="number">5</literal></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pgwin32_waitforsinglesocket</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>FD_READ</name> <operator>|</operator> <name>FD_CLOSE</name> <operator>|</operator> <name>FD_ACCEPT</name></expr></argument>,
										<argument><expr><name>INFINITE</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* errno already set */</comment>

		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>WSARecv</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wbuf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>SOCKET_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>b</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* success */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>WSAGetLastError</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>WSAEWOULDBLOCK</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>TranslateSocketError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * There seem to be cases on win2k (at least) where WSARecv can return
		 * WSAEWOULDBLOCK even when pgwin32_waitforsinglesocket claims the
		 * socket is readable.  In this case, just sleep for a moment and try
		 * again.  We try up to 5 times - if it fails more than that it's not
		 * likely to ever come back.
		 */</comment>
		<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">10000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"could not read from ready socket (after retries)"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EWOULDBLOCK</name></expr>;</expr_stmt>
	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * The second argument to send() is defined by SUS to be a "const void *"
 * and so we use the same signature here to keep compilers happy when
 * handling callers.
 *
 * But the buf member of a WSABUF struct is defined as "char *", so we cast
 * the second argument to that here when assigning it, also to keep compilers
 * happy.
 */</comment>

<function><type><name>int</name></type>
<name>pgwin32_send</name><parameter_list>(<parameter><decl><type><name>SOCKET</name></type> <name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WSABUF</name></type>		<name>wbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>r</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DWORD</name></type>		<name>b</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pgwin32_poll_signals</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>wbuf</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>wbuf</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>buf</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Readiness of socket to send data to UDP socket may be not true: socket
	 * can become busy again! So loop until send or error occurs.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>WSASend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wbuf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>SOCKET_ERROR</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/* Write succeeded right away */</comment>
			<return>return <expr><name>b</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>SOCKET_ERROR</name> <operator>&amp;&amp;</operator>
			<call><name>WSAGetLastError</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>WSAEWOULDBLOCK</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>TranslateSocketError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>pgwin32_noblock</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * No data sent, and we are in "emulated non-blocking mode", so
			 * return indicating that we'd block if we were to continue.
			 */</comment>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EWOULDBLOCK</name></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* No error, zero bytes (win2000+) or error+WSAEWOULDBLOCK (&lt;=nt4) */</comment>

		<if_stmt><if>if <condition>(<expr><call><name>pgwin32_waitforsinglesocket</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>FD_WRITE</name> <operator>|</operator> <name>FD_CLOSE</name></expr></argument>, <argument><expr><name>INFINITE</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Wait for activity on one or more sockets.
 * While waiting, allow signals to run
 *
 * NOTE! Currently does not implement exceptfds check,
 * since it is not used in postgresql!
 */</comment>
<function><type><name>int</name></type>
<name>pgwin32_select</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nfds</name></decl></parameter>, <parameter><decl><type><name>fd_set</name> <modifier>*</modifier></type><name>readfds</name></decl></parameter>, <parameter><decl><type><name>fd_set</name> <modifier>*</modifier></type><name>writefds</name></decl></parameter>, <parameter><decl><type><name>fd_set</name> <modifier>*</modifier></type><name>exceptfds</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>timeval</name></name> <modifier>*</modifier></type><name>timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WSAEVENT</name></type>	<name><name>events</name><index>[<expr><name>FD_SETSIZE</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* worst case is readfds totally
										 * different from writefds, so
										 * 2*FD_SETSIZE sockets */</comment>
	<decl_stmt><decl><type><name>SOCKET</name></type>		<name><name>sockets</name><index>[<expr><name>FD_SETSIZE</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numevents</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>r</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DWORD</name></type>		<name>timeoutval</name> <init>= <expr><name>WSA_INFINITE</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FD_SET</name></type>		<name>outreadfds</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FD_SET</name></type>		<name>outwritefds</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nummatches</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>exceptfds</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pgwin32_poll_signals</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>outreadfds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>outwritefds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Windows does not guarantee to log an FD_WRITE network event indicating
	 * that more data can be sent unless the previous send() failed with
	 * WSAEWOULDBLOCK.  While our caller might well have made such a call, we
	 * cannot assume that here.  Therefore, if waiting for write-ready, force
	 * the issue by doing a dummy send().  If the dummy send() succeeds,
	 * assume that the socket is in fact write-ready, and return immediately.
	 * Also, if it fails with something other than WSAEWOULDBLOCK, return a
	 * write-ready indication to let our caller deal with the error condition.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>writefds</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>writefds</name><operator>-&gt;</operator><name>fd_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name>c</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>WSABUF</name></type>		<name>buf</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>DWORD</name></type>		<name>sent</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>buf</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <operator>&amp;</operator><name>c</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>buf</name><operator>.</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>WSASend</name><argument_list>(<argument><expr><name><name>writefds</name><operator>-&gt;</operator><name>fd_array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>sent</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>WSAGetLastError</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>WSAEWOULDBLOCK</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name><name>writefds</name><operator>-&gt;</operator><name>fd_array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outwritefds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* If we found any write-ready sockets, just return them immediately */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>outwritefds</name><operator>.</operator><name>fd_count</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>writefds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outwritefds</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fd_set</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>readfds</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><name>readfds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name><name>outwritefds</name><operator>.</operator><name>fd_count</name></name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>


	<comment type="block">/* Now set up for an actual select */</comment>

	<if_stmt><if>if <condition>(<expr><name>timeout</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* timeoutval is in milliseconds */</comment>
		<expr_stmt><expr><name>timeoutval</name> <operator>=</operator> <name><name>timeout</name><operator>-&gt;</operator><name>tv_sec</name></name> <operator>*</operator> <literal type="number">1000</literal> <operator>+</operator> <name><name>timeout</name><operator>-&gt;</operator><name>tv_usec</name></name> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>readfds</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>readfds</name><operator>-&gt;</operator><name>fd_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>events</name><index>[<expr><name>numevents</name></expr>]</index></name> <operator>=</operator> <call><name>WSACreateEvent</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sockets</name><index>[<expr><name>numevents</name></expr>]</index></name> <operator>=</operator> <name><name>readfds</name><operator>-&gt;</operator><name>fd_array</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>numevents</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>writefds</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>writefds</name><operator>-&gt;</operator><name>fd_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>readfds</name> <operator>||</operator>
				<operator>!</operator><call><name>FD_ISSET</name><argument_list>(<argument><expr><name><name>writefds</name><operator>-&gt;</operator><name>fd_array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>readfds</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* If the socket is not in the read list */</comment>
				<expr_stmt><expr><name><name>events</name><index>[<expr><name>numevents</name></expr>]</index></name> <operator>=</operator> <call><name>WSACreateEvent</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sockets</name><index>[<expr><name>numevents</name></expr>]</index></name> <operator>=</operator> <name><name>writefds</name><operator>-&gt;</operator><name>fd_array</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>numevents</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numevents</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>readfds</name> <operator>&amp;&amp;</operator> <call><name>FD_ISSET</name><argument_list>(<argument><expr><name><name>sockets</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>readfds</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>FD_READ</name> <operator>|</operator> <name>FD_ACCEPT</name> <operator>|</operator> <name>FD_CLOSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>writefds</name> <operator>&amp;&amp;</operator> <call><name>FD_ISSET</name><argument_list>(<argument><expr><name><name>sockets</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>writefds</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>FD_WRITE</name> <operator>|</operator> <name>FD_CLOSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>WSAEventSelect</name><argument_list>(<argument><expr><name><name>sockets</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>events</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>TranslateSocketError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* release already-assigned event objects */</comment>
			<while>while <condition>(<expr><operator>--</operator><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>WSAEventSelect</name><argument_list>(<argument><expr><name><name>sockets</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numevents</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>WSACloseEvent</name><argument_list>(<argument><expr><name><name>events</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>events</name><index>[<expr><name>numevents</name></expr>]</index></name> <operator>=</operator> <name>pgwin32_signal_event</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>WaitForMultipleObjectsEx</name><argument_list>(<argument><expr><name>numevents</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>events</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>timeoutval</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>WAIT_TIMEOUT</name> <operator>&amp;&amp;</operator> <name>r</name> <operator>!=</operator> <name>WAIT_IO_COMPLETION</name> <operator>&amp;&amp;</operator> <name>r</name> <operator>!=</operator> <operator>(</operator><name>WAIT_OBJECT_0</name> <operator>+</operator> <name>numevents</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We scan all events, even those not signaled, in case more than one
		 * event has been tagged but Wait.. can only return one.
		 */</comment>
		<decl_stmt><decl><type><name>WSANETWORKEVENTS</name></type> <name>resEvents</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numevents</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ZeroMemory</name><argument_list>(<argument><expr><operator>&amp;</operator><name>resEvents</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>resEvents</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>WSAEnumNetworkEvents</name><argument_list>(<argument><expr><name><name>sockets</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>events</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>resEvents</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to enumerate network events: error code %u"</literal></expr></argument>,
					 <argument><expr><call><name>WSAGetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* Read activity? */</comment>
			<if_stmt><if>if <condition>(<expr><name>readfds</name> <operator>&amp;&amp;</operator> <call><name>FD_ISSET</name><argument_list>(<argument><expr><name><name>sockets</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>readfds</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>resEvents</name><operator>.</operator><name>lNetworkEvents</name></name> <operator>&amp;</operator> <name>FD_READ</name><operator>)</operator> <operator>||</operator>
					<operator>(</operator><name><name>resEvents</name><operator>.</operator><name>lNetworkEvents</name></name> <operator>&amp;</operator> <name>FD_ACCEPT</name><operator>)</operator> <operator>||</operator>
					<operator>(</operator><name><name>resEvents</name><operator>.</operator><name>lNetworkEvents</name></name> <operator>&amp;</operator> <name>FD_CLOSE</name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name><name>sockets</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outreadfds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>nummatches</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Write activity? */</comment>
			<if_stmt><if>if <condition>(<expr><name>writefds</name> <operator>&amp;&amp;</operator> <call><name>FD_ISSET</name><argument_list>(<argument><expr><name><name>sockets</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>writefds</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>resEvents</name><operator>.</operator><name>lNetworkEvents</name></name> <operator>&amp;</operator> <name>FD_WRITE</name><operator>)</operator> <operator>||</operator>
					<operator>(</operator><name><name>resEvents</name><operator>.</operator><name>lNetworkEvents</name></name> <operator>&amp;</operator> <name>FD_CLOSE</name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name><name>sockets</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outwritefds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>nummatches</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Clean up all the event objects */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numevents</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>WSAEventSelect</name><argument_list>(<argument><expr><name><name>sockets</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WSACloseEvent</name><argument_list>(<argument><expr><name><name>events</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>WSA_WAIT_TIMEOUT</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>readfds</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><name>readfds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>writefds</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><name>writefds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Signal-like events. */</comment>
	<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>WAIT_OBJECT_0</name> <operator>+</operator> <name>numevents</name> <operator>||</operator> <name>r</name> <operator>==</operator> <name>WAIT_IO_COMPLETION</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pgwin32_dispatch_queued_signals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EINTR</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>readfds</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><name>readfds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>writefds</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><name>writefds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Overwrite socket sets with our resulting values */</comment>
	<if_stmt><if>if <condition>(<expr><name>readfds</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>readfds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outreadfds</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fd_set</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>writefds</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>writefds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outwritefds</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fd_set</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>nummatches</name></expr>;</return>
</block_content>}</block></function>
</unit>
