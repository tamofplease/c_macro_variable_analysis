<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/statistics/dependencies.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * dependencies.c
 *	  POSTGRES functional dependencies
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/statistics/dependencies.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_statistic_ext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_statistic_ext_data.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pathnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"statistics/extended_stats_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"statistics/statistics.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/bytea.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgrprotos.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/selfuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>

<comment type="block">/* size of the struct header fields (magic, type, ndeps) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SizeOfHeader</name></cpp:macro>		<cpp:value>(3 * sizeof(uint32))</cpp:value></cpp:define>

<comment type="block">/* size of a serialized dependency (degree, natts, atts) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SizeOfItem</name><parameter_list>(<parameter><type><name>natts</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(sizeof(double) + sizeof(AttrNumber) * (1 + (natts)))</cpp:value></cpp:define>

<comment type="block">/* minimal size of a dependency (with two attributes) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MinSizeOfItem</name></cpp:macro>	<cpp:value>SizeOfItem(2)</cpp:value></cpp:define>

<comment type="block">/* minimal size of dependencies, when all deps are minimal */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MinSizeOfItems</name><parameter_list>(<parameter><type><name>ndeps</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(SizeOfHeader + (ndeps) * MinSizeOfItem)</cpp:value></cpp:define>

<comment type="block">/*
 * Internal state for DependencyGenerator of dependencies. Dependencies are similar to
 * k-permutations of n elements, except that the order does not matter for the
 * first (k-1) elements. That is, (a,b=&gt;c) and (b,a=&gt;c) are equivalent.
 */</comment>
<typedef>typedef <type><struct>struct <name>DependencyGeneratorData</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>k</name></decl>;</decl_stmt>				<comment type="block">/* size of the dependency */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>;</decl_stmt>				<comment type="block">/* number of possible attributes */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>current</name></decl>;</decl_stmt>		<comment type="block">/* next dependency to return (index) */</comment>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>ndependencies</name></decl>;</decl_stmt>	<comment type="block">/* number of dependencies generated */</comment>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>dependencies</name></decl>;</decl_stmt>	<comment type="block">/* array of pre-generated dependencies	*/</comment>
}</block></struct></type> <name>DependencyGeneratorData</name>;</typedef>

<typedef>typedef <type><name>DependencyGeneratorData</name> <modifier>*</modifier></type><name>DependencyGenerator</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>generate_dependencies_recurse</name><parameter_list>(<parameter><decl><type><name>DependencyGenerator</name></type> <name>state</name></decl></parameter>,
										  <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>current</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>generate_dependencies</name><parameter_list>(<parameter><decl><type><name>DependencyGenerator</name></type> <name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DependencyGenerator</name></type> <name>DependencyGenerator_init</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DependencyGenerator_free</name><parameter_list>(<parameter><decl><type><name>DependencyGenerator</name></type> <name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>AttrNumber</name> <modifier>*</modifier></type><name>DependencyGenerator_next</name><parameter_list>(<parameter><decl><type><name>DependencyGenerator</name></type> <name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>dependency_degree</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>numrows</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>,
								<parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>dependency</name></decl></parameter>, <parameter><decl><type><name>VacAttrStats</name> <modifier>*</modifier><modifier>*</modifier></type><name>stats</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>attrs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>dependency_is_fully_matched</name><parameter_list>(<parameter><decl><type><name>MVDependency</name> <modifier>*</modifier></type><name>dependency</name></decl></parameter>,
										<parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>attnums</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>dependency_is_compatible_clause</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>relid</name></decl></parameter>,
											<parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>attnum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MVDependency</name> <modifier>*</modifier></type><name>find_strongest_dependency</name><parameter_list>(<parameter><decl><type><name>MVDependencies</name> <modifier>*</modifier><modifier>*</modifier></type><name>dependencies</name></decl></parameter>,
											   <parameter><decl><type><name>int</name></type> <name>ndependencies</name></decl></parameter>,
											   <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>attnums</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Selectivity</name></type> <name>clauselist_apply_dependencies</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>,
												 <parameter><decl><type><name>int</name></type> <name>varRelid</name></decl></parameter>, <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
												 <parameter><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name></decl></parameter>,
												 <parameter><decl><type><name>MVDependency</name> <modifier>*</modifier><modifier>*</modifier></type><name>dependencies</name></decl></parameter>,
												 <parameter><decl><type><name>int</name></type> <name>ndependencies</name></decl></parameter>,
												 <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>list_attnums</name></decl></parameter>,
												 <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier><modifier>*</modifier></type><name>estimatedclauses</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>generate_dependencies_recurse</name><parameter_list>(<parameter><decl><type><name>DependencyGenerator</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>,
							  <parameter><decl><type><name>AttrNumber</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>current</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * The generator handles the first (k-1) elements differently from the
	 * last element.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>k</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>i</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * The first (k-1) values have to be in ascending order, which we
		 * generate recursively.
		 */</comment>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>start</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>n</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>current</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>generate_dependencies_recurse</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>(</operator><name>index</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * the last element is the implied value, which does not respect the
		 * ascending order. We just need to check that the value is not in the
		 * first (k-1) elements.
		 */</comment>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>n</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>match</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>current</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>index</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>current</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>i</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>match</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>

			<comment type="block">/*
			 * If the value is not found in the first part of the dependency,
			 * we're done.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>match</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>dependencies</name></name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>dependencies</name></name></expr></argument>,
															  <argument><expr><name><name>state</name><operator>-&gt;</operator><name>k</name></name> <operator>*</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ndependencies</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>dependencies</name><index>[<expr><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>k</name></name> <operator>*</operator> <name><name>state</name><operator>-&gt;</operator><name>ndependencies</name></name><operator>)</operator></expr>]</index></name></expr></argument>,
					   <argument><expr><name>current</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>k</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ndependencies</name></name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* generate all dependencies (k-permutations of n elements) */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>generate_dependencies</name><parameter_list>(<parameter><decl><type><name>DependencyGenerator</name></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>current</name> <init>= <expr><operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>state</name><operator>-&gt;</operator><name>k</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>generate_dependencies_recurse</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * initialize the DependencyGenerator of variations, and prebuild the variations
 *
 * This pre-builds all the variations. We could also generate them in
 * DependencyGenerator_next(), but this seems simpler.
 */</comment>
<function><type><specifier>static</specifier> <name>DependencyGenerator</name></type>
<name>DependencyGenerator_init</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DependencyGenerator</name></type> <name>state</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>n</name> <operator>&gt;=</operator> <name>k</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>k</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* allocate the DependencyGenerator state */</comment>
	<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>DependencyGenerator</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DependencyGeneratorData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>dependencies</name></name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>k</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ndependencies</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>k</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>

	<comment type="block">/* now actually pre-generate all the variations */</comment>
	<expr_stmt><expr><call><name>generate_dependencies</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* free the DependencyGenerator state */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DependencyGenerator_free</name><parameter_list>(<parameter><decl><type><name>DependencyGenerator</name></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>dependencies</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<comment type="block">/* generate next combination */</comment>
<function><type><specifier>static</specifier> <name>AttrNumber</name> <modifier>*</modifier></type>
<name>DependencyGenerator_next</name><parameter_list>(<parameter><decl><type><name>DependencyGenerator</name></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>current</name></name> <operator>==</operator> <name><name>state</name><operator>-&gt;</operator><name>ndependencies</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>dependencies</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>k</name></name> <operator>*</operator> <name><name>state</name><operator>-&gt;</operator><name>current</name></name><operator>++</operator></expr>]</index></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * validates functional dependency on the data
 *
 * An actual work horse of detecting functional dependencies. Given a variation
 * of k attributes, it checks that the first (k-1) are sufficient to determine
 * the last one.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>dependency_degree</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>numrows</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>dependency</name></decl></parameter>,
				  <parameter><decl><type><name>VacAttrStats</name> <modifier>*</modifier><modifier>*</modifier></type><name>stats</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>attrs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>nitems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiSortSupport</name></type> <name>mss</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SortItem</name>   <modifier>*</modifier></type><name>items</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>attnums</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>attnums_dep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numattrs</name></decl>;</decl_stmt>

	<comment type="block">/* counters valid within a group */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>group_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>n_violations</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* total number of rows supporting (consistent with) the dependency */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>n_supporting_rows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Make sure we have at least two input attributes. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>k</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* sort info for all attributes columns */</comment>
	<expr_stmt><expr><name>mss</name> <operator>=</operator> <call><name>multi_sort_init</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Transform the attrs from bitmap to an array to make accessing the i-th
	 * member easier, and then construct a filtered version with only attnums
	 * referenced by the dependency we validate.
	 */</comment>
	<expr_stmt><expr><name>attnums</name> <operator>=</operator> <call><name>build_attnums_array</name><argument_list>(<argument><expr><name>attrs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numattrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>attnums_dep</name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>k</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>k</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>attnums_dep</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>attnums</name><index>[<expr><name><name>dependency</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/*
	 * Verify the dependency (a,b,...)-&gt;z, using a rather simple algorithm:
	 *
	 * (a) sort the data lexicographically
	 *
	 * (b) split the data into groups by first (k-1) columns
	 *
	 * (c) for each group count different values in the last column
	 *
	 * We use the column data types' default sort operators and collations;
	 * perhaps at some point it'd be worth using column-specific collations?
	 */</comment>

	<comment type="block">/* prepare the sort function for the dimensions */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>k</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>VacAttrStats</name> <modifier>*</modifier></type><name>colstat</name> <init>= <expr><name><name>stats</name><index>[<expr><name><name>dependency</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>type</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name><name>colstat</name><operator>-&gt;</operator><name>attrtypid</name></name></expr></argument>, <argument><expr><name>TYPECACHE_LT_OPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>type</name><operator>-&gt;</operator><name>lt_opr</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* shouldn't happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for ordering operator for type %u"</literal></expr></argument>,
				 <argument><expr><name><name>colstat</name><operator>-&gt;</operator><name>attrtypid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* prepare the sort function for this dimension */</comment>
		<expr_stmt><expr><call><name>multi_sort_add_dimension</name><argument_list>(<argument><expr><name>mss</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>type</name><operator>-&gt;</operator><name>lt_opr</name></name></expr></argument>, <argument><expr><name><name>colstat</name><operator>-&gt;</operator><name>attrcollid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * build an array of SortItem(s) sorted using the multi-sort support
	 *
	 * XXX This relies on all stats entries pointing to the same tuple
	 * descriptor.  For now that assumption holds, but it might change in the
	 * future for example if we support statistics on multiple tables.
	 */</comment>
	<expr_stmt><expr><name>items</name> <operator>=</operator> <call><name>build_sorted_items</name><argument_list>(<argument><expr><name>numrows</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nitems</name></expr></argument>, <argument><expr><name>rows</name></expr></argument>, <argument><expr><name><name>stats</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>tupDesc</name></expr></argument>,
							   <argument><expr><name>mss</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>attnums_dep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Walk through the sorted array, split it into rows according to the
	 * first (k-1) columns. If there's a single value in the last column, we
	 * count the group as 'supporting' the functional dependency. Otherwise we
	 * count it as contradicting.
	 */</comment>

	<comment type="block">/* start with the first row forming a group */</comment>
	<expr_stmt><expr><name>group_size</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* loop 1 beyond the end of the array so that we count the final group */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * Check if the group ended, which may be either because we processed
		 * all the items (i==nitems), or because the i-th item is not equal to
		 * the preceding one.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>nitems</name> <operator>||</operator>
			<call><name>multi_sort_compare_dims</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>k</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>items</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>mss</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If no violations were found in the group then track the rows of
			 * the group as supporting the functional dependency.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>n_violations</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>n_supporting_rows</name> <operator>+=</operator> <name>group_size</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Reset counters for the new group */</comment>
			<expr_stmt><expr><name>n_violations</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>group_size</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if>
		<comment type="block">/* first columns match, but the last one does not (so contradicting) */</comment>
		<if type="elseif">else if <condition>(<expr><call><name>multi_sort_compare_dim</name><argument_list>(<argument><expr><name>k</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>items</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>mss</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>n_violations</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>group_size</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Compute the 'degree of validity' as (supporting/total). */</comment>
	<return>return <expr><operator>(</operator><name>n_supporting_rows</name> <operator>*</operator> <literal type="number">1.0</literal> <operator>/</operator> <name>numrows</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * detects functional dependencies between groups of columns
 *
 * Generates all possible subsets of columns (variations) and computes
 * the degree of validity for each one. For example when creating statistics
 * on three columns (a,b,c) there are 9 possible dependencies
 *
 *	   two columns			  three columns
 *	   -----------			  -------------
 *	   (a) -&gt; b				  (a,b) -&gt; c
 *	   (a) -&gt; c				  (a,c) -&gt; b
 *	   (b) -&gt; a				  (b,c) -&gt; a
 *	   (b) -&gt; c
 *	   (c) -&gt; a
 *	   (c) -&gt; b
 */</comment>
<function><type><name>MVDependencies</name> <modifier>*</modifier></type>
<name>statext_dependencies_build</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>numrows</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>attrs</name></decl></parameter>,
						   <parameter><decl><type><name>VacAttrStats</name> <modifier>*</modifier><modifier>*</modifier></type><name>stats</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numattrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>attnums</name></decl>;</decl_stmt>

	<comment type="block">/* result */</comment>
	<decl_stmt><decl><type><name>MVDependencies</name> <modifier>*</modifier></type><name>dependencies</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type>	<name>cxt</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Transform the bms into an array, to make accessing i-th member easier.
	 */</comment>
	<expr_stmt><expr><name>attnums</name> <operator>=</operator> <call><name>build_attnums_array</name><argument_list>(<argument><expr><name>attrs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numattrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numattrs</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* tracks memory allocated by dependency_degree calls */</comment>
	<expr_stmt><expr><name>cxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
								<argument><expr><literal type="string">"dependency_degree cxt"</literal></expr></argument>,
								<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We'll try build functional dependencies starting from the smallest ones
	 * covering just 2 columns, to the largest ones, covering all columns
	 * included in the statistics object.  We start from the smallest ones
	 * because we want to be able to skip already implied ones.
	 */</comment>
	<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;=</operator> <name>numattrs</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>dependency</name></decl>;</decl_stmt> <comment type="block">/* array with k elements */</comment>

		<comment type="block">/* prepare a DependencyGenerator of variation */</comment>
		<decl_stmt><decl><type><name>DependencyGenerator</name></type> <name>DependencyGenerator</name> <init>= <expr><call><name>DependencyGenerator_init</name><argument_list>(<argument><expr><name>numattrs</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* generate all possible variations of k values (out of n) */</comment>
		<while>while <condition>(<expr><operator>(</operator><name>dependency</name> <operator>=</operator> <call><name>DependencyGenerator_next</name><argument_list>(<argument><expr><name>DependencyGenerator</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>double</name></type>		<name>degree</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>MVDependency</name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

			<comment type="block">/* release memory used by dependency degree calculation */</comment>
			<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* compute how valid the dependency seems */</comment>
			<expr_stmt><expr><name>degree</name> <operator>=</operator> <call><name>dependency_degree</name><argument_list>(<argument><expr><name>numrows</name></expr></argument>, <argument><expr><name>rows</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>dependency</name></expr></argument>, <argument><expr><name>stats</name></expr></argument>, <argument><expr><name>attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * if the dependency seems entirely invalid, don't store it
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>degree</name> <operator>==</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>d</name> <operator>=</operator> <operator>(</operator><name>MVDependency</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MVDependency</name></expr></argument>, <argument><expr><name>attributes</name></expr></argument>)</argument_list></call>
										 <operator>+</operator> <name>k</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* copy the dependency (and keep the indexes into stxkeys) */</comment>
			<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>degree</name></name> <operator>=</operator> <name>degree</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>nattributes</name></name> <operator>=</operator> <name>k</name></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>k</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>attributes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>attnums</name><index>[<expr><name><name>dependency</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

			<comment type="block">/* initialize the list of dependencies */</comment>
			<if_stmt><if>if <condition>(<expr><name>dependencies</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>dependencies</name>
					<operator>=</operator> <operator>(</operator><name>MVDependencies</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MVDependencies</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>dependencies</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>STATS_DEPS_MAGIC</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>dependencies</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>STATS_DEPS_TYPE_BASIC</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>dependencies</name><operator>-&gt;</operator><name>ndeps</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>dependencies</name><operator>-&gt;</operator><name>ndeps</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>dependencies</name> <operator>=</operator> <operator>(</operator><name>MVDependencies</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name>dependencies</name></expr></argument>,
													   <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MVDependencies</name></expr></argument>, <argument><expr><name>deps</name></expr></argument>)</argument_list></call>
													   <operator>+</operator> <name><name>dependencies</name><operator>-&gt;</operator><name>ndeps</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MVDependency</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>dependencies</name><operator>-&gt;</operator><name>deps</name><index>[<expr><name><name>dependencies</name><operator>-&gt;</operator><name>ndeps</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
		</block_content>}</block></while>

		<comment type="block">/*
		 * we're done with variations of k elements, so free the
		 * DependencyGenerator
		 */</comment>
		<expr_stmt><expr><call><name>DependencyGenerator_free</name><argument_list>(<argument><expr><name>DependencyGenerator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>dependencies</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Serialize list of dependencies into a bytea value.
 */</comment>
<function><type><name>bytea</name> <modifier>*</modifier></type>
<name>statext_dependencies_serialize</name><parameter_list>(<parameter><decl><type><name>MVDependencies</name> <modifier>*</modifier></type><name>dependencies</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>output</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>len</name></decl>;</decl_stmt>

	<comment type="block">/* we need to store ndeps, with a number of attributes for each one */</comment>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <name>VARHDRSZ</name> <operator>+</operator> <name>SizeOfHeader</name></expr>;</expr_stmt>

	<comment type="block">/* and also include space for the actual attribute numbers and degrees */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>dependencies</name><operator>-&gt;</operator><name>ndeps</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>SizeOfItem</name><argument_list>(<argument><expr><name><name>dependencies</name><operator>-&gt;</operator><name>deps</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nattributes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><name>output</name> <operator>=</operator> <operator>(</operator><name>bytea</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>VARDATA</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Store the base struct values (magic, type, ndeps) */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dependencies</name><operator>-&gt;</operator><name>magic</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmp</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dependencies</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmp</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dependencies</name><operator>-&gt;</operator><name>ndeps</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmp</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<comment type="block">/* store number of attributes and attribute numbers for each dependency */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>dependencies</name><operator>-&gt;</operator><name>ndeps</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MVDependency</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><name><name>dependencies</name><operator>-&gt;</operator><name>deps</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>degree</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tmp</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>nattributes</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tmp</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>attributes</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>d</name><operator>-&gt;</operator><name>nattributes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tmp</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>d</name><operator>-&gt;</operator><name>nattributes</name></name></expr>;</expr_stmt>

		<comment type="block">/* protect against overflow */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tmp</name> <operator>&lt;=</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>output</name> <operator>+</operator> <name>len</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* make sure we've produced exactly the right amount of data */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tmp</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>output</name> <operator>+</operator> <name>len</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>output</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Reads serialized dependencies into MVDependencies structure.
 */</comment>
<function><type><name>MVDependencies</name> <modifier>*</modifier></type>
<name>statext_dependencies_deserialize</name><parameter_list>(<parameter><decl><type><name>bytea</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>min_expected_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MVDependencies</name> <modifier>*</modifier></type><name>dependencies</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>data</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>SizeOfHeader</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid MVDependencies size %zd (expected at least %zd)"</literal></expr></argument>,
			 <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SizeOfHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* read the MVDependencies header */</comment>
	<expr_stmt><expr><name>dependencies</name> <operator>=</operator> <operator>(</operator><name>MVDependencies</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MVDependencies</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* initialize pointer to the data part (skip the varlena header) */</comment>
	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* read the header fields and perform basic sanity checks */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dependencies</name><operator>-&gt;</operator><name>magic</name></name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmp</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dependencies</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmp</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dependencies</name><operator>-&gt;</operator><name>ndeps</name></name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmp</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dependencies</name><operator>-&gt;</operator><name>magic</name></name> <operator>!=</operator> <name>STATS_DEPS_MAGIC</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid dependency magic %d (expected %d)"</literal></expr></argument>,
			 <argument><expr><name><name>dependencies</name><operator>-&gt;</operator><name>magic</name></name></expr></argument>, <argument><expr><name>STATS_DEPS_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dependencies</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>STATS_DEPS_TYPE_BASIC</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid dependency type %d (expected %d)"</literal></expr></argument>,
			 <argument><expr><name><name>dependencies</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>STATS_DEPS_TYPE_BASIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dependencies</name><operator>-&gt;</operator><name>ndeps</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid zero-length item array in MVDependencies"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* what minimum bytea size do we expect for those parameters */</comment>
	<expr_stmt><expr><name>min_expected_size</name> <operator>=</operator> <call><name>SizeOfItem</name><argument_list>(<argument><expr><name><name>dependencies</name><operator>-&gt;</operator><name>ndeps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>min_expected_size</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid dependencies size %zd (expected at least %zd)"</literal></expr></argument>,
			 <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>min_expected_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* allocate space for the MCV items */</comment>
	<expr_stmt><expr><name>dependencies</name> <operator>=</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name>dependencies</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MVDependencies</name></expr></argument>, <argument><expr><name>deps</name></expr></argument>)</argument_list></call>
							<operator>+</operator> <operator>(</operator><name><name>dependencies</name><operator>-&gt;</operator><name>ndeps</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MVDependency</name> <operator>*</operator></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>dependencies</name><operator>-&gt;</operator><name>ndeps</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>		<name>degree</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>k</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MVDependency</name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>

		<comment type="block">/* degree of validity */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>degree</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tmp</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

		<comment type="block">/* number of attributes */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>k</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tmp</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

		<comment type="block">/* is the number of attributes valid? */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>k</name> <operator>&gt;=</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>k</name> <operator>&lt;=</operator> <name>STATS_MAX_DIMENSIONS</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* now that we know the number of attributes, allocate the dependency */</comment>
		<expr_stmt><expr><name>d</name> <operator>=</operator> <operator>(</operator><name>MVDependency</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MVDependency</name></expr></argument>, <argument><expr><name>attributes</name></expr></argument>)</argument_list></call>
									 <operator>+</operator> <operator>(</operator><name>k</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>degree</name></name> <operator>=</operator> <name>degree</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>nattributes</name></name> <operator>=</operator> <name>k</name></expr>;</expr_stmt>

		<comment type="block">/* copy attribute numbers */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>attributes</name></name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>d</name><operator>-&gt;</operator><name>nattributes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tmp</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>d</name><operator>-&gt;</operator><name>nattributes</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>dependencies</name><operator>-&gt;</operator><name>deps</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>

		<comment type="block">/* still within the bytea */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tmp</name> <operator>&lt;=</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>data</name> <operator>+</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* we should have consumed the whole bytea exactly */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tmp</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>data</name> <operator>+</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>dependencies</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * dependency_is_fully_matched
 *		checks that a functional dependency is fully matched given clauses on
 *		attributes (assuming the clauses are suitable equality clauses)
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>dependency_is_fully_matched</name><parameter_list>(<parameter><decl><type><name>MVDependency</name> <modifier>*</modifier></type><name>dependency</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>attnums</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check that the dependency actually is fully covered by clauses. We have
	 * to translate all attribute numbers, as those are referenced
	 */</comment>
	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>dependency</name><operator>-&gt;</operator><name>nattributes</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><name><name>dependency</name><operator>-&gt;</operator><name>attributes</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>attnums</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * statext_dependencies_load
 *		Load the functional dependencies for the indicated pg_statistic_ext tuple
 */</comment>
<function><type><name>MVDependencies</name> <modifier>*</modifier></type>
<name>statext_dependencies_load</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>mvoid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MVDependencies</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>deps</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>htup</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>htup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>STATEXTDATASTXOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>mvoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for statistics object %u"</literal></expr></argument>, <argument><expr><name>mvoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>deps</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>STATEXTDATASTXOID</name></expr></argument>, <argument><expr><name>htup</name></expr></argument>,
						   <argument><expr><name>Anum_pg_statistic_ext_data_stxddependencies</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			 <argument><expr><literal type="string">"requested statistics kind \"%c\" is not yet built for statistics object %u"</literal></expr></argument>,
			 <argument><expr><name>STATS_EXT_DEPENDENCIES</name></expr></argument>, <argument><expr><name>mvoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>statext_dependencies_deserialize</name><argument_list>(<argument><expr><call><name>DatumGetByteaPP</name><argument_list>(<argument><expr><name>deps</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pg_dependencies_in		- input routine for type pg_dependencies.
 *
 * pg_dependencies is real enough to be a table column, but it has no operations
 * of its own, and disallows input too
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_dependencies_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * pg_node_list stores the data in binary form and parsing text input is
	 * not needed, so disallow this.
	 */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot accept a value of type %s"</literal></expr></argument>, <argument><expr><literal type="string">"pg_dependencies"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>			<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * pg_dependencies		- output routine for type pg_dependencies.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_dependencies_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>data</name> <init>= <expr><call><name>PG_GETARG_BYTEA_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MVDependencies</name> <modifier>*</modifier></type><name>dependencies</name> <init>= <expr><call><name>statext_dependencies_deserialize</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>str</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>dependencies</name><operator>-&gt;</operator><name>ndeps</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MVDependency</name> <modifier>*</modifier></type><name>dependency</name> <init>= <expr><name><name>dependencies</name><operator>-&gt;</operator><name>deps</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>dependency</name><operator>-&gt;</operator><name>nattributes</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <name><name>dependency</name><operator>-&gt;</operator><name>nattributes</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">" =&gt; "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>dependency</name><operator>-&gt;</operator><name>attributes</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"\": %f"</literal></expr></argument>, <argument><expr><name><name>dependency</name><operator>-&gt;</operator><name>degree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name><name>str</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_dependencies_recv		- binary input routine for type pg_dependencies.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_dependencies_recv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot accept a value of type %s"</literal></expr></argument>, <argument><expr><literal type="string">"pg_dependencies"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>			<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * pg_dependencies_send		- binary output routine for type pg_dependencies.
 *
 * Functional dependencies are serialized in a bytea value (although the type
 * is named differently), so let's just send that.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_dependencies_send</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>byteasend</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * dependency_is_compatible_clause
 *		Determines if the clause is compatible with functional dependencies
 *
 * Only clauses that have the form of equality to a pseudoconstant, or can be
 * interpreted that way, are currently accepted.  Furthermore the variable
 * part of the clause must be a simple Var belonging to the specified
 * relation, whose attribute number we return in *attnum on success.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>dependency_is_compatible_clause</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>RestrictInfo</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Pseudoconstants are not interesting (they couldn't contain a Var) */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>pseudoconstant</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Clauses referencing multiple, or no, varnos are incompatible */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>bms_membership</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause_relids</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>BMS_SINGLETON</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>clause</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>is_opclause</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* If it's an opclause, check for Var = Const or Const = Var. */</comment>
		<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Only expressions with two arguments are candidates. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Make sure non-selected argument is a pseudoconstant. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>is_pseudo_constant_clause</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>is_pseudo_constant_clause</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * If it's not an "=" operator, just ignore the clause, as it's not
		 * compatible with functional dependencies.
		 *
		 * This uses the function for estimating selectivity, not the operator
		 * directly (a bit awkward, but well ...).
		 *
		 * XXX this is pretty dubious; probably it'd be better to check btree
		 * or hash opclass membership, so as not to be fooled by custom
		 * selectivity functions, and to be more consistent with decisions
		 * elsewhere in the planner.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>get_oprrest</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>F_EQSEL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* OK to proceed with checking "var" */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>ScalarArrayOpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* If it's an scalar array operator, check for Var IN Const. */</comment>
		<decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Reject ALL() variant, we only care about ANY/IN.
		 *
		 * FIXME Maybe we should check if all the values are the same, and
		 * allow ALL in that case? Doesn't seem very practical, though.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>expr</name><operator>-&gt;</operator><name>useOr</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Only expressions with two arguments are candidates. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We know it's always (Var IN Const), so we assume the var is the
		 * first argument, and pseudoconstant is the second one.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_pseudo_constant_clause</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If it's not an "=" operator, just ignore the clause, as it's not
		 * compatible with functional dependencies. The operator is identified
		 * simply by looking at which function it uses to estimate
		 * selectivity. That's a bit strange, but it's what other similar
		 * places do.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>get_oprrest</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>F_EQSEL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* OK to proceed with checking "var" */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>is_orclause</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BoolExpr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<comment type="block">/* start with no attribute number */</comment>
		<expr_stmt><expr><operator>*</operator><name>attnum</name> <operator>=</operator> <name>InvalidAttrNumber</name></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>expr-&gt;args</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>clause_attnum</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Had we found incompatible clause in the arguments, treat the
			 * whole clause as incompatible.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dependency_is_compatible_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><name>relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>clause_attnum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>attnum</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>attnum</name> <operator>=</operator> <name>clause_attnum</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>attnum</name> <operator>!=</operator> <name>clause_attnum</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/* the Var is already checked by the recursive call */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>is_notclause</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * "NOT x" can be interpreted as "x = false", so get the argument and
		 * proceed with seeing if it's a suitable Var.
		 */</comment>
		<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>get_notclausearg</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * A boolean expression "x" can be interpreted as "x = true", so
		 * proceed with seeing if it's a suitable Var.
		 */</comment>
		<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * We may ignore any RelabelType node above the operand.  (There won't be
	 * more than one, since eval_const_expressions has been applied already.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>var</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* We only support plain Vars for now */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Ensure Var is from the correct relation */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>!=</operator> <name>relid</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* We also better ensure the Var is from the current level */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Also ignore system attributes (we don't allow stats on those) */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AttrNumberIsForUserDefinedAttr</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>attnum</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * find_strongest_dependency
 *		find the strongest dependency on the attributes
 *
 * When applying functional dependencies, we start with the strongest
 * dependencies. That is, we select the dependency that:
 *
 * (a) has all attributes covered by equality clauses
 *
 * (b) has the most attributes
 *
 * (c) has the highest degree of validity
 *
 * This guarantees that we eliminate the most redundant conditions first
 * (see the comment in dependencies_clauselist_selectivity).
 */</comment>
<function><type><specifier>static</specifier> <name>MVDependency</name> <modifier>*</modifier></type>
<name>find_strongest_dependency</name><parameter_list>(<parameter><decl><type><name>MVDependencies</name> <modifier>*</modifier><modifier>*</modifier></type><name>dependencies</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ndependencies</name></decl></parameter>,
						  <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>attnums</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MVDependency</name> <modifier>*</modifier></type><name>strongest</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* number of attnums in clauses */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nattnums</name> <init>= <expr><call><name>bms_num_members</name><argument_list>(<argument><expr><name>attnums</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Iterate over the MVDependency items and find the strongest one from the
	 * fully-matched dependencies. We do the cheap checks first, before
	 * matching it against the attnums.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndependencies</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>dependencies</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ndeps</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MVDependency</name> <modifier>*</modifier></type><name>dependency</name> <init>= <expr><name><name>dependencies</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>deps</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Skip dependencies referencing more attributes than available
			 * clauses, as those can't be fully matched.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>dependency</name><operator>-&gt;</operator><name>nattributes</name></name> <operator>&gt;</operator> <name>nattnums</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>strongest</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* skip dependencies on fewer attributes than the strongest. */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>dependency</name><operator>-&gt;</operator><name>nattributes</name></name> <operator>&lt;</operator> <name><name>strongest</name><operator>-&gt;</operator><name>nattributes</name></name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<comment type="block">/* also skip weaker dependencies when attribute count matches */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>strongest</name><operator>-&gt;</operator><name>nattributes</name></name> <operator>==</operator> <name><name>dependency</name><operator>-&gt;</operator><name>nattributes</name></name> <operator>&amp;&amp;</operator>
					<name><name>strongest</name><operator>-&gt;</operator><name>degree</name></name> <operator>&gt;</operator> <name><name>dependency</name><operator>-&gt;</operator><name>degree</name></name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * this dependency is stronger, but we must still check that it's
			 * fully matched to these attnums. We perform this check last as
			 * it's slightly more expensive than the previous checks.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>dependency_is_fully_matched</name><argument_list>(<argument><expr><name>dependency</name></expr></argument>, <argument><expr><name>attnums</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>strongest</name> <operator>=</operator> <name>dependency</name></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* save new best match */</comment>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<return>return <expr><name>strongest</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * clauselist_apply_dependencies
 *		Apply the specified functional dependencies to a list of clauses and
 *		return the estimated selecvitity of the clauses that are compatible
 *		with any of the given dependencies.
 *
 * This will estimate all not-already-estimated clauses that are compatible
 * with functional dependencies, and which have an attribute mentioned by any
 * of the given dependencies (either as an implying or implied attribute).
 *
 * Given (lists of) clauses on attributes (a,b) and a functional dependency
 * (a=&gt;b), the per-column selectivities P(a) and P(b) are notionally combined
 * using the formula
 *
 *		P(a,b) = f * P(a) + (1-f) * P(a) * P(b)
 *
 * where 'f' is the degree of dependency.  This reflects the fact that we
 * expect a fraction f of all rows to be consistent with the dependency
 * (a=&gt;b), and so have a selectivity of P(a), while the remaining rows are
 * treated as independent.
 *
 * In practice, we use a slightly modified version of this formula, which uses
 * a selectivity of Min(P(a), P(b)) for the dependent rows, since the result
 * should obviously not exceed either column's individual selectivity.  I.e.,
 * we actually combine selectivities using the formula
 *
 *		P(a,b) = f * Min(P(a), P(b)) + (1-f) * P(a) * P(b)
 *
 * This can make quite a difference if the specific values matching the
 * clauses are not consistent with the functional dependency.
 */</comment>
<function><type><specifier>static</specifier> <name>Selectivity</name></type>
<name>clauselist_apply_dependencies</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>,
							  <parameter><decl><type><name>int</name></type> <name>varRelid</name></decl></parameter>, <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
							  <parameter><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name></decl></parameter>,
							  <parameter><decl><type><name>MVDependency</name> <modifier>*</modifier><modifier>*</modifier></type><name>dependencies</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ndependencies</name></decl></parameter>,
							  <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>list_attnums</name></decl></parameter>,
							  <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier><modifier>*</modifier></type><name>estimatedclauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>attnums</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nattrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Selectivity</name> <modifier>*</modifier></type><name>attr_sel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attidx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>listidx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>s1</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Extract the attnums of all implying and implied attributes from all the
	 * given dependencies.  Each of these attributes is expected to have at
	 * least 1 not-already-estimated compatible clause that we will estimate
	 * here.
	 */</comment>
	<expr_stmt><expr><name>attnums</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndependencies</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>dependencies</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nattributes</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name> <init>= <expr><name><name>dependencies</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>attributes</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>attnums</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>attnums</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Compute per-column selectivity estimates for each of these attributes,
	 * and mark all the corresponding clauses as estimated.
	 */</comment>
	<expr_stmt><expr><name>nattrs</name> <operator>=</operator> <call><name>bms_num_members</name><argument_list>(<argument><expr><name>attnums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attr_sel</name> <operator>=</operator> <operator>(</operator><name>Selectivity</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Selectivity</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nattrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>attidx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>attnums</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>attr_clauses</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Selectivity</name></type> <name>simple_sel</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>listidx</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>clauses</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>clause</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>listidx</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>list_attnums</name><index>[<expr><name>listidx</name></expr>]</index></name> <operator>==</operator> <name>i</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>attr_clauses</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>attr_clauses</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>estimatedclauses</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><operator>*</operator><name>estimatedclauses</name></expr></argument>, <argument><expr><name>listidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<expr_stmt><expr><name>simple_sel</name> <operator>=</operator> <call><name>clauselist_selectivity_simple</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>attr_clauses</name></expr></argument>, <argument><expr><name>varRelid</name></expr></argument>,
												   <argument><expr><name>jointype</name></expr></argument>, <argument><expr><name>sjinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>attr_sel</name><index>[<expr><name>attidx</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>simple_sel</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Now combine these selectivities using the dependency information.  For
	 * chains of dependencies such as a -&gt; b -&gt; c, the b -&gt; c dependency will
	 * come before the a -&gt; b dependency in the array, so we traverse the
	 * array backwards to ensure such chains are computed in the right order.
	 *
	 * As explained above, pairs of selectivities are combined using the
	 * formula
	 *
	 * P(a,b) = f * Min(P(a), P(b)) + (1-f) * P(a) * P(b)
	 *
	 * to ensure that the combined selectivity is never greater than either
	 * individual selectivity.
	 *
	 * Where multiple dependencies apply (e.g., a -&gt; b -&gt; c), we use
	 * conditional probabilities to compute the overall result as follows:
	 *
	 * P(a,b,c) = P(c|a,b) * P(a,b) = P(c|a,b) * P(b|a) * P(a)
	 *
	 * so we replace the selectivities of all implied attributes with
	 * conditional probabilities, that are conditional on all their implying
	 * attributes.  The selectivities of all other non-implied attributes are
	 * left as they are.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>ndependencies</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MVDependency</name> <modifier>*</modifier></type><name>dependency</name> <init>= <expr><name><name>dependencies</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Selectivity</name></type> <name>s2</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>f</name></decl>;</decl_stmt>

		<comment type="block">/* Selectivity of all the implying attributes */</comment>
		<expr_stmt><expr><name>s1</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>dependency</name><operator>-&gt;</operator><name>nattributes</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>dependency</name><operator>-&gt;</operator><name>attributes</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>attidx</name> <operator>=</operator> <call><name>bms_member_index</name><argument_list>(<argument><expr><name>attnums</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>s1</name> <operator>*=</operator> <name><name>attr_sel</name><index>[<expr><name>attidx</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Original selectivity of the implied attribute */</comment>
		<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>dependency</name><operator>-&gt;</operator><name>attributes</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>attidx</name> <operator>=</operator> <call><name>bms_member_index</name><argument_list>(<argument><expr><name>attnums</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>s2</name> <operator>=</operator> <name><name>attr_sel</name><index>[<expr><name>attidx</name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Replace s2 with the conditional probability s2 given s1, computed
		 * using the formula P(b|a) = P(a,b) / P(a), which simplifies to
		 *
		 * P(b|a) = f * Min(P(a), P(b)) / P(a) + (1-f) * P(b)
		 *
		 * where P(a) = s1, the selectivity of the implying attributes, and
		 * P(b) = s2, the selectivity of the implied attribute.
		 */</comment>
		<expr_stmt><expr><name>f</name> <operator>=</operator> <name><name>dependency</name><operator>-&gt;</operator><name>degree</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>s1</name> <operator>&lt;=</operator> <name>s2</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>attr_sel</name><index>[<expr><name>attidx</name></expr>]</index></name> <operator>=</operator> <name>f</name> <operator>+</operator> <operator>(</operator><literal type="number">1</literal> <operator>-</operator> <name>f</name><operator>)</operator> <operator>*</operator> <name>s2</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>attr_sel</name><index>[<expr><name>attidx</name></expr>]</index></name> <operator>=</operator> <name>f</name> <operator>*</operator> <name>s2</name> <operator>/</operator> <name>s1</name> <operator>+</operator> <operator>(</operator><literal type="number">1</literal> <operator>-</operator> <name>f</name><operator>)</operator> <operator>*</operator> <name>s2</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * The overall selectivity of all the clauses on all these attributes is
	 * then the product of all the original (non-implied) probabilities and
	 * the new conditional (implied) probabilities.
	 */</comment>
	<expr_stmt><expr><name>s1</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nattrs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>s1</name> <operator>*=</operator> <name><name>attr_sel</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>CLAMP_PROBABILITY</name><argument_list>(<argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>attr_sel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>attnums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>s1</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * dependencies_clauselist_selectivity
 *		Return the estimated selectivity of (a subset of) the given clauses
 *		using functional dependency statistics, or 1.0 if no useful functional
 *		dependency statistic exists.
 *
 * 'estimatedclauses' is an input/output argument that gets a bit set
 * corresponding to the (zero-based) list index of each clause that is included
 * in the estimated selectivity.
 *
 * Given equality clauses on attributes (a,b) we find the strongest dependency
 * between them, i.e. either (a=&gt;b) or (b=&gt;a). Assuming (a=&gt;b) is the selected
 * dependency, we then combine the per-clause selectivities using the formula
 *
 *	   P(a,b) = f * P(a) + (1-f) * P(a) * P(b)
 *
 * where 'f' is the degree of the dependency.  (Actually we use a slightly
 * modified version of this formula -- see clauselist_apply_dependencies()).
 *
 * With clauses on more than two attributes, the dependencies are applied
 * recursively, starting with the widest/strongest dependencies. For example
 * P(a,b,c) is first split like this:
 *
 *	   P(a,b,c) = f * P(a,b) + (1-f) * P(a,b) * P(c)
 *
 * assuming (a,b=&gt;c) is the strongest dependency.
 */</comment>
<function><type><name>Selectivity</name></type>
<name>dependencies_clauselist_selectivity</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
									<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>,
									<parameter><decl><type><name>int</name></type> <name>varRelid</name></decl></parameter>,
									<parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
									<parameter><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name></decl></parameter>,
									<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
									<parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier><modifier>*</modifier></type><name>estimatedclauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>s1</name> <init>= <expr><literal type="number">1.0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>clauses_attnums</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>list_attnums</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>listidx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MVDependencies</name> <modifier>*</modifier><modifier>*</modifier></type><name>func_dependencies</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nfunc_dependencies</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>total_ndeps</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MVDependency</name> <modifier>*</modifier><modifier>*</modifier></type><name>dependencies</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndependencies</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * When dealing with regular inheritance trees, ignore extended stats
	 * (which were built without data from child rels, and thus do not
	 * represent them). For partitioned tables data there's no data in the
	 * non-leaf relations, so we build stats only for the inheritance tree.
	 * So for partitioned tables we do consider extended stats.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name> <operator>&amp;&amp;</operator> <name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1.0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* check if there's any stats that might be useful for us. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>has_stats_of_kind</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>statlist</name></name></expr></argument>, <argument><expr><name>STATS_EXT_DEPENDENCIES</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1.0</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>list_attnums</name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator>
										 <call><name>list_length</name><argument_list>(<argument><expr><name>clauses</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Pre-process the clauses list to extract the attnums seen in each item.
	 * We need to determine if there's any clauses which will be useful for
	 * dependency selectivity estimations. Along the way we'll record all of
	 * the attnums for each clause in a list which we'll reference later so we
	 * don't need to repeat the same work again. We'll also keep track of all
	 * attnums seen.
	 *
	 * We also skip clauses that we already estimated using different types of
	 * statistics (we treat them as incompatible).
	 */</comment>
	<expr_stmt><expr><name>listidx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>clauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>clause</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>listidx</name></expr></argument>, <argument><expr><operator>*</operator><name>estimatedclauses</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>dependency_is_compatible_clause</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>list_attnums</name><index>[<expr><name>listidx</name></expr>]</index></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>clauses_attnums</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>clauses_attnums</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>list_attnums</name><index>[<expr><name>listidx</name></expr>]</index></name> <operator>=</operator> <name>InvalidAttrNumber</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>listidx</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If there's not at least two distinct attnums then reject the whole list
	 * of clauses. We must return 1.0 so the calling function's selectivity is
	 * unaffected.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>bms_num_members</name><argument_list>(<argument><expr><name>clauses_attnums</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>clauses_attnums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>list_attnums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">1.0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Load all functional dependencies matching at least two parameters. We
	 * can simply consider all dependencies at once, without having to search
	 * for the best statistics object.
	 *
	 * To not waste cycles and memory, we deserialize dependencies only for
	 * statistics that match at least two attributes. The array is allocated
	 * with the assumption that all objects match - we could grow the array to
	 * make it just the right size, but it's likely wasteful anyway thanks to
	 * moving the freed chunks to freelists etc.
	 */</comment>
	<expr_stmt><expr><name>func_dependencies</name> <operator>=</operator> <operator>(</operator><name>MVDependencies</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MVDependencies</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator>
												   <call><name>list_length</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>statlist</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nfunc_dependencies</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>total_ndeps</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>rel-&gt;statlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StatisticExtInfo</name> <modifier>*</modifier></type><name>stat</name> <init>= <expr><operator>(</operator><name>StatisticExtInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>matched</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>num_matched</name></decl>;</decl_stmt>

		<comment type="block">/* skip statistics that are not of the correct type */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>stat</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <name>STATS_EXT_DEPENDENCIES</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>matched</name> <operator>=</operator> <call><name>bms_intersect</name><argument_list>(<argument><expr><name>clauses_attnums</name></expr></argument>, <argument><expr><name><name>stat</name><operator>-&gt;</operator><name>keys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>num_matched</name> <operator>=</operator> <call><name>bms_num_members</name><argument_list>(<argument><expr><name>matched</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>matched</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* skip objects matching fewer than two attributes from clauses */</comment>
		<if_stmt><if>if <condition>(<expr><name>num_matched</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>func_dependencies</name><index>[<expr><name>nfunc_dependencies</name></expr>]</index></name>
			<operator>=</operator> <call><name>statext_dependencies_load</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>statOid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>total_ndeps</name> <operator>+=</operator> <name><name>func_dependencies</name><index>[<expr><name>nfunc_dependencies</name></expr>]</index></name><operator>-&gt;</operator><name>ndeps</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nfunc_dependencies</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* if no matching stats could be found then we've nothing to do */</comment>
	<if_stmt><if>if <condition>(<expr><name>nfunc_dependencies</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>func_dependencies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>clauses_attnums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>list_attnums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">1.0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Work out which dependencies we can apply, starting with the
	 * widest/stongest ones, and proceeding to smaller/weaker ones.
	 */</comment>
	<expr_stmt><expr><name>dependencies</name> <operator>=</operator> <operator>(</operator><name>MVDependency</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MVDependency</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator>
											<name>total_ndeps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ndependencies</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MVDependency</name> <modifier>*</modifier></type><name>dependency</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>

		<comment type="block">/* the widest/strongest dependency, fully matched by clauses */</comment>
		<expr_stmt><expr><name>dependency</name> <operator>=</operator> <call><name>find_strongest_dependency</name><argument_list>(<argument><expr><name>func_dependencies</name></expr></argument>,
											   <argument><expr><name>nfunc_dependencies</name></expr></argument>,
											   <argument><expr><name>clauses_attnums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dependency</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>dependencies</name><index>[<expr><name>ndependencies</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>dependency</name></expr>;</expr_stmt>

		<comment type="block">/* Ignore dependencies using this implied attribute in later loops */</comment>
		<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>dependency</name><operator>-&gt;</operator><name>attributes</name><index>[<expr><name><name>dependency</name><operator>-&gt;</operator><name>nattributes</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>clauses_attnums</name> <operator>=</operator> <call><name>bms_del_member</name><argument_list>(<argument><expr><name>clauses_attnums</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * If we found applicable dependencies, use them to estimate all
	 * compatible clauses on attributes that they refer to.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ndependencies</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>s1</name> <operator>=</operator> <call><name>clauselist_apply_dependencies</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>clauses</name></expr></argument>, <argument><expr><name>varRelid</name></expr></argument>, <argument><expr><name>jointype</name></expr></argument>,
										   <argument><expr><name>sjinfo</name></expr></argument>, <argument><expr><name>dependencies</name></expr></argument>, <argument><expr><name>ndependencies</name></expr></argument>,
										   <argument><expr><name>list_attnums</name></expr></argument>, <argument><expr><name>estimatedclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* free deserialized functional dependencies (and then the array) */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nfunc_dependencies</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>func_dependencies</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>dependencies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>func_dependencies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>clauses_attnums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>list_attnums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>s1</name></expr>;</return>
</block_content>}</block></function>
</unit>
