<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/storage/lmgr/lmgr.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * lmgr.c
 *	  POSTGRES lock manager code
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/storage/lmgr/lmgr.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/subtrans.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/progress.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/sinvaladt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>


<comment type="block">/*
 * Per-backend counter for generating speculative insertion tokens.
 *
 * This may wrap around, but that's OK as it's only used for the short
 * duration between inserting a tuple and checking that there are no (unique)
 * constraint violations.  It's theoretically possible that a backend sees a
 * tuple that was speculatively inserted by another backend, but before it has
 * started waiting on the token, the other backend completes its insertion,
 * and then performs 2^32 unrelated insertions.  And after all that, the
 * first backend finally calls SpeculativeInsertionLockAcquire(), with the
 * intention of waiting for the first insertion to complete, but ends up
 * waiting for the latest unrelated insertion instead.  Even then, nothing
 * particularly bad happens: in the worst case they deadlock, causing one of
 * the transactions to abort.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint32</name></type> <name>speculativeInsertionToken</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<comment type="block">/*
 * Struct to hold context info for transaction lock waits.
 *
 * 'oper' is the operation that needs to wait for the other transaction; 'rel'
 * and 'ctid' specify the address of the tuple being waited for.
 */</comment>
<typedef>typedef <type><struct>struct <name>XactLockTableWaitInfo</name>
<block>{
	<decl_stmt><decl><type><name>XLTW_Oper</name></type>	<name>oper</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointer</name></type> <name>ctid</name></decl>;</decl_stmt>
}</block></struct></type> <name>XactLockTableWaitInfo</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>XactLockTableWaitErrorCb</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * RelationInitLockInfo
 *		Initializes the lock information in a relation descriptor.
 *
 *		relcache.c must call this during creation of any reldesc.
 */</comment>
<function><type><name>void</name></type>
<name>RelationInitLockInfo</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RelationIsValid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>relId</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relisshared</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>dbId</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>dbId</name></name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SetLocktagRelationOid
 *		Set up a locktag for a relation, given only relation OID
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>SetLocktagRelationOid</name><parameter_list>(<parameter><decl><type><name>LOCKTAG</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>dbid</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsSharedRelation</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>dbid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>dbid</name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>SET_LOCKTAG_RELATION</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>dbid</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		LockRelationOid
 *
 * Lock a relation given only its OID.  This should generally be used
 * before attempting to open the relation's relcache entry.
 */</comment>
<function><type><name>void</name></type>
<name>LockRelationOid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCALLOCK</name>  <modifier>*</modifier></type><name>locallock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LockAcquireResult</name></type> <name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SetLocktagRelationOid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>LockAcquireExtended</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>locallock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now that we have the lock, check for invalidation messages, so that we
	 * will update or flush any stale relcache entry before we try to use it.
	 * RangeVarGetRelid() specifically relies on us for this.  We can skip
	 * this in the not-uncommon case that we already had the same type of lock
	 * being requested, since then no one else could have modified the
	 * relcache entry in an undesirable way.  (In the case where our own xact
	 * modifies the rel, the relcache update happens via
	 * CommandCounterIncrement, not here.)
	 *
	 * However, in corner cases where code acts on tables (usually catalogs)
	 * recursively, we might get here while still processing invalidation
	 * messages in some outer execution of this function or a sibling.  The
	 * "cleared" status of the lock tells us whether we really are done
	 * absorbing relevant inval messages.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>LOCKACQUIRE_ALREADY_CLEAR</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AcceptInvalidationMessages</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkLockClear</name><argument_list>(<argument><expr><name>locallock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		ConditionalLockRelationOid
 *
 * As above, but only lock if we can get the lock without blocking.
 * Returns true iff the lock was acquired.
 *
 * NOTE: we do not currently need conditional versions of all the
 * LockXXX routines in this file, but they could easily be added if needed.
 */</comment>
<function><type><name>bool</name></type>
<name>ConditionalLockRelationOid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCALLOCK</name>  <modifier>*</modifier></type><name>locallock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LockAcquireResult</name></type> <name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SetLocktagRelationOid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>LockAcquireExtended</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>locallock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>LOCKACQUIRE_NOT_AVAIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Now that we have the lock, check for invalidation messages; see notes
	 * in LockRelationOid.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>LOCKACQUIRE_ALREADY_CLEAR</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AcceptInvalidationMessages</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkLockClear</name><argument_list>(<argument><expr><name>locallock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		UnlockRelationId
 *
 * Unlock, given a LockRelId.  This is preferred over UnlockRelationOid
 * for speed reasons.
 */</comment>
<function><type><name>void</name></type>
<name>UnlockRelationId</name><parameter_list>(<parameter><decl><type><name>LockRelId</name> <modifier>*</modifier></type><name>relid</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_LOCKTAG_RELATION</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name><name>relid</name><operator>-&gt;</operator><name>dbId</name></name></expr></argument>, <argument><expr><name><name>relid</name><operator>-&gt;</operator><name>relId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		UnlockRelationOid
 *
 * Unlock, given only a relation Oid.  Use UnlockRelationId if you can.
 */</comment>
<function><type><name>void</name></type>
<name>UnlockRelationOid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SetLocktagRelationOid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		LockRelation
 *
 * This is a convenience routine for acquiring an additional lock on an
 * already-open relation.  Never try to do "relation_open(foo, NoLock)"
 * and then lock with this.
 */</comment>
<function><type><name>void</name></type>
<name>LockRelation</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCALLOCK</name>  <modifier>*</modifier></type><name>locallock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LockAcquireResult</name></type> <name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_LOCKTAG_RELATION</name><argument_list>(<argument><expr><name>tag</name></expr></argument>,
						 <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>dbId</name></name></expr></argument>,
						 <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>relId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>LockAcquireExtended</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>locallock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now that we have the lock, check for invalidation messages; see notes
	 * in LockRelationOid.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>LOCKACQUIRE_ALREADY_CLEAR</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AcceptInvalidationMessages</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkLockClear</name><argument_list>(<argument><expr><name>locallock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		ConditionalLockRelation
 *
 * This is a convenience routine for acquiring an additional lock on an
 * already-open relation.  Never try to do "relation_open(foo, NoLock)"
 * and then lock with this.
 */</comment>
<function><type><name>bool</name></type>
<name>ConditionalLockRelation</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCALLOCK</name>  <modifier>*</modifier></type><name>locallock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LockAcquireResult</name></type> <name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_LOCKTAG_RELATION</name><argument_list>(<argument><expr><name>tag</name></expr></argument>,
						 <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>dbId</name></name></expr></argument>,
						 <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>relId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>LockAcquireExtended</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>locallock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>LOCKACQUIRE_NOT_AVAIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Now that we have the lock, check for invalidation messages; see notes
	 * in LockRelationOid.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>LOCKACQUIRE_ALREADY_CLEAR</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AcceptInvalidationMessages</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkLockClear</name><argument_list>(<argument><expr><name>locallock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		UnlockRelation
 *
 * This is a convenience routine for unlocking a relation without also
 * closing it.
 */</comment>
<function><type><name>void</name></type>
<name>UnlockRelation</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_LOCKTAG_RELATION</name><argument_list>(<argument><expr><name>tag</name></expr></argument>,
						 <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>dbId</name></name></expr></argument>,
						 <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>relId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		CheckRelationLockedByMe
 *
 * Returns true if current transaction holds a lock on 'relation' of mode
 * 'lockmode'.  If 'orstronger' is true, a stronger lockmode is also OK.
 * ("Stronger" is defined as "numerically higher", which is a bit
 * semantically dubious but is OK for the purposes we use this for.)
 */</comment>
<function><type><name>bool</name></type>
<name>CheckRelationLockedByMe</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>orstronger</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_LOCKTAG_RELATION</name><argument_list>(<argument><expr><name>tag</name></expr></argument>,
						 <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>dbId</name></name></expr></argument>,
						 <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>relId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>LockHeldByMe</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>orstronger</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>slockmode</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>slockmode</name> <operator>=</operator> <name>lockmode</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init>
			 <condition><expr><name>slockmode</name> <operator>&lt;=</operator> <name>MaxLockMode</name></expr>;</condition>
			 <incr><expr><name>slockmode</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>LockHeldByMe</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>slockmode</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
				<comment type="block">/* Sometimes this might be useful for debugging purposes */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"lock mode %s substituted for %s on relation %s"</literal></expr></argument>,
					 <argument><expr><call><name>GetLockmodeName</name><argument_list>(<argument><expr><name><name>tag</name><operator>.</operator><name>locktag_lockmethodid</name></name></expr></argument>, <argument><expr><name>slockmode</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>GetLockmodeName</name><argument_list>(<argument><expr><name><name>tag</name><operator>.</operator><name>locktag_lockmethodid</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		LockHasWaitersRelation
 *
 * This is a function to check whether someone else is waiting for a
 * lock which we are currently holding.
 */</comment>
<function><type><name>bool</name></type>
<name>LockHasWaitersRelation</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_LOCKTAG_RELATION</name><argument_list>(<argument><expr><name>tag</name></expr></argument>,
						 <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>dbId</name></name></expr></argument>,
						 <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>relId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>LockHasWaiters</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		LockRelationIdForSession
 *
 * This routine grabs a session-level lock on the target relation.  The
 * session lock persists across transaction boundaries.  It will be removed
 * when UnlockRelationIdForSession() is called, or if an ereport(ERROR) occurs,
 * or if the backend exits.
 *
 * Note that one should also grab a transaction-level lock on the rel
 * in any transaction that actually uses the rel, to ensure that the
 * relcache entry is up to date.
 */</comment>
<function><type><name>void</name></type>
<name>LockRelationIdForSession</name><parameter_list>(<parameter><decl><type><name>LockRelId</name> <modifier>*</modifier></type><name>relid</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_LOCKTAG_RELATION</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name><name>relid</name><operator>-&gt;</operator><name>dbId</name></name></expr></argument>, <argument><expr><name><name>relid</name><operator>-&gt;</operator><name>relId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		UnlockRelationIdForSession
 */</comment>
<function><type><name>void</name></type>
<name>UnlockRelationIdForSession</name><parameter_list>(<parameter><decl><type><name>LockRelId</name> <modifier>*</modifier></type><name>relid</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_LOCKTAG_RELATION</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name><name>relid</name><operator>-&gt;</operator><name>dbId</name></name></expr></argument>, <argument><expr><name><name>relid</name><operator>-&gt;</operator><name>relId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		LockRelationForExtension
 *
 * This lock tag is used to interlock addition of pages to relations.
 * We need such locking because bufmgr/smgr definition of P_NEW is not
 * race-condition-proof.
 *
 * We assume the caller is already holding some type of regular lock on
 * the relation, so no AcceptInvalidationMessages call is needed here.
 */</comment>
<function><type><name>void</name></type>
<name>LockRelationForExtension</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_LOCKTAG_RELATION_EXTEND</name><argument_list>(<argument><expr><name>tag</name></expr></argument>,
								<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>dbId</name></name></expr></argument>,
								<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>relId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		ConditionalLockRelationForExtension
 *
 * As above, but only lock if we can get the lock without blocking.
 * Returns true iff the lock was acquired.
 */</comment>
<function><type><name>bool</name></type>
<name>ConditionalLockRelationForExtension</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_LOCKTAG_RELATION_EXTEND</name><argument_list>(<argument><expr><name>tag</name></expr></argument>,
								<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>dbId</name></name></expr></argument>,
								<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>relId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>LOCKACQUIRE_NOT_AVAIL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		RelationExtensionLockWaiterCount
 *
 * Count the number of processes waiting for the given relation extension lock.
 */</comment>
<function><type><name>int</name></type>
<name>RelationExtensionLockWaiterCount</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_LOCKTAG_RELATION_EXTEND</name><argument_list>(<argument><expr><name>tag</name></expr></argument>,
								<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>dbId</name></name></expr></argument>,
								<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>relId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>LockWaiterCount</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		UnlockRelationForExtension
 */</comment>
<function><type><name>void</name></type>
<name>UnlockRelationForExtension</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_LOCKTAG_RELATION_EXTEND</name><argument_list>(<argument><expr><name>tag</name></expr></argument>,
								<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>dbId</name></name></expr></argument>,
								<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>relId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		LockDatabaseFrozenIds
 *
 * This allows one backend per database to execute vac_update_datfrozenxid().
 */</comment>
<function><type><name>void</name></type>
<name>LockDatabaseFrozenIds</name><parameter_list>(<parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_LOCKTAG_DATABASE_FROZEN_IDS</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		LockPage
 *
 * Obtain a page-level lock.  This is currently used by some index access
 * methods to lock individual index pages.
 */</comment>
<function><type><name>void</name></type>
<name>LockPage</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_LOCKTAG_PAGE</name><argument_list>(<argument><expr><name>tag</name></expr></argument>,
					 <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>dbId</name></name></expr></argument>,
					 <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>relId</name></name></expr></argument>,
					 <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		ConditionalLockPage
 *
 * As above, but only lock if we can get the lock without blocking.
 * Returns true iff the lock was acquired.
 */</comment>
<function><type><name>bool</name></type>
<name>ConditionalLockPage</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_LOCKTAG_PAGE</name><argument_list>(<argument><expr><name>tag</name></expr></argument>,
					 <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>dbId</name></name></expr></argument>,
					 <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>relId</name></name></expr></argument>,
					 <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>LOCKACQUIRE_NOT_AVAIL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		UnlockPage
 */</comment>
<function><type><name>void</name></type>
<name>UnlockPage</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_LOCKTAG_PAGE</name><argument_list>(<argument><expr><name>tag</name></expr></argument>,
					 <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>dbId</name></name></expr></argument>,
					 <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>relId</name></name></expr></argument>,
					 <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		LockTuple
 *
 * Obtain a tuple-level lock.  This is used in a less-than-intuitive fashion
 * because we can't afford to keep a separate lock in shared memory for every
 * tuple.  See heap_lock_tuple before using this!
 */</comment>
<function><type><name>void</name></type>
<name>LockTuple</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_LOCKTAG_TUPLE</name><argument_list>(<argument><expr><name>tag</name></expr></argument>,
					  <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>dbId</name></name></expr></argument>,
					  <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>relId</name></name></expr></argument>,
					  <argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		ConditionalLockTuple
 *
 * As above, but only lock if we can get the lock without blocking.
 * Returns true iff the lock was acquired.
 */</comment>
<function><type><name>bool</name></type>
<name>ConditionalLockTuple</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_LOCKTAG_TUPLE</name><argument_list>(<argument><expr><name>tag</name></expr></argument>,
					  <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>dbId</name></name></expr></argument>,
					  <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>relId</name></name></expr></argument>,
					  <argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>LOCKACQUIRE_NOT_AVAIL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		UnlockTuple
 */</comment>
<function><type><name>void</name></type>
<name>UnlockTuple</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_LOCKTAG_TUPLE</name><argument_list>(<argument><expr><name>tag</name></expr></argument>,
					  <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>dbId</name></name></expr></argument>,
					  <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>relId</name></name></expr></argument>,
					  <argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		XactLockTableInsert
 *
 * Insert a lock showing that the given transaction ID is running ---
 * this is done when an XID is acquired by a transaction or subtransaction.
 * The lock can then be used to wait for the transaction to finish.
 */</comment>
<function><type><name>void</name></type>
<name>XactLockTableInsert</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_LOCKTAG_TRANSACTION</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		XactLockTableDelete
 *
 * Delete the lock showing that the given transaction ID is running.
 * (This is never used for main transaction IDs; those locks are only
 * released implicitly at transaction end.  But we do use it for subtrans IDs.)
 */</comment>
<function><type><name>void</name></type>
<name>XactLockTableDelete</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_LOCKTAG_TRANSACTION</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		XactLockTableWait
 *
 * Wait for the specified transaction to commit or abort.  If an operation
 * is specified, an error context callback is set up.  If 'oper' is passed as
 * None, no error context callback is set up.
 *
 * Note that this does the right thing for subtransactions: if we wait on a
 * subtransaction, we will exit as soon as it aborts or its top parent commits.
 * It takes some extra work to ensure this, because to save on shared memory
 * the XID lock of a subtransaction is released when it ends, whether
 * successfully or unsuccessfully.  So we have to check if it's "still running"
 * and if so wait for its parent.
 */</comment>
<function><type><name>void</name></type>
<name>XactLockTableWait</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>ctid</name></decl></parameter>,
				  <parameter><decl><type><name>XLTW_Oper</name></type> <name>oper</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XactLockTableWaitInfo</name></type> <name>info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>callback</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If an operation is specified, set up our verbose error context
	 * callback.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>oper</name> <operator>!=</operator> <name>XLTW_None</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RelationIsValid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><name>ctid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>info</name><operator>.</operator><name>rel</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>info</name><operator>.</operator><name>ctid</name></name> <operator>=</operator> <name>ctid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>info</name><operator>.</operator><name>oper</name></name> <operator>=</operator> <name>oper</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>callback</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>XactLockTableWaitErrorCb</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>callback</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <operator>&amp;</operator><name>info</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>callback</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>callback</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SET_LOCKTAG_TRANSACTION</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsInProgress</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If the Xid belonged to a subtransaction, then the lock would have
		 * gone away as soon as it was finished; for correct tuple visibility,
		 * the right action is to wait on its parent transaction to go away.
		 * But instead of going levels up one by one, we can just wait for the
		 * topmost transaction to finish with the same end result, which also
		 * incurs less locktable traffic.
		 *
		 * Some uses of this function don't involve tuple visibility -- such
		 * as when building snapshots for logical decoding.  It is possible to
		 * see a transaction in ProcArray before it registers itself in the
		 * locktable.  The topmost transaction in that case is the same xid,
		 * so we try again after a short sleep.  (Don't sleep the first time
		 * through, to avoid slowing down the normal case.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>xid</name> <operator>=</operator> <call><name>SubTransGetTopmostTransaction</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>oper</name> <operator>!=</operator> <name>XLTW_None</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>callback</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		ConditionalXactLockTableWait
 *
 * As above, but only lock if we can get the lock without blocking.
 * Returns true if the lock was acquired.
 */</comment>
<function><type><name>bool</name></type>
<name>ConditionalXactLockTableWait</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SET_LOCKTAG_TRANSACTION</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>LOCKACQUIRE_NOT_AVAIL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>LockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsInProgress</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* See XactLockTableWait about this case */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>xid</name> <operator>=</operator> <call><name>SubTransGetTopmostTransaction</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		SpeculativeInsertionLockAcquire
 *
 * Insert a lock showing that the given transaction ID is inserting a tuple,
 * but hasn't yet decided whether it's going to keep it.  The lock can then be
 * used to wait for the decision to go ahead with the insertion, or aborting
 * it.
 *
 * The token is used to distinguish multiple insertions by the same
 * transaction.  It is returned to caller.
 */</comment>
<function><type><name>uint32</name></type>
<name>SpeculativeInsertionLockAcquire</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>speculativeInsertionToken</name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check for wrap-around. Zero means no token is held, so don't use that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>speculativeInsertionToken</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>speculativeInsertionToken</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>SET_LOCKTAG_SPECULATIVE_INSERTION</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>speculativeInsertionToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>speculativeInsertionToken</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		SpeculativeInsertionLockRelease
 *
 * Delete the lock showing that the given transaction is speculatively
 * inserting a tuple.
 */</comment>
<function><type><name>void</name></type>
<name>SpeculativeInsertionLockRelease</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_LOCKTAG_SPECULATIVE_INSERTION</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>speculativeInsertionToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		SpeculativeInsertionWait
 *
 * Wait for the specified transaction to finish or abort the insertion of a
 * tuple.
 */</comment>
<function><type><name>void</name></type>
<name>SpeculativeInsertionWait</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>token</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_LOCKTAG_SPECULATIVE_INSERTION</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>token</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * XactLockTableWaitErrorCb
 *		Error context callback for transaction lock waits.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>XactLockTableWaitErrorCb</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XactLockTableWaitInfo</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><operator>(</operator><name>XactLockTableWaitInfo</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We would like to print schema name too, but that would require a
	 * syscache lookup.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>oper</name></name> <operator>!=</operator> <name>XLTW_None</name> <operator>&amp;&amp;</operator>
		<call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>ctid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>RelationIsValid</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cxt</name></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>oper</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>XLTW_Update</name></expr>:</case>
				<expr_stmt><expr><name>cxt</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"while updating tuple (%u,%u) in relation \"%s\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>XLTW_Delete</name></expr>:</case>
				<expr_stmt><expr><name>cxt</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"while deleting tuple (%u,%u) in relation \"%s\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>XLTW_Lock</name></expr>:</case>
				<expr_stmt><expr><name>cxt</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"while locking tuple (%u,%u) in relation \"%s\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>XLTW_LockUpdated</name></expr>:</case>
				<expr_stmt><expr><name>cxt</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"while locking updated version (%u,%u) of tuple in relation \"%s\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>XLTW_InsertIndex</name></expr>:</case>
				<expr_stmt><expr><name>cxt</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"while inserting index tuple (%u,%u) in relation \"%s\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>XLTW_InsertIndexUnique</name></expr>:</case>
				<expr_stmt><expr><name>cxt</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"while checking uniqueness of tuple (%u,%u) in relation \"%s\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>XLTW_FetchUpdated</name></expr>:</case>
				<expr_stmt><expr><name>cxt</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"while rechecking updated tuple (%u,%u) in relation \"%s\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>XLTW_RecheckExclusionConstr</name></expr>:</case>
				<expr_stmt><expr><name>cxt</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"while checking exclusion constraint on tuple (%u,%u) in relation \"%s\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<return>return;</return>
		</block_content>}</block></switch>

		<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><name>cxt</name></expr></argument>,
				   <argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>ctid</name></name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>ctid</name></name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * WaitForLockersMultiple
 *		Wait until no transaction holds locks that conflict with the given
 *		locktags at the given lockmode.
 *
 * To do this, obtain the current list of lockers, and wait on their VXIDs
 * until they are finished.
 *
 * Note we don't try to acquire the locks on the given locktags, only the
 * VXIDs and XIDs of their lock holders; if somebody grabs a conflicting lock
 * on the objects after we obtained our initial list of lockers, we will not
 * wait for them.
 */</comment>
<function><type><name>void</name></type>
<name>WaitForLockersMultiple</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>locktags</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>progress</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>holders</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>total</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>done</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Done if no locks to wait for */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>locktags</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Collect the transactions we need to wait on */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>locktags</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LOCKTAG</name>    <modifier>*</modifier></type><name>locktag</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>count</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>holders</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>holders</name></expr></argument>,
						  <argument><expr><call><name>GetLockConflicts</name><argument_list>(<argument><expr><name>locktag</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>,
										   <argument><expr><ternary><condition><expr><name>progress</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>count</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>progress</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>total</name> <operator>+=</operator> <name>count</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>progress</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_WAITFOR_TOTAL</name></expr></argument>, <argument><expr><name>total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Note: GetLockConflicts() never reports our own xid, hence we need not
	 * check for that.  Also, prepared xacts are reported and awaited.
	 */</comment>

	<comment type="block">/* Finally wait for each such transaction to complete */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>holders</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>VirtualTransactionId</name> <modifier>*</modifier></type><name>lockholders</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><call><name>VirtualTransactionIdIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>lockholders</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* If requested, publish who we're going to wait for. */</comment>
			<if_stmt><if>if <condition>(<expr><name>progress</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>holder</name> <init>= <expr><call><name>BackendIdGetProc</name><argument_list>(<argument><expr><name><name>lockholders</name><operator>-&gt;</operator><name>backendId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>holder</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_WAITFOR_CURRENT_PID</name></expr></argument>,
												 <argument><expr><name><name>holder</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>VirtualXactLock</name><argument_list>(<argument><expr><operator>*</operator><name>lockholders</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>lockholders</name><operator>++</operator></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>progress</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_WAITFOR_DONE</name></expr></argument>, <argument><expr><operator>++</operator><name>done</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></while>
	</block_content>}</block>
	<if_stmt><if>if <condition>(<expr><name>progress</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type>	<name><name>index</name><index>[]</index></name> <init>= <expr><block>{
			<expr><name>PROGRESS_WAITFOR_TOTAL</name></expr>,
			<expr><name>PROGRESS_WAITFOR_DONE</name></expr>,
			<expr><name>PROGRESS_WAITFOR_CURRENT_PID</name></expr>
		}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>int64</name></type> <name><name>values</name><index>[]</index></name> <init>= <expr><block>{
			<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>
		}</block></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pgstat_progress_update_multi_param</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>holders</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * WaitForLockers
 *
 * Same as WaitForLockersMultiple, for a single lock tag.
 */</comment>
<function><type><name>void</name></type>
<name>WaitForLockers</name><parameter_list>(<parameter><decl><type><name>LOCKTAG</name></type> <name>heaplocktag</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>progress</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><operator>&amp;</operator><name>heaplocktag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WaitForLockersMultiple</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>progress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		LockDatabaseObject
 *
 * Obtain a lock on a general object of the current database.  Don't use
 * this for shared objects (such as tablespaces).  It's unwise to apply it
 * to relations, also, since a lock taken this way will NOT conflict with
 * locks taken via LockRelation and friends.
 */</comment>
<function><type><name>void</name></type>
<name>LockDatabaseObject</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>classid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objid</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>objsubid</name></decl></parameter>,
				   <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_LOCKTAG_OBJECT</name><argument_list>(<argument><expr><name>tag</name></expr></argument>,
					   <argument><expr><name>MyDatabaseId</name></expr></argument>,
					   <argument><expr><name>classid</name></expr></argument>,
					   <argument><expr><name>objid</name></expr></argument>,
					   <argument><expr><name>objsubid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make sure syscaches are up-to-date with any changes we waited for */</comment>
	<expr_stmt><expr><call><name>AcceptInvalidationMessages</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		UnlockDatabaseObject
 */</comment>
<function><type><name>void</name></type>
<name>UnlockDatabaseObject</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>classid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objid</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>objsubid</name></decl></parameter>,
					 <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_LOCKTAG_OBJECT</name><argument_list>(<argument><expr><name>tag</name></expr></argument>,
					   <argument><expr><name>MyDatabaseId</name></expr></argument>,
					   <argument><expr><name>classid</name></expr></argument>,
					   <argument><expr><name>objid</name></expr></argument>,
					   <argument><expr><name>objsubid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		LockSharedObject
 *
 * Obtain a lock on a shared-across-databases object.
 */</comment>
<function><type><name>void</name></type>
<name>LockSharedObject</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>classid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objid</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>objsubid</name></decl></parameter>,
				 <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_LOCKTAG_OBJECT</name><argument_list>(<argument><expr><name>tag</name></expr></argument>,
					   <argument><expr><name>InvalidOid</name></expr></argument>,
					   <argument><expr><name>classid</name></expr></argument>,
					   <argument><expr><name>objid</name></expr></argument>,
					   <argument><expr><name>objsubid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make sure syscaches are up-to-date with any changes we waited for */</comment>
	<expr_stmt><expr><call><name>AcceptInvalidationMessages</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		UnlockSharedObject
 */</comment>
<function><type><name>void</name></type>
<name>UnlockSharedObject</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>classid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objid</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>objsubid</name></decl></parameter>,
				   <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_LOCKTAG_OBJECT</name><argument_list>(<argument><expr><name>tag</name></expr></argument>,
					   <argument><expr><name>InvalidOid</name></expr></argument>,
					   <argument><expr><name>classid</name></expr></argument>,
					   <argument><expr><name>objid</name></expr></argument>,
					   <argument><expr><name>objsubid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		LockSharedObjectForSession
 *
 * Obtain a session-level lock on a shared-across-databases object.
 * See LockRelationIdForSession for notes about session-level locks.
 */</comment>
<function><type><name>void</name></type>
<name>LockSharedObjectForSession</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>classid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objid</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>objsubid</name></decl></parameter>,
						   <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_LOCKTAG_OBJECT</name><argument_list>(<argument><expr><name>tag</name></expr></argument>,
					   <argument><expr><name>InvalidOid</name></expr></argument>,
					   <argument><expr><name>classid</name></expr></argument>,
					   <argument><expr><name>objid</name></expr></argument>,
					   <argument><expr><name>objsubid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		UnlockSharedObjectForSession
 */</comment>
<function><type><name>void</name></type>
<name>UnlockSharedObjectForSession</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>classid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objid</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>objsubid</name></decl></parameter>,
							 <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_LOCKTAG_OBJECT</name><argument_list>(<argument><expr><name>tag</name></expr></argument>,
					   <argument><expr><name>InvalidOid</name></expr></argument>,
					   <argument><expr><name>classid</name></expr></argument>,
					   <argument><expr><name>objid</name></expr></argument>,
					   <argument><expr><name>objsubid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Append a description of a lockable object to buf.
 *
 * Ideally we would print names for the numeric values, but that requires
 * getting locks on system tables, which might cause problems since this is
 * typically used to report deadlock situations.
 */</comment>
<function><type><name>void</name></type>
<name>DescribeLockTag</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LOCKTAG</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><operator>(</operator><name>LockTagType</name><operator>)</operator> <name><name>tag</name><operator>-&gt;</operator><name>locktag_type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>LOCKTAG_RELATION</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
							 <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"relation %u of database %u"</literal></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>locktag_field2</name></name></expr></argument>,
							 <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>locktag_field1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>LOCKTAG_RELATION_EXTEND</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
							 <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"extension of relation %u of database %u"</literal></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>locktag_field2</name></name></expr></argument>,
							 <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>locktag_field1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>LOCKTAG_DATABASE_FROZEN_IDS</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
							 <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"pg_database.datfrozenxid of database %u"</literal></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>locktag_field1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>LOCKTAG_PAGE</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
							 <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"page %u of relation %u of database %u"</literal></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>locktag_field3</name></name></expr></argument>,
							 <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>locktag_field2</name></name></expr></argument>,
							 <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>locktag_field1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>LOCKTAG_TUPLE</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
							 <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"tuple (%u,%u) of relation %u of database %u"</literal></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>locktag_field3</name></name></expr></argument>,
							 <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>locktag_field4</name></name></expr></argument>,
							 <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>locktag_field2</name></name></expr></argument>,
							 <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>locktag_field1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>LOCKTAG_TRANSACTION</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
							 <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"transaction %u"</literal></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>locktag_field1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>LOCKTAG_VIRTUALTRANSACTION</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
							 <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"virtual transaction %d/%u"</literal></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>locktag_field1</name></name></expr></argument>,
							 <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>locktag_field2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>LOCKTAG_SPECULATIVE_TOKEN</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
							 <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"speculative token %u of transaction %u"</literal></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>locktag_field2</name></name></expr></argument>,
							 <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>locktag_field1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>LOCKTAG_OBJECT</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
							 <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"object %u of class %u of database %u"</literal></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>locktag_field3</name></name></expr></argument>,
							 <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>locktag_field2</name></name></expr></argument>,
							 <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>locktag_field1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>LOCKTAG_USERLOCK</name></expr>:</case>
			<comment type="block">/* reserved for old contrib code, now on pgfoundry */</comment>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
							 <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"user lock [%u,%u,%u]"</literal></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>locktag_field1</name></name></expr></argument>,
							 <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>locktag_field2</name></name></expr></argument>,
							 <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>locktag_field3</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>LOCKTAG_ADVISORY</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
							 <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"advisory lock [%u,%u,%u,%u]"</literal></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>locktag_field1</name></name></expr></argument>,
							 <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>locktag_field2</name></name></expr></argument>,
							 <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>locktag_field3</name></name></expr></argument>,
							 <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>locktag_field4</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
							 <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unrecognized locktag type %d"</literal></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>tag</name><operator>-&gt;</operator><name>locktag_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * GetLockNameFromTagType
 *
 *	Given locktag type, return the corresponding lock name.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GetLockNameFromTagType</name><parameter_list>(<parameter><decl><type><name>uint16</name></type> <name>locktag_type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>locktag_type</name> <operator>&gt;</operator> <name>LOCKTAG_LAST_TYPE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="string">"???"</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name><name>LockTagTypeNames</name><index>[<expr><name>locktag_type</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>
</unit>
