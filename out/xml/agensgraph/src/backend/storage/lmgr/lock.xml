<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/storage/lmgr/lock.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * lock.c
 *	  POSTGRES primary lock mechanism
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/storage/lmgr/lock.c
 *
 * NOTES
 *	  A lock table is a shared memory hash table.  When
 *	  a process tries to acquire a lock of a type that conflicts
 *	  with existing locks, it is put to sleep using the routines
 *	  in storage/lmgr/proc.c.
 *
 *	  For the most part, this code should be invoked via lmgr.c
 *	  or another lock-management module, not directly.
 *
 *	Interface:
 *
 *	InitLocks(), GetLocksMethodTable(), GetLockTagsMethodTable(),
 *	LockAcquire(), LockRelease(), LockReleaseAll(),
 *	LockCheckConflicts(), GrantLock()
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/twophase.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/twophase_rmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_trace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/sinvaladt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/spin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/standby.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ps_status.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resowner_private.h"</cpp:file></cpp:include>


<comment type="block">/* This configuration variable is used to set the lock table size */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>max_locks_per_xact</name></decl>;</decl_stmt> <comment type="block">/* set by guc.c */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NLOCKENTS</name><parameter_list>()</parameter_list></cpp:macro> \
	<cpp:value>mul_size(max_locks_per_xact, add_size(MaxBackends, max_prepared_xacts))</cpp:value></cpp:define>


<comment type="block">/*
 * Data structures defining the semantics of the standard lock methods.
 *
 * The conflict table defines the semantics of the various lock modes.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>LOCKMASK</name></type> <name><name>LockConflicts</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="number">0</literal></expr>,

	<comment type="block">/* AccessShareLock */</comment>
	<expr><call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>,

	<comment type="block">/* RowShareLock */</comment>
	<expr><call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>,

	<comment type="block">/* RowExclusiveLock */</comment>
	<expr><call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>ShareRowExclusiveLock</name></expr></argument>)</argument_list></call> <operator>|</operator>
	<call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>,

	<comment type="block">/* ShareUpdateExclusiveLock */</comment>
	<expr><call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call> <operator>|</operator>
	<call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>ShareRowExclusiveLock</name></expr></argument>)</argument_list></call> <operator>|</operator>
	<call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>,

	<comment type="block">/* ShareLock */</comment>
	<expr><call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call> <operator>|</operator>
	<call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>ShareRowExclusiveLock</name></expr></argument>)</argument_list></call> <operator>|</operator>
	<call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>,

	<comment type="block">/* ShareRowExclusiveLock */</comment>
	<expr><call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call> <operator>|</operator>
	<call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>ShareRowExclusiveLock</name></expr></argument>)</argument_list></call> <operator>|</operator>
	<call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>,

	<comment type="block">/* ExclusiveLock */</comment>
	<expr><call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>RowShareLock</name></expr></argument>)</argument_list></call> <operator>|</operator>
	<call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call> <operator>|</operator>
	<call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>ShareRowExclusiveLock</name></expr></argument>)</argument_list></call> <operator>|</operator>
	<call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>,

	<comment type="block">/* AccessExclusiveLock */</comment>
	<expr><call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>RowShareLock</name></expr></argument>)</argument_list></call> <operator>|</operator>
	<call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call> <operator>|</operator>
	<call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>ShareRowExclusiveLock</name></expr></argument>)</argument_list></call> <operator>|</operator>
	<call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call> <operator>|</operator> <macro><name>LOCKBIT_ON</name><argument_list>(<argument>AccessExclusiveLock</argument>)</argument_list></macro></expr>

}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Names of lock modes, for debug printouts */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>lock_mode_names</name><index>[]</index></name> <init>=
<expr><block>{
	<expr><literal type="string">"INVALID"</literal></expr>,
	<expr><literal type="string">"AccessShareLock"</literal></expr>,
	<expr><literal type="string">"RowShareLock"</literal></expr>,
	<expr><literal type="string">"RowExclusiveLock"</literal></expr>,
	<expr><literal type="string">"ShareUpdateExclusiveLock"</literal></expr>,
	<expr><literal type="string">"ShareLock"</literal></expr>,
	<expr><literal type="string">"ShareRowExclusiveLock"</literal></expr>,
	<expr><literal type="string">"ExclusiveLock"</literal></expr>,
	<expr><literal type="string">"AccessExclusiveLock"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>LOCK_DEBUG</name></cpp:ifndef>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>Dummy_trace</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>LockMethodData</name></type> <name>default_lockmethod</name> <init>= <expr><block>{
	<expr><name>AccessExclusiveLock</name></expr>,		<comment type="block">/* highest valid lock mode number */</comment>
	<expr><name>LockConflicts</name></expr>,
	<expr><name>lock_mode_names</name></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LOCK_DEBUG</name></cpp:ifdef>
	<expr><operator>&amp;</operator><name>Trace_locks</name>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<operator>&amp;</operator><name>Dummy_trace</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>LockMethodData</name></type> <name>user_lockmethod</name> <init>= <expr><block>{
	<expr><name>AccessExclusiveLock</name></expr>,		<comment type="block">/* highest valid lock mode number */</comment>
	<expr><name>LockConflicts</name></expr>,
	<expr><name>lock_mode_names</name></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LOCK_DEBUG</name></cpp:ifdef>
	<expr><operator>&amp;</operator><name>Trace_userlocks</name>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<operator>&amp;</operator><name>Dummy_trace</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * map from lock method id to the lock table data structures
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>LockMethod</name></type> <name><name>LockMethods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><name>NULL</name></expr>,
	<expr><operator>&amp;</operator><name>default_lockmethod</name></expr>,
	<expr><operator>&amp;</operator><name>user_lockmethod</name></expr>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* Record that's written to 2PC state file when a lock is persisted */</comment>
<typedef>typedef <type><struct>struct <name>TwoPhaseLockRecord</name>
<block>{
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>locktag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>lockmode</name></decl>;</decl_stmt>
}</block></struct></type> <name>TwoPhaseLockRecord</name>;</typedef>


<comment type="block">/*
 * Count of the number of fast path lock slots we believe to be used.  This
 * might be higher than the real number if another backend has transferred
 * our locks to the primary lock table, but it can never be lower than the
 * real value, since only we can acquire locks on our own behalf.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>FastPathLocalUseCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Flag to indicate if the relation extension lock is held by this backend.
 * This flag is used to ensure that while holding the relation extension lock
 * we don't try to acquire a heavyweight lock on any other object.  This
 * restriction implies that the relation extension lock won't ever participate
 * in the deadlock cycle because we can never wait for any other heavyweight
 * lock after acquiring this lock.
 *
 * Such a restriction is okay for relation extension locks as unlike other
 * heavyweight locks these are not held till the transaction end.  These are
 * taken for a short duration to extend a particular relation and then
 * released.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name> <name>IsRelationExtensionLockHeld</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Flag to indicate if the page lock is held by this backend.  We don't
 * acquire any other heavyweight lock while holding the page lock except for
 * relation extension.  However, these locks are never taken in reverse order
 * which implies that page locks will also never participate in the deadlock
 * cycle.
 *
 * Similar to relation extension, page locks are also held for a short
 * duration, so imposing such a restriction won't hurt.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name> <name>IsPageLockHeld</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Macros for manipulating proc-&gt;fpLockBits */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FAST_PATH_BITS_PER_SLOT</name></cpp:macro>			<cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FAST_PATH_LOCKNUMBER_OFFSET</name></cpp:macro>		<cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FAST_PATH_MASK</name></cpp:macro>					<cpp:value>((1 &lt;&lt; FAST_PATH_BITS_PER_SLOT) - 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FAST_PATH_GET_BITS</name><parameter_list>(<parameter><type><name>proc</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(((proc)-&gt;fpLockBits &gt;&gt; (FAST_PATH_BITS_PER_SLOT * n)) &amp; FAST_PATH_MASK)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FAST_PATH_BIT_POSITION</name><parameter_list>(<parameter><type><name>n</name></type></parameter>, <parameter><type><name>l</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(AssertMacro((l) &gt;= FAST_PATH_LOCKNUMBER_OFFSET), \
	 AssertMacro((l) &lt; FAST_PATH_BITS_PER_SLOT+FAST_PATH_LOCKNUMBER_OFFSET), \
	 AssertMacro((n) &lt; FP_LOCK_SLOTS_PER_BACKEND), \
	 ((l) - FAST_PATH_LOCKNUMBER_OFFSET + FAST_PATH_BITS_PER_SLOT * (n)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FAST_PATH_SET_LOCKMODE</name><parameter_list>(<parameter><type><name>proc</name></type></parameter>, <parameter><type><name>n</name></type></parameter>, <parameter><type><name>l</name></type></parameter>)</parameter_list></cpp:macro> \
	 <cpp:value>(proc)-&gt;fpLockBits |= UINT64CONST(1) &lt;&lt; FAST_PATH_BIT_POSITION(n, l)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FAST_PATH_CLEAR_LOCKMODE</name><parameter_list>(<parameter><type><name>proc</name></type></parameter>, <parameter><type><name>n</name></type></parameter>, <parameter><type><name>l</name></type></parameter>)</parameter_list></cpp:macro> \
	 <cpp:value>(proc)-&gt;fpLockBits &amp;= ~(UINT64CONST(1) &lt;&lt; FAST_PATH_BIT_POSITION(n, l))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FAST_PATH_CHECK_LOCKMODE</name><parameter_list>(<parameter><type><name>proc</name></type></parameter>, <parameter><type><name>n</name></type></parameter>, <parameter><type><name>l</name></type></parameter>)</parameter_list></cpp:macro> \
	 <cpp:value>((proc)-&gt;fpLockBits &amp; (UINT64CONST(1) &lt;&lt; FAST_PATH_BIT_POSITION(n, l)))</cpp:value></cpp:define>

<comment type="block">/*
 * The fast-path lock mechanism is concerned only with relation locks on
 * unshared relations by backends bound to a database.  The fast-path
 * mechanism exists mostly to accelerate acquisition and release of locks
 * that rarely conflict.  Because ShareUpdateExclusiveLock is
 * self-conflicting, it can't use the fast-path mechanism; but it also does
 * not conflict with any of the locks that do, so we can ignore it completely.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EligibleForRelationFastPath</name><parameter_list>(<parameter><type><name>locktag</name></type></parameter>, <parameter><type><name>mode</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((locktag)-&gt;locktag_lockmethodid == DEFAULT_LOCKMETHOD &amp;&amp; \
	(locktag)-&gt;locktag_type == LOCKTAG_RELATION &amp;&amp; \
	(locktag)-&gt;locktag_field1 == MyDatabaseId &amp;&amp; \
	MyDatabaseId != InvalidOid &amp;&amp; \
	(mode) &lt; ShareUpdateExclusiveLock)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ConflictsWithRelationFastPath</name><parameter_list>(<parameter><type><name>locktag</name></type></parameter>, <parameter><type><name>mode</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((locktag)-&gt;locktag_lockmethodid == DEFAULT_LOCKMETHOD &amp;&amp; \
	(locktag)-&gt;locktag_type == LOCKTAG_RELATION &amp;&amp; \
	(locktag)-&gt;locktag_field1 != InvalidOid &amp;&amp; \
	(mode) &gt; ShareUpdateExclusiveLock)</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>FastPathGrantRelationLock</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>FastPathUnGrantRelationLock</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>FastPathTransferRelationLocks</name><parameter_list>(<parameter><decl><type><name>LockMethod</name></type> <name>lockMethodTable</name></decl></parameter>,
										  <parameter><decl><type><specifier>const</specifier> <name>LOCKTAG</name> <modifier>*</modifier></type><name>locktag</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hashcode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PROCLOCK</name> <modifier>*</modifier></type><name>FastPathGetRelationLockEntry</name><parameter_list>(<parameter><decl><type><name>LOCALLOCK</name> <modifier>*</modifier></type><name>locallock</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * To make the fast-path lock mechanism work, we must have some way of
 * preventing the use of the fast-path when a conflicting lock might be present.
 * We partition* the locktag space into FAST_PATH_STRONG_LOCK_HASH_PARTITIONS,
 * and maintain an integer count of the number of "strong" lockers
 * in each partition.  When any "strong" lockers are present (which is
 * hopefully not very often), the fast-path mechanism can't be used, and we
 * must fall back to the slower method of pushing matching locks directly
 * into the main lock tables.
 *
 * The deadlock detector does not know anything about the fast path mechanism,
 * so any locks that might be involved in a deadlock must be transferred from
 * the fast-path queues to the main lock table.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FAST_PATH_STRONG_LOCK_HASH_BITS</name></cpp:macro>			<cpp:value>10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FAST_PATH_STRONG_LOCK_HASH_PARTITIONS</name></cpp:macro> \
	<cpp:value>(1 &lt;&lt; FAST_PATH_STRONG_LOCK_HASH_BITS)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FastPathStrongLockHashPartition</name><parameter_list>(<parameter><type><name>hashcode</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((hashcode) % FAST_PATH_STRONG_LOCK_HASH_PARTITIONS)</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>slock_t</name></type>		<name>mutex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name><name>count</name><index>[<expr><name>FAST_PATH_STRONG_LOCK_HASH_PARTITIONS</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>FastPathStrongRelationLockData</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>FastPathStrongRelationLockData</name> <modifier>*</modifier></type><name>FastPathStrongRelationLocks</name></decl>;</decl_stmt>


<comment type="block">/*
 * Pointers to hash tables containing lock state
 *
 * The LockMethodLockHash and LockMethodProcLockHash hash tables are in
 * shared memory; LockMethodLocalHash is local to each backend.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>LockMethodLockHash</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>LockMethodProcLockHash</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>LockMethodLocalHash</name></decl>;</decl_stmt>


<comment type="block">/* private state for error cleanup */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>LOCALLOCK</name> <modifier>*</modifier></type><name>StrongLockInProgress</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>LOCALLOCK</name> <modifier>*</modifier></type><name>awaitedLock</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ResourceOwner</name></type> <name>awaitedOwner</name></decl>;</decl_stmt>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LOCK_DEBUG</name></cpp:ifdef>

<comment type="block">/*------
 * The following configuration options are available for lock debugging:
 *
 *	   TRACE_LOCKS		-- give a bunch of output what's going on in this file
 *	   TRACE_USERLOCKS	-- same but for user locks
 *	   TRACE_LOCK_OIDMIN-- do not trace locks for tables below this oid
 *						   (use to avoid output on system tables)
 *	   TRACE_LOCK_TABLE -- trace locks on this table (oid) unconditionally
 *	   DEBUG_DEADLOCKS	-- currently dumps locks at untimely occasions ;)
 *
 * Furthermore, but in storage/lmgr/lwlock.c:
 *	   TRACE_LWLOCKS	-- trace lightweight locks (pretty useless)
 *
 * Define LOCK_DEBUG at compile time to get all these enabled.
 * --------
 */</comment>

<decl_stmt><decl><type><name>int</name></type>			<name>Trace_lock_oidmin</name> <init>= <expr><name>FirstNormalObjectId</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>Trace_locks</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>Trace_userlocks</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>Trace_lock_table</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>Debug_deadlocks</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>


<function><type><specifier>inline</specifier> <specifier>static</specifier> <name>bool</name></type>
<name>LOCK_DEBUG_ENABLED</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LOCKTAG</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return
		<expr><operator>(</operator><operator>*</operator><operator>(</operator><name><name>LockMethods</name><index>[<expr><name><name>tag</name><operator>-&gt;</operator><name>locktag_lockmethodid</name></name></expr>]</index></name><operator>-&gt;</operator><name>trace_flag</name><operator>)</operator> <operator>&amp;&amp;</operator>
		 <operator>(</operator><operator>(</operator><name>Oid</name><operator>)</operator> <name><name>tag</name><operator>-&gt;</operator><name>locktag_field2</name></name> <operator>&gt;=</operator> <operator>(</operator><name>Oid</name><operator>)</operator> <name>Trace_lock_oidmin</name><operator>)</operator><operator>)</operator>
		<operator>||</operator> <operator>(</operator><name>Trace_lock_table</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>tag</name><operator>-&gt;</operator><name>locktag_field2</name></name> <operator>==</operator> <name>Trace_lock_table</name><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>inline</specifier> <specifier>static</specifier> <name>void</name></type>
<name>LOCK_PRINT</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>where</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LOCK</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>LOCK_DEBUG_ENABLED</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
			 <argument><expr><literal type="string">"%s: lock(%p) id(%u,%u,%u,%u,%u,%u) grantMask(%x) "</literal>
			 <literal type="string">"req(%d,%d,%d,%d,%d,%d,%d)=%d "</literal>
			 <literal type="string">"grant(%d,%d,%d,%d,%d,%d,%d)=%d wait(%d) type(%s)"</literal></expr></argument>,
			 <argument><expr><name>where</name></expr></argument>, <argument><expr><name>lock</name></expr></argument>,
			 <argument><expr><name><name>lock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>locktag_field1</name></name></expr></argument>, <argument><expr><name><name>lock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>locktag_field2</name></name></expr></argument>,
			 <argument><expr><name><name>lock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>locktag_field3</name></name></expr></argument>, <argument><expr><name><name>lock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>locktag_field4</name></name></expr></argument>,
			 <argument><expr><name><name>lock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>locktag_type</name></name></expr></argument>, <argument><expr><name><name>lock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>locktag_lockmethodid</name></name></expr></argument>,
			 <argument><expr><name><name>lock</name><operator>-&gt;</operator><name>grantMask</name></name></expr></argument>,
			 <argument><expr><name><name>lock</name><operator>-&gt;</operator><name>requested</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>lock</name><operator>-&gt;</operator><name>requested</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>lock</name><operator>-&gt;</operator><name>requested</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>,
			 <argument><expr><name><name>lock</name><operator>-&gt;</operator><name>requested</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>lock</name><operator>-&gt;</operator><name>requested</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>lock</name><operator>-&gt;</operator><name>requested</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr></argument>,
			 <argument><expr><name><name>lock</name><operator>-&gt;</operator><name>requested</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name></expr></argument>,
			 <argument><expr><name><name>lock</name><operator>-&gt;</operator><name>granted</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>lock</name><operator>-&gt;</operator><name>granted</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>lock</name><operator>-&gt;</operator><name>granted</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>,
			 <argument><expr><name><name>lock</name><operator>-&gt;</operator><name>granted</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>lock</name><operator>-&gt;</operator><name>granted</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>lock</name><operator>-&gt;</operator><name>granted</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr></argument>,
			 <argument><expr><name><name>lock</name><operator>-&gt;</operator><name>granted</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>lock</name><operator>-&gt;</operator><name>nGranted</name></name></expr></argument>,
			 <argument><expr><name><name>lock</name><operator>-&gt;</operator><name>waitProcs</name><operator>.</operator><name>size</name></name></expr></argument>,
			 <argument><expr><name><name>LockMethods</name><index>[<expr><call><name>LOCK_LOCKMETHOD</name><argument_list>(<argument><expr><operator>*</operator><name>lock</name></expr></argument>)</argument_list></call></expr>]</index></name><operator>-&gt;</operator><name><name>lockModeNames</name><index>[<expr><name>type</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>inline</specifier> <specifier>static</specifier> <name>void</name></type>
<name>PROCLOCK_PRINT</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>where</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PROCLOCK</name> <modifier>*</modifier></type><name>proclockP</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>LOCK_DEBUG_ENABLED</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proclockP</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myLock</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
			 <argument><expr><literal type="string">"%s: proclock(%p) lock(%p) method(%u) proc(%p) hold(%x)"</literal></expr></argument>,
			 <argument><expr><name>where</name></expr></argument>, <argument><expr><name>proclockP</name></expr></argument>, <argument><expr><name><name>proclockP</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myLock</name></name></expr></argument>,
			 <argument><expr><call><name>PROCLOCK_LOCKMETHOD</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>proclockP</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><name><name>proclockP</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myProc</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>proclockP</name><operator>-&gt;</operator><name>holdMask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* not LOCK_DEBUG */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCK_PRINT</name><parameter_list>(<parameter><type><name>where</name></type></parameter>, <parameter><type><name>lock</name></type></parameter>, <parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>((void) 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROCLOCK_PRINT</name><parameter_list>(<parameter><type><name>where</name></type></parameter>, <parameter><type><name>proclockP</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>((void) 0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* not LOCK_DEBUG */</comment>


<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>proclock_hash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RemoveLocalLock</name><parameter_list>(<parameter><decl><type><name>LOCALLOCK</name> <modifier>*</modifier></type><name>locallock</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PROCLOCK</name> <modifier>*</modifier></type><name>SetupLockInTable</name><parameter_list>(<parameter><decl><type><name>LockMethod</name></type> <name>lockMethodTable</name></decl></parameter>, <parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>,
								  <parameter><decl><type><specifier>const</specifier> <name>LOCKTAG</name> <modifier>*</modifier></type><name>locktag</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hashcode</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>GrantLockLocal</name><parameter_list>(<parameter><decl><type><name>LOCALLOCK</name> <modifier>*</modifier></type><name>locallock</name></decl></parameter>, <parameter><decl><type><name>ResourceOwner</name></type> <name>owner</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>BeginStrongLockAcquire</name><parameter_list>(<parameter><decl><type><name>LOCALLOCK</name> <modifier>*</modifier></type><name>locallock</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>fasthashcode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FinishStrongLockAcquire</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WaitOnLock</name><parameter_list>(<parameter><decl><type><name>LOCALLOCK</name> <modifier>*</modifier></type><name>locallock</name></decl></parameter>, <parameter><decl><type><name>ResourceOwner</name></type> <name>owner</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReleaseLockIfHeld</name><parameter_list>(<parameter><decl><type><name>LOCALLOCK</name> <modifier>*</modifier></type><name>locallock</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>sessionLock</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>LockReassignOwner</name><parameter_list>(<parameter><decl><type><name>LOCALLOCK</name> <modifier>*</modifier></type><name>locallock</name></decl></parameter>, <parameter><decl><type><name>ResourceOwner</name></type> <name>parent</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>UnGrantLock</name><parameter_list>(<parameter><decl><type><name>LOCK</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>,
						<parameter><decl><type><name>PROCLOCK</name> <modifier>*</modifier></type><name>proclock</name></decl></parameter>, <parameter><decl><type><name>LockMethod</name></type> <name>lockMethodTable</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CleanUpLock</name><parameter_list>(<parameter><decl><type><name>LOCK</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>, <parameter><decl><type><name>PROCLOCK</name> <modifier>*</modifier></type><name>proclock</name></decl></parameter>,
						<parameter><decl><type><name>LockMethod</name></type> <name>lockMethodTable</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hashcode</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>wakeupNeeded</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>LockRefindAndRelease</name><parameter_list>(<parameter><decl><type><name>LockMethod</name></type> <name>lockMethodTable</name></decl></parameter>, <parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>,
								 <parameter><decl><type><name>LOCKTAG</name> <modifier>*</modifier></type><name>locktag</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>,
								 <parameter><decl><type><name>bool</name></type> <name>decrement_strong_lock_count</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>GetSingleProcBlockerStatusData</name><parameter_list>(<parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>blocked_proc</name></decl></parameter>,
										   <parameter><decl><type><name>BlockedProcsData</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * InitLocks -- Initialize the lock manager's data structures.
 *
 * This is called from CreateSharedMemoryAndSemaphores(), which see for
 * more comments.  In the normal postmaster case, the shared hash tables
 * are created here, as well as a locallock hash table that will remain
 * unused and empty in the postmaster itself.  Backends inherit the pointers
 * to the shared tables via fork(), and also inherit an image of the locallock
 * hash table, which they proceed to use.  In the EXEC_BACKEND case, each
 * backend re-executes this code to obtain pointers to the already existing
 * shared hash tables and to create its locallock hash table.
 */</comment>
<function><type><name>void</name></type>
<name>InitLocks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>init_table_size</name></decl>,
				<decl><type ref="prev"/><name>max_table_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Compute init/max size to request for lock hashtables.  Note these
	 * calculations must agree with LockShmemSize!
	 */</comment>
	<expr_stmt><expr><name>max_table_size</name> <operator>=</operator> <call><name>NLOCKENTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>init_table_size</name> <operator>=</operator> <name>max_table_size</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate hash table for LOCK structs.  This stores per-locked-object
	 * information.
	 */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LOCKTAG</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LOCK</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>num_partitions</name></name> <operator>=</operator> <name>NUM_LOCK_PARTITIONS</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>LockMethodLockHash</name> <operator>=</operator> <call><name>ShmemInitHash</name><argument_list>(<argument><expr><literal type="string">"LOCK hash"</literal></expr></argument>,
									   <argument><expr><name>init_table_size</name></expr></argument>,
									   <argument><expr><name>max_table_size</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>,
									   <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_PARTITION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Assume an average of 2 holders per lock */</comment>
	<expr_stmt><expr><name>max_table_size</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>init_table_size</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate hash table for PROCLOCK structs.  This stores
	 * per-lock-per-holder information.
	 */</comment>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PROCLOCKTAG</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PROCLOCK</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>proclock_hash</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>num_partitions</name></name> <operator>=</operator> <name>NUM_LOCK_PARTITIONS</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>LockMethodProcLockHash</name> <operator>=</operator> <call><name>ShmemInitHash</name><argument_list>(<argument><expr><literal type="string">"PROCLOCK hash"</literal></expr></argument>,
										   <argument><expr><name>init_table_size</name></expr></argument>,
										   <argument><expr><name>max_table_size</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>,
										   <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name> <operator>|</operator> <name>HASH_PARTITION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate fast-path structures.
	 */</comment>
	<expr_stmt><expr><name>FastPathStrongRelationLocks</name> <operator>=</operator>
		<call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Fast Path Strong Relation Lock Data"</literal></expr></argument>,
						<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FastPathStrongRelationLockData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>FastPathStrongRelationLocks</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Allocate non-shared hash table for LOCALLOCK structs.  This stores lock
	 * counts and resource owner information.
	 *
	 * The non-shared table could already exist in this process (this occurs
	 * when the postmaster is recreating shared memory after a backend crash).
	 * If so, delete and recreate it.  (We could simply leave it, since it
	 * ought to be empty in the postmaster, but for safety let's zap it.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>LockMethodLocalHash</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>LockMethodLocalHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LOCALLOCKTAG</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LOCALLOCK</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><name>LockMethodLocalHash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"LOCALLOCK hash"</literal></expr></argument>,
									  <argument><expr><literal type="number">16</literal></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>,
									  <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Fetch the lock method table associated with a given lock
 */</comment>
<function><type><name>LockMethod</name></type>
<name>GetLocksMethodTable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LOCK</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKMETHODID</name></type> <name>lockmethodid</name> <init>= <expr><call><name>LOCK_LOCKMETHOD</name><argument_list>(<argument><expr><operator>*</operator><name>lock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>&lt;</operator> <name>lockmethodid</name> <operator>&amp;&amp;</operator> <name>lockmethodid</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>LockMethods</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>LockMethods</name><index>[<expr><name>lockmethodid</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch the lock method table associated with a given locktag
 */</comment>
<function><type><name>LockMethod</name></type>
<name>GetLockTagsMethodTable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LOCKTAG</name> <modifier>*</modifier></type><name>locktag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKMETHODID</name></type> <name>lockmethodid</name> <init>= <expr><operator>(</operator><name>LOCKMETHODID</name><operator>)</operator> <name><name>locktag</name><operator>-&gt;</operator><name>locktag_lockmethodid</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>&lt;</operator> <name>lockmethodid</name> <operator>&amp;&amp;</operator> <name>lockmethodid</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>LockMethods</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>LockMethods</name><index>[<expr><name>lockmethodid</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Compute the hash code associated with a LOCKTAG.
 *
 * To avoid unnecessary recomputations of the hash code, we try to do this
 * just once per function, and then pass it around as needed.  Aside from
 * passing the hashcode to hash_search_with_hash_value(), we can extract
 * the lock partition number from the hashcode.
 */</comment>
<function><type><name>uint32</name></type>
<name>LockTagHashCode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LOCKTAG</name> <modifier>*</modifier></type><name>locktag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>get_hash_value</name><argument_list>(<argument><expr><name>LockMethodLockHash</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator> <name>locktag</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Compute the hash code associated with a PROCLOCKTAG.
 *
 * Because we want to use just one set of partition locks for both the
 * LOCK and PROCLOCK hash tables, we have to make sure that PROCLOCKs
 * fall into the same partition number as their associated LOCKs.
 * dynahash.c expects the partition number to be the low-order bits of
 * the hash code, and therefore a PROCLOCKTAG's hash code must have the
 * same low-order bits as the associated LOCKTAG's hash code.  We achieve
 * this with this specialized hash function.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>proclock_hash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>PROCLOCKTAG</name> <modifier>*</modifier></type><name>proclocktag</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>PROCLOCKTAG</name> <operator>*</operator><operator>)</operator> <name>key</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>lockhash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>procptr</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>keysize</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PROCLOCKTAG</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Look into the associated LOCK object, and compute its hash code */</comment>
	<expr_stmt><expr><name>lockhash</name> <operator>=</operator> <call><name>LockTagHashCode</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proclocktag</name><operator>-&gt;</operator><name>myLock</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * To make the hash code also depend on the PGPROC, we xor the proc
	 * struct's address into the hash code, left-shifted so that the
	 * partition-number bits don't change.  Since this is only a hash, we
	 * don't care if we lose high-order bits of the address; use an
	 * intermediate variable to suppress cast-pointer-to-int warnings.
	 */</comment>
	<expr_stmt><expr><name>procptr</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>proclocktag</name><operator>-&gt;</operator><name>myProc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lockhash</name> <operator>^=</operator> <operator>(</operator><operator>(</operator><name>uint32</name><operator>)</operator> <name>procptr</name><operator>)</operator> <operator>&lt;&lt;</operator> <name>LOG2_NUM_LOCK_PARTITIONS</name></expr>;</expr_stmt>

	<return>return <expr><name>lockhash</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Compute the hash code associated with a PROCLOCKTAG, given the hashcode
 * for its underlying LOCK.
 *
 * We use this just to avoid redundant calls of LockTagHashCode().
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint32</name></type>
<name>ProcLockHashCode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PROCLOCKTAG</name> <modifier>*</modifier></type><name>proclocktag</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hashcode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>lockhash</name> <init>= <expr><name>hashcode</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>procptr</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * This must match proclock_hash()!
	 */</comment>
	<expr_stmt><expr><name>procptr</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>proclocktag</name><operator>-&gt;</operator><name>myProc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lockhash</name> <operator>^=</operator> <operator>(</operator><operator>(</operator><name>uint32</name><operator>)</operator> <name>procptr</name><operator>)</operator> <operator>&lt;&lt;</operator> <name>LOG2_NUM_LOCK_PARTITIONS</name></expr>;</expr_stmt>

	<return>return <expr><name>lockhash</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given two lock modes, return whether they would conflict.
 */</comment>
<function><type><name>bool</name></type>
<name>DoLockModesConflict</name><parameter_list>(<parameter><decl><type><name>LOCKMODE</name></type> <name>mode1</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>mode2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LockMethod</name></type>	<name>lockMethodTable</name> <init>= <expr><name><name>LockMethods</name><index>[<expr><name>DEFAULT_LOCKMETHOD</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>lockMethodTable</name><operator>-&gt;</operator><name>conflictTab</name><index>[<expr><name>mode1</name></expr>]</index></name> <operator>&amp;</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>mode2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * LockHeldByMe -- test whether lock 'locktag' is held with mode 'lockmode'
 *		by the current transaction
 */</comment>
<function><type><name>bool</name></type>
<name>LockHeldByMe</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LOCKTAG</name> <modifier>*</modifier></type><name>locktag</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCALLOCKTAG</name></type> <name>localtag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCALLOCK</name>  <modifier>*</modifier></type><name>locallock</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * See if there is a LOCALLOCK entry for this lock and lockmode
	 */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>localtag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>localtag</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* must clear padding */</comment>
	<expr_stmt><expr><name><name>localtag</name><operator>.</operator><name>lock</name></name> <operator>=</operator> <operator>*</operator><name>locktag</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>localtag</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name>lockmode</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>locallock</name> <operator>=</operator> <operator>(</operator><name>LOCALLOCK</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>LockMethodLocalHash</name></expr></argument>,
										  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>localtag</name></expr></argument>,
										  <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>locallock</name> <operator>&amp;&amp;</operator> <name><name>locallock</name><operator>-&gt;</operator><name>nLocks</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
<comment type="block">/*
 * GetLockMethodLocalHash -- return the hash of local locks, for modules that
 *		evaluate assertions based on all locks held.
 */</comment>
<function><type><name>HTAB</name> <modifier>*</modifier></type>
<name>GetLockMethodLocalHash</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>LockMethodLocalHash</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * LockHasWaiters -- look up 'locktag' and check if releasing this
 *		lock would wake up other processes waiting for it.
 */</comment>
<function><type><name>bool</name></type>
<name>LockHasWaiters</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LOCKTAG</name> <modifier>*</modifier></type><name>locktag</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>sessionLock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKMETHODID</name></type> <name>lockmethodid</name> <init>= <expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_lockmethodid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LockMethod</name></type>	<name>lockMethodTable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCALLOCKTAG</name></type> <name>localtag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCALLOCK</name>  <modifier>*</modifier></type><name>locallock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCK</name>	   <modifier>*</modifier></type><name>lock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PROCLOCK</name>   <modifier>*</modifier></type><name>proclock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLock</name>	   <modifier>*</modifier></type><name>partitionLock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hasWaiters</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>lockmethodid</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>lockmethodid</name> <operator>&gt;=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>LockMethods</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized lock method: %d"</literal></expr></argument>, <argument><expr><name>lockmethodid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>lockMethodTable</name> <operator>=</operator> <name><name>LockMethods</name><index>[<expr><name>lockmethodid</name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>lockmode</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>lockmode</name> <operator>&gt;</operator> <name><name>lockMethodTable</name><operator>-&gt;</operator><name>numLockModes</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized lock mode: %d"</literal></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LOCK_DEBUG</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><call><name>LOCK_DEBUG_ENABLED</name><argument_list>(<argument><expr><name>locktag</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"LockHasWaiters: lock [%u,%u] %s"</literal></expr></argument>,
			 <argument><expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_field1</name></name></expr></argument>, <argument><expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_field2</name></name></expr></argument>,
			 <argument><expr><name><name>lockMethodTable</name><operator>-&gt;</operator><name>lockModeNames</name><index>[<expr><name>lockmode</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Find the LOCALLOCK entry for this lock and lockmode
	 */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>localtag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>localtag</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* must clear padding */</comment>
	<expr_stmt><expr><name><name>localtag</name><operator>.</operator><name>lock</name></name> <operator>=</operator> <operator>*</operator><name>locktag</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>localtag</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name>lockmode</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>locallock</name> <operator>=</operator> <operator>(</operator><name>LOCALLOCK</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>LockMethodLocalHash</name></expr></argument>,
										  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>localtag</name></expr></argument>,
										  <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * let the caller print its own error message, too. Do not ereport(ERROR).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>locallock</name> <operator>||</operator> <name><name>locallock</name><operator>-&gt;</operator><name>nLocks</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"you don't own a lock of type %s"</literal></expr></argument>,
			 <argument><expr><name><name>lockMethodTable</name><operator>-&gt;</operator><name>lockModeNames</name><index>[<expr><name>lockmode</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check the shared lock table.
	 */</comment>
	<expr_stmt><expr><name>partitionLock</name> <operator>=</operator> <call><name>LockHashPartitionLock</name><argument_list>(<argument><expr><name><name>locallock</name><operator>-&gt;</operator><name>hashcode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We don't need to re-find the lock or proclock, since we kept their
	 * addresses in the locallock table, and they couldn't have been removed
	 * while we were holding a lock on them.
	 */</comment>
	<expr_stmt><expr><name>lock</name> <operator>=</operator> <name><name>locallock</name><operator>-&gt;</operator><name>lock</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"LockHasWaiters: found"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>proclock</name> <operator>=</operator> <name><name>locallock</name><operator>-&gt;</operator><name>proclock</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PROCLOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"LockHasWaiters: found"</literal></expr></argument>, <argument><expr><name>proclock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Double-check that we are actually holding a lock of the type we want to
	 * release.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>proclock</name><operator>-&gt;</operator><name>holdMask</name></name> <operator>&amp;</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>lockmode</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PROCLOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"LockHasWaiters: WRONGTYPE"</literal></expr></argument>, <argument><expr><name>proclock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"you don't own a lock of type %s"</literal></expr></argument>,
			 <argument><expr><name><name>lockMethodTable</name><operator>-&gt;</operator><name>lockModeNames</name><index>[<expr><name>lockmode</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RemoveLocalLock</name><argument_list>(<argument><expr><name>locallock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Do the checking.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>lockMethodTable</name><operator>-&gt;</operator><name>conflictTab</name><index>[<expr><name>lockmode</name></expr>]</index></name> <operator>&amp;</operator> <name><name>lock</name><operator>-&gt;</operator><name>waitMask</name></name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>hasWaiters</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>hasWaiters</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * LockAcquire -- Check for lock conflicts, sleep if conflict found,
 *		set lock if/when no conflicts.
 *
 * Inputs:
 *	locktag: unique identifier for the lockable object
 *	lockmode: lock mode to acquire
 *	sessionLock: if true, acquire lock for session not current transaction
 *	dontWait: if true, don't wait to acquire lock
 *
 * Returns one of:
 *		LOCKACQUIRE_NOT_AVAIL		lock not available, and dontWait=true
 *		LOCKACQUIRE_OK				lock successfully acquired
 *		LOCKACQUIRE_ALREADY_HELD	incremented count for lock already held
 *		LOCKACQUIRE_ALREADY_CLEAR	incremented count for lock already clear
 *
 * In the normal case where dontWait=false and the caller doesn't need to
 * distinguish a freshly acquired lock from one already taken earlier in
 * this same transaction, there is no need to examine the return value.
 *
 * Side Effects: The lock is acquired and recorded in lock tables.
 *
 * NOTE: if we wait for the lock, there is no way to abort the wait
 * short of aborting the transaction.
 */</comment>
<function><type><name>LockAcquireResult</name></type>
<name>LockAcquire</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LOCKTAG</name> <modifier>*</modifier></type><name>locktag</name></decl></parameter>,
			<parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>,
			<parameter><decl><type><name>bool</name></type> <name>sessionLock</name></decl></parameter>,
			<parameter><decl><type><name>bool</name></type> <name>dontWait</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>LockAcquireExtended</name><argument_list>(<argument><expr><name>locktag</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>sessionLock</name></expr></argument>, <argument><expr><name>dontWait</name></expr></argument>,
							   <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * LockAcquireExtended - allows us to specify additional options
 *
 * reportMemoryError specifies whether a lock request that fills the lock
 * table should generate an ERROR or not.  Passing "false" allows the caller
 * to attempt to recover from lock-table-full situations, perhaps by forcibly
 * canceling other lock holders and then retrying.  Note, however, that the
 * return code for that is LOCKACQUIRE_NOT_AVAIL, so that it's unsafe to use
 * in combination with dontWait = true, as the cause of failure couldn't be
 * distinguished.
 *
 * If locallockp isn't NULL, *locallockp receives a pointer to the LOCALLOCK
 * table entry if a lock is successfully acquired, or NULL if not.
 */</comment>
<function><type><name>LockAcquireResult</name></type>
<name>LockAcquireExtended</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LOCKTAG</name> <modifier>*</modifier></type><name>locktag</name></decl></parameter>,
					<parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>sessionLock</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>dontWait</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>reportMemoryError</name></decl></parameter>,
					<parameter><decl><type><name>LOCALLOCK</name> <modifier>*</modifier><modifier>*</modifier></type><name>locallockp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKMETHODID</name></type> <name>lockmethodid</name> <init>= <expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_lockmethodid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LockMethod</name></type>	<name>lockMethodTable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCALLOCKTAG</name></type> <name>localtag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCALLOCK</name>  <modifier>*</modifier></type><name>locallock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCK</name>	   <modifier>*</modifier></type><name>lock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PROCLOCK</name>   <modifier>*</modifier></type><name>proclock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResourceOwner</name></type> <name>owner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>hashcode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLock</name>	   <modifier>*</modifier></type><name>partitionLock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found_conflict</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>log_lock</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>lockmethodid</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>lockmethodid</name> <operator>&gt;=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>LockMethods</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized lock method: %d"</literal></expr></argument>, <argument><expr><name>lockmethodid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>lockMethodTable</name> <operator>=</operator> <name><name>LockMethods</name><index>[<expr><name>lockmethodid</name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>lockmode</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>lockmode</name> <operator>&gt;</operator> <name><name>lockMethodTable</name><operator>-&gt;</operator><name>numLockModes</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized lock mode: %d"</literal></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>InRecovery</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>locktag</name><operator>-&gt;</operator><name>locktag_type</name></name> <operator>==</operator> <name>LOCKTAG_OBJECT</name> <operator>||</operator>
		 <name><name>locktag</name><operator>-&gt;</operator><name>locktag_type</name></name> <operator>==</operator> <name>LOCKTAG_RELATION</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<name>lockmode</name> <operator>&gt;</operator> <name>RowExclusiveLock</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot acquire lock mode %s on database objects while recovery is in progress"</literal></expr></argument>,
						<argument><expr><name><name>lockMethodTable</name><operator>-&gt;</operator><name>lockModeNames</name><index>[<expr><name>lockmode</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Only RowExclusiveLock or less can be acquired on database objects during recovery."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LOCK_DEBUG</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><call><name>LOCK_DEBUG_ENABLED</name><argument_list>(<argument><expr><name>locktag</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"LockAcquire: lock [%u,%u] %s"</literal></expr></argument>,
			 <argument><expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_field1</name></name></expr></argument>, <argument><expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_field2</name></name></expr></argument>,
			 <argument><expr><name><name>lockMethodTable</name><operator>-&gt;</operator><name>lockModeNames</name><index>[<expr><name>lockmode</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Identify owner for lock */</comment>
	<if_stmt><if>if <condition>(<expr><name>sessionLock</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>owner</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>owner</name> <operator>=</operator> <name>CurrentResourceOwner</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Find or create a LOCALLOCK entry for this lock and lockmode
	 */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>localtag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>localtag</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* must clear padding */</comment>
	<expr_stmt><expr><name><name>localtag</name><operator>.</operator><name>lock</name></name> <operator>=</operator> <operator>*</operator><name>locktag</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>localtag</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name>lockmode</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>locallock</name> <operator>=</operator> <operator>(</operator><name>LOCALLOCK</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>LockMethodLocalHash</name></expr></argument>,
										  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>localtag</name></expr></argument>,
										  <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * if it's a new locallock object, initialize it
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>lock</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>proclock</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>hashcode</name></name> <operator>=</operator> <call><name>LockTagHashCode</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>localtag</name><operator>.</operator><name>lock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>nLocks</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>holdsStrongLockCount</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>lockCleared</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>numLockOwners</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>maxLockOwners</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>lockOwners</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* in case next line fails */</comment>
		<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>lockOwners</name></name> <operator>=</operator> <operator>(</operator><name>LOCALLOCKOWNER</name> <operator>*</operator><operator>)</operator>
			<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
							   <argument><expr><name><name>locallock</name><operator>-&gt;</operator><name>maxLockOwners</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LOCALLOCKOWNER</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Make sure there will be room to remember the lock */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>locallock</name><operator>-&gt;</operator><name>numLockOwners</name></name> <operator>&gt;=</operator> <name><name>locallock</name><operator>-&gt;</operator><name>maxLockOwners</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>newsize</name> <init>= <expr><name><name>locallock</name><operator>-&gt;</operator><name>maxLockOwners</name></name> <operator>*</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>lockOwners</name></name> <operator>=</operator> <operator>(</operator><name>LOCALLOCKOWNER</name> <operator>*</operator><operator>)</operator>
				<call><name>repalloc</name><argument_list>(<argument><expr><name><name>locallock</name><operator>-&gt;</operator><name>lockOwners</name></name></expr></argument>,
						 <argument><expr><name>newsize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LOCALLOCKOWNER</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>maxLockOwners</name></name> <operator>=</operator> <name>newsize</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>hashcode</name> <operator>=</operator> <name><name>locallock</name><operator>-&gt;</operator><name>hashcode</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>locallockp</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>locallockp</name> <operator>=</operator> <name>locallock</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we already hold the lock, we can just increase the count locally.
	 *
	 * If lockCleared is already set, caller need not worry about absorbing
	 * sinval messages related to the lock's object.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>locallock</name><operator>-&gt;</operator><name>nLocks</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>GrantLockLocal</name><argument_list>(<argument><expr><name>locallock</name></expr></argument>, <argument><expr><name>owner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>locallock</name><operator>-&gt;</operator><name>lockCleared</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>LOCKACQUIRE_ALREADY_CLEAR</name></expr>;</return></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>LOCKACQUIRE_ALREADY_HELD</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We don't acquire any other heavyweight lock while holding the relation
	 * extension lock.  We do allow to acquire the same relation extension
	 * lock more than once but that case won't reach here.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>IsRelationExtensionLockHeld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We don't acquire any other heavyweight lock while holding the page lock
	 * except for relation extension.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>IsPageLockHeld</name> <operator>||</operator>
		   <operator>(</operator><name><name>locktag</name><operator>-&gt;</operator><name>locktag_type</name></name> <operator>==</operator> <name>LOCKTAG_RELATION_EXTEND</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Prepare to emit a WAL record if acquisition of this lock needs to be
	 * replayed in a standby server.
	 *
	 * Here we prepare to log; after lock is acquired we'll issue log record.
	 * This arrangement simplifies error recovery in case the preparation step
	 * fails.
	 *
	 * Only AccessExclusiveLocks can conflict with lock types that read-only
	 * transactions can acquire in a standby server. Make sure this definition
	 * matches the one in GetRunningTransactionLocks().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>lockmode</name> <operator>&gt;=</operator> <name>AccessExclusiveLock</name> <operator>&amp;&amp;</operator>
		<name><name>locktag</name><operator>-&gt;</operator><name>locktag_type</name></name> <operator>==</operator> <name>LOCKTAG_RELATION</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>XLogStandbyInfoActive</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LogAccessExclusiveLockPrepare</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>log_lock</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Attempt to take lock via fast path, if eligible.  But if we remember
	 * having filled up the fast path array, we don't attempt to make any
	 * further use of it until we release some locks.  It's possible that some
	 * other backend has transferred some of those locks to the shared hash
	 * table, leaving space free, but it's not worth acquiring the LWLock just
	 * to check.  It's also possible that we're acquiring a second or third
	 * lock type on a relation we have already locked using the fast-path, but
	 * for now we don't worry about that case either.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>EligibleForRelationFastPath</name><argument_list>(<argument><expr><name>locktag</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name>FastPathLocalUseCount</name> <operator>&lt;</operator> <name>FP_LOCK_SLOTS_PER_BACKEND</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>fasthashcode</name> <init>= <expr><call><name>FastPathStrongLockHashPartition</name><argument_list>(<argument><expr><name>hashcode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>acquired</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * LWLockAcquire acts as a memory sequencing point, so it's safe to
		 * assume that any strong locker whose increment to
		 * FastPathStrongRelationLocks-&gt;counts becomes visible after we test
		 * it has yet to begin to transfer fast-path locks.
		 */</comment>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>fpInfoLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>FastPathStrongRelationLocks</name><operator>-&gt;</operator><name>count</name><index>[<expr><name>fasthashcode</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>acquired</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>acquired</name> <operator>=</operator> <call><name>FastPathGrantRelationLock</name><argument_list>(<argument><expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_field2</name></name></expr></argument>,
												 <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>fpInfoLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>acquired</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The locallock might contain stale pointers to some old shared
			 * objects; we MUST reset these to null before considering the
			 * lock to be acquired via fast-path.
			 */</comment>
			<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>lock</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>proclock</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>GrantLockLocal</name><argument_list>(<argument><expr><name>locallock</name></expr></argument>, <argument><expr><name>owner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>LOCKACQUIRE_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If this lock could potentially have been taken via the fast-path by
	 * some other backend, we must (temporarily) disable further use of the
	 * fast-path for this lock tag, and migrate any locks already taken via
	 * this method to the main lock table.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ConflictsWithRelationFastPath</name><argument_list>(<argument><expr><name>locktag</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>fasthashcode</name> <init>= <expr><call><name>FastPathStrongLockHashPartition</name><argument_list>(<argument><expr><name>hashcode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>BeginStrongLockAcquire</name><argument_list>(<argument><expr><name>locallock</name></expr></argument>, <argument><expr><name>fasthashcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FastPathTransferRelationLocks</name><argument_list>(<argument><expr><name>lockMethodTable</name></expr></argument>, <argument><expr><name>locktag</name></expr></argument>,
										   <argument><expr><name>hashcode</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>AbortStrongLockAcquire</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>locallock</name><operator>-&gt;</operator><name>nLocks</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>RemoveLocalLock</name><argument_list>(<argument><expr><name>locallock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>locallockp</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>locallockp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>reportMemoryError</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of shared memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You might need to increase max_locks_per_transaction."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><name>LOCKACQUIRE_NOT_AVAIL</name></expr>;</return></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We didn't find the lock in our LOCALLOCK table, and we didn't manage to
	 * take it via the fast-path, either, so we've got to mess with the shared
	 * lock table.
	 */</comment>
	<expr_stmt><expr><name>partitionLock</name> <operator>=</operator> <call><name>LockHashPartitionLock</name><argument_list>(<argument><expr><name>hashcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Find or create lock and proclock entries with this tag
	 *
	 * Note: if the locallock object already existed, it might have a pointer
	 * to the lock already ... but we should not assume that that pointer is
	 * valid, since a lock object with zero hold and request counts can go
	 * away anytime.  So we have to use SetupLockInTable() to recompute the
	 * lock and proclock pointers, even if they're already set.
	 */</comment>
	<expr_stmt><expr><name>proclock</name> <operator>=</operator> <call><name>SetupLockInTable</name><argument_list>(<argument><expr><name>lockMethodTable</name></expr></argument>, <argument><expr><name>MyProc</name></expr></argument>, <argument><expr><name>locktag</name></expr></argument>,
								<argument><expr><name>hashcode</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>proclock</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AbortStrongLockAcquire</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>locallock</name><operator>-&gt;</operator><name>nLocks</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>RemoveLocalLock</name><argument_list>(<argument><expr><name>locallock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>locallockp</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>locallockp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>reportMemoryError</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of shared memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You might need to increase max_locks_per_transaction."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>LOCKACQUIRE_NOT_AVAIL</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>proclock</name></name> <operator>=</operator> <name>proclock</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>lock</name> <operator>=</operator> <name><name>proclock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myLock</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>lock</name></name> <operator>=</operator> <name>lock</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If lock requested conflicts with locks requested by waiters, must join
	 * wait queue.  Otherwise, check for conflict with already-held locks.
	 * (That's last because most complex check.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>lockMethodTable</name><operator>-&gt;</operator><name>conflictTab</name><index>[<expr><name>lockmode</name></expr>]</index></name> <operator>&amp;</operator> <name><name>lock</name><operator>-&gt;</operator><name>waitMask</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>found_conflict</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>found_conflict</name> <operator>=</operator> <call><name>LockCheckConflicts</name><argument_list>(<argument><expr><name>lockMethodTable</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>,
											<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>proclock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found_conflict</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No conflict with held or previously requested locks */</comment>
		<expr_stmt><expr><call><name>GrantLock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>proclock</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>GrantLockLocal</name><argument_list>(<argument><expr><name>locallock</name></expr></argument>, <argument><expr><name>owner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * We can't acquire the lock immediately.  If caller specified no
		 * blocking, remove useless table entries and return
		 * LOCKACQUIRE_NOT_AVAIL without waiting.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>dontWait</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>AbortStrongLockAcquire</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>proclock</name><operator>-&gt;</operator><name>holdMask</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>uint32</name></type>		<name>proclock_hashcode</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>proclock_hashcode</name> <operator>=</operator> <call><name>ProcLockHashCode</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proclock</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>, <argument><expr><name>hashcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SHMQueueDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proclock</name><operator>-&gt;</operator><name>lockLink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SHMQueueDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proclock</name><operator>-&gt;</operator><name>procLink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>LockMethodProcLockHash</name></expr></argument>,
												 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>proclock</name><operator>-&gt;</operator><name>tag</name></name><operator>)</operator></expr></argument>,
												 <argument><expr><name>proclock_hashcode</name></expr></argument>,
												 <argument><expr><name>HASH_REMOVE</name></expr></argument>,
												 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"proclock table corrupted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PROCLOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"LockAcquire: NOWAIT"</literal></expr></argument>, <argument><expr><name>proclock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name><operator>--</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>requested</name><index>[<expr><name>lockmode</name></expr>]</index></name><operator>--</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"LockAcquire: conditional lock failed"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>requested</name><index>[<expr><name>lockmode</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lock</name><operator>-&gt;</operator><name>nGranted</name></name> <operator>&lt;=</operator> <name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>locallock</name><operator>-&gt;</operator><name>nLocks</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>RemoveLocalLock</name><argument_list>(<argument><expr><name>locallock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>locallockp</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>locallockp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>LOCKACQUIRE_NOT_AVAIL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Set bitmask of locks this process already holds on this object.
		 */</comment>
		<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>heldLocks</name></name> <operator>=</operator> <name><name>proclock</name><operator>-&gt;</operator><name>holdMask</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Sleep till someone wakes me up.
		 */</comment>

		<expr_stmt><expr><call><name>TRACE_POSTGRESQL_LOCK_WAIT_START</name><argument_list>(<argument><expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_field1</name></name></expr></argument>,
										 <argument><expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_field2</name></name></expr></argument>,
										 <argument><expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_field3</name></name></expr></argument>,
										 <argument><expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_field4</name></name></expr></argument>,
										 <argument><expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_type</name></name></expr></argument>,
										 <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>WaitOnLock</name><argument_list>(<argument><expr><name>locallock</name></expr></argument>, <argument><expr><name>owner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>TRACE_POSTGRESQL_LOCK_WAIT_DONE</name><argument_list>(<argument><expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_field1</name></name></expr></argument>,
										<argument><expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_field2</name></name></expr></argument>,
										<argument><expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_field3</name></name></expr></argument>,
										<argument><expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_field4</name></name></expr></argument>,
										<argument><expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_type</name></name></expr></argument>,
										<argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * NOTE: do not do any material change of state between here and
		 * return.  All required changes in locktable state must have been
		 * done when the lock was granted to us --- see notes in WaitOnLock.
		 */</comment>

		<comment type="block">/*
		 * Check the proclock entry status, in case something in the ipc
		 * communication doesn't work correctly.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>proclock</name><operator>-&gt;</operator><name>holdMask</name></name> <operator>&amp;</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>lockmode</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>AbortStrongLockAcquire</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PROCLOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"LockAcquire: INCONSISTENT"</literal></expr></argument>, <argument><expr><name>proclock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"LockAcquire: INCONSISTENT"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Should we retry ? */</comment>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"LockAcquire failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>PROCLOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"LockAcquire: granted"</literal></expr></argument>, <argument><expr><name>proclock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"LockAcquire: granted"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Lock state is fully up-to-date now; if we error out after this, no
	 * special error cleanup is required.
	 */</comment>
	<expr_stmt><expr><call><name>FinishStrongLockAcquire</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Emit a WAL record if acquisition of this lock needs to be replayed in a
	 * standby server.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>log_lock</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Decode the locktag back to the original values, to avoid sending
		 * lots of empty bytes with every message.  See lock.h to check how a
		 * locktag is defined for LOCKTAG_RELATION
		 */</comment>
		<expr_stmt><expr><call><name>LogAccessExclusiveLock</name><argument_list>(<argument><expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_field1</name></name></expr></argument>,
							   <argument><expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_field2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>LOCKACQUIRE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find or create LOCK and PROCLOCK objects as needed for a new lock
 * request.
 *
 * Returns the PROCLOCK object, or NULL if we failed to create the objects
 * for lack of shared memory.
 *
 * The appropriate partition lock must be held at entry, and will be
 * held at exit.
 */</comment>
<function><type><specifier>static</specifier> <name>PROCLOCK</name> <modifier>*</modifier></type>
<name>SetupLockInTable</name><parameter_list>(<parameter><decl><type><name>LockMethod</name></type> <name>lockMethodTable</name></decl></parameter>, <parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>,
				 <parameter><decl><type><specifier>const</specifier> <name>LOCKTAG</name> <modifier>*</modifier></type><name>locktag</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hashcode</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCK</name>	   <modifier>*</modifier></type><name>lock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PROCLOCK</name>   <modifier>*</modifier></type><name>proclock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PROCLOCKTAG</name></type> <name>proclocktag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>proclock_hashcode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Find or create a lock with this tag.
	 */</comment>
	<expr_stmt><expr><name>lock</name> <operator>=</operator> <operator>(</operator><name>LOCK</name> <operator>*</operator><operator>)</operator> <call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>LockMethodLockHash</name></expr></argument>,
												<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator> <name>locktag</name></expr></argument>,
												<argument><expr><name>hashcode</name></expr></argument>,
												<argument><expr><name>HASH_ENTER_NULL</name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lock</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * if it's a new lock object, initialize it
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>grantMask</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>waitMask</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SHMQueueInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>procLocks</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ProcQueueInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>waitProcs</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>nGranted</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>lock</name><operator>-&gt;</operator><name>requested</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>MAX_LOCKMODES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>lock</name><operator>-&gt;</operator><name>granted</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>MAX_LOCKMODES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"LockAcquire: new"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>LOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"LockAcquire: found"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>requested</name><index>[<expr><name>lockmode</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>nGranted</name></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>granted</name><index>[<expr><name>lockmode</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lock</name><operator>-&gt;</operator><name>nGranted</name></name> <operator>&lt;=</operator> <name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Create the hash key for the proclock table.
	 */</comment>
	<expr_stmt><expr><name><name>proclocktag</name><operator>.</operator><name>myLock</name></name> <operator>=</operator> <name>lock</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proclocktag</name><operator>.</operator><name>myProc</name></name> <operator>=</operator> <name>proc</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>proclock_hashcode</name> <operator>=</operator> <call><name>ProcLockHashCode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>proclocktag</name></expr></argument>, <argument><expr><name>hashcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Find or create a proclock entry with this tag
	 */</comment>
	<expr_stmt><expr><name>proclock</name> <operator>=</operator> <operator>(</operator><name>PROCLOCK</name> <operator>*</operator><operator>)</operator> <call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>LockMethodProcLockHash</name></expr></argument>,
														<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>proclocktag</name></expr></argument>,
														<argument><expr><name>proclock_hashcode</name></expr></argument>,
														<argument><expr><name>HASH_ENTER_NULL</name></expr></argument>,
														<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>proclock</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Oops, not enough shmem for the proclock */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * There are no other requestors of this lock, so garbage-collect
			 * the lock object.  We *must* do this to avoid a permanent leak
			 * of shared memory, because there won't be anything to cause
			 * anyone to release the lock object later.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>SHMQueueEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>procLocks</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>LockMethodLockHash</name></expr></argument>,
											 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>tag</name></name><operator>)</operator></expr></argument>,
											 <argument><expr><name>hashcode</name></expr></argument>,
											 <argument><expr><name>HASH_REMOVE</name></expr></argument>,
											 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"lock table corrupted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If new, initialize the new entry
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>partition</name> <init>= <expr><call><name>LockHashPartition</name><argument_list>(<argument><expr><name>hashcode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * It might seem unsafe to access proclock-&gt;groupLeader without a
		 * lock, but it's not really.  Either we are initializing a proclock
		 * on our own behalf, in which case our group leader isn't changing
		 * because the group leader for a process can only ever be changed by
		 * the process itself; or else we are transferring a fast-path lock to
		 * the main lock table, in which case that process can't change it's
		 * lock group leader without first releasing all of its locks (and in
		 * particular the one we are currently transferring).
		 */</comment>
		<expr_stmt><expr><name><name>proclock</name><operator>-&gt;</operator><name>groupLeader</name></name> <operator>=</operator> <ternary><condition><expr><name><name>proc</name><operator>-&gt;</operator><name>lockGroupLeader</name></name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then>
			<expr><name><name>proc</name><operator>-&gt;</operator><name>lockGroupLeader</name></name></expr> </then><else>: <expr><name>proc</name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>proclock</name><operator>-&gt;</operator><name>holdMask</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>proclock</name><operator>-&gt;</operator><name>releaseMask</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<comment type="block">/* Add proclock to appropriate lists */</comment>
		<expr_stmt><expr><call><name>SHMQueueInsertBefore</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>procLocks</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>proclock</name><operator>-&gt;</operator><name>lockLink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SHMQueueInsertBefore</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>proc</name><operator>-&gt;</operator><name>myProcLocks</name><index>[<expr><name>partition</name></expr>]</index></name><operator>)</operator></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>proclock</name><operator>-&gt;</operator><name>procLink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PROCLOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"LockAcquire: new"</literal></expr></argument>, <argument><expr><name>proclock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>PROCLOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"LockAcquire: found"</literal></expr></argument>, <argument><expr><name>proclock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>proclock</name><operator>-&gt;</operator><name>holdMask</name></name> <operator>&amp;</operator> <operator>~</operator><name><name>lock</name><operator>-&gt;</operator><name>grantMask</name></name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CHECK_DEADLOCK_RISK</name></cpp:ifdef>

		<comment type="block">/*
		 * Issue warning if we already hold a lower-level lock on this object
		 * and do not hold a lock of the requested level or higher. This
		 * indicates a deadlock-prone coding practice (eg, we'd have a
		 * deadlock if another backend were following the same code path at
		 * about the same time).
		 *
		 * This is not enabled by default, because it may generate log entries
		 * about user-level coding practices that are in fact safe in context.
		 * It can be enabled to help find system-level problems.
		 *
		 * XXX Doing numeric comparison on the lockmodes is a hack; it'd be
		 * better to use a table.  For now, though, this works.
		 */</comment>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>lockMethodTable</name><operator>-&gt;</operator><name>numLockModes</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>proclock</name><operator>-&gt;</operator><name>holdMask</name></name> <operator>&amp;</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>lockmode</name></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>	<comment type="block">/* safe: we have a lock &gt;= req level */</comment>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"deadlock risk: raising lock level"</literal>
						 <literal type="string">" from %s to %s on object %u/%u/%u"</literal></expr></argument>,
						 <argument><expr><name><name>lockMethodTable</name><operator>-&gt;</operator><name>lockModeNames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
						 <argument><expr><name><name>lockMethodTable</name><operator>-&gt;</operator><name>lockModeNames</name><index>[<expr><name>lockmode</name></expr>]</index></name></expr></argument>,
						 <argument><expr><name><name>lock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>locktag_field1</name></name></expr></argument>, <argument><expr><name><name>lock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>locktag_field2</name></name></expr></argument>,
						 <argument><expr><name><name>lock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>locktag_field3</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* CHECK_DEADLOCK_RISK */</comment>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * lock-&gt;nRequested and lock-&gt;requested[] count the total number of
	 * requests, whether granted or waiting, so increment those immediately.
	 * The other counts don't increment till we get the lock.
	 */</comment>
	<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>requested</name><index>[<expr><name>lockmode</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>requested</name><index>[<expr><name>lockmode</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We shouldn't already hold the desired lock; else locallock table is
	 * broken.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>proclock</name><operator>-&gt;</operator><name>holdMask</name></name> <operator>&amp;</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"lock %s on object %u/%u/%u is already held"</literal></expr></argument>,
			 <argument><expr><name><name>lockMethodTable</name><operator>-&gt;</operator><name>lockModeNames</name><index>[<expr><name>lockmode</name></expr>]</index></name></expr></argument>,
			 <argument><expr><name><name>lock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>locktag_field1</name></name></expr></argument>, <argument><expr><name><name>lock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>locktag_field2</name></name></expr></argument>,
			 <argument><expr><name><name>lock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>locktag_field3</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>proclock</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check and set/reset the flag that we hold the relation extension/page lock.
 *
 * It is callers responsibility that this function is called after
 * acquiring/releasing the relation extension/page lock.
 *
 * Pass acquired as true if lock is acquired, false otherwise.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>CheckAndSetLockHeld</name><parameter_list>(<parameter><decl><type><name>LOCALLOCK</name> <modifier>*</modifier></type><name>locallock</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>acquired</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><call><name>LOCALLOCK_LOCKTAG</name><argument_list>(<argument><expr><operator>*</operator><name>locallock</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>LOCKTAG_RELATION_EXTEND</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>IsRelationExtensionLockHeld</name> <operator>=</operator> <name>acquired</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>LOCALLOCK_LOCKTAG</name><argument_list>(<argument><expr><operator>*</operator><name>locallock</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>LOCKTAG_PAGE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>IsPageLockHeld</name> <operator>=</operator> <name>acquired</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine to free a locallock entry
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RemoveLocalLock</name><parameter_list>(<parameter><decl><type><name>LOCALLOCK</name> <modifier>*</modifier></type><name>locallock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>locallock</name><operator>-&gt;</operator><name>numLockOwners</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>locallock</name><operator>-&gt;</operator><name>lockOwners</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>owner</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ResourceOwnerForgetLock</name><argument_list>(<argument><expr><name><name>locallock</name><operator>-&gt;</operator><name>lockOwners</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>owner</name></expr></argument>, <argument><expr><name>locallock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>numLockOwners</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>locallock</name><operator>-&gt;</operator><name>lockOwners</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>locallock</name><operator>-&gt;</operator><name>lockOwners</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>lockOwners</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>locallock</name><operator>-&gt;</operator><name>holdsStrongLockCount</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>fasthashcode</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>fasthashcode</name> <operator>=</operator> <call><name>FastPathStrongLockHashPartition</name><argument_list>(<argument><expr><name><name>locallock</name><operator>-&gt;</operator><name>hashcode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>FastPathStrongRelationLocks</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>FastPathStrongRelationLocks</name><operator>-&gt;</operator><name>count</name><index>[<expr><name>fasthashcode</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>FastPathStrongRelationLocks</name><operator>-&gt;</operator><name>count</name><index>[<expr><name>fasthashcode</name></expr>]</index></name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>holdsStrongLockCount</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>FastPathStrongRelationLocks</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hash_search</name><argument_list>(<argument><expr><name>LockMethodLocalHash</name></expr></argument>,
					 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>locallock</name><operator>-&gt;</operator><name>tag</name></name><operator>)</operator></expr></argument>,
					 <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"locallock table corrupted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Indicate that the lock is released for certain types of locks
	 */</comment>
	<expr_stmt><expr><call><name>CheckAndSetLockHeld</name><argument_list>(<argument><expr><name>locallock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * LockCheckConflicts -- test whether requested lock conflicts
 *		with those already granted
 *
 * Returns true if conflict, false if no conflict.
 *
 * NOTES:
 *		Here's what makes this complicated: one process's locks don't
 * conflict with one another, no matter what purpose they are held for
 * (eg, session and transaction locks do not conflict).  Nor do the locks
 * of one process in a lock group conflict with those of another process in
 * the same group.  So, we must subtract off these locks when determining
 * whether the requested new lock conflicts with those already held.
 */</comment>
<function><type><name>bool</name></type>
<name>LockCheckConflicts</name><parameter_list>(<parameter><decl><type><name>LockMethod</name></type> <name>lockMethodTable</name></decl></parameter>,
				   <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>,
				   <parameter><decl><type><name>LOCK</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>,
				   <parameter><decl><type><name>PROCLOCK</name> <modifier>*</modifier></type><name>proclock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>numLockModes</name> <init>= <expr><name><name>lockMethodTable</name><operator>-&gt;</operator><name>numLockModes</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMASK</name></type>	<name>myLocks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>conflictMask</name> <init>= <expr><name><name>lockMethodTable</name><operator>-&gt;</operator><name>conflictTab</name><index>[<expr><name>lockmode</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>conflictsRemaining</name><index>[<expr><name>MAX_LOCKMODES</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>totalConflictsRemaining</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SHM_QUEUE</name>  <modifier>*</modifier></type><name>procLocks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PROCLOCK</name>   <modifier>*</modifier></type><name>otherproclock</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * first check for global conflicts: If no locks conflict with my request,
	 * then I get the lock.
	 *
	 * Checking for conflict: lock-&gt;grantMask represents the types of
	 * currently held locks.  conflictTable[lockmode] has a bit set for each
	 * type of lock that conflicts with request.   Bitwise compare tells if
	 * there is a conflict.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>conflictMask</name> <operator>&amp;</operator> <name><name>lock</name><operator>-&gt;</operator><name>grantMask</name></name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PROCLOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"LockCheckConflicts: no conflict"</literal></expr></argument>, <argument><expr><name>proclock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Rats.  Something conflicts.  But it could still be my own lock, or a
	 * lock held by another member of my locking group.  First, figure out how
	 * many conflicts remain after subtracting out any locks I hold myself.
	 */</comment>
	<expr_stmt><expr><name>myLocks</name> <operator>=</operator> <name><name>proclock</name><operator>-&gt;</operator><name>holdMask</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>numLockModes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>conflictMask</name> <operator>&amp;</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>conflictsRemaining</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>conflictsRemaining</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>lock</name><operator>-&gt;</operator><name>granted</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>myLocks</name> <operator>&amp;</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>--</operator><name><name>conflictsRemaining</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>totalConflictsRemaining</name> <operator>+=</operator> <name><name>conflictsRemaining</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* If no conflicts remain, we get the lock. */</comment>
	<if_stmt><if>if <condition>(<expr><name>totalConflictsRemaining</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PROCLOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"LockCheckConflicts: resolved (simple)"</literal></expr></argument>, <argument><expr><name>proclock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If no group locking, it's definitely a conflict. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>proclock</name><operator>-&gt;</operator><name>groupLeader</name></name> <operator>==</operator> <name>MyProc</name> <operator>&amp;&amp;</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>lockGroupLeader</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>proclock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myProc</name></name> <operator>==</operator> <name>MyProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PROCLOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"LockCheckConflicts: conflicting (simple)"</literal></expr></argument>,
					   <argument><expr><name>proclock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The relation extension or page lock conflict even between the group
	 * members.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>LOCK_LOCKTAG</name><argument_list>(<argument><expr><operator>*</operator><name>lock</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>LOCKTAG_RELATION_EXTEND</name> <operator>||</operator>
		<operator>(</operator><call><name>LOCK_LOCKTAG</name><argument_list>(<argument><expr><operator>*</operator><name>lock</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>LOCKTAG_PAGE</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PROCLOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"LockCheckConflicts: conflicting (group)"</literal></expr></argument>,
					   <argument><expr><name>proclock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Locks held in conflicting modes by members of our own lock group are
	 * not real conflicts; we can subtract those out and see if we still have
	 * a conflict.  This is O(N) in the number of processes holding or
	 * awaiting locks on this object.  We could improve that by making the
	 * shared memory state more complex (and larger) but it doesn't seem worth
	 * it.
	 */</comment>
	<expr_stmt><expr><name>procLocks</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>procLocks</name></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>otherproclock</name> <operator>=</operator> <operator>(</operator><name>PROCLOCK</name> <operator>*</operator><operator>)</operator>
		<call><name>SHMQueueNext</name><argument_list>(<argument><expr><name>procLocks</name></expr></argument>, <argument><expr><name>procLocks</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PROCLOCK</name></expr></argument>, <argument><expr><name>lockLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>otherproclock</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>proclock</name> <operator>!=</operator> <name>otherproclock</name> <operator>&amp;&amp;</operator>
			<name><name>proclock</name><operator>-&gt;</operator><name>groupLeader</name></name> <operator>==</operator> <name><name>otherproclock</name><operator>-&gt;</operator><name>groupLeader</name></name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>otherproclock</name><operator>-&gt;</operator><name>holdMask</name></name> <operator>&amp;</operator> <name>conflictMask</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>intersectMask</name> <init>= <expr><name><name>otherproclock</name><operator>-&gt;</operator><name>holdMask</name></name> <operator>&amp;</operator> <name>conflictMask</name></expr></init></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>numLockModes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name>intersectMask</name> <operator>&amp;</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>conflictsRemaining</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"proclocks held do not match lock"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>conflictsRemaining</name><index>[<expr><name>i</name></expr>]</index></name><operator>--</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name>totalConflictsRemaining</name><operator>--</operator></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>

			<if_stmt><if>if <condition>(<expr><name>totalConflictsRemaining</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>PROCLOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"LockCheckConflicts: resolved (group)"</literal></expr></argument>,
							   <argument><expr><name>proclock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>otherproclock</name> <operator>=</operator> <operator>(</operator><name>PROCLOCK</name> <operator>*</operator><operator>)</operator>
			<call><name>SHMQueueNext</name><argument_list>(<argument><expr><name>procLocks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>otherproclock</name><operator>-&gt;</operator><name>lockLink</name></name></expr></argument>,
						 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PROCLOCK</name></expr></argument>, <argument><expr><name>lockLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Nope, it's a real conflict. */</comment>
	<expr_stmt><expr><call><name>PROCLOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"LockCheckConflicts: conflicting (group)"</literal></expr></argument>, <argument><expr><name>proclock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GrantLock -- update the lock and proclock data structures to show
 *		the lock request has been granted.
 *
 * NOTE: if proc was blocked, it also needs to be removed from the wait list
 * and have its waitLock/waitProcLock fields cleared.  That's not done here.
 *
 * NOTE: the lock grant also has to be recorded in the associated LOCALLOCK
 * table entry; but since we may be awaking some other process, we can't do
 * that here; it's done by GrantLockLocal, instead.
 */</comment>
<function><type><name>void</name></type>
<name>GrantLock</name><parameter_list>(<parameter><decl><type><name>LOCK</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>, <parameter><decl><type><name>PROCLOCK</name> <modifier>*</modifier></type><name>proclock</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>nGranted</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>granted</name><index>[<expr><name>lockmode</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>grantMask</name></name> <operator>|=</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>lock</name><operator>-&gt;</operator><name>granted</name><index>[<expr><name>lockmode</name></expr>]</index></name> <operator>==</operator> <name><name>lock</name><operator>-&gt;</operator><name>requested</name><index>[<expr><name>lockmode</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>waitMask</name></name> <operator>&amp;=</operator> <call><name>LOCKBIT_OFF</name><argument_list>(<argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>proclock</name><operator>-&gt;</operator><name>holdMask</name></name> <operator>|=</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"GrantLock"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>nGranted</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>granted</name><index>[<expr><name>lockmode</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lock</name><operator>-&gt;</operator><name>nGranted</name></name> <operator>&lt;=</operator> <name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * UnGrantLock -- opposite of GrantLock.
 *
 * Updates the lock and proclock data structures to show that the lock
 * is no longer held nor requested by the current holder.
 *
 * Returns true if there were any waiters waiting on the lock that
 * should now be woken up with ProcLockWakeup.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>UnGrantLock</name><parameter_list>(<parameter><decl><type><name>LOCK</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>,
			<parameter><decl><type><name>PROCLOCK</name> <modifier>*</modifier></type><name>proclock</name></decl></parameter>, <parameter><decl><type><name>LockMethod</name></type> <name>lockMethodTable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>wakeupNeeded</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>requested</name><index>[<expr><name>lockmode</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>nGranted</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>granted</name><index>[<expr><name>lockmode</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lock</name><operator>-&gt;</operator><name>nGranted</name></name> <operator>&lt;=</operator> <name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * fix the general lock stats
	 */</comment>
	<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>requested</name><index>[<expr><name>lockmode</name></expr>]</index></name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>nGranted</name></name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>granted</name><index>[<expr><name>lockmode</name></expr>]</index></name><operator>--</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>lock</name><operator>-&gt;</operator><name>granted</name><index>[<expr><name>lockmode</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* change the conflict mask.  No more of this lock type. */</comment>
		<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>grantMask</name></name> <operator>&amp;=</operator> <call><name>LOCKBIT_OFF</name><argument_list>(<argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"UnGrantLock: updated"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We need only run ProcLockWakeup if the released lock conflicts with at
	 * least one of the lock types requested by waiter(s).  Otherwise whatever
	 * conflict made them wait must still exist.  NOTE: before MVCC, we could
	 * skip wakeup if lock-&gt;granted[lockmode] was still positive. But that's
	 * not true anymore, because the remaining granted locks might belong to
	 * some waiter, who could now be awakened because he doesn't conflict with
	 * his own locks.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>lockMethodTable</name><operator>-&gt;</operator><name>conflictTab</name><index>[<expr><name>lockmode</name></expr>]</index></name> <operator>&amp;</operator> <name><name>lock</name><operator>-&gt;</operator><name>waitMask</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>wakeupNeeded</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Now fix the per-proclock state.
	 */</comment>
	<expr_stmt><expr><name><name>proclock</name><operator>-&gt;</operator><name>holdMask</name></name> <operator>&amp;=</operator> <call><name>LOCKBIT_OFF</name><argument_list>(<argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PROCLOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"UnGrantLock: updated"</literal></expr></argument>, <argument><expr><name>proclock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>wakeupNeeded</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CleanUpLock -- clean up after releasing a lock.  We garbage-collect the
 * proclock and lock objects if possible, and call ProcLockWakeup if there
 * are remaining requests and the caller says it's OK.  (Normally, this
 * should be called after UnGrantLock, and wakeupNeeded is the result from
 * UnGrantLock.)
 *
 * The appropriate partition lock must be held at entry, and will be
 * held at exit.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CleanUpLock</name><parameter_list>(<parameter><decl><type><name>LOCK</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>, <parameter><decl><type><name>PROCLOCK</name> <modifier>*</modifier></type><name>proclock</name></decl></parameter>,
			<parameter><decl><type><name>LockMethod</name></type> <name>lockMethodTable</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hashcode</name></decl></parameter>,
			<parameter><decl><type><name>bool</name></type> <name>wakeupNeeded</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If this was my last hold on this lock, delete my entry in the proclock
	 * table.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>proclock</name><operator>-&gt;</operator><name>holdMask</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>proclock_hashcode</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>PROCLOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"CleanUpLock: deleting"</literal></expr></argument>, <argument><expr><name>proclock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SHMQueueDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proclock</name><operator>-&gt;</operator><name>lockLink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SHMQueueDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proclock</name><operator>-&gt;</operator><name>procLink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>proclock_hashcode</name> <operator>=</operator> <call><name>ProcLockHashCode</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proclock</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>, <argument><expr><name>hashcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>LockMethodProcLockHash</name></expr></argument>,
										 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>proclock</name><operator>-&gt;</operator><name>tag</name></name><operator>)</operator></expr></argument>,
										 <argument><expr><name>proclock_hashcode</name></expr></argument>,
										 <argument><expr><name>HASH_REMOVE</name></expr></argument>,
										 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"proclock table corrupted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The caller just released the last lock, so garbage-collect the lock
		 * object.
		 */</comment>
		<expr_stmt><expr><call><name>LOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"CleanUpLock: deleting"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>SHMQueueEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>procLocks</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>LockMethodLockHash</name></expr></argument>,
										 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>tag</name></name><operator>)</operator></expr></argument>,
										 <argument><expr><name>hashcode</name></expr></argument>,
										 <argument><expr><name>HASH_REMOVE</name></expr></argument>,
										 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"lock table corrupted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>wakeupNeeded</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* There are waiters on this lock, so wake them up. */</comment>
		<expr_stmt><expr><call><name>ProcLockWakeup</name><argument_list>(<argument><expr><name>lockMethodTable</name></expr></argument>, <argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * GrantLockLocal -- update the locallock data structures to show
 *		the lock request has been granted.
 *
 * We expect that LockAcquire made sure there is room to add a new
 * ResourceOwner entry.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>GrantLockLocal</name><parameter_list>(<parameter><decl><type><name>LOCALLOCK</name> <modifier>*</modifier></type><name>locallock</name></decl></parameter>, <parameter><decl><type><name>ResourceOwner</name></type> <name>owner</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCALLOCKOWNER</name> <modifier>*</modifier></type><name>lockOwners</name> <init>= <expr><name><name>locallock</name><operator>-&gt;</operator><name>lockOwners</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>locallock</name><operator>-&gt;</operator><name>numLockOwners</name></name> <operator>&lt;</operator> <name><name>locallock</name><operator>-&gt;</operator><name>maxLockOwners</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Count the total */</comment>
	<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>nLocks</name></name><operator>++</operator></expr>;</expr_stmt>
	<comment type="block">/* Count the per-owner lock */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>locallock</name><operator>-&gt;</operator><name>numLockOwners</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>lockOwners</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>owner</name> <operator>==</operator> <name>owner</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>lockOwners</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nLocks</name><operator>++</operator></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>lockOwners</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>owner</name> <operator>=</operator> <name>owner</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lockOwners</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nLocks</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>numLockOwners</name></name><operator>++</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>owner</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResourceOwnerRememberLock</name><argument_list>(<argument><expr><name>owner</name></expr></argument>, <argument><expr><name>locallock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Indicate that the lock is acquired for certain types of locks. */</comment>
	<expr_stmt><expr><call><name>CheckAndSetLockHeld</name><argument_list>(<argument><expr><name>locallock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * BeginStrongLockAcquire - inhibit use of fastpath for a given LOCALLOCK,
 * and arrange for error cleanup if it fails
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>BeginStrongLockAcquire</name><parameter_list>(<parameter><decl><type><name>LOCALLOCK</name> <modifier>*</modifier></type><name>locallock</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>fasthashcode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>StrongLockInProgress</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>locallock</name><operator>-&gt;</operator><name>holdsStrongLockCount</name></name> <operator>==</operator> <name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Adding to a memory location is not atomic, so we take a spinlock to
	 * ensure we don't collide with someone else trying to bump the count at
	 * the same time.
	 *
	 * XXX: It might be worth considering using an atomic fetch-and-add
	 * instruction here, on architectures where that is supported.
	 */</comment>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>FastPathStrongRelationLocks</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>FastPathStrongRelationLocks</name><operator>-&gt;</operator><name>count</name><index>[<expr><name>fasthashcode</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>holdsStrongLockCount</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>StrongLockInProgress</name> <operator>=</operator> <name>locallock</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>FastPathStrongRelationLocks</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * FinishStrongLockAcquire - cancel pending cleanup for a strong lock
 * acquisition once it's no longer needed
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FinishStrongLockAcquire</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>StrongLockInProgress</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AbortStrongLockAcquire - undo strong lock state changes performed by
 * BeginStrongLockAcquire.
 */</comment>
<function><type><name>void</name></type>
<name>AbortStrongLockAcquire</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>fasthashcode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCALLOCK</name>  <modifier>*</modifier></type><name>locallock</name> <init>= <expr><name>StrongLockInProgress</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>locallock</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>fasthashcode</name> <operator>=</operator> <call><name>FastPathStrongLockHashPartition</name><argument_list>(<argument><expr><name><name>locallock</name><operator>-&gt;</operator><name>hashcode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>locallock</name><operator>-&gt;</operator><name>holdsStrongLockCount</name></name> <operator>==</operator> <name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>FastPathStrongRelationLocks</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>FastPathStrongRelationLocks</name><operator>-&gt;</operator><name>count</name><index>[<expr><name>fasthashcode</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>FastPathStrongRelationLocks</name><operator>-&gt;</operator><name>count</name><index>[<expr><name>fasthashcode</name></expr>]</index></name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>holdsStrongLockCount</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>StrongLockInProgress</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>FastPathStrongRelationLocks</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * GrantAwaitedLock -- call GrantLockLocal for the lock we are doing
 *		WaitOnLock on.
 *
 * proc.c needs this for the case where we are booted off the lock by
 * timeout, but discover that someone granted us the lock anyway.
 *
 * We could just export GrantLockLocal, but that would require including
 * resowner.h in lock.h, which creates circularity.
 */</comment>
<function><type><name>void</name></type>
<name>GrantAwaitedLock</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>GrantLockLocal</name><argument_list>(<argument><expr><name>awaitedLock</name></expr></argument>, <argument><expr><name>awaitedOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * MarkLockClear -- mark an acquired lock as "clear"
 *
 * This means that we know we have absorbed all sinval messages that other
 * sessions generated before we acquired this lock, and so we can confidently
 * assume we know about any catalog changes protected by this lock.
 */</comment>
<function><type><name>void</name></type>
<name>MarkLockClear</name><parameter_list>(<parameter><decl><type><name>LOCALLOCK</name> <modifier>*</modifier></type><name>locallock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>locallock</name><operator>-&gt;</operator><name>nLocks</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>lockCleared</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * WaitOnLock -- wait to acquire a lock
 *
 * Caller must have set MyProc-&gt;heldLocks to reflect locks already held
 * on the lockable object by this process.
 *
 * The appropriate partition lock must be held at entry.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WaitOnLock</name><parameter_list>(<parameter><decl><type><name>LOCALLOCK</name> <modifier>*</modifier></type><name>locallock</name></decl></parameter>, <parameter><decl><type><name>ResourceOwner</name></type> <name>owner</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKMETHODID</name></type> <name>lockmethodid</name> <init>= <expr><call><name>LOCALLOCK_LOCKMETHOD</name><argument_list>(<argument><expr><operator>*</operator><name>locallock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LockMethod</name></type>	<name>lockMethodTable</name> <init>= <expr><name><name>LockMethods</name><index>[<expr><name>lockmethodid</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier><specifier>volatile</specifier></type> <name>new_status</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"WaitOnLock: sleeping on lock"</literal></expr></argument>,
			   <argument><expr><name><name>locallock</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>, <argument><expr><name><name>locallock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Report change to waiting status */</comment>
	<if_stmt><if>if <condition>(<expr><name>update_process_title</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>old_status</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>old_status</name> <operator>=</operator> <call><name>get_ps_display</name><argument_list>(<argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>new_status</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">8</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new_status</name></expr></argument>, <argument><expr><name>old_status</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>new_status</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><literal type="string">" waiting"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><name>new_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new_status</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt> <comment type="block">/* truncate off " waiting" */</comment>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>awaitedLock</name> <operator>=</operator> <name>locallock</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>awaitedOwner</name> <operator>=</operator> <name>owner</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * NOTE: Think not to put any shared-state cleanup after the call to
	 * ProcSleep, in either the normal or failure path.  The lock state must
	 * be fully set by the lock grantor, or by CheckDeadLock if we give up
	 * waiting for the lock.  This is necessary because of the possibility
	 * that a cancel/die interrupt will interrupt ProcSleep after someone else
	 * grants us the lock, but before we've noticed it. Hence, after granting,
	 * the locktable state must fully reflect the fact that we own the lock;
	 * we can't do additional work on return.
	 *
	 * We can and do use a PG_TRY block to try to clean up after failure, but
	 * this still has a major limitation: elog(FATAL) can occur while waiting
	 * (eg, a "die" interrupt), and then control won't come back here. So all
	 * cleanup of essential state should happen in LockErrorCleanup, not here.
	 * We can use PG_TRY to clear the "waiting" status flags, since doing that
	 * is unimportant if the process exits.
	 */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>ProcSleep</name><argument_list>(<argument><expr><name>locallock</name></expr></argument>, <argument><expr><name>lockMethodTable</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>STATUS_OK</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We failed as a result of a deadlock, see CheckDeadLock(). Quit
			 * now.
			 */</comment>
			<expr_stmt><expr><name>awaitedLock</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"WaitOnLock: aborting on lock"</literal></expr></argument>,
					   <argument><expr><name><name>locallock</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>, <argument><expr><name><name>locallock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>LockHashPartitionLock</name><argument_list>(<argument><expr><name><name>locallock</name><operator>-&gt;</operator><name>hashcode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Now that we aren't holding the partition lock, we can give an
			 * error report including details about the detected deadlock.
			 */</comment>
			<expr_stmt><expr><call><name>DeadLockReport</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* not reached */</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/* In this path, awaitedLock remains set until LockErrorCleanup */</comment>

		<comment type="block">/* Report change to non-waiting status */</comment>
		<if_stmt><if>if <condition>(<expr><name>update_process_title</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><name>new_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* and propagate the error */</comment>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>awaitedLock</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Report change to non-waiting status */</comment>
	<if_stmt><if>if <condition>(<expr><name>update_process_title</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><name>new_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"WaitOnLock: wakeup on lock"</literal></expr></argument>,
			   <argument><expr><name><name>locallock</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>, <argument><expr><name><name>locallock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Remove a proc from the wait-queue it is on (caller must know it is on one).
 * This is only used when the proc has failed to get the lock, so we set its
 * waitStatus to STATUS_ERROR.
 *
 * Appropriate partition lock must be held by caller.  Also, caller is
 * responsible for signaling the proc if needed.
 *
 * NB: this does not clean up any locallock object that may exist for the lock.
 */</comment>
<function><type><name>void</name></type>
<name>RemoveFromWaitQueue</name><parameter_list>(<parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hashcode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCK</name>	   <modifier>*</modifier></type><name>waitLock</name> <init>= <expr><name><name>proc</name><operator>-&gt;</operator><name>waitLock</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PROCLOCK</name>   <modifier>*</modifier></type><name>proclock</name> <init>= <expr><name><name>proc</name><operator>-&gt;</operator><name>waitProcLock</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>lockmode</name> <init>= <expr><name><name>proc</name><operator>-&gt;</operator><name>waitLockMode</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMETHODID</name></type> <name>lockmethodid</name> <init>= <expr><call><name>LOCK_LOCKMETHOD</name><argument_list>(<argument><expr><operator>*</operator><name>waitLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Make sure proc is waiting */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>waitStatus</name></name> <operator>==</operator> <name>STATUS_WAITING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>next</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>waitLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>waitLock</name><operator>-&gt;</operator><name>waitProcs</name><operator>.</operator><name>size</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>&lt;</operator> <name>lockmethodid</name> <operator>&amp;&amp;</operator> <name>lockmethodid</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>LockMethods</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Remove proc from lock's wait queue */</comment>
	<expr_stmt><expr><call><name>SHMQueueDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>proc</name><operator>-&gt;</operator><name>links</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>waitLock</name><operator>-&gt;</operator><name>waitProcs</name><operator>.</operator><name>size</name></name><operator>--</operator></expr>;</expr_stmt>

	<comment type="block">/* Undo increments of request counts by waiting process */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>waitLock</name><operator>-&gt;</operator><name>nRequested</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>waitLock</name><operator>-&gt;</operator><name>nRequested</name></name> <operator>&gt;</operator> <name><name>proc</name><operator>-&gt;</operator><name>waitLock</name><operator>-&gt;</operator><name>nGranted</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>waitLock</name><operator>-&gt;</operator><name>nRequested</name></name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>waitLock</name><operator>-&gt;</operator><name>requested</name><index>[<expr><name>lockmode</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>waitLock</name><operator>-&gt;</operator><name>requested</name><index>[<expr><name>lockmode</name></expr>]</index></name><operator>--</operator></expr>;</expr_stmt>
	<comment type="block">/* don't forget to clear waitMask bit if appropriate */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>waitLock</name><operator>-&gt;</operator><name>granted</name><index>[<expr><name>lockmode</name></expr>]</index></name> <operator>==</operator> <name><name>waitLock</name><operator>-&gt;</operator><name>requested</name><index>[<expr><name>lockmode</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>waitLock</name><operator>-&gt;</operator><name>waitMask</name></name> <operator>&amp;=</operator> <call><name>LOCKBIT_OFF</name><argument_list>(<argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Clean up the proc's own state, and pass it the ok/fail signal */</comment>
	<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>waitLock</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>waitProcLock</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>waitStatus</name></name> <operator>=</operator> <name>STATUS_ERROR</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Delete the proclock immediately if it represents no already-held locks.
	 * (This must happen now because if the owner of the lock decides to
	 * release it, and the requested/granted counts then go to zero,
	 * LockRelease expects there to be no remaining proclocks.) Then see if
	 * any other waiters for the lock can be woken up now.
	 */</comment>
	<expr_stmt><expr><call><name>CleanUpLock</name><argument_list>(<argument><expr><name>waitLock</name></expr></argument>, <argument><expr><name>proclock</name></expr></argument>,
				<argument><expr><name><name>LockMethods</name><index>[<expr><name>lockmethodid</name></expr>]</index></name></expr></argument>, <argument><expr><name>hashcode</name></expr></argument>,
				<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * LockRelease -- look up 'locktag' and release one 'lockmode' lock on it.
 *		Release a session lock if 'sessionLock' is true, else release a
 *		regular transaction lock.
 *
 * Side Effects: find any waiting processes that are now wakable,
 *		grant them their requested locks and awaken them.
 *		(We have to grant the lock here to avoid a race between
 *		the waking process and any new process to
 *		come along and request the lock.)
 */</comment>
<function><type><name>bool</name></type>
<name>LockRelease</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LOCKTAG</name> <modifier>*</modifier></type><name>locktag</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>sessionLock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKMETHODID</name></type> <name>lockmethodid</name> <init>= <expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_lockmethodid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LockMethod</name></type>	<name>lockMethodTable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCALLOCKTAG</name></type> <name>localtag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCALLOCK</name>  <modifier>*</modifier></type><name>locallock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCK</name>	   <modifier>*</modifier></type><name>lock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PROCLOCK</name>   <modifier>*</modifier></type><name>proclock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLock</name>	   <modifier>*</modifier></type><name>partitionLock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>wakeupNeeded</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>lockmethodid</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>lockmethodid</name> <operator>&gt;=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>LockMethods</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized lock method: %d"</literal></expr></argument>, <argument><expr><name>lockmethodid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>lockMethodTable</name> <operator>=</operator> <name><name>LockMethods</name><index>[<expr><name>lockmethodid</name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>lockmode</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>lockmode</name> <operator>&gt;</operator> <name><name>lockMethodTable</name><operator>-&gt;</operator><name>numLockModes</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized lock mode: %d"</literal></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LOCK_DEBUG</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><call><name>LOCK_DEBUG_ENABLED</name><argument_list>(<argument><expr><name>locktag</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"LockRelease: lock [%u,%u] %s"</literal></expr></argument>,
			 <argument><expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_field1</name></name></expr></argument>, <argument><expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_field2</name></name></expr></argument>,
			 <argument><expr><name><name>lockMethodTable</name><operator>-&gt;</operator><name>lockModeNames</name><index>[<expr><name>lockmode</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Find the LOCALLOCK entry for this lock and lockmode
	 */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>localtag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>localtag</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* must clear padding */</comment>
	<expr_stmt><expr><name><name>localtag</name><operator>.</operator><name>lock</name></name> <operator>=</operator> <operator>*</operator><name>locktag</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>localtag</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name>lockmode</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>locallock</name> <operator>=</operator> <operator>(</operator><name>LOCALLOCK</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>LockMethodLocalHash</name></expr></argument>,
										  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>localtag</name></expr></argument>,
										  <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * let the caller print its own error message, too. Do not ereport(ERROR).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>locallock</name> <operator>||</operator> <name><name>locallock</name><operator>-&gt;</operator><name>nLocks</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"you don't own a lock of type %s"</literal></expr></argument>,
			 <argument><expr><name><name>lockMethodTable</name><operator>-&gt;</operator><name>lockModeNames</name><index>[<expr><name>lockmode</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Decrease the count for the resource owner.
	 */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LOCALLOCKOWNER</name> <modifier>*</modifier></type><name>lockOwners</name> <init>= <expr><name><name>locallock</name><operator>-&gt;</operator><name>lockOwners</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ResourceOwner</name></type> <name>owner</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/* Identify owner for lock */</comment>
		<if_stmt><if>if <condition>(<expr><name>sessionLock</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>owner</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>owner</name> <operator>=</operator> <name>CurrentResourceOwner</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>locallock</name><operator>-&gt;</operator><name>numLockOwners</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>lockOwners</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>owner</name> <operator>==</operator> <name>owner</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lockOwners</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nLocks</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>--</operator><name><name>lockOwners</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nLocks</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>owner</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ResourceOwnerForgetLock</name><argument_list>(<argument><expr><name>owner</name></expr></argument>, <argument><expr><name>locallock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<comment type="block">/* compact out unused slot */</comment>
					<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>numLockOwners</name></name><operator>--</operator></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>locallock</name><operator>-&gt;</operator><name>numLockOwners</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>lockOwners</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>lockOwners</name><index>[<expr><name><name>locallock</name><operator>-&gt;</operator><name>numLockOwners</name></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* don't release a lock belonging to another owner */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"you don't own a lock of type %s"</literal></expr></argument>,
				 <argument><expr><name><name>lockMethodTable</name><operator>-&gt;</operator><name>lockModeNames</name><index>[<expr><name>lockmode</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Decrease the total local count.  If we're still holding the lock, we're
	 * done.
	 */</comment>
	<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>nLocks</name></name><operator>--</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>locallock</name><operator>-&gt;</operator><name>nLocks</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * At this point we can no longer suppose we are clear of invalidation
	 * messages related to this lock.  Although we'll delete the LOCALLOCK
	 * object before any intentional return from this routine, it seems worth
	 * the trouble to explicitly reset lockCleared right now, just in case
	 * some error prevents us from deleting the LOCALLOCK.
	 */</comment>
	<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>lockCleared</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Attempt fast release of any lock eligible for the fast path. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>EligibleForRelationFastPath</name><argument_list>(<argument><expr><name>locktag</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name>FastPathLocalUseCount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>released</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We might not find the lock here, even if we originally entered it
		 * here.  Another backend may have moved it to the main table.
		 */</comment>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>fpInfoLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>released</name> <operator>=</operator> <call><name>FastPathUnGrantRelationLock</name><argument_list>(<argument><expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_field2</name></name></expr></argument>,
											   <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>fpInfoLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>released</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>RemoveLocalLock</name><argument_list>(<argument><expr><name>locallock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise we've got to mess with the shared lock table.
	 */</comment>
	<expr_stmt><expr><name>partitionLock</name> <operator>=</operator> <call><name>LockHashPartitionLock</name><argument_list>(<argument><expr><name><name>locallock</name><operator>-&gt;</operator><name>hashcode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Normally, we don't need to re-find the lock or proclock, since we kept
	 * their addresses in the locallock table, and they couldn't have been
	 * removed while we were holding a lock on them.  But it's possible that
	 * the lock was taken fast-path and has since been moved to the main hash
	 * table by another backend, in which case we will need to look up the
	 * objects here.  We assume the lock field is NULL if so.
	 */</comment>
	<expr_stmt><expr><name>lock</name> <operator>=</operator> <name><name>locallock</name><operator>-&gt;</operator><name>lock</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lock</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PROCLOCKTAG</name></type> <name>proclocktag</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>EligibleForRelationFastPath</name><argument_list>(<argument><expr><name>locktag</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lock</name> <operator>=</operator> <operator>(</operator><name>LOCK</name> <operator>*</operator><operator>)</operator> <call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>LockMethodLockHash</name></expr></argument>,
													<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator> <name>locktag</name></expr></argument>,
													<argument><expr><name><name>locallock</name><operator>-&gt;</operator><name>hashcode</name></name></expr></argument>,
													<argument><expr><name>HASH_FIND</name></expr></argument>,
													<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lock</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to re-find shared lock object"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>lock</name></name> <operator>=</operator> <name>lock</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>proclocktag</name><operator>.</operator><name>myLock</name></name> <operator>=</operator> <name>lock</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>proclocktag</name><operator>.</operator><name>myProc</name></name> <operator>=</operator> <name>MyProc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>proclock</name></name> <operator>=</operator> <operator>(</operator><name>PROCLOCK</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>LockMethodProcLockHash</name></expr></argument>,
													   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>proclocktag</name></expr></argument>,
													   <argument><expr><name>HASH_FIND</name></expr></argument>,
													   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>locallock</name><operator>-&gt;</operator><name>proclock</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to re-find shared proclock object"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>LOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"LockRelease: found"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>proclock</name> <operator>=</operator> <name><name>locallock</name><operator>-&gt;</operator><name>proclock</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PROCLOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"LockRelease: found"</literal></expr></argument>, <argument><expr><name>proclock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Double-check that we are actually holding a lock of the type we want to
	 * release.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>proclock</name><operator>-&gt;</operator><name>holdMask</name></name> <operator>&amp;</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>lockmode</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PROCLOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"LockRelease: WRONGTYPE"</literal></expr></argument>, <argument><expr><name>proclock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"you don't own a lock of type %s"</literal></expr></argument>,
			 <argument><expr><name><name>lockMethodTable</name><operator>-&gt;</operator><name>lockModeNames</name><index>[<expr><name>lockmode</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RemoveLocalLock</name><argument_list>(<argument><expr><name>locallock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Do the releasing.  CleanUpLock will waken any now-wakable waiters.
	 */</comment>
	<expr_stmt><expr><name>wakeupNeeded</name> <operator>=</operator> <call><name>UnGrantLock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>proclock</name></expr></argument>, <argument><expr><name>lockMethodTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CleanUpLock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>proclock</name></expr></argument>,
				<argument><expr><name>lockMethodTable</name></expr></argument>, <argument><expr><name><name>locallock</name><operator>-&gt;</operator><name>hashcode</name></name></expr></argument>,
				<argument><expr><name>wakeupNeeded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>RemoveLocalLock</name><argument_list>(<argument><expr><name>locallock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * LockReleaseAll -- Release all locks of the specified lock method that
 *		are held by the current process.
 *
 * Well, not necessarily *all* locks.  The available behaviors are:
 *		allLocks == true: release all locks including session locks.
 *		allLocks == false: release all non-session locks.
 */</comment>
<function><type><name>void</name></type>
<name>LockReleaseAll</name><parameter_list>(<parameter><decl><type><name>LOCKMETHODID</name></type> <name>lockmethodid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>allLocks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LockMethod</name></type>	<name>lockMethodTable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>numLockModes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCALLOCK</name>  <modifier>*</modifier></type><name>locallock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCK</name>	   <modifier>*</modifier></type><name>lock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PROCLOCK</name>   <modifier>*</modifier></type><name>proclock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>partition</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_fast_path_lwlock</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>lockmethodid</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>lockmethodid</name> <operator>&gt;=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>LockMethods</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized lock method: %d"</literal></expr></argument>, <argument><expr><name>lockmethodid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>lockMethodTable</name> <operator>=</operator> <name><name>LockMethods</name><index>[<expr><name>lockmethodid</name></expr>]</index></name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LOCK_DEBUG</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><name><name>lockMethodTable</name><operator>-&gt;</operator><name>trace_flag</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"LockReleaseAll: lockmethod=%d"</literal></expr></argument>, <argument><expr><name>lockmethodid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Get rid of our fast-path VXID lock, if appropriate.  Note that this is
	 * the only way that the lock we hold on our own VXID can ever get
	 * released: it is always and only released when a toplevel transaction
	 * ends.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>lockmethodid</name> <operator>==</operator> <name>DEFAULT_LOCKMETHOD</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>VirtualXactLockTableCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>numLockModes</name> <operator>=</operator> <name><name>lockMethodTable</name><operator>-&gt;</operator><name>numLockModes</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * First we run through the locallock table and get rid of unwanted
	 * entries, then we scan the process's proclocks and get rid of those. We
	 * do this separately because we may have multiple locallock entries
	 * pointing to the same proclock, and we daren't end up with any dangling
	 * pointers.  Fast-path locks are cleaned up during the locallock table
	 * scan, though.
	 */</comment>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>LockMethodLocalHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>locallock</name> <operator>=</operator> <operator>(</operator><name>LOCALLOCK</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If the LOCALLOCK entry is unused, we must've run out of shared
		 * memory while trying to set up this lock.  Just forget the local
		 * entry.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>locallock</name><operator>-&gt;</operator><name>nLocks</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>RemoveLocalLock</name><argument_list>(<argument><expr><name>locallock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Ignore items that are not of the lockmethod to be removed */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>LOCALLOCK_LOCKMETHOD</name><argument_list>(<argument><expr><operator>*</operator><name>locallock</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>lockmethodid</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If we are asked to release all locks, we can just zap the entry.
		 * Otherwise, must scan to see if there are session locks. We assume
		 * there is at most one lockOwners entry for session locks.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allLocks</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>LOCALLOCKOWNER</name> <modifier>*</modifier></type><name>lockOwners</name> <init>= <expr><name><name>locallock</name><operator>-&gt;</operator><name>lockOwners</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* If session lock is above array position 0, move it down to 0 */</comment>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>locallock</name><operator>-&gt;</operator><name>numLockOwners</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>lockOwners</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>owner</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>lockOwners</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>lockOwners</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ResourceOwnerForgetLock</name><argument_list>(<argument><expr><name><name>lockOwners</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>owner</name></expr></argument>, <argument><expr><name>locallock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></for>

			<if_stmt><if>if <condition>(<expr><name><name>locallock</name><operator>-&gt;</operator><name>numLockOwners</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<name><name>lockOwners</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>owner</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				<name><name>lockOwners</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>nLocks</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Fix the locallock to show just the session locks */</comment>
				<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>nLocks</name></name> <operator>=</operator> <name><name>lockOwners</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>nLocks</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>numLockOwners</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<comment type="block">/* We aren't deleting this locallock, so done */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>numLockOwners</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If the lock or proclock pointers are NULL, this lock was taken via
		 * the relation fast-path (and is not known to have been transferred).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>locallock</name><operator>-&gt;</operator><name>proclock</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>locallock</name><operator>-&gt;</operator><name>lock</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>lockmode</name> <init>= <expr><name><name>locallock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>mode</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>

			<comment type="block">/* Verify that a fast-path lock is what we've got. */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EligibleForRelationFastPath</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>locallock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>lock</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"locallock table corrupted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * If we don't currently hold the LWLock that protects our
			 * fast-path data structures, we must acquire it before attempting
			 * to release the lock via the fast-path.  We will continue to
			 * hold the LWLock until we're done scanning the locallock table,
			 * unless we hit a transferred fast-path lock.  (XXX is this
			 * really such a good idea?  There could be a lot of entries ...)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_fast_path_lwlock</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>fpInfoLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>have_fast_path_lwlock</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Attempt fast-path release. */</comment>
			<expr_stmt><expr><name>relid</name> <operator>=</operator> <name><name>locallock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>lock</name><operator>.</operator><name>locktag_field2</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>FastPathUnGrantRelationLock</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>RemoveLocalLock</name><argument_list>(<argument><expr><name>locallock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Our lock, originally taken via the fast path, has been
			 * transferred to the main lock table.  That's going to require
			 * some extra work, so release our fast-path lock before starting.
			 */</comment>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>fpInfoLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>have_fast_path_lwlock</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Now dump the lock.  We haven't got a pointer to the LOCK or
			 * PROCLOCK in this case, so we have to handle this a bit
			 * differently than a normal lock release.  Unfortunately, this
			 * requires an extra LWLock acquire-and-release cycle on the
			 * partitionLock, but hopefully it shouldn't happen often.
			 */</comment>
			<expr_stmt><expr><call><name>LockRefindAndRelease</name><argument_list>(<argument><expr><name>lockMethodTable</name></expr></argument>, <argument><expr><name>MyProc</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name><name>locallock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>lock</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>RemoveLocalLock</name><argument_list>(<argument><expr><name>locallock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Mark the proclock to show we need to release this lockmode */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>locallock</name><operator>-&gt;</operator><name>nLocks</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>proclock</name><operator>-&gt;</operator><name>releaseMask</name></name> <operator>|=</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name><name>locallock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* And remove the locallock hashtable entry */</comment>
		<expr_stmt><expr><call><name>RemoveLocalLock</name><argument_list>(<argument><expr><name>locallock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Done with the fast-path data structures */</comment>
	<if_stmt><if>if <condition>(<expr><name>have_fast_path_lwlock</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>fpInfoLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Now, scan each lock partition separately.
	 */</comment>
	<for>for <control>(<init><expr><name>partition</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>partition</name> <operator>&lt;</operator> <name>NUM_LOCK_PARTITIONS</name></expr>;</condition> <incr><expr><name>partition</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LWLock</name>	   <modifier>*</modifier></type><name>partitionLock</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SHM_QUEUE</name>  <modifier>*</modifier></type><name>procLocks</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>MyProc</name><operator>-&gt;</operator><name>myProcLocks</name><index>[<expr><name>partition</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PROCLOCK</name>   <modifier>*</modifier></type><name>nextplock</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>partitionLock</name> <operator>=</operator> <call><name>LockHashPartitionLockByIndex</name><argument_list>(<argument><expr><name>partition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the proclock list for this partition is empty, we can skip
		 * acquiring the partition lock.  This optimization is trickier than
		 * it looks, because another backend could be in process of adding
		 * something to our proclock list due to promoting one of our
		 * fast-path locks.  However, any such lock must be one that we
		 * decided not to delete above, so it's okay to skip it again now;
		 * we'd just decide not to delete it again.  We must, however, be
		 * careful to re-fetch the list header once we've acquired the
		 * partition lock, to be sure we have a valid, up-to-date pointer.
		 * (There is probably no significant risk if pointer fetch/store is
		 * atomic, but we don't wish to assume that.)
		 *
		 * XXX This argument assumes that the locallock table correctly
		 * represents all of our fast-path locks.  While allLocks mode
		 * guarantees to clean up all of our normal locks regardless of the
		 * locallock situation, we lose that guarantee for fast-path locks.
		 * This is not ideal.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>SHMQueueNext</name><argument_list>(<argument><expr><name>procLocks</name></expr></argument>, <argument><expr><name>procLocks</name></expr></argument>,
						 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PROCLOCK</name></expr></argument>, <argument><expr><name>procLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* needn't examine this partition */</comment>

		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>proclock</name> <operator>=</operator> <operator>(</operator><name>PROCLOCK</name> <operator>*</operator><operator>)</operator> <call><name>SHMQueueNext</name><argument_list>(<argument><expr><name>procLocks</name></expr></argument>, <argument><expr><name>procLocks</name></expr></argument>,
												  <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PROCLOCK</name></expr></argument>, <argument><expr><name>procLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</init>
			 <condition><expr><name>proclock</name></expr>;</condition>
			 <incr><expr><name>proclock</name> <operator>=</operator> <name>nextplock</name></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>wakeupNeeded</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Get link first, since we may unlink/delete this proclock */</comment>
			<expr_stmt><expr><name>nextplock</name> <operator>=</operator> <operator>(</operator><name>PROCLOCK</name> <operator>*</operator><operator>)</operator>
				<call><name>SHMQueueNext</name><argument_list>(<argument><expr><name>procLocks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>proclock</name><operator>-&gt;</operator><name>procLink</name></name></expr></argument>,
							 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PROCLOCK</name></expr></argument>, <argument><expr><name>procLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>proclock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myProc</name></name> <operator>==</operator> <name>MyProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>lock</name> <operator>=</operator> <name><name>proclock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myLock</name></name></expr>;</expr_stmt>

			<comment type="block">/* Ignore items that are not of the lockmethod to be removed */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>LOCK_LOCKMETHOD</name><argument_list>(<argument><expr><operator>*</operator><name>lock</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>lockmethodid</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * In allLocks mode, force release of all locks even if locallock
			 * table had problems
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>allLocks</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>proclock</name><operator>-&gt;</operator><name>releaseMask</name></name> <operator>=</operator> <name><name>proclock</name><operator>-&gt;</operator><name>holdMask</name></name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>proclock</name><operator>-&gt;</operator><name>releaseMask</name></name> <operator>&amp;</operator> <operator>~</operator><name><name>proclock</name><operator>-&gt;</operator><name>holdMask</name></name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/*
			 * Ignore items that have nothing to be released, unless they have
			 * holdMask == 0 and are therefore recyclable
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>proclock</name><operator>-&gt;</operator><name>releaseMask</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>proclock</name><operator>-&gt;</operator><name>holdMask</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>PROCLOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"LockReleaseAll"</literal></expr></argument>, <argument><expr><name>proclock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"LockReleaseAll"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lock</name><operator>-&gt;</operator><name>nGranted</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lock</name><operator>-&gt;</operator><name>nGranted</name></name> <operator>&lt;=</operator> <name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>proclock</name><operator>-&gt;</operator><name>holdMask</name></name> <operator>&amp;</operator> <operator>~</operator><name><name>lock</name><operator>-&gt;</operator><name>grantMask</name></name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Release the previously-marked lock modes
			 */</comment>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>numLockModes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>proclock</name><operator>-&gt;</operator><name>releaseMask</name></name> <operator>&amp;</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>wakeupNeeded</name> <operator>|=</operator> <call><name>UnGrantLock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>proclock</name></expr></argument>,
												<argument><expr><name>lockMethodTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>nGranted</name></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lock</name><operator>-&gt;</operator><name>nGranted</name></name> <operator>&lt;=</operator> <name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"LockReleaseAll: updated"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>proclock</name><operator>-&gt;</operator><name>releaseMask</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<comment type="block">/* CleanUpLock will wake up waiters if needed. */</comment>
			<expr_stmt><expr><call><name>CleanUpLock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>proclock</name></expr></argument>,
						<argument><expr><name>lockMethodTable</name></expr></argument>,
						<argument><expr><call><name>LockTagHashCode</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>wakeupNeeded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>						<comment type="block">/* loop over PROCLOCKs within this partition */</comment>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>							<comment type="block">/* loop over partitions */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LOCK_DEBUG</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><name><name>lockMethodTable</name><operator>-&gt;</operator><name>trace_flag</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"LockReleaseAll done"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * LockReleaseSession -- Release all session locks of the specified lock method
 *		that are held by the current process.
 */</comment>
<function><type><name>void</name></type>
<name>LockReleaseSession</name><parameter_list>(<parameter><decl><type><name>LOCKMETHODID</name></type> <name>lockmethodid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCALLOCK</name>  <modifier>*</modifier></type><name>locallock</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>lockmethodid</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>lockmethodid</name> <operator>&gt;=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>LockMethods</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized lock method: %d"</literal></expr></argument>, <argument><expr><name>lockmethodid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>LockMethodLocalHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>locallock</name> <operator>=</operator> <operator>(</operator><name>LOCALLOCK</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Ignore items that are not of the specified lock method */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>LOCALLOCK_LOCKMETHOD</name><argument_list>(<argument><expr><operator>*</operator><name>locallock</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>lockmethodid</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ReleaseLockIfHeld</name><argument_list>(<argument><expr><name>locallock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * LockReleaseCurrentOwner
 *		Release all locks belonging to CurrentResourceOwner
 *
 * If the caller knows what those locks are, it can pass them as an array.
 * That speeds up the call significantly, when a lot of locks are held.
 * Otherwise, pass NULL for locallocks, and we'll traverse through our hash
 * table to find them.
 */</comment>
<function><type><name>void</name></type>
<name>LockReleaseCurrentOwner</name><parameter_list>(<parameter><decl><type><name>LOCALLOCK</name> <modifier>*</modifier><modifier>*</modifier></type><name>locallocks</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nlocks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>locallocks</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LOCALLOCK</name>  <modifier>*</modifier></type><name>locallock</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>LockMethodLocalHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<while>while <condition>(<expr><operator>(</operator><name>locallock</name> <operator>=</operator> <operator>(</operator><name>LOCALLOCK</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ReleaseLockIfHeld</name><argument_list>(<argument><expr><name>locallock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>nlocks</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ReleaseLockIfHeld</name><argument_list>(<argument><expr><name><name>locallocks</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ReleaseLockIfHeld
 *		Release any session-level locks on this lockable object if sessionLock
 *		is true; else, release any locks held by CurrentResourceOwner.
 *
 * It is tempting to pass this a ResourceOwner pointer (or NULL for session
 * locks), but without refactoring LockRelease() we cannot support releasing
 * locks belonging to resource owners other than CurrentResourceOwner.
 * If we were to refactor, it'd be a good idea to fix it so we don't have to
 * do a hashtable lookup of the locallock, too.  However, currently this
 * function isn't used heavily enough to justify refactoring for its
 * convenience.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReleaseLockIfHeld</name><parameter_list>(<parameter><decl><type><name>LOCALLOCK</name> <modifier>*</modifier></type><name>locallock</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>sessionLock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResourceOwner</name></type> <name>owner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCALLOCKOWNER</name> <modifier>*</modifier></type><name>lockOwners</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Identify owner for lock (must match LockRelease!) */</comment>
	<if_stmt><if>if <condition>(<expr><name>sessionLock</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>owner</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>owner</name> <operator>=</operator> <name>CurrentResourceOwner</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Scan to see if there are any locks belonging to the target owner */</comment>
	<expr_stmt><expr><name>lockOwners</name> <operator>=</operator> <name><name>locallock</name><operator>-&gt;</operator><name>lockOwners</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>locallock</name><operator>-&gt;</operator><name>numLockOwners</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>lockOwners</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>owner</name> <operator>==</operator> <name>owner</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lockOwners</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nLocks</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>lockOwners</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nLocks</name> <operator>&lt;</operator> <name><name>locallock</name><operator>-&gt;</operator><name>nLocks</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * We will still hold this lock after forgetting this
				 * ResourceOwner.
				 */</comment>
				<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>nLocks</name></name> <operator>-=</operator> <name><name>lockOwners</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nLocks</name></expr>;</expr_stmt>
				<comment type="block">/* compact out unused slot */</comment>
				<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>numLockOwners</name></name><operator>--</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>owner</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ResourceOwnerForgetLock</name><argument_list>(<argument><expr><name>owner</name></expr></argument>, <argument><expr><name>locallock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>locallock</name><operator>-&gt;</operator><name>numLockOwners</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>lockOwners</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>lockOwners</name><index>[<expr><name><name>locallock</name><operator>-&gt;</operator><name>numLockOwners</name></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lockOwners</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nLocks</name> <operator>==</operator> <name><name>locallock</name><operator>-&gt;</operator><name>nLocks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* We want to call LockRelease just once */</comment>
				<expr_stmt><expr><name><name>lockOwners</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nLocks</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>nLocks</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>LockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>locallock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>lock</name></name></expr></argument>,
								 <argument><expr><name><name>locallock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>mode</name></name></expr></argument>,
								 <argument><expr><name>sessionLock</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"ReleaseLockIfHeld: failed??"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * LockReassignCurrentOwner
 *		Reassign all locks belonging to CurrentResourceOwner to belong
 *		to its parent resource owner.
 *
 * If the caller knows what those locks are, it can pass them as an array.
 * That speeds up the call significantly, when a lot of locks are held
 * (e.g pg_dump with a large schema).  Otherwise, pass NULL for locallocks,
 * and we'll traverse through our hash table to find them.
 */</comment>
<function><type><name>void</name></type>
<name>LockReassignCurrentOwner</name><parameter_list>(<parameter><decl><type><name>LOCALLOCK</name> <modifier>*</modifier><modifier>*</modifier></type><name>locallocks</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nlocks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResourceOwner</name></type> <name>parent</name> <init>= <expr><call><name>ResourceOwnerGetParent</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>parent</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>locallocks</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LOCALLOCK</name>  <modifier>*</modifier></type><name>locallock</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>LockMethodLocalHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<while>while <condition>(<expr><operator>(</operator><name>locallock</name> <operator>=</operator> <operator>(</operator><name>LOCALLOCK</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LockReassignOwner</name><argument_list>(<argument><expr><name>locallock</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>nlocks</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LockReassignOwner</name><argument_list>(<argument><expr><name><name>locallocks</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine of LockReassignCurrentOwner. Reassigns a given lock belonging to
 * CurrentResourceOwner to its parent.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>LockReassignOwner</name><parameter_list>(<parameter><decl><type><name>LOCALLOCK</name> <modifier>*</modifier></type><name>locallock</name></decl></parameter>, <parameter><decl><type><name>ResourceOwner</name></type> <name>parent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCALLOCKOWNER</name> <modifier>*</modifier></type><name>lockOwners</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ic</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ip</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Scan to see if there are any locks belonging to current owner or its
	 * parent
	 */</comment>
	<expr_stmt><expr><name>lockOwners</name> <operator>=</operator> <name><name>locallock</name><operator>-&gt;</operator><name>lockOwners</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>locallock</name><operator>-&gt;</operator><name>numLockOwners</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>lockOwners</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>owner</name> <operator>==</operator> <name>CurrentResourceOwner</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ic</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>lockOwners</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>owner</name> <operator>==</operator> <name>parent</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ip</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>ic</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* no current locks */</comment>

	<if_stmt><if>if <condition>(<expr><name>ip</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Parent has no slot, so just give it the child's slot */</comment>
		<expr_stmt><expr><name><name>lockOwners</name><index>[<expr><name>ic</name></expr>]</index></name><operator>.</operator><name>owner</name> <operator>=</operator> <name>parent</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ResourceOwnerRememberLock</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>locallock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Merge child's count with parent's */</comment>
		<expr_stmt><expr><name><name>lockOwners</name><index>[<expr><name>ip</name></expr>]</index></name><operator>.</operator><name>nLocks</name> <operator>+=</operator> <name><name>lockOwners</name><index>[<expr><name>ic</name></expr>]</index></name><operator>.</operator><name>nLocks</name></expr>;</expr_stmt>
		<comment type="block">/* compact out unused slot */</comment>
		<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>numLockOwners</name></name><operator>--</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ic</name> <operator>&lt;</operator> <name><name>locallock</name><operator>-&gt;</operator><name>numLockOwners</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>lockOwners</name><index>[<expr><name>ic</name></expr>]</index></name> <operator>=</operator> <name><name>lockOwners</name><index>[<expr><name><name>locallock</name><operator>-&gt;</operator><name>numLockOwners</name></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>ResourceOwnerForgetLock</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>, <argument><expr><name>locallock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * FastPathGrantRelationLock
 *		Grant lock using per-backend fast-path array, if there is space.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>FastPathGrantRelationLock</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>f</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>unused_slot</name> <init>= <expr><name>FP_LOCK_SLOTS_PER_BACKEND</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Scan for existing entry for this relid, remembering empty slot. */</comment>
	<for>for <control>(<init><expr><name>f</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <name>FP_LOCK_SLOTS_PER_BACKEND</name></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>FAST_PATH_GET_BITS</name><argument_list>(<argument><expr><name>MyProc</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>unused_slot</name> <operator>=</operator> <name>f</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>MyProc</name><operator>-&gt;</operator><name>fpRelId</name><index>[<expr><name>f</name></expr>]</index></name> <operator>==</operator> <name>relid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>FAST_PATH_CHECK_LOCKMODE</name><argument_list>(<argument><expr><name>MyProc</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FAST_PATH_SET_LOCKMODE</name><argument_list>(<argument><expr><name>MyProc</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* If no existing entry, use any empty slot. */</comment>
	<if_stmt><if>if <condition>(<expr><name>unused_slot</name> <operator>&lt;</operator> <name>FP_LOCK_SLOTS_PER_BACKEND</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>fpRelId</name><index>[<expr><name>unused_slot</name></expr>]</index></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FAST_PATH_SET_LOCKMODE</name><argument_list>(<argument><expr><name>MyProc</name></expr></argument>, <argument><expr><name>unused_slot</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>++</operator><name>FastPathLocalUseCount</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* No existing entry, and no empty slot. */</comment>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * FastPathUnGrantRelationLock
 *		Release fast-path lock, if present.  Update backend-private local
 *		use count, while we're at it.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>FastPathUnGrantRelationLock</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>f</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>FastPathLocalUseCount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>f</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <name>FP_LOCK_SLOTS_PER_BACKEND</name></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>MyProc</name><operator>-&gt;</operator><name>fpRelId</name><index>[<expr><name>f</name></expr>]</index></name> <operator>==</operator> <name>relid</name>
			<operator>&amp;&amp;</operator> <call><name>FAST_PATH_CHECK_LOCKMODE</name><argument_list>(<argument><expr><name>MyProc</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FAST_PATH_CLEAR_LOCKMODE</name><argument_list>(<argument><expr><name>MyProc</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<comment type="block">/* we continue iterating so as to update FastPathLocalUseCount */</comment>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>FAST_PATH_GET_BITS</name><argument_list>(<argument><expr><name>MyProc</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>++</operator><name>FastPathLocalUseCount</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * FastPathTransferRelationLocks
 *		Transfer locks matching the given lock tag from per-backend fast-path
 *		arrays to the shared hash table.
 *
 * Returns true if successful, false if ran out of shared memory.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>FastPathTransferRelationLocks</name><parameter_list>(<parameter><decl><type><name>LockMethod</name></type> <name>lockMethodTable</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LOCKTAG</name> <modifier>*</modifier></type><name>locktag</name></decl></parameter>,
							  <parameter><decl><type><name>uint32</name></type> <name>hashcode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LWLock</name>	   <modifier>*</modifier></type><name>partitionLock</name> <init>= <expr><call><name>LockHashPartitionLock</name><argument_list>(<argument><expr><name>hashcode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_field2</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Every PGPROC that can potentially hold a fast-path lock is present in
	 * ProcGlobal-&gt;allProcs.  Prepared transactions are not, but any
	 * outstanding fast-path locks held by prepared transactions are
	 * transferred to the main lock table.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ProcGlobal</name><operator>-&gt;</operator><name>allProcCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allProcs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>f</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>fpInfoLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the target backend isn't referencing the same database as the
		 * lock, then we needn't examine the individual relation IDs at all;
		 * none of them can be relevant.
		 *
		 * proc-&gt;databaseId is set at backend startup time and never changes
		 * thereafter, so it might be safe to perform this test before
		 * acquiring &amp;proc-&gt;fpInfoLock.  In particular, it's certainly safe to
		 * assume that if the target backend holds any fast-path locks, it
		 * must have performed a memory-fencing operation (in particular, an
		 * LWLock acquisition) since setting proc-&gt;databaseId.  However, it's
		 * less clear that our backend is certain to have performed a memory
		 * fencing operation since the other backend set proc-&gt;databaseId.  So
		 * for now, we test it after acquiring the LWLock just to be safe.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>databaseId</name></name> <operator>!=</operator> <name><name>locktag</name><operator>-&gt;</operator><name>locktag_field1</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>fpInfoLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<for>for <control>(<init><expr><name>f</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <name>FP_LOCK_SLOTS_PER_BACKEND</name></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint32</name></type>		<name>lockmode</name></decl>;</decl_stmt>

			<comment type="block">/* Look for an allocated slot matching the given relid. */</comment>
			<if_stmt><if>if <condition>(<expr><name>relid</name> <operator>!=</operator> <name><name>proc</name><operator>-&gt;</operator><name>fpRelId</name><index>[<expr><name>f</name></expr>]</index></name> <operator>||</operator> <call><name>FAST_PATH_GET_BITS</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* Find or create lock object. */</comment>
			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>lockmode</name> <operator>=</operator> <name>FAST_PATH_LOCKNUMBER_OFFSET</name></expr>;</init>
				 <condition><expr><name>lockmode</name> <operator>&lt;</operator> <name>FAST_PATH_LOCKNUMBER_OFFSET</name> <operator>+</operator> <name>FAST_PATH_BITS_PER_SLOT</name></expr>;</condition>
				 <incr><expr><operator>++</operator><name>lockmode</name></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PROCLOCK</name>   <modifier>*</modifier></type><name>proclock</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FAST_PATH_CHECK_LOCKMODE</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>proclock</name> <operator>=</operator> <call><name>SetupLockInTable</name><argument_list>(<argument><expr><name>lockMethodTable</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>, <argument><expr><name>locktag</name></expr></argument>,
											<argument><expr><name>hashcode</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>proclock</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>fpInfoLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>GrantLock</name><argument_list>(<argument><expr><name><name>proclock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myLock</name></name></expr></argument>, <argument><expr><name>proclock</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>FAST_PATH_CLEAR_LOCKMODE</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* No need to examine remaining slots. */</comment>
			<break>break;</break>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>fpInfoLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * FastPathGetRelationLockEntry
 *		Return the PROCLOCK for a lock originally taken via the fast-path,
 *		transferring it to the primary lock table if necessary.
 *
 * Note: caller takes care of updating the locallock object.
 */</comment>
<function><type><specifier>static</specifier> <name>PROCLOCK</name> <modifier>*</modifier></type>
<name>FastPathGetRelationLockEntry</name><parameter_list>(<parameter><decl><type><name>LOCALLOCK</name> <modifier>*</modifier></type><name>locallock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LockMethod</name></type>	<name>lockMethodTable</name> <init>= <expr><name><name>LockMethods</name><index>[<expr><name>DEFAULT_LOCKMETHOD</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKTAG</name>    <modifier>*</modifier></type><name>locktag</name> <init>= <expr><operator>&amp;</operator><name><name>locallock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>lock</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PROCLOCK</name>   <modifier>*</modifier></type><name>proclock</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLock</name>	   <modifier>*</modifier></type><name>partitionLock</name> <init>= <expr><call><name>LockHashPartitionLock</name><argument_list>(<argument><expr><name><name>locallock</name><operator>-&gt;</operator><name>hashcode</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_field2</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>f</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>fpInfoLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>f</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <name>FP_LOCK_SLOTS_PER_BACKEND</name></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>lockmode</name></decl>;</decl_stmt>

		<comment type="block">/* Look for an allocated slot matching the given relid. */</comment>
		<if_stmt><if>if <condition>(<expr><name>relid</name> <operator>!=</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>fpRelId</name><index>[<expr><name>f</name></expr>]</index></name> <operator>||</operator> <call><name>FAST_PATH_GET_BITS</name><argument_list>(<argument><expr><name>MyProc</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* If we don't have a lock of the given mode, forget it! */</comment>
		<expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name><name>locallock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>mode</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FAST_PATH_CHECK_LOCKMODE</name><argument_list>(<argument><expr><name>MyProc</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* Find or create lock object. */</comment>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>proclock</name> <operator>=</operator> <call><name>SetupLockInTable</name><argument_list>(<argument><expr><name>lockMethodTable</name></expr></argument>, <argument><expr><name>MyProc</name></expr></argument>, <argument><expr><name>locktag</name></expr></argument>,
									<argument><expr><name><name>locallock</name><operator>-&gt;</operator><name>hashcode</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>proclock</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>fpInfoLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of shared memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You might need to increase max_locks_per_transaction."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>GrantLock</name><argument_list>(<argument><expr><name><name>proclock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myLock</name></name></expr></argument>, <argument><expr><name>proclock</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FAST_PATH_CLEAR_LOCKMODE</name><argument_list>(<argument><expr><name>MyProc</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* No need to examine remaining slots. */</comment>
		<break>break;</break>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>fpInfoLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Lock may have already been transferred by some other backend. */</comment>
	<if_stmt><if>if <condition>(<expr><name>proclock</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LOCK</name>	   <modifier>*</modifier></type><name>lock</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PROCLOCKTAG</name></type> <name>proclocktag</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>proclock_hashcode</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>lock</name> <operator>=</operator> <operator>(</operator><name>LOCK</name> <operator>*</operator><operator>)</operator> <call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>LockMethodLockHash</name></expr></argument>,
													<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>locktag</name></expr></argument>,
													<argument><expr><name><name>locallock</name><operator>-&gt;</operator><name>hashcode</name></name></expr></argument>,
													<argument><expr><name>HASH_FIND</name></expr></argument>,
													<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lock</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to re-find shared lock object"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>proclocktag</name><operator>.</operator><name>myLock</name></name> <operator>=</operator> <name>lock</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>proclocktag</name><operator>.</operator><name>myProc</name></name> <operator>=</operator> <name>MyProc</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>proclock_hashcode</name> <operator>=</operator> <call><name>ProcLockHashCode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>proclocktag</name></expr></argument>, <argument><expr><name><name>locallock</name><operator>-&gt;</operator><name>hashcode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>proclock</name> <operator>=</operator> <operator>(</operator><name>PROCLOCK</name> <operator>*</operator><operator>)</operator>
			<call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>LockMethodProcLockHash</name></expr></argument>,
										<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>proclocktag</name></expr></argument>,
										<argument><expr><name>proclock_hashcode</name></expr></argument>,
										<argument><expr><name>HASH_FIND</name></expr></argument>,
										<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>proclock</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to re-find shared proclock object"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>proclock</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetLockConflicts
 *		Get an array of VirtualTransactionIds of xacts currently holding locks
 *		that would conflict with the specified lock/lockmode.
 *		xacts merely awaiting such a lock are NOT reported.
 *
 * The result array is palloc'd and is terminated with an invalid VXID.
 * *countp, if not null, is updated to the number of items set.
 *
 * Of course, the result could be out of date by the time it's returned, so
 * use of this function has to be thought about carefully.  Similarly, a
 * PGPROC with no "lxid" will be considered non-conflicting regardless of any
 * lock it holds.  Existing callers don't care about a locker after that
 * locker's pg_xact updates complete.  CommitTransaction() clears "lxid" after
 * pg_xact updates and before releasing locks.
 *
 * Note we never include the current xact's vxid in the result array,
 * since an xact never blocks itself.
 */</comment>
<function><type><name>VirtualTransactionId</name> <modifier>*</modifier></type>
<name>GetLockConflicts</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LOCKTAG</name> <modifier>*</modifier></type><name>locktag</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>countp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>VirtualTransactionId</name> <modifier>*</modifier></type><name>vxids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMETHODID</name></type> <name>lockmethodid</name> <init>= <expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_lockmethodid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LockMethod</name></type>	<name>lockMethodTable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCK</name>	   <modifier>*</modifier></type><name>lock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMASK</name></type>	<name>conflictMask</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SHM_QUEUE</name>  <modifier>*</modifier></type><name>procLocks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PROCLOCK</name>   <modifier>*</modifier></type><name>proclock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>hashcode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLock</name>	   <modifier>*</modifier></type><name>partitionLock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fast_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>lockmethodid</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>lockmethodid</name> <operator>&gt;=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>LockMethods</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized lock method: %d"</literal></expr></argument>, <argument><expr><name>lockmethodid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>lockMethodTable</name> <operator>=</operator> <name><name>LockMethods</name><index>[<expr><name>lockmethodid</name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>lockmode</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>lockmode</name> <operator>&gt;</operator> <name><name>lockMethodTable</name><operator>-&gt;</operator><name>numLockModes</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized lock mode: %d"</literal></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Allocate memory to store results, and fill with InvalidVXID.  We only
	 * need enough space for MaxBackends + max_prepared_xacts + a terminator.
	 * InHotStandby allocate once in TopMemoryContext.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>InHotStandby</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>vxids</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>vxids</name> <operator>=</operator> <operator>(</operator><name>VirtualTransactionId</name> <operator>*</operator><operator>)</operator>
				<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
								   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VirtualTransactionId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator>
								   <operator>(</operator><name>MaxBackends</name> <operator>+</operator> <name>max_prepared_xacts</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>vxids</name> <operator>=</operator> <operator>(</operator><name>VirtualTransactionId</name> <operator>*</operator><operator>)</operator>
			<call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VirtualTransactionId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator>
					<operator>(</operator><name>MaxBackends</name> <operator>+</operator> <name>max_prepared_xacts</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Compute hash code and partition lock, and look up conflicting modes. */</comment>
	<expr_stmt><expr><name>hashcode</name> <operator>=</operator> <call><name>LockTagHashCode</name><argument_list>(<argument><expr><name>locktag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>partitionLock</name> <operator>=</operator> <call><name>LockHashPartitionLock</name><argument_list>(<argument><expr><name>hashcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>conflictMask</name> <operator>=</operator> <name><name>lockMethodTable</name><operator>-&gt;</operator><name>conflictTab</name><index>[<expr><name>lockmode</name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fast path locks might not have been entered in the primary lock table.
	 * If the lock we're dealing with could conflict with such a lock, we must
	 * examine each backend's fast-path array for conflicts.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ConflictsWithRelationFastPath</name><argument_list>(<argument><expr><name>locktag</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_field2</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>VirtualTransactionId</name></type> <name>vxid</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Iterate over relevant PGPROCs.  Anything held by a prepared
		 * transaction will have been transferred to the primary lock table,
		 * so we need not worry about those.  This is all a bit fuzzy, because
		 * new locks could be taken after we've visited a particular
		 * partition, but the callers had better be prepared to deal with that
		 * anyway, since the locks could equally well be taken between the
		 * time we return the value and the time the caller does something
		 * with it.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ProcGlobal</name><operator>-&gt;</operator><name>allProcCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allProcs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint32</name></type>		<name>f</name></decl>;</decl_stmt>

			<comment type="block">/* A backend never blocks itself */</comment>
			<if_stmt><if>if <condition>(<expr><name>proc</name> <operator>==</operator> <name>MyProc</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>fpInfoLock</name></name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If the target backend isn't referencing the same database as
			 * the lock, then we needn't examine the individual relation IDs
			 * at all; none of them can be relevant.
			 *
			 * See FastPathTransferRelationLocks() for discussion of why we do
			 * this test after acquiring the lock.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>databaseId</name></name> <operator>!=</operator> <name><name>locktag</name><operator>-&gt;</operator><name>locktag_field1</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>fpInfoLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<for>for <control>(<init><expr><name>f</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <name>FP_LOCK_SLOTS_PER_BACKEND</name></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>uint32</name></type>		<name>lockmask</name></decl>;</decl_stmt>

				<comment type="block">/* Look for an allocated slot matching the given relid. */</comment>
				<if_stmt><if>if <condition>(<expr><name>relid</name> <operator>!=</operator> <name><name>proc</name><operator>-&gt;</operator><name>fpRelId</name><index>[<expr><name>f</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>lockmask</name> <operator>=</operator> <call><name>FAST_PATH_GET_BITS</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lockmask</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>lockmask</name> <operator>&lt;&lt;=</operator> <name>FAST_PATH_LOCKNUMBER_OFFSET</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * There can only be one entry per relation, so if we found it
				 * and it doesn't conflict, we can skip the rest of the slots.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name>lockmask</name> <operator>&amp;</operator> <name>conflictMask</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>

				<comment type="block">/* Conflict! */</comment>
				<expr_stmt><expr><call><name>GET_VXID_FROM_PGPROC</name><argument_list>(<argument><expr><name>vxid</name></expr></argument>, <argument><expr><operator>*</operator><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>VirtualTransactionIdIsValid</name><argument_list>(<argument><expr><name>vxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>vxids</name><index>[<expr><name>count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>vxid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<comment type="block">/* else, xact already committed or aborted */</comment>

				<comment type="block">/* No need to examine remaining slots. */</comment>
				<break>break;</break>
			</block_content>}</block></for>

			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>fpInfoLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Remember how many fast-path conflicts we found. */</comment>
	<expr_stmt><expr><name>fast_count</name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Look up the lock object matching the tag.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>lock</name> <operator>=</operator> <operator>(</operator><name>LOCK</name> <operator>*</operator><operator>)</operator> <call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>LockMethodLockHash</name></expr></argument>,
												<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator> <name>locktag</name></expr></argument>,
												<argument><expr><name>hashcode</name></expr></argument>,
												<argument><expr><name>HASH_FIND</name></expr></argument>,
												<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lock</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If the lock object doesn't exist, there is nothing holding a lock
		 * on this lockable object.
		 */</comment>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>vxids</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>backendId</name> <operator>=</operator> <name>InvalidBackendId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>vxids</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>localTransactionId</name> <operator>=</operator> <name>InvalidLocalTransactionId</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>countp</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>countp</name> <operator>=</operator> <name>count</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>vxids</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Examine each existing holder (or awaiter) of the lock.
	 */</comment>

	<expr_stmt><expr><name>procLocks</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>procLocks</name></name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>proclock</name> <operator>=</operator> <operator>(</operator><name>PROCLOCK</name> <operator>*</operator><operator>)</operator> <call><name>SHMQueueNext</name><argument_list>(<argument><expr><name>procLocks</name></expr></argument>, <argument><expr><name>procLocks</name></expr></argument>,
										 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PROCLOCK</name></expr></argument>, <argument><expr><name>lockLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>proclock</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>conflictMask</name> <operator>&amp;</operator> <name><name>proclock</name><operator>-&gt;</operator><name>holdMask</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>proc</name> <init>= <expr><name><name>proclock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myProc</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* A backend never blocks itself */</comment>
			<if_stmt><if>if <condition>(<expr><name>proc</name> <operator>!=</operator> <name>MyProc</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>VirtualTransactionId</name></type> <name>vxid</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>GET_VXID_FROM_PGPROC</name><argument_list>(<argument><expr><name>vxid</name></expr></argument>, <argument><expr><operator>*</operator><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>VirtualTransactionIdIsValid</name><argument_list>(<argument><expr><name>vxid</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

					<comment type="block">/* Avoid duplicate entries. */</comment>
					<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>fast_count</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
						<if_stmt><if>if <condition>(<expr><call><name>VirtualTransactionIdEquals</name><argument_list>(<argument><expr><name><name>vxids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>vxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
					<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>fast_count</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>vxids</name><index>[<expr><name>count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>vxid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* else, xact already committed or aborted */</comment>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>proclock</name> <operator>=</operator> <operator>(</operator><name>PROCLOCK</name> <operator>*</operator><operator>)</operator> <call><name>SHMQueueNext</name><argument_list>(<argument><expr><name>procLocks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>proclock</name><operator>-&gt;</operator><name>lockLink</name></name></expr></argument>,
											 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PROCLOCK</name></expr></argument>, <argument><expr><name>lockLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <name>MaxBackends</name> <operator>+</operator> <name>max_prepared_xacts</name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* should never happen */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"too many conflicting locks found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>vxids</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>backendId</name> <operator>=</operator> <name>InvalidBackendId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vxids</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>localTransactionId</name> <operator>=</operator> <name>InvalidLocalTransactionId</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>countp</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>countp</name> <operator>=</operator> <name>count</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>vxids</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find a lock in the shared lock table and release it.  It is the caller's
 * responsibility to verify that this is a sane thing to do.  (For example, it
 * would be bad to release a lock here if there might still be a LOCALLOCK
 * object with pointers to it.)
 *
 * We currently use this in two situations: first, to release locks held by
 * prepared transactions on commit (see lock_twophase_postcommit); and second,
 * to release locks taken via the fast-path, transferred to the main hash
 * table, and then released (see LockReleaseAll).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>LockRefindAndRelease</name><parameter_list>(<parameter><decl><type><name>LockMethod</name></type> <name>lockMethodTable</name></decl></parameter>, <parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>,
					 <parameter><decl><type><name>LOCKTAG</name> <modifier>*</modifier></type><name>locktag</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>decrement_strong_lock_count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCK</name>	   <modifier>*</modifier></type><name>lock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PROCLOCK</name>   <modifier>*</modifier></type><name>proclock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PROCLOCKTAG</name></type> <name>proclocktag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>hashcode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>proclock_hashcode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLock</name>	   <modifier>*</modifier></type><name>partitionLock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>wakeupNeeded</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>hashcode</name> <operator>=</operator> <call><name>LockTagHashCode</name><argument_list>(<argument><expr><name>locktag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>partitionLock</name> <operator>=</operator> <call><name>LockHashPartitionLock</name><argument_list>(<argument><expr><name>hashcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Re-find the lock object (it had better be there).
	 */</comment>
	<expr_stmt><expr><name>lock</name> <operator>=</operator> <operator>(</operator><name>LOCK</name> <operator>*</operator><operator>)</operator> <call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>LockMethodLockHash</name></expr></argument>,
												<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>locktag</name></expr></argument>,
												<argument><expr><name>hashcode</name></expr></argument>,
												<argument><expr><name>HASH_FIND</name></expr></argument>,
												<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lock</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"failed to re-find shared lock object"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Re-find the proclock object (ditto).
	 */</comment>
	<expr_stmt><expr><name><name>proclocktag</name><operator>.</operator><name>myLock</name></name> <operator>=</operator> <name>lock</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proclocktag</name><operator>.</operator><name>myProc</name></name> <operator>=</operator> <name>proc</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>proclock_hashcode</name> <operator>=</operator> <call><name>ProcLockHashCode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>proclocktag</name></expr></argument>, <argument><expr><name>hashcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>proclock</name> <operator>=</operator> <operator>(</operator><name>PROCLOCK</name> <operator>*</operator><operator>)</operator> <call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>LockMethodProcLockHash</name></expr></argument>,
														<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>proclocktag</name></expr></argument>,
														<argument><expr><name>proclock_hashcode</name></expr></argument>,
														<argument><expr><name>HASH_FIND</name></expr></argument>,
														<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>proclock</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"failed to re-find shared proclock object"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Double-check that we are actually holding a lock of the type we want to
	 * release.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>proclock</name><operator>-&gt;</operator><name>holdMask</name></name> <operator>&amp;</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>lockmode</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PROCLOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"lock_twophase_postcommit: WRONGTYPE"</literal></expr></argument>, <argument><expr><name>proclock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"you don't own a lock of type %s"</literal></expr></argument>,
			 <argument><expr><name><name>lockMethodTable</name><operator>-&gt;</operator><name>lockModeNames</name><index>[<expr><name>lockmode</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Do the releasing.  CleanUpLock will waken any now-wakable waiters.
	 */</comment>
	<expr_stmt><expr><name>wakeupNeeded</name> <operator>=</operator> <call><name>UnGrantLock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>proclock</name></expr></argument>, <argument><expr><name>lockMethodTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CleanUpLock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>proclock</name></expr></argument>,
				<argument><expr><name>lockMethodTable</name></expr></argument>, <argument><expr><name>hashcode</name></expr></argument>,
				<argument><expr><name>wakeupNeeded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Decrement strong lock count.  This logic is needed only for 2PC.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>decrement_strong_lock_count</name>
		<operator>&amp;&amp;</operator> <call><name>ConflictsWithRelationFastPath</name><argument_list>(<argument><expr><name>locktag</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>fasthashcode</name> <init>= <expr><call><name>FastPathStrongLockHashPartition</name><argument_list>(<argument><expr><name>hashcode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>FastPathStrongRelationLocks</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>FastPathStrongRelationLocks</name><operator>-&gt;</operator><name>count</name><index>[<expr><name>fasthashcode</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>FastPathStrongRelationLocks</name><operator>-&gt;</operator><name>count</name><index>[<expr><name>fasthashcode</name></expr>]</index></name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>FastPathStrongRelationLocks</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * CheckForSessionAndXactLocks
 *		Check to see if transaction holds both session-level and xact-level
 *		locks on the same object; if so, throw an error.
 *
 * If we have both session- and transaction-level locks on the same object,
 * PREPARE TRANSACTION must fail.  This should never happen with regular
 * locks, since we only take those at session level in some special operations
 * like VACUUM.  It's possible to hit this with advisory locks, though.
 *
 * It would be nice if we could keep the session hold and give away the
 * transactional hold to the prepared xact.  However, that would require two
 * PROCLOCK objects, and we cannot be sure that another PROCLOCK will be
 * available when it comes time for PostPrepare_Locks to do the deed.
 * So for now, we error out while we can still do so safely.
 *
 * Since the LOCALLOCK table stores a separate entry for each lockmode,
 * we can't implement this check by examining LOCALLOCK entries in isolation.
 * We must build a transient hashtable that is indexed by locktag only.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CheckForSessionAndXactLocks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<typedef>typedef <type><struct>struct
	<block>{
		<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>lock</name></decl>;</decl_stmt>		<comment type="block">/* identifies the lockable object */</comment>
		<decl_stmt><decl><type><name>bool</name></type>		<name>sessLock</name></decl>;</decl_stmt>	<comment type="block">/* is any lockmode held at session level? */</comment>
		<decl_stmt><decl><type><name>bool</name></type>		<name>xactLock</name></decl>;</decl_stmt>	<comment type="block">/* is any lockmode held at xact level? */</comment>
	}</block></struct></type> <name>PerLockTagEntry</name>;</typedef>

	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>hash_ctl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HTAB</name>	   <modifier>*</modifier></type><name>lockhtab</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCALLOCK</name>  <modifier>*</modifier></type><name>locallock</name></decl>;</decl_stmt>

	<comment type="block">/* Create a local hash table keyed by LOCKTAG only */</comment>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LOCKTAG</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PerLockTagEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>lockhtab</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"CheckForSessionAndXactLocks table"</literal></expr></argument>,
						   <argument><expr><literal type="number">256</literal></expr></argument>, <comment type="block">/* arbitrary initial size */</comment>
						   <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
						   <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Scan local lock table to find entries for each LOCKTAG */</comment>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>LockMethodLocalHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>locallock</name> <operator>=</operator> <operator>(</operator><name>LOCALLOCK</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LOCALLOCKOWNER</name> <modifier>*</modifier></type><name>lockOwners</name> <init>= <expr><name><name>locallock</name><operator>-&gt;</operator><name>lockOwners</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PerLockTagEntry</name> <modifier>*</modifier></type><name>hentry</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Ignore VXID locks.  We don't want those to be held by prepared
		 * transactions, since they aren't meaningful after a restart.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>locallock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>lock</name><operator>.</operator><name>locktag_type</name></name> <operator>==</operator> <name>LOCKTAG_VIRTUALTRANSACTION</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Ignore it if we don't actually hold the lock */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>locallock</name><operator>-&gt;</operator><name>nLocks</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Otherwise, find or make an entry in lockhtab */</comment>
		<expr_stmt><expr><name>hentry</name> <operator>=</operator> <operator>(</operator><name>PerLockTagEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>lockhtab</name></expr></argument>,
												 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>locallock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>lock</name></name></expr></argument>,
												 <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>				<comment type="block">/* initialize, if newly created */</comment>
			<expr_stmt><expr><name><name>hentry</name><operator>-&gt;</operator><name>sessLock</name></name> <operator>=</operator> <name><name>hentry</name><operator>-&gt;</operator><name>xactLock</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Scan to see if we hold lock at session or xact level or both */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>locallock</name><operator>-&gt;</operator><name>numLockOwners</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>lockOwners</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>owner</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>hentry</name><operator>-&gt;</operator><name>sessLock</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>hentry</name><operator>-&gt;</operator><name>xactLock</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * We can throw error immediately when we see both types of locks; no
		 * need to wait around to see if there are more violations.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>hentry</name><operator>-&gt;</operator><name>sessLock</name></name> <operator>&amp;&amp;</operator> <name><name>hentry</name><operator>-&gt;</operator><name>xactLock</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot PREPARE while holding both session-level and transaction-level locks on the same object"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Success, so clean up */</comment>
	<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>lockhtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AtPrepare_Locks
 *		Do the preparatory work for a PREPARE: make 2PC state file records
 *		for all locks currently held.
 *
 * Session-level locks are ignored, as are VXID locks.
 *
 * For the most part, we don't need to touch shared memory for this ---
 * all the necessary state information is in the locallock table.
 * Fast-path locks are an exception, however: we move any such locks to
 * the main table before allowing PREPARE TRANSACTION to succeed.
 */</comment>
<function><type><name>void</name></type>
<name>AtPrepare_Locks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCALLOCK</name>  <modifier>*</modifier></type><name>locallock</name></decl>;</decl_stmt>

	<comment type="block">/* First, verify there aren't locks of both xact and session level */</comment>
	<expr_stmt><expr><call><name>CheckForSessionAndXactLocks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now do the per-locallock cleanup work */</comment>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>LockMethodLocalHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>locallock</name> <operator>=</operator> <operator>(</operator><name>LOCALLOCK</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TwoPhaseLockRecord</name></type> <name>record</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LOCALLOCKOWNER</name> <modifier>*</modifier></type><name>lockOwners</name> <init>= <expr><name><name>locallock</name><operator>-&gt;</operator><name>lockOwners</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>haveSessionLock</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>haveXactLock</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Ignore VXID locks.  We don't want those to be held by prepared
		 * transactions, since they aren't meaningful after a restart.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>locallock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>lock</name><operator>.</operator><name>locktag_type</name></name> <operator>==</operator> <name>LOCKTAG_VIRTUALTRANSACTION</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Ignore it if we don't actually hold the lock */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>locallock</name><operator>-&gt;</operator><name>nLocks</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Scan to see whether we hold it at session or transaction level */</comment>
		<expr_stmt><expr><name>haveSessionLock</name> <operator>=</operator> <name>haveXactLock</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>locallock</name><operator>-&gt;</operator><name>numLockOwners</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>lockOwners</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>owner</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>haveSessionLock</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>haveXactLock</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Ignore it if we have only session lock */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>haveXactLock</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* This can't happen, because we already checked it */</comment>
		<if_stmt><if>if <condition>(<expr><name>haveSessionLock</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot PREPARE while holding both session-level and transaction-level locks on the same object"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If the local lock was taken via the fast-path, we need to move it
		 * to the primary lock table, or just get a pointer to the existing
		 * primary lock table entry if by chance it's already been
		 * transferred.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>locallock</name><operator>-&gt;</operator><name>proclock</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>proclock</name></name> <operator>=</operator> <call><name>FastPathGetRelationLockEntry</name><argument_list>(<argument><expr><name>locallock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>lock</name></name> <operator>=</operator> <name><name>locallock</name><operator>-&gt;</operator><name>proclock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myLock</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Arrange to not release any strong lock count held by this lock
		 * entry.  We must retain the count until the prepared transaction is
		 * committed or rolled back.
		 */</comment>
		<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>holdsStrongLockCount</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Create a 2PC record.
		 */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>record</name><operator>.</operator><name>locktag</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>locallock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>lock</name></name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LOCKTAG</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>record</name><operator>.</operator><name>lockmode</name></name> <operator>=</operator> <name><name>locallock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>mode</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>RegisterTwoPhaseRecord</name><argument_list>(<argument><expr><name>TWOPHASE_RM_LOCK_ID</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>record</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TwoPhaseLockRecord</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * PostPrepare_Locks
 *		Clean up after successful PREPARE
 *
 * Here, we want to transfer ownership of our locks to a dummy PGPROC
 * that's now associated with the prepared transaction, and we want to
 * clean out the corresponding entries in the LOCALLOCK table.
 *
 * Note: by removing the LOCALLOCK entries, we are leaving dangling
 * pointers in the transaction's resource owner.  This is OK at the
 * moment since resowner.c doesn't try to free locks retail at a toplevel
 * transaction commit or abort.  We could alternatively zero out nLocks
 * and leave the LOCALLOCK entries to be garbage-collected by LockReleaseAll,
 * but that probably costs more cycles.
 */</comment>
<function><type><name>void</name></type>
<name>PostPrepare_Locks</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>newproc</name> <init>= <expr><call><name>TwoPhaseGetDummyProc</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCALLOCK</name>  <modifier>*</modifier></type><name>locallock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCK</name>	   <modifier>*</modifier></type><name>lock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PROCLOCK</name>   <modifier>*</modifier></type><name>proclock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PROCLOCKTAG</name></type> <name>proclocktag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>partition</name></decl>;</decl_stmt>

	<comment type="block">/* Can't prepare a lock group follower. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>lockGroupLeader</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		   <name><name>MyProc</name><operator>-&gt;</operator><name>lockGroupLeader</name></name> <operator>==</operator> <name>MyProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* This is a critical section: any error means big trouble */</comment>
	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * First we run through the locallock table and get rid of unwanted
	 * entries, then we scan the process's proclocks and transfer them to the
	 * target proc.
	 *
	 * We do this separately because we may have multiple locallock entries
	 * pointing to the same proclock, and we daren't end up with any dangling
	 * pointers.
	 */</comment>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>LockMethodLocalHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>locallock</name> <operator>=</operator> <operator>(</operator><name>LOCALLOCK</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LOCALLOCKOWNER</name> <modifier>*</modifier></type><name>lockOwners</name> <init>= <expr><name><name>locallock</name><operator>-&gt;</operator><name>lockOwners</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>haveSessionLock</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>haveXactLock</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>locallock</name><operator>-&gt;</operator><name>proclock</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>locallock</name><operator>-&gt;</operator><name>lock</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We must've run out of shared memory while trying to set up this
			 * lock.  Just forget the local entry.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>locallock</name><operator>-&gt;</operator><name>nLocks</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>RemoveLocalLock</name><argument_list>(<argument><expr><name>locallock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Ignore VXID locks */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>locallock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>lock</name><operator>.</operator><name>locktag_type</name></name> <operator>==</operator> <name>LOCKTAG_VIRTUALTRANSACTION</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Scan to see whether we hold it at session or transaction level */</comment>
		<expr_stmt><expr><name>haveSessionLock</name> <operator>=</operator> <name>haveXactLock</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>locallock</name><operator>-&gt;</operator><name>numLockOwners</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>lockOwners</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>owner</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>haveSessionLock</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>haveXactLock</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Ignore it if we have only session lock */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>haveXactLock</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* This can't happen, because we already checked it */</comment>
		<if_stmt><if>if <condition>(<expr><name>haveSessionLock</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot PREPARE while holding both session-level and transaction-level locks on the same object"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Mark the proclock to show we need to release this lockmode */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>locallock</name><operator>-&gt;</operator><name>nLocks</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>proclock</name><operator>-&gt;</operator><name>releaseMask</name></name> <operator>|=</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name><name>locallock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* And remove the locallock hashtable entry */</comment>
		<expr_stmt><expr><call><name>RemoveLocalLock</name><argument_list>(<argument><expr><name>locallock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Now, scan each lock partition separately.
	 */</comment>
	<for>for <control>(<init><expr><name>partition</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>partition</name> <operator>&lt;</operator> <name>NUM_LOCK_PARTITIONS</name></expr>;</condition> <incr><expr><name>partition</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LWLock</name>	   <modifier>*</modifier></type><name>partitionLock</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SHM_QUEUE</name>  <modifier>*</modifier></type><name>procLocks</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>MyProc</name><operator>-&gt;</operator><name>myProcLocks</name><index>[<expr><name>partition</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PROCLOCK</name>   <modifier>*</modifier></type><name>nextplock</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>partitionLock</name> <operator>=</operator> <call><name>LockHashPartitionLockByIndex</name><argument_list>(<argument><expr><name>partition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the proclock list for this partition is empty, we can skip
		 * acquiring the partition lock.  This optimization is safer than the
		 * situation in LockReleaseAll, because we got rid of any fast-path
		 * locks during AtPrepare_Locks, so there cannot be any case where
		 * another backend is adding something to our lists now.  For safety,
		 * though, we code this the same way as in LockReleaseAll.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>SHMQueueNext</name><argument_list>(<argument><expr><name>procLocks</name></expr></argument>, <argument><expr><name>procLocks</name></expr></argument>,
						 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PROCLOCK</name></expr></argument>, <argument><expr><name>procLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* needn't examine this partition */</comment>

		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>proclock</name> <operator>=</operator> <operator>(</operator><name>PROCLOCK</name> <operator>*</operator><operator>)</operator> <call><name>SHMQueueNext</name><argument_list>(<argument><expr><name>procLocks</name></expr></argument>, <argument><expr><name>procLocks</name></expr></argument>,
												  <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PROCLOCK</name></expr></argument>, <argument><expr><name>procLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</init>
			 <condition><expr><name>proclock</name></expr>;</condition>
			 <incr><expr><name>proclock</name> <operator>=</operator> <name>nextplock</name></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/* Get link first, since we may unlink/relink this proclock */</comment>
			<expr_stmt><expr><name>nextplock</name> <operator>=</operator> <operator>(</operator><name>PROCLOCK</name> <operator>*</operator><operator>)</operator>
				<call><name>SHMQueueNext</name><argument_list>(<argument><expr><name>procLocks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>proclock</name><operator>-&gt;</operator><name>procLink</name></name></expr></argument>,
							 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PROCLOCK</name></expr></argument>, <argument><expr><name>procLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>proclock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myProc</name></name> <operator>==</operator> <name>MyProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>lock</name> <operator>=</operator> <name><name>proclock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myLock</name></name></expr>;</expr_stmt>

			<comment type="block">/* Ignore VXID locks */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>lock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>locktag_type</name></name> <operator>==</operator> <name>LOCKTAG_VIRTUALTRANSACTION</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>PROCLOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"PostPrepare_Locks"</literal></expr></argument>, <argument><expr><name>proclock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"PostPrepare_Locks"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lock</name><operator>-&gt;</operator><name>nGranted</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lock</name><operator>-&gt;</operator><name>nGranted</name></name> <operator>&lt;=</operator> <name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>proclock</name><operator>-&gt;</operator><name>holdMask</name></name> <operator>&amp;</operator> <operator>~</operator><name><name>lock</name><operator>-&gt;</operator><name>grantMask</name></name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Ignore it if nothing to release (must be a session lock) */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>proclock</name><operator>-&gt;</operator><name>releaseMask</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* Else we should be releasing all locks */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>proclock</name><operator>-&gt;</operator><name>releaseMask</name></name> <operator>!=</operator> <name><name>proclock</name><operator>-&gt;</operator><name>holdMask</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"we seem to have dropped a bit somewhere"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * We cannot simply modify proclock-&gt;tag.myProc to reassign
			 * ownership of the lock, because that's part of the hash key and
			 * the proclock would then be in the wrong hash chain.  Instead
			 * use hash_update_hash_key.  (We used to create a new hash entry,
			 * but that risks out-of-memory failure if other processes are
			 * busy making proclocks too.)	We must unlink the proclock from
			 * our procLink chain and put it into the new proc's chain, too.
			 *
			 * Note: the updated proclock hash key will still belong to the
			 * same hash partition, cf proclock_hash().  So the partition lock
			 * we already hold is sufficient for this.
			 */</comment>
			<expr_stmt><expr><call><name>SHMQueueDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proclock</name><operator>-&gt;</operator><name>procLink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Create the new hash key for the proclock.
			 */</comment>
			<expr_stmt><expr><name><name>proclocktag</name><operator>.</operator><name>myLock</name></name> <operator>=</operator> <name>lock</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>proclocktag</name><operator>.</operator><name>myProc</name></name> <operator>=</operator> <name>newproc</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Update groupLeader pointer to point to the new proc.  (We'd
			 * better not be a member of somebody else's lock group!)
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>proclock</name><operator>-&gt;</operator><name>groupLeader</name></name> <operator>==</operator> <name><name>proclock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myProc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>proclock</name><operator>-&gt;</operator><name>groupLeader</name></name> <operator>=</operator> <name>newproc</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Update the proclock.  We should not find any existing entry for
			 * the same hash key, since there can be only one entry for any
			 * given lock with my own proc.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hash_update_hash_key</name><argument_list>(<argument><expr><name>LockMethodProcLockHash</name></expr></argument>,
									  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>proclock</name></expr></argument>,
									  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>proclocktag</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"duplicate entry found while reassigning a prepared transaction's locks"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Re-link into the new proc's proclock list */</comment>
			<expr_stmt><expr><call><name>SHMQueueInsertBefore</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>newproc</name><operator>-&gt;</operator><name>myProcLocks</name><index>[<expr><name>partition</name></expr>]</index></name><operator>)</operator></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name><name>proclock</name><operator>-&gt;</operator><name>procLink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PROCLOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"PostPrepare_Locks: updated"</literal></expr></argument>, <argument><expr><name>proclock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>						<comment type="block">/* loop over PROCLOCKs within this partition */</comment>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>							<comment type="block">/* loop over partitions */</comment>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Estimate shared-memory space used for lock tables
 */</comment>
<function><type><name>Size</name></type>
<name>LockShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>max_table_size</name></decl>;</decl_stmt>

	<comment type="block">/* lock hash table */</comment>
	<expr_stmt><expr><name>max_table_size</name> <operator>=</operator> <call><name>NLOCKENTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>hash_estimate_size</name><argument_list>(<argument><expr><name>max_table_size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LOCK</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* proclock hash table */</comment>
	<expr_stmt><expr><name>max_table_size</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>hash_estimate_size</name><argument_list>(<argument><expr><name>max_table_size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PROCLOCK</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since NLOCKENTS is only an estimate, add 10% safety margin.
	 */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>size</name> <operator>/</operator> <literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetLockStatusData - Return a summary of the lock manager's internal
 * status, for use in a user-level reporting function.
 *
 * The return data consists of an array of LockInstanceData objects,
 * which are a lightly abstracted version of the PROCLOCK data structures,
 * i.e. there is one entry for each unique lock and interested PGPROC.
 * It is the caller's responsibility to match up related items (such as
 * references to the same lockable object or PGPROC) if wanted.
 *
 * The design goal is to hold the LWLocks for as short a time as possible;
 * thus, this function simply makes a copy of the necessary data and releases
 * the locks, allowing the caller to contemplate and format the data for as
 * long as it pleases.
 */</comment>
<function><type><name>LockData</name> <modifier>*</modifier></type>
<name>GetLockStatusData</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LockData</name>   <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PROCLOCK</name>   <modifier>*</modifier></type><name>proclock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>seqstat</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>els</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>el</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><name>LockData</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LockData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Guess how much space we'll need. */</comment>
	<expr_stmt><expr><name>els</name> <operator>=</operator> <name>MaxBackends</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>el</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>locks</name></name> <operator>=</operator> <operator>(</operator><name>LockInstanceData</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LockInstanceData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>els</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * First, we iterate through the per-backend fast-path arrays, locking
	 * them one at a time.  This might produce an inconsistent picture of the
	 * system state, but taking all of those LWLocks at the same time seems
	 * impractical (in particular, note MAX_SIMUL_LWLOCKS).  It shouldn't
	 * matter too much, because none of these locks can be involved in lock
	 * conflicts anyway - anything that might must be present in the main lock
	 * table.  (For the same reason, we don't sweat about making leaderPid
	 * completely valid.  We cannot safely dereference another backend's
	 * lockGroupLeader field without holding all lock partition locks, and
	 * it's not worth that.)
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ProcGlobal</name><operator>-&gt;</operator><name>allProcCount</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allProcs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>f</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>fpInfoLock</name></name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>f</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <name>FP_LOCK_SLOTS_PER_BACKEND</name></expr>;</condition> <incr><expr><operator>++</operator><name>f</name></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>LockInstanceData</name> <modifier>*</modifier></type><name>instance</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint32</name></type>		<name>lockbits</name> <init>= <expr><call><name>FAST_PATH_GET_BITS</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Skip unallocated slots. */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lockbits</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>el</name> <operator>&gt;=</operator> <name>els</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>els</name> <operator>+=</operator> <name>MaxBackends</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>locks</name></name> <operator>=</operator> <operator>(</operator><name>LockInstanceData</name> <operator>*</operator><operator>)</operator>
					<call><name>repalloc</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>locks</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LockInstanceData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>els</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>instance</name> <operator>=</operator> <operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>locks</name><index>[<expr><name>el</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_LOCKTAG_RELATION</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>locktag</name></name></expr></argument>, <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>databaseId</name></name></expr></argument>,
								 <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>fpRelId</name><index>[<expr><name>f</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>holdMask</name></name> <operator>=</operator> <name>lockbits</name> <operator>&lt;&lt;</operator> <name>FAST_PATH_LOCKNUMBER_OFFSET</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>waitLockMode</name></name> <operator>=</operator> <name>NoLock</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>backend</name></name> <operator>=</operator> <name><name>proc</name><operator>-&gt;</operator><name>backendId</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>lxid</name></name> <operator>=</operator> <name><name>proc</name><operator>-&gt;</operator><name>lxid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <name><name>proc</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>leaderPid</name></name> <operator>=</operator> <name><name>proc</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>fastpath</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>el</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>fpVXIDLock</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>VirtualTransactionId</name></type> <name>vxid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>LockInstanceData</name> <modifier>*</modifier></type><name>instance</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>el</name> <operator>&gt;=</operator> <name>els</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>els</name> <operator>+=</operator> <name>MaxBackends</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>locks</name></name> <operator>=</operator> <operator>(</operator><name>LockInstanceData</name> <operator>*</operator><operator>)</operator>
					<call><name>repalloc</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>locks</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LockInstanceData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>els</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>vxid</name><operator>.</operator><name>backendId</name></name> <operator>=</operator> <name><name>proc</name><operator>-&gt;</operator><name>backendId</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>vxid</name><operator>.</operator><name>localTransactionId</name></name> <operator>=</operator> <name><name>proc</name><operator>-&gt;</operator><name>fpLocalTransactionId</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name>instance</name> <operator>=</operator> <operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>locks</name><index>[<expr><name>el</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_LOCKTAG_VIRTUALTRANSACTION</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>locktag</name></name></expr></argument>, <argument><expr><name>vxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>holdMask</name></name> <operator>=</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>waitLockMode</name></name> <operator>=</operator> <name>NoLock</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>backend</name></name> <operator>=</operator> <name><name>proc</name><operator>-&gt;</operator><name>backendId</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>lxid</name></name> <operator>=</operator> <name><name>proc</name><operator>-&gt;</operator><name>lxid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <name><name>proc</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>leaderPid</name></name> <operator>=</operator> <name><name>proc</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>fastpath</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>el</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>fpInfoLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Next, acquire lock on the entire shared lock data structure.  We do
	 * this so that, at least for locks in the primary lock table, the state
	 * will be self-consistent.
	 *
	 * Since this is a read-only operation, we take shared instead of
	 * exclusive lock.  There's not a whole lot of point to this, because all
	 * the normal operations require exclusive lock, but it doesn't hurt
	 * anything either. It will at least allow two backends to do
	 * GetLockStatusData in parallel.
	 *
	 * Must grab LWLocks in partition-number order to avoid LWLock deadlock.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_LOCK_PARTITIONS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>LockHashPartitionLockByIndex</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* Now we can safely count the number of proclocks */</comment>
	<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>nelements</name></name> <operator>=</operator> <name>el</name> <operator>+</operator> <call><name>hash_get_num_entries</name><argument_list>(<argument><expr><name>LockMethodProcLockHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>nelements</name></name> <operator>&gt;</operator> <name>els</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>els</name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>nelements</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>locks</name></name> <operator>=</operator> <operator>(</operator><name>LockInstanceData</name> <operator>*</operator><operator>)</operator>
			<call><name>repalloc</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>locks</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LockInstanceData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>els</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Now scan the tables to copy the data */</comment>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seqstat</name></expr></argument>, <argument><expr><name>LockMethodProcLockHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>proclock</name> <operator>=</operator> <operator>(</operator><name>PROCLOCK</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seqstat</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>proc</name> <init>= <expr><name><name>proclock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myProc</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LOCK</name>	   <modifier>*</modifier></type><name>lock</name> <init>= <expr><name><name>proclock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myLock</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LockInstanceData</name> <modifier>*</modifier></type><name>instance</name> <init>= <expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>locks</name><index>[<expr><name>el</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>instance</name><operator>-&gt;</operator><name>locktag</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LOCKTAG</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>holdMask</name></name> <operator>=</operator> <name><name>proclock</name><operator>-&gt;</operator><name>holdMask</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>waitLock</name></name> <operator>==</operator> <name><name>proclock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myLock</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>waitLockMode</name></name> <operator>=</operator> <name><name>proc</name><operator>-&gt;</operator><name>waitLockMode</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>waitLockMode</name></name> <operator>=</operator> <name>NoLock</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>backend</name></name> <operator>=</operator> <name><name>proc</name><operator>-&gt;</operator><name>backendId</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>lxid</name></name> <operator>=</operator> <name><name>proc</name><operator>-&gt;</operator><name>lxid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <name><name>proc</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>leaderPid</name></name> <operator>=</operator> <name><name>proclock</name><operator>-&gt;</operator><name>groupLeader</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>fastpath</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>el</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * And release locks.  We do this in reverse order for two reasons: (1)
	 * Anyone else who needs more than one of the locks will be trying to lock
	 * them in increasing order; we don't want to release the other process
	 * until it can get all the locks it needs. (2) This avoids O(N^2)
	 * behavior inside LWLockRelease.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>NUM_LOCK_PARTITIONS</name></expr>;</init> <condition><expr><operator>--</operator><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition><incr/>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>LockHashPartitionLockByIndex</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>el</name> <operator>==</operator> <name><name>data</name><operator>-&gt;</operator><name>nelements</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>data</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetBlockerStatusData - Return a summary of the lock manager's state
 * concerning locks that are blocking the specified PID or any member of
 * the PID's lock group, for use in a user-level reporting function.
 *
 * For each PID within the lock group that is awaiting some heavyweight lock,
 * the return data includes an array of LockInstanceData objects, which are
 * the same data structure used by GetLockStatusData; but unlike that function,
 * this one reports only the PROCLOCKs associated with the lock that that PID
 * is blocked on.  (Hence, all the locktags should be the same for any one
 * blocked PID.)  In addition, we return an array of the PIDs of those backends
 * that are ahead of the blocked PID in the lock's wait queue.  These can be
 * compared with the PIDs in the LockInstanceData objects to determine which
 * waiters are ahead of or behind the blocked PID in the queue.
 *
 * If blocked_pid isn't a valid backend PID or nothing in its lock group is
 * waiting on any heavyweight lock, return empty arrays.
 *
 * The design goal is to hold the LWLocks for as short a time as possible;
 * thus, this function simply makes a copy of the necessary data and releases
 * the locks, allowing the caller to contemplate and format the data for as
 * long as it pleases.
 */</comment>
<function><type><name>BlockedProcsData</name> <modifier>*</modifier></type>
<name>GetBlockerStatusData</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>blocked_pid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockedProcsData</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><name>BlockedProcsData</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BlockedProcsData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Guess how much space we'll need, and preallocate.  Most of the time
	 * this will avoid needing to do repalloc while holding the LWLocks.  (We
	 * assume, but check with an Assert, that MaxBackends is enough entries
	 * for the procs[] array; the other two could need enlargement, though.)
	 */</comment>
	<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>nprocs</name></name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>nlocks</name></name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>npids</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>maxprocs</name></name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>maxlocks</name></name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>maxpids</name></name> <operator>=</operator> <name>MaxBackends</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>procs</name></name> <operator>=</operator> <operator>(</operator><name>BlockedProcData</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BlockedProcData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>data</name><operator>-&gt;</operator><name>maxprocs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>locks</name></name> <operator>=</operator> <operator>(</operator><name>LockInstanceData</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LockInstanceData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>data</name><operator>-&gt;</operator><name>maxlocks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>waiter_pids</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>data</name><operator>-&gt;</operator><name>maxpids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In order to search the ProcArray for blocked_pid and assume that that
	 * entry won't immediately disappear under us, we must hold ProcArrayLock.
	 * In addition, to examine the lock grouping fields of any other backend,
	 * we must hold all the hash partition locks.  (Only one of those locks is
	 * actually relevant for any one lock group, but we can't know which one
	 * ahead of time.)	It's fairly annoying to hold all those locks
	 * throughout this, but it's no worse than GetLockStatusData(), and it
	 * does have the advantage that we're guaranteed to return a
	 * self-consistent instantaneous state.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>proc</name> <operator>=</operator> <call><name>BackendPidGetProcWithLock</name><argument_list>(<argument><expr><name>blocked_pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Nothing to do if it's gone */</comment>
	<if_stmt><if>if <condition>(<expr><name>proc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Acquire lock on the entire shared lock data structure.  See notes
		 * in GetLockStatusData().
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_LOCK_PARTITIONS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>LockHashPartitionLockByIndex</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

		<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>lockGroupLeader</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Easy case, proc is not a lock group member */</comment>
			<expr_stmt><expr><call><name>GetSingleProcBlockerStatusData</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Examine all procs in proc's lock group */</comment>
			<decl_stmt><decl><type><name>dlist_iter</name></type>	<name>iter</name></decl>;</decl_stmt>

			<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;proc-&gt;lockGroupLeader-&gt;lockGroupMembers</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>memberProc</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>memberProc</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>PGPROC</name></expr></argument>, <argument><expr><name>lockGroupLink</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>GetSingleProcBlockerStatusData</name><argument_list>(<argument><expr><name>memberProc</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * And release locks.  See notes in GetLockStatusData().
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>NUM_LOCK_PARTITIONS</name></expr>;</init> <condition><expr><operator>--</operator><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition><incr/>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>LockHashPartitionLockByIndex</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>nprocs</name></name> <operator>&lt;=</operator> <name><name>data</name><operator>-&gt;</operator><name>maxprocs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>data</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Accumulate data about one possibly-blocked proc for GetBlockerStatusData */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>GetSingleProcBlockerStatusData</name><parameter_list>(<parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>blocked_proc</name></decl></parameter>, <parameter><decl><type><name>BlockedProcsData</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCK</name>	   <modifier>*</modifier></type><name>theLock</name> <init>= <expr><name><name>blocked_proc</name><operator>-&gt;</operator><name>waitLock</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockedProcData</name> <modifier>*</modifier></type><name>bproc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SHM_QUEUE</name>  <modifier>*</modifier></type><name>procLocks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PROCLOCK</name>   <modifier>*</modifier></type><name>proclock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PROC_QUEUE</name> <modifier>*</modifier></type><name>waitQueue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>queue_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Nothing to do if this proc is not blocked */</comment>
	<if_stmt><if>if <condition>(<expr><name>theLock</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Set up a procs[] element */</comment>
	<expr_stmt><expr><name>bproc</name> <operator>=</operator> <operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>procs</name><index>[<expr><name><name>data</name><operator>-&gt;</operator><name>nprocs</name></name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bproc</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <name><name>blocked_proc</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bproc</name><operator>-&gt;</operator><name>first_lock</name></name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>nlocks</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bproc</name><operator>-&gt;</operator><name>first_waiter</name></name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>npids</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We may ignore the proc's fast-path arrays, since nothing in those could
	 * be related to a contended lock.
	 */</comment>

	<comment type="block">/* Collect all PROCLOCKs associated with theLock */</comment>
	<expr_stmt><expr><name>procLocks</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>theLock</name><operator>-&gt;</operator><name>procLocks</name></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>proclock</name> <operator>=</operator> <operator>(</operator><name>PROCLOCK</name> <operator>*</operator><operator>)</operator> <call><name>SHMQueueNext</name><argument_list>(<argument><expr><name>procLocks</name></expr></argument>, <argument><expr><name>procLocks</name></expr></argument>,
										 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PROCLOCK</name></expr></argument>, <argument><expr><name>lockLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>proclock</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>proc</name> <init>= <expr><name><name>proclock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myProc</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LOCK</name>	   <modifier>*</modifier></type><name>lock</name> <init>= <expr><name><name>proclock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myLock</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LockInstanceData</name> <modifier>*</modifier></type><name>instance</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>nlocks</name></name> <operator>&gt;=</operator> <name><name>data</name><operator>-&gt;</operator><name>maxlocks</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>maxlocks</name></name> <operator>+=</operator> <name>MaxBackends</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>locks</name></name> <operator>=</operator> <operator>(</operator><name>LockInstanceData</name> <operator>*</operator><operator>)</operator>
				<call><name>repalloc</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>locks</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LockInstanceData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>data</name><operator>-&gt;</operator><name>maxlocks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>instance</name> <operator>=</operator> <operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>locks</name><index>[<expr><name><name>data</name><operator>-&gt;</operator><name>nlocks</name></name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>instance</name><operator>-&gt;</operator><name>locktag</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LOCKTAG</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>holdMask</name></name> <operator>=</operator> <name><name>proclock</name><operator>-&gt;</operator><name>holdMask</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>waitLock</name></name> <operator>==</operator> <name>lock</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>waitLockMode</name></name> <operator>=</operator> <name><name>proc</name><operator>-&gt;</operator><name>waitLockMode</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>waitLockMode</name></name> <operator>=</operator> <name>NoLock</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>backend</name></name> <operator>=</operator> <name><name>proc</name><operator>-&gt;</operator><name>backendId</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>lxid</name></name> <operator>=</operator> <name><name>proc</name><operator>-&gt;</operator><name>lxid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <name><name>proc</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>leaderPid</name></name> <operator>=</operator> <name><name>proclock</name><operator>-&gt;</operator><name>groupLeader</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>fastpath</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>nlocks</name></name><operator>++</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name>proclock</name> <operator>=</operator> <operator>(</operator><name>PROCLOCK</name> <operator>*</operator><operator>)</operator> <call><name>SHMQueueNext</name><argument_list>(<argument><expr><name>procLocks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>proclock</name><operator>-&gt;</operator><name>lockLink</name></name></expr></argument>,
											 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PROCLOCK</name></expr></argument>, <argument><expr><name>lockLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Enlarge waiter_pids[] if it's too small to hold all wait queue PIDs */</comment>
	<expr_stmt><expr><name>waitQueue</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>theLock</name><operator>-&gt;</operator><name>waitProcs</name></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>queue_size</name> <operator>=</operator> <name><name>waitQueue</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>queue_size</name> <operator>&gt;</operator> <name><name>data</name><operator>-&gt;</operator><name>maxpids</name></name> <operator>-</operator> <name><name>data</name><operator>-&gt;</operator><name>npids</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>maxpids</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>maxpids</name></name> <operator>+</operator> <name>MaxBackends</name></expr></argument>,
							<argument><expr><name><name>data</name><operator>-&gt;</operator><name>npids</name></name> <operator>+</operator> <name>queue_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>waiter_pids</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>waiter_pids</name></name></expr></argument>,
											 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>data</name><operator>-&gt;</operator><name>maxpids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Collect PIDs from the lock's wait queue, stopping at blocked_proc */</comment>
	<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator> <name><name>waitQueue</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>queue_size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>proc</name> <operator>==</operator> <name>blocked_proc</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>waiter_pids</name><index>[<expr><name><name>data</name><operator>-&gt;</operator><name>npids</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>proc</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator> <name><name>proc</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>bproc</name><operator>-&gt;</operator><name>num_locks</name></name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>nlocks</name></name> <operator>-</operator> <name><name>bproc</name><operator>-&gt;</operator><name>first_lock</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bproc</name><operator>-&gt;</operator><name>num_waiters</name></name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>npids</name></name> <operator>-</operator> <name><name>bproc</name><operator>-&gt;</operator><name>first_waiter</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Returns a list of currently held AccessExclusiveLocks, for use by
 * LogStandbySnapshot().  The result is a palloc'd array,
 * with the number of elements returned into *nlocks.
 *
 * XXX This currently takes a lock on all partitions of the lock table,
 * but it's possible to do better.  By reference counting locks and storing
 * the value in the ProcArray entry for each backend we could tell if any
 * locks need recording without having to acquire the partition locks and
 * scan the lock table.  Whether that's worth the additional overhead
 * is pretty dubious though.
 */</comment>
<function><type><name>xl_standby_lock</name> <modifier>*</modifier></type>
<name>GetRunningTransactionLocks</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nlocks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>xl_standby_lock</name> <modifier>*</modifier></type><name>accessExclusiveLocks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PROCLOCK</name>   <modifier>*</modifier></type><name>proclock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>seqstat</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>els</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Acquire lock on the entire shared lock data structure.
	 *
	 * Must grab LWLocks in partition-number order to avoid LWLock deadlock.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_LOCK_PARTITIONS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>LockHashPartitionLockByIndex</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* Now we can safely count the number of proclocks */</comment>
	<expr_stmt><expr><name>els</name> <operator>=</operator> <call><name>hash_get_num_entries</name><argument_list>(<argument><expr><name>LockMethodProcLockHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocating enough space for all locks in the lock table is overkill,
	 * but it's more convenient and faster than having to enlarge the array.
	 */</comment>
	<expr_stmt><expr><name>accessExclusiveLocks</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>els</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>xl_standby_lock</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now scan the tables to copy the data */</comment>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seqstat</name></expr></argument>, <argument><expr><name>LockMethodProcLockHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If lock is a currently granted AccessExclusiveLock then it will have
	 * just one proclock holder, so locks are never accessed twice in this
	 * particular case. Don't copy this code for use elsewhere because in the
	 * general case this will give you duplicate locks when looking at
	 * non-exclusive lock types.
	 */</comment>
	<expr_stmt><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>proclock</name> <operator>=</operator> <operator>(</operator><name>PROCLOCK</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seqstat</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* make sure this definition matches the one used in LockAcquire */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>proclock</name><operator>-&gt;</operator><name>holdMask</name></name> <operator>&amp;</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
			<name><name>proclock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myLock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>locktag_type</name></name> <operator>==</operator> <name>LOCKTAG_RELATION</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>proc</name> <init>= <expr><name><name>proclock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myProc</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PGXACT</name>	   <modifier>*</modifier></type><name>pgxact</name> <init>= <expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allPgXact</name><index>[<expr><name><name>proc</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>LOCK</name>	   <modifier>*</modifier></type><name>lock</name> <init>= <expr><name><name>proclock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myLock</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name> <init>= <expr><name><name>pgxact</name><operator>-&gt;</operator><name>xid</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Don't record locks for transactions if we know they have
			 * already issued their WAL record for commit but not yet released
			 * lock. It is still possible that we see locks held by already
			 * complete transactions, if they haven't yet zeroed their xids.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>accessExclusiveLocks</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>xid</name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>accessExclusiveLocks</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>dbOid</name> <operator>=</operator> <name><name>lock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>locktag_field1</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>accessExclusiveLocks</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>relOid</name> <operator>=</operator> <name><name>lock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>locktag_field2</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name>index</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>index</name> <operator>&lt;=</operator> <name>els</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * And release locks.  We do this in reverse order for two reasons: (1)
	 * Anyone else who needs more than one of the locks will be trying to lock
	 * them in increasing order; we don't want to release the other process
	 * until it can get all the locks it needs. (2) This avoids O(N^2)
	 * behavior inside LWLockRelease.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>NUM_LOCK_PARTITIONS</name></expr>;</init> <condition><expr><operator>--</operator><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition><incr/>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>LockHashPartitionLockByIndex</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><operator>*</operator><name>nlocks</name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
	<return>return <expr><name>accessExclusiveLocks</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Provide the textual name of any lock mode */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GetLockmodeName</name><parameter_list>(<parameter><decl><type><name>LOCKMETHODID</name></type> <name>lockmethodid</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>lockmethodid</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>lockmethodid</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>LockMethods</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>mode</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>mode</name> <operator>&lt;=</operator> <name><name>LockMethods</name><index>[<expr><name>lockmethodid</name></expr>]</index></name><operator>-&gt;</operator><name>numLockModes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>LockMethods</name><index>[<expr><name>lockmethodid</name></expr>]</index></name><operator>-&gt;</operator><name><name>lockModeNames</name><index>[<expr><name>mode</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LOCK_DEBUG</name></cpp:ifdef>
<comment type="block">/*
 * Dump all locks in the given proc's myProcLocks lists.
 *
 * Caller is responsible for having acquired appropriate LWLocks.
 */</comment>
<function><type><name>void</name></type>
<name>DumpLocks</name><parameter_list>(<parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SHM_QUEUE</name>  <modifier>*</modifier></type><name>procLocks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PROCLOCK</name>   <modifier>*</modifier></type><name>proclock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCK</name>	   <modifier>*</modifier></type><name>lock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>proc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>waitLock</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"DumpLocks: waiting on"</literal></expr></argument>, <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>waitLock</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_LOCK_PARTITIONS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>procLocks</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>proc</name><operator>-&gt;</operator><name>myProcLocks</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name>proclock</name> <operator>=</operator> <operator>(</operator><name>PROCLOCK</name> <operator>*</operator><operator>)</operator> <call><name>SHMQueueNext</name><argument_list>(<argument><expr><name>procLocks</name></expr></argument>, <argument><expr><name>procLocks</name></expr></argument>,
											 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PROCLOCK</name></expr></argument>, <argument><expr><name>procLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<while>while <condition>(<expr><name>proclock</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>proclock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myProc</name></name> <operator>==</operator> <name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>lock</name> <operator>=</operator> <name><name>proclock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myLock</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PROCLOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"DumpLocks"</literal></expr></argument>, <argument><expr><name>proclock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"DumpLocks"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>proclock</name> <operator>=</operator> <operator>(</operator><name>PROCLOCK</name> <operator>*</operator><operator>)</operator>
				<call><name>SHMQueueNext</name><argument_list>(<argument><expr><name>procLocks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>proclock</name><operator>-&gt;</operator><name>procLink</name></name></expr></argument>,
							 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PROCLOCK</name></expr></argument>, <argument><expr><name>procLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Dump all lmgr locks.
 *
 * Caller is responsible for having acquired appropriate LWLocks.
 */</comment>
<function><type><name>void</name></type>
<name>DumpAllLocks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PROCLOCK</name>   <modifier>*</modifier></type><name>proclock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCK</name>	   <modifier>*</modifier></type><name>lock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>proc</name> <operator>=</operator> <name>MyProc</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>proc</name> <operator>&amp;&amp;</operator> <name><name>proc</name><operator>-&gt;</operator><name>waitLock</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"DumpAllLocks: waiting on"</literal></expr></argument>, <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>waitLock</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>LockMethodProcLockHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>proclock</name> <operator>=</operator> <operator>(</operator><name>PROCLOCK</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PROCLOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"DumpAllLocks"</literal></expr></argument>, <argument><expr><name>proclock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>lock</name> <operator>=</operator> <name><name>proclock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myLock</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>lock</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"DumpAllLocks"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"DumpAllLocks: proclock-&gt;tag.myLock = NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* LOCK_DEBUG */</comment>

<comment type="block">/*
 * LOCK 2PC resource manager's routines
 */</comment>

<comment type="block">/*
 * Re-acquire a lock belonging to a transaction that was prepared.
 *
 * Because this function is run at db startup, re-acquiring the locks should
 * never conflict with running transactions because there are none.  We
 * assume that the lock state represented by the stored 2PC files is legal.
 *
 * When switching from Hot Standby mode to normal operation, the locks will
 * be already held by the startup process. The locks are acquired for the new
 * procs without checking for conflicts, so we don't get a conflict between the
 * startup process and the dummy procs, even though we will momentarily have
 * a situation where two procs are holding the same AccessExclusiveLock,
 * which isn't normally possible because the conflict. If we're in standby
 * mode, but a recovery snapshot hasn't been established yet, it's possible
 * that some but not all of the locks are already held by the startup process.
 *
 * This approach is simple, but also a bit dangerous, because if there isn't
 * enough shared memory to acquire the locks, an error will be thrown, which
 * is promoted to FATAL and recovery will abort, bringing down postmaster.
 * A safer approach would be to transfer the locks like we do in
 * AtPrepare_Locks, but then again, in hot standby mode it's possible for
 * read-only backends to use up all the shared lock memory anyway, so that
 * replaying the WAL record that needs to acquire a lock will throw an error
 * and PANIC anyway.
 */</comment>
<function><type><name>void</name></type>
<name>lock_twophase_recover</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>info</name></decl></parameter>,
					  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>recdata</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TwoPhaseLockRecord</name> <modifier>*</modifier></type><name>rec</name> <init>= <expr><operator>(</operator><name>TwoPhaseLockRecord</name> <operator>*</operator><operator>)</operator> <name>recdata</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>proc</name> <init>= <expr><call><name>TwoPhaseGetDummyProc</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKTAG</name>    <modifier>*</modifier></type><name>locktag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>lockmode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMETHODID</name></type> <name>lockmethodid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCK</name>	   <modifier>*</modifier></type><name>lock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PROCLOCK</name>   <modifier>*</modifier></type><name>proclock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PROCLOCKTAG</name></type> <name>proclocktag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>hashcode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>proclock_hashcode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>partition</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLock</name>	   <modifier>*</modifier></type><name>partitionLock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LockMethod</name></type>	<name>lockMethodTable</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>len</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TwoPhaseLockRecord</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>locktag</name> <operator>=</operator> <operator>&amp;</operator><name><name>rec</name><operator>-&gt;</operator><name>locktag</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>lockmode</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>lockmethodid</name> <operator>=</operator> <name><name>locktag</name><operator>-&gt;</operator><name>locktag_lockmethodid</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>lockmethodid</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>lockmethodid</name> <operator>&gt;=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>LockMethods</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized lock method: %d"</literal></expr></argument>, <argument><expr><name>lockmethodid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>lockMethodTable</name> <operator>=</operator> <name><name>LockMethods</name><index>[<expr><name>lockmethodid</name></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>hashcode</name> <operator>=</operator> <call><name>LockTagHashCode</name><argument_list>(<argument><expr><name>locktag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>partition</name> <operator>=</operator> <call><name>LockHashPartition</name><argument_list>(<argument><expr><name>hashcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>partitionLock</name> <operator>=</operator> <call><name>LockHashPartitionLock</name><argument_list>(<argument><expr><name>hashcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Find or create a lock with this tag.
	 */</comment>
	<expr_stmt><expr><name>lock</name> <operator>=</operator> <operator>(</operator><name>LOCK</name> <operator>*</operator><operator>)</operator> <call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>LockMethodLockHash</name></expr></argument>,
												<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>locktag</name></expr></argument>,
												<argument><expr><name>hashcode</name></expr></argument>,
												<argument><expr><name>HASH_ENTER_NULL</name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lock</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of shared memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You might need to increase max_locks_per_transaction."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * if it's a new lock object, initialize it
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>grantMask</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>waitMask</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SHMQueueInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>procLocks</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ProcQueueInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>waitProcs</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>nGranted</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>lock</name><operator>-&gt;</operator><name>requested</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>MAX_LOCKMODES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>lock</name><operator>-&gt;</operator><name>granted</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>MAX_LOCKMODES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"lock_twophase_recover: new"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>LOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"lock_twophase_recover: found"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>requested</name><index>[<expr><name>lockmode</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>nGranted</name></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>granted</name><index>[<expr><name>lockmode</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lock</name><operator>-&gt;</operator><name>nGranted</name></name> <operator>&lt;=</operator> <name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Create the hash key for the proclock table.
	 */</comment>
	<expr_stmt><expr><name><name>proclocktag</name><operator>.</operator><name>myLock</name></name> <operator>=</operator> <name>lock</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proclocktag</name><operator>.</operator><name>myProc</name></name> <operator>=</operator> <name>proc</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>proclock_hashcode</name> <operator>=</operator> <call><name>ProcLockHashCode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>proclocktag</name></expr></argument>, <argument><expr><name>hashcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Find or create a proclock entry with this tag
	 */</comment>
	<expr_stmt><expr><name>proclock</name> <operator>=</operator> <operator>(</operator><name>PROCLOCK</name> <operator>*</operator><operator>)</operator> <call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>LockMethodProcLockHash</name></expr></argument>,
														<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>proclocktag</name></expr></argument>,
														<argument><expr><name>proclock_hashcode</name></expr></argument>,
														<argument><expr><name>HASH_ENTER_NULL</name></expr></argument>,
														<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>proclock</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Oops, not enough shmem for the proclock */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * There are no other requestors of this lock, so garbage-collect
			 * the lock object.  We *must* do this to avoid a permanent leak
			 * of shared memory, because there won't be anything to cause
			 * anyone to release the lock object later.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>SHMQueueEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>procLocks</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>LockMethodLockHash</name></expr></argument>,
											 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>tag</name></name><operator>)</operator></expr></argument>,
											 <argument><expr><name>hashcode</name></expr></argument>,
											 <argument><expr><name>HASH_REMOVE</name></expr></argument>,
											 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"lock table corrupted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of shared memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You might need to increase max_locks_per_transaction."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If new, initialize the new entry
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>lockGroupLeader</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>proclock</name><operator>-&gt;</operator><name>groupLeader</name></name> <operator>=</operator> <name>proc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>proclock</name><operator>-&gt;</operator><name>holdMask</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>proclock</name><operator>-&gt;</operator><name>releaseMask</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<comment type="block">/* Add proclock to appropriate lists */</comment>
		<expr_stmt><expr><call><name>SHMQueueInsertBefore</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>procLocks</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>proclock</name><operator>-&gt;</operator><name>lockLink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SHMQueueInsertBefore</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>proc</name><operator>-&gt;</operator><name>myProcLocks</name><index>[<expr><name>partition</name></expr>]</index></name><operator>)</operator></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>proclock</name><operator>-&gt;</operator><name>procLink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PROCLOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"lock_twophase_recover: new"</literal></expr></argument>, <argument><expr><name>proclock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>PROCLOCK_PRINT</name><argument_list>(<argument><expr><literal type="string">"lock_twophase_recover: found"</literal></expr></argument>, <argument><expr><name>proclock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>proclock</name><operator>-&gt;</operator><name>holdMask</name></name> <operator>&amp;</operator> <operator>~</operator><name><name>lock</name><operator>-&gt;</operator><name>grantMask</name></name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * lock-&gt;nRequested and lock-&gt;requested[] count the total number of
	 * requests, whether granted or waiting, so increment those immediately.
	 */</comment>
	<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>requested</name><index>[<expr><name>lockmode</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>requested</name><index>[<expr><name>lockmode</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We shouldn't already hold the desired lock.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>proclock</name><operator>-&gt;</operator><name>holdMask</name></name> <operator>&amp;</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"lock %s on object %u/%u/%u is already held"</literal></expr></argument>,
			 <argument><expr><name><name>lockMethodTable</name><operator>-&gt;</operator><name>lockModeNames</name><index>[<expr><name>lockmode</name></expr>]</index></name></expr></argument>,
			 <argument><expr><name><name>lock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>locktag_field1</name></name></expr></argument>, <argument><expr><name><name>lock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>locktag_field2</name></name></expr></argument>,
			 <argument><expr><name><name>lock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>locktag_field3</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We ignore any possible conflicts and just grant ourselves the lock. Not
	 * only because we don't bother, but also to avoid deadlocks when
	 * switching from standby to normal mode. See function comment.
	 */</comment>
	<expr_stmt><expr><call><name>GrantLock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>proclock</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Bump strong lock count, to make sure any fast-path lock requests won't
	 * be granted without consulting the primary lock table.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ConflictsWithRelationFastPath</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>fasthashcode</name> <init>= <expr><call><name>FastPathStrongLockHashPartition</name><argument_list>(<argument><expr><name>hashcode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>FastPathStrongRelationLocks</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>FastPathStrongRelationLocks</name><operator>-&gt;</operator><name>count</name><index>[<expr><name>fasthashcode</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>FastPathStrongRelationLocks</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Re-acquire a lock belonging to a transaction that was prepared, when
 * starting up into hot standby mode.
 */</comment>
<function><type><name>void</name></type>
<name>lock_twophase_standby_recover</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>info</name></decl></parameter>,
							  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>recdata</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TwoPhaseLockRecord</name> <modifier>*</modifier></type><name>rec</name> <init>= <expr><operator>(</operator><name>TwoPhaseLockRecord</name> <operator>*</operator><operator>)</operator> <name>recdata</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKTAG</name>    <modifier>*</modifier></type><name>locktag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>lockmode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMETHODID</name></type> <name>lockmethodid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>len</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TwoPhaseLockRecord</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>locktag</name> <operator>=</operator> <operator>&amp;</operator><name><name>rec</name><operator>-&gt;</operator><name>locktag</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>lockmode</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>lockmethodid</name> <operator>=</operator> <name><name>locktag</name><operator>-&gt;</operator><name>locktag_lockmethodid</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>lockmethodid</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>lockmethodid</name> <operator>&gt;=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>LockMethods</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized lock method: %d"</literal></expr></argument>, <argument><expr><name>lockmethodid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>lockmode</name> <operator>==</operator> <name>AccessExclusiveLock</name> <operator>&amp;&amp;</operator>
		<name><name>locktag</name><operator>-&gt;</operator><name>locktag_type</name></name> <operator>==</operator> <name>LOCKTAG_RELATION</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>StandbyAcquireAccessExclusiveLock</name><argument_list>(<argument><expr><name>xid</name></expr></argument>,
										  <argument><expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_field1</name></name></expr></argument> <comment type="block">/* dboid */</comment> ,
										  <argument><expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_field2</name></name></expr></argument> <comment type="block">/* reloid */</comment> )</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * 2PC processing routine for COMMIT PREPARED case.
 *
 * Find and release the lock indicated by the 2PC record.
 */</comment>
<function><type><name>void</name></type>
<name>lock_twophase_postcommit</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>info</name></decl></parameter>,
						 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>recdata</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TwoPhaseLockRecord</name> <modifier>*</modifier></type><name>rec</name> <init>= <expr><operator>(</operator><name>TwoPhaseLockRecord</name> <operator>*</operator><operator>)</operator> <name>recdata</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>proc</name> <init>= <expr><call><name>TwoPhaseGetDummyProc</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKTAG</name>    <modifier>*</modifier></type><name>locktag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMETHODID</name></type> <name>lockmethodid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LockMethod</name></type>	<name>lockMethodTable</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>len</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TwoPhaseLockRecord</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>locktag</name> <operator>=</operator> <operator>&amp;</operator><name><name>rec</name><operator>-&gt;</operator><name>locktag</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>lockmethodid</name> <operator>=</operator> <name><name>locktag</name><operator>-&gt;</operator><name>locktag_lockmethodid</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>lockmethodid</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>lockmethodid</name> <operator>&gt;=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>LockMethods</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized lock method: %d"</literal></expr></argument>, <argument><expr><name>lockmethodid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>lockMethodTable</name> <operator>=</operator> <name><name>LockMethods</name><index>[<expr><name>lockmethodid</name></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LockRefindAndRelease</name><argument_list>(<argument><expr><name>lockMethodTable</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>, <argument><expr><name>locktag</name></expr></argument>, <argument><expr><name><name>rec</name><operator>-&gt;</operator><name>lockmode</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * 2PC processing routine for ROLLBACK PREPARED case.
 *
 * This is actually just the same as the COMMIT case.
 */</comment>
<function><type><name>void</name></type>
<name>lock_twophase_postabort</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>info</name></decl></parameter>,
						<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>recdata</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>lock_twophase_postcommit</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><name>recdata</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		VirtualXactLockTableInsert
 *
 *		Take vxid lock via the fast-path.  There can't be any pre-existing
 *		lockers, as we haven't advertised this vxid via the ProcArray yet.
 *
 *		Since MyProc-&gt;fpLocalTransactionId will normally contain the same data
 *		as MyProc-&gt;lxid, you might wonder if we really need both.  The
 *		difference is that MyProc-&gt;lxid is set and cleared unlocked, and
 *		examined by procarray.c, while fpLocalTransactionId is protected by
 *		fpInfoLock and is used only by the locking subsystem.  Doing it this
 *		way makes it easier to verify that there are no funny race conditions.
 *
 *		We don't bother recording this lock in the local lock table, since it's
 *		only ever released at the end of a transaction.  Instead,
 *		LockReleaseAll() calls VirtualXactLockTableCleanup().
 */</comment>
<function><type><name>void</name></type>
<name>VirtualXactLockTableInsert</name><parameter_list>(<parameter><decl><type><name>VirtualTransactionId</name></type> <name>vxid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>VirtualTransactionIdIsValid</name><argument_list>(<argument><expr><name>vxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>fpInfoLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>backendId</name></name> <operator>==</operator> <name><name>vxid</name><operator>.</operator><name>backendId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>fpLocalTransactionId</name></name> <operator>==</operator> <name>InvalidLocalTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>fpVXIDLock</name></name> <operator>==</operator> <name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>fpVXIDLock</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>fpLocalTransactionId</name></name> <operator>=</operator> <name><name>vxid</name><operator>.</operator><name>localTransactionId</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>fpInfoLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		VirtualXactLockTableCleanup
 *
 *		Check whether a VXID lock has been materialized; if so, release it,
 *		unblocking waiters.
 */</comment>
<function><type><name>void</name></type>
<name>VirtualXactLockTableCleanup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>fastpath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LocalTransactionId</name></type> <name>lxid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>backendId</name></name> <operator>!=</operator> <name>InvalidBackendId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Clean up shared memory state.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>fpInfoLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fastpath</name> <operator>=</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>fpVXIDLock</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>lxid</name> <operator>=</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>fpLocalTransactionId</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>fpVXIDLock</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>fpLocalTransactionId</name></name> <operator>=</operator> <name>InvalidLocalTransactionId</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>fpInfoLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If fpVXIDLock has been cleared without touching fpLocalTransactionId,
	 * that means someone transferred the lock to the main lock table.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fastpath</name> <operator>&amp;&amp;</operator> <call><name>LocalTransactionIdIsValid</name><argument_list>(<argument><expr><name>lxid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>VirtualTransactionId</name></type> <name>vxid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>locktag</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>vxid</name><operator>.</operator><name>backendId</name></name> <operator>=</operator> <name>MyBackendId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>vxid</name><operator>.</operator><name>localTransactionId</name></name> <operator>=</operator> <name>lxid</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SET_LOCKTAG_VIRTUALTRANSACTION</name><argument_list>(<argument><expr><name>locktag</name></expr></argument>, <argument><expr><name>vxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LockRefindAndRelease</name><argument_list>(<argument><expr><name><name>LockMethods</name><index>[<expr><name>DEFAULT_LOCKMETHOD</name></expr>]</index></name></expr></argument>, <argument><expr><name>MyProc</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>locktag</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		XactLockForVirtualXact
 *
 * If TransactionIdIsValid(xid), this is essentially XactLockTableWait(xid,
 * NULL, NULL, XLTW_None) or ConditionalXactLockTableWait(xid).  Unlike those
 * functions, it assumes "xid" is never a subtransaction and that "xid" is
 * prepared, committed, or aborted.
 *
 * If !TransactionIdIsValid(xid), this locks every prepared XID having been
 * known as "vxid" before its PREPARE TRANSACTION.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>XactLockForVirtualXact</name><parameter_list>(<parameter><decl><type><name>VirtualTransactionId</name></type> <name>vxid</name></decl></parameter>,
					   <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>wait</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>more</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* There is no point to wait for 2PCs if you have no 2PCs. */</comment>
	<if_stmt><if>if <condition>(<expr><name>max_prepared_xacts</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<do>do
	<block>{<block_content>
		<decl_stmt><decl><type><name>LockAcquireResult</name></type> <name>lar</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>

		<comment type="block">/* Clear state from previous iterations. */</comment>
		<if_stmt><if>if <condition>(<expr><name>more</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>xid</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>more</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* If we have no xid, try to find one. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>xid</name> <operator>=</operator> <call><name>TwoPhaseGetXidByVirtualXID</name><argument_list>(<argument><expr><name>vxid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>more</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>more</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Check or wait for XID completion. */</comment>
		<expr_stmt><expr><call><name>SET_LOCKTAG_TRANSACTION</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lar</name> <operator>=</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>!</operator><name>wait</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>lar</name> <operator>==</operator> <name>LOCKACQUIRE_NOT_AVAIL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>LockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><name>more</name></expr>)</condition>;</do>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		VirtualXactLock
 *
 * If wait = true, wait as long as the given VXID or any XID acquired by the
 * same transaction is still running.  Then, return true.
 *
 * If wait = false, just check whether that VXID or one of those XIDs is still
 * running, and return true or false.
 */</comment>
<function><type><name>bool</name></type>
<name>VirtualXactLock</name><parameter_list>(<parameter><decl><type><name>VirtualTransactionId</name></type> <name>vxid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>wait</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name> <init>= <expr><name>InvalidTransactionId</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>VirtualTransactionIdIsValid</name><argument_list>(<argument><expr><name>vxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>VirtualTransactionIdIsRecoveredPreparedXact</name><argument_list>(<argument><expr><name>vxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* no vxid lock; localTransactionId is a normal, locked XID */</comment>
		<return>return <expr><call><name>XactLockForVirtualXact</name><argument_list>(<argument><expr><name>vxid</name></expr></argument>, <argument><expr><name><name>vxid</name><operator>.</operator><name>localTransactionId</name></name></expr></argument>, <argument><expr><name>wait</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>SET_LOCKTAG_VIRTUALTRANSACTION</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>vxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If a lock table entry must be made, this is the PGPROC on whose behalf
	 * it must be done.  Note that the transaction might end or the PGPROC
	 * might be reassigned to a new backend before we get around to examining
	 * it, but it doesn't matter.  If we find upon examination that the
	 * relevant lxid is no longer running here, that's enough to prove that
	 * it's no longer running anywhere.
	 */</comment>
	<expr_stmt><expr><name>proc</name> <operator>=</operator> <call><name>BackendIdGetProc</name><argument_list>(<argument><expr><name><name>vxid</name><operator>.</operator><name>backendId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>proc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>XactLockForVirtualXact</name><argument_list>(<argument><expr><name>vxid</name></expr></argument>, <argument><expr><name>InvalidTransactionId</name></expr></argument>, <argument><expr><name>wait</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We must acquire this lock before checking the backendId and lxid
	 * against the ones we're waiting for.  The target backend will only set
	 * or clear lxid while holding this lock.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>fpInfoLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>backendId</name></name> <operator>!=</operator> <name><name>vxid</name><operator>.</operator><name>backendId</name></name>
		<operator>||</operator> <name><name>proc</name><operator>-&gt;</operator><name>fpLocalTransactionId</name></name> <operator>!=</operator> <name><name>vxid</name><operator>.</operator><name>localTransactionId</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* VXID ended */</comment>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>fpInfoLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>XactLockForVirtualXact</name><argument_list>(<argument><expr><name>vxid</name></expr></argument>, <argument><expr><name>InvalidTransactionId</name></expr></argument>, <argument><expr><name>wait</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we aren't asked to wait, there's no need to set up a lock table
	 * entry.  The transaction is still in progress, so just return false.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>wait</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>fpInfoLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * OK, we're going to need to sleep on the VXID.  But first, we must set
	 * up the primary lock table entry, if needed (ie, convert the proc's
	 * fast-path lock on its VXID to a regular lock).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>fpVXIDLock</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PROCLOCK</name>   <modifier>*</modifier></type><name>proclock</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>hashcode</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LWLock</name>	   <modifier>*</modifier></type><name>partitionLock</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>hashcode</name> <operator>=</operator> <call><name>LockTagHashCode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>partitionLock</name> <operator>=</operator> <call><name>LockHashPartitionLock</name><argument_list>(<argument><expr><name>hashcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>proclock</name> <operator>=</operator> <call><name>SetupLockInTable</name><argument_list>(<argument><expr><name><name>LockMethods</name><index>[<expr><name>DEFAULT_LOCKMETHOD</name></expr>]</index></name></expr></argument>, <argument><expr><name>proc</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>hashcode</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>proclock</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>fpInfoLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of shared memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You might need to increase max_locks_per_transaction."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>GrantLock</name><argument_list>(<argument><expr><name><name>proclock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myLock</name></name></expr></argument>, <argument><expr><name>proclock</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>fpVXIDLock</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the proc has an XID now, we'll avoid a TwoPhaseGetXidByVirtualXID()
	 * search.  The proc might have assigned this XID but not yet locked it,
	 * in which case the proc will lock this XID before releasing the VXID.
	 * The fpInfoLock critical section excludes VirtualXactLockTableCleanup(),
	 * so we won't save an XID of a different VXID.  It doesn't matter whether
	 * we save this before or after setting up the primary lock table entry.
	 */</comment>
	<expr_stmt><expr><name>xid</name> <operator>=</operator> <name><name>ProcGlobal</name><operator>-&gt;</operator><name>allPgXact</name><index>[<expr><name><name>proc</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name><operator>.</operator><name>xid</name></expr>;</expr_stmt>

	<comment type="block">/* Done with proc-&gt;fpLockBits */</comment>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>fpInfoLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Time to wait. */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>XactLockForVirtualXact</name><argument_list>(<argument><expr><name>vxid</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>wait</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * LockWaiterCount
 *
 * Find the number of lock requester on this locktag
 */</comment>
<function><type><name>int</name></type>
<name>LockWaiterCount</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LOCKTAG</name> <modifier>*</modifier></type><name>locktag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKMETHODID</name></type> <name>lockmethodid</name> <init>= <expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_lockmethodid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCK</name>	   <modifier>*</modifier></type><name>lock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>hashcode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLock</name>	   <modifier>*</modifier></type><name>partitionLock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>waiters</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>lockmethodid</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>lockmethodid</name> <operator>&gt;=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>LockMethods</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized lock method: %d"</literal></expr></argument>, <argument><expr><name>lockmethodid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>hashcode</name> <operator>=</operator> <call><name>LockTagHashCode</name><argument_list>(<argument><expr><name>locktag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>partitionLock</name> <operator>=</operator> <call><name>LockHashPartitionLock</name><argument_list>(<argument><expr><name>hashcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>lock</name> <operator>=</operator> <operator>(</operator><name>LOCK</name> <operator>*</operator><operator>)</operator> <call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>LockMethodLockHash</name></expr></argument>,
												<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator> <name>locktag</name></expr></argument>,
												<argument><expr><name>hashcode</name></expr></argument>,
												<argument><expr><name>HASH_FIND</name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>lock</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>waiters</name> <operator>=</operator> <name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>waiters</name></expr>;</return>
</block_content>}</block></function>
</unit>
