<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/storage/buffer/bufmgr.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * bufmgr.c
 *	  buffer manager interface routines
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/storage/buffer/bufmgr.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<comment type="block">/*
 * Principal entry points:
 *
 * ReadBuffer() -- find or create a buffer holding the requested page,
 *		and pin it so that no one can destroy it while this process
 *		is using it.
 *
 * ReleaseBuffer() -- unpin a buffer
 *
 * MarkBufferDirty() -- mark a pinned buffer's contents as "dirty".
 *		The disk write is delayed until buffer replacement or checkpoint.
 *
 * See also these files:
 *		freelist.c -- chooses victim for buffer replacement
 *		buf_table.c -- manages the buffer lookup table
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/file.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tableam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/storage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/instrument.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/binaryheap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_trace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/bgwriter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/buf_internals.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/standby.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ps_status.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resowner_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>


<comment type="block">/* Note: these two macros only work on shared buffers, not local ones! */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BufHdrGetBlock</name><parameter_list>(<parameter><type><name>bufHdr</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((Block) (BufferBlocks + ((Size) (bufHdr)-&gt;buf_id) * BLCKSZ))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BufferGetLSN</name><parameter_list>(<parameter><type><name>bufHdr</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(PageGetLSN(BufHdrGetBlock(bufHdr)))</cpp:value></cpp:define>

<comment type="block">/* Note: this macro only works on local buffers, not shared ones! */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LocalBufHdrGetBlock</name><parameter_list>(<parameter><type><name>bufHdr</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>LocalBufferBlockPointers[-((bufHdr)-&gt;buf_id + 2)]</cpp:value></cpp:define>

<comment type="block">/* Bits in SyncOneBuffer's return value */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUF_WRITTEN</name></cpp:macro>				<cpp:value>0x01</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUF_REUSABLE</name></cpp:macro>			<cpp:value>0x02</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RELS_BSEARCH_THRESHOLD</name></cpp:macro>		<cpp:value>20</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>PrivateRefCountEntry</name>
<block>{
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>refcount</name></decl>;</decl_stmt>
}</block></struct></type> <name>PrivateRefCountEntry</name>;</typedef>

<comment type="block">/* 64 bytes, about the size of a cache line on common systems */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REFCOUNT_ARRAY_ENTRIES</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>

<comment type="block">/*
 * Status of buffers to checkpoint for a particular tablespace, used
 * internally in BufferSync.
 */</comment>
<typedef>typedef <type><struct>struct <name>CkptTsStatus</name>
<block>{
	<comment type="block">/* oid of the tablespace */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>tsId</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Checkpoint progress for this tablespace. To make progress comparable
	 * between tablespaces the progress is, for each tablespace, measured as a
	 * number between 0 and the total number of to-be-checkpointed pages. Each
	 * page checkpointed in this tablespace increments this space's progress
	 * by progress_slice.
	 */</comment>
	<decl_stmt><decl><type><name>float8</name></type>		<name>progress</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>progress_slice</name></decl>;</decl_stmt>

	<comment type="block">/* number of to-be checkpointed pages in this tablespace */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_to_scan</name></decl>;</decl_stmt>
	<comment type="block">/* already processed pages in this tablespace */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_scanned</name></decl>;</decl_stmt>

	<comment type="block">/* current offset in CkptBufferIds for this tablespace */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>index</name></decl>;</decl_stmt>
}</block></struct></type> <name>CkptTsStatus</name>;</typedef>

<comment type="block">/*
 * Type for array used to sort SMgrRelations
 *
 * FlushRelationsAllBuffers shares the same comparator function with
 * DropRelFileNodesAllBuffers. Pointer to this struct and RelFileNode must be
 * compatible.
 */</comment>
<typedef>typedef <type><struct>struct <name>SMgrSortArray</name>
<block>{
	<decl_stmt><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl>;</decl_stmt>			<comment type="block">/* This must be the first member */</comment>
	<decl_stmt><decl><type><name>SMgrRelation</name></type> <name>srel</name></decl>;</decl_stmt>
}</block></struct></type> <name>SMgrSortArray</name>;</typedef>

<comment type="block">/* GUC variables */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>zero_damaged_pages</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>bgwriter_lru_maxpages</name> <init>= <expr><literal type="number">100</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type>		<name>bgwriter_lru_multiplier</name> <init>= <expr><literal type="number">2.0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>track_io_timing</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * How many buffers PrefetchBuffer callers should try to stay ahead of their
 * ReadBuffer calls by.  Zero means "never prefetch".  This value is only used
 * for buffers not belonging to tablespaces that have their
 * effective_io_concurrency parameter set.
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>effective_io_concurrency</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Like effective_io_concurrency, but used by maintenance code paths that might
 * benefit from a higher setting because they work on behalf of many sessions.
 * Overridden by the tablespace setting of the same name.
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>maintenance_io_concurrency</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * GUC variables about triggering kernel writeback for buffers written; OS
 * dependent defaults are set via the GUC mechanism.
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>checkpoint_flush_after</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>bgwriter_flush_after</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>backend_flush_after</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* local state for StartBufferIO and related functions */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>BufferDesc</name> <modifier>*</modifier></type><name>InProgressBuf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsForInput</name></decl>;</decl_stmt>

<comment type="block">/* local state for LockBufferForCleanup */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>BufferDesc</name> <modifier>*</modifier></type><name>PinCountWaitBuf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Backend-Private refcount management:
 *
 * Each buffer also has a private refcount that keeps track of the number of
 * times the buffer is pinned in the current process.  This is so that the
 * shared refcount needs to be modified only once if a buffer is pinned more
 * than once by an individual backend.  It's also used to check that no buffers
 * are still pinned at the end of transactions and when exiting.
 *
 *
 * To avoid - as we used to - requiring an array with NBuffers entries to keep
 * track of local buffers, we use a small sequentially searched array
 * (PrivateRefCountArray) and an overflow hash table (PrivateRefCountHash) to
 * keep track of backend local pins.
 *
 * Until no more than REFCOUNT_ARRAY_ENTRIES buffers are pinned at once, all
 * refcounts are kept track of in the array; after that, new array entries
 * displace old ones into the hash table. That way a frequently used entry
 * can't get "stuck" in the hashtable while infrequent ones clog the array.
 *
 * Note that in most scenarios the number of pinned buffers will not exceed
 * REFCOUNT_ARRAY_ENTRIES.
 *
 *
 * To enter a buffer into the refcount tracking mechanism first reserve a free
 * entry using ReservePrivateRefCountEntry() and then later, if necessary,
 * fill it with NewPrivateRefCountEntry(). That split lets us avoid doing
 * memory allocations in NewPrivateRefCountEntry() which can be important
 * because in some scenarios it's called with a spinlock held...
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>PrivateRefCountEntry</name></name></type> <name><name>PrivateRefCountArray</name><index>[<expr><name>REFCOUNT_ARRAY_ENTRIES</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>PrivateRefCountHash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int32</name></type> <name>PrivateRefCountOverflowed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint32</name></type> <name>PrivateRefCountClock</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PrivateRefCountEntry</name> <modifier>*</modifier></type><name>ReservedRefCountEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReservePrivateRefCountEntry</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PrivateRefCountEntry</name> <modifier>*</modifier></type><name>NewPrivateRefCountEntry</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PrivateRefCountEntry</name> <modifier>*</modifier></type><name>GetPrivateRefCountEntry</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>do_move</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>int32</name></type> <name>GetPrivateRefCount</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ForgetPrivateRefCountEntry</name><parameter_list>(<parameter><decl><type><name>PrivateRefCountEntry</name> <modifier>*</modifier></type><name>ref</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Ensure that the PrivateRefCountArray has sufficient space to store one more
 * entry. This has to be called before using NewPrivateRefCountEntry() to fill
 * a new entry - but it's perfectly fine to not use a reserved entry.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReservePrivateRefCountEntry</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Already reserved (or freed), nothing to do */</comment>
	<if_stmt><if>if <condition>(<expr><name>ReservedRefCountEntry</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * First search for a free entry the array, that'll be sufficient in the
	 * majority of cases.
	 */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>REFCOUNT_ARRAY_ENTRIES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PrivateRefCountEntry</name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>res</name> <operator>=</operator> <operator>&amp;</operator><name><name>PrivateRefCountArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>buffer</name></name> <operator>==</operator> <name>InvalidBuffer</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>ReservedRefCountEntry</name> <operator>=</operator> <name>res</name></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block>

	<comment type="block">/*
	 * No luck. All array entries are full. Move one array entry into the hash
	 * table.
	 */</comment>
	<block>{<block_content>
		<comment type="block">/*
		 * Move entry from the current clock position in the array into the
		 * hashtable. Use that slot.
		 */</comment>
		<decl_stmt><decl><type><name>PrivateRefCountEntry</name> <modifier>*</modifier></type><name>hashent</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

		<comment type="block">/* select victim slot */</comment>
		<expr_stmt><expr><name>ReservedRefCountEntry</name> <operator>=</operator>
			<operator>&amp;</operator><name><name>PrivateRefCountArray</name><index>[<expr><name>PrivateRefCountClock</name><operator>++</operator> <operator>%</operator> <name>REFCOUNT_ARRAY_ENTRIES</name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/* Better be used, otherwise we shouldn't get here. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ReservedRefCountEntry</name><operator>-&gt;</operator><name>buffer</name></name> <operator>!=</operator> <name>InvalidBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* enter victim array entry into hashtable */</comment>
		<expr_stmt><expr><name>hashent</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>PrivateRefCountHash</name></expr></argument>,
							  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>ReservedRefCountEntry</name><operator>-&gt;</operator><name>buffer</name></name><operator>)</operator></expr></argument>,
							  <argument><expr><name>HASH_ENTER</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hashent</name><operator>-&gt;</operator><name>refcount</name></name> <operator>=</operator> <name><name>ReservedRefCountEntry</name><operator>-&gt;</operator><name>refcount</name></name></expr>;</expr_stmt>

		<comment type="block">/* clear the now free array slot */</comment>
		<expr_stmt><expr><name><name>ReservedRefCountEntry</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ReservedRefCountEntry</name><operator>-&gt;</operator><name>refcount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>PrivateRefCountOverflowed</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Fill a previously reserved refcount entry.
 */</comment>
<function><type><specifier>static</specifier> <name>PrivateRefCountEntry</name> <modifier>*</modifier></type>
<name>NewPrivateRefCountEntry</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PrivateRefCountEntry</name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<comment type="block">/* only allowed to be called when a reservation has been made */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ReservedRefCountEntry</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* use up the reserved entry */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <name>ReservedRefCountEntry</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ReservedRefCountEntry</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* and fill it */</comment>
	<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>refcount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return the PrivateRefCount entry for the passed buffer.
 *
 * Returns NULL if a buffer doesn't have a refcount entry. Otherwise, if
 * do_move is true, and the entry resides in the hashtable the entry is
 * optimized for frequent access by moving it to the array.
 */</comment>
<function><type><specifier>static</specifier> <name>PrivateRefCountEntry</name> <modifier>*</modifier></type>
<name>GetPrivateRefCountEntry</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>do_move</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PrivateRefCountEntry</name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>BufferIsLocal</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * First search for references in the array, that'll be sufficient in the
	 * majority of cases.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>REFCOUNT_ARRAY_ENTRIES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <operator>&amp;</operator><name><name>PrivateRefCountArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>buffer</name></name> <operator>==</operator> <name>buffer</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * By here we know that the buffer, if already pinned, isn't residing in
	 * the array.
	 *
	 * Only look up the buffer in the hashtable if we've previously overflowed
	 * into it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>PrivateRefCountOverflowed</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>PrivateRefCountHash</name></expr></argument>,
					  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>buffer</name></expr></argument>,
					  <argument><expr><name>HASH_FIND</name></expr></argument>,
					  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name>do_move</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* caller doesn't want us to move the hash entry into the array */</comment>
		<return>return <expr><name>res</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* move buffer from hashtable into the free array slot */</comment>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PrivateRefCountEntry</name> <modifier>*</modifier></type><name>free</name></decl>;</decl_stmt>

		<comment type="block">/* Ensure there's a free array slot */</comment>
		<expr_stmt><expr><call><name>ReservePrivateRefCountEntry</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Use up the reserved slot */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ReservedRefCountEntry</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>free</name> <operator>=</operator> <name>ReservedRefCountEntry</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ReservedRefCountEntry</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>free</name><operator>-&gt;</operator><name>buffer</name></name> <operator>==</operator> <name>InvalidBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* and fill it */</comment>
		<expr_stmt><expr><name><name>free</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>free</name><operator>-&gt;</operator><name>refcount</name></name> <operator>=</operator> <name><name>res</name><operator>-&gt;</operator><name>refcount</name></name></expr>;</expr_stmt>

		<comment type="block">/* delete from hashtable */</comment>
		<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>PrivateRefCountHash</name></expr></argument>,
					<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>buffer</name></expr></argument>,
					<argument><expr><name>HASH_REMOVE</name></expr></argument>,
					<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>PrivateRefCountOverflowed</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>PrivateRefCountOverflowed</name><operator>--</operator></expr>;</expr_stmt>

		<return>return <expr><name>free</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Returns how many times the passed buffer is pinned by this backend.
 *
 * Only works for shared memory buffers!
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int32</name></type>
<name>GetPrivateRefCount</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PrivateRefCountEntry</name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>BufferIsLocal</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Not moving the entry - that's ok for the current users, but we might
	 * want to change this one day.
	 */</comment>
	<expr_stmt><expr><name>ref</name> <operator>=</operator> <call><name>GetPrivateRefCountEntry</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ref</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name><name>ref</name><operator>-&gt;</operator><name>refcount</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Release resources used to track the reference count of a buffer which we no
 * longer have pinned and don't want to pin again immediately.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ForgetPrivateRefCountEntry</name><parameter_list>(<parameter><decl><type><name>PrivateRefCountEntry</name> <modifier>*</modifier></type><name>ref</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>refcount</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ref</name> <operator>&gt;=</operator> <operator>&amp;</operator><name><name>PrivateRefCountArray</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator>
		<name>ref</name> <operator>&lt;</operator> <operator>&amp;</operator><name><name>PrivateRefCountArray</name><index>[<expr><name>REFCOUNT_ARRAY_ENTRIES</name></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Mark the just used entry as reserved - in many scenarios that
		 * allows us to avoid ever having to search the array/hash for free
		 * entries.
		 */</comment>
		<expr_stmt><expr><name>ReservedRefCountEntry</name> <operator>=</operator> <name>ref</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name> <init>= <expr><name><name>ref</name><operator>-&gt;</operator><name>buffer</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>PrivateRefCountHash</name></expr></argument>,
					<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>buffer</name></expr></argument>,
					<argument><expr><name>HASH_REMOVE</name></expr></argument>,
					<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>PrivateRefCountOverflowed</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>PrivateRefCountOverflowed</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * BufferIsPinned
 *		True iff the buffer is pinned (also checks for valid buffer number).
 *
 *		NOTE: what we check here is that *this* backend holds a pin on
 *		the buffer.  We do not care whether some other backend does.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BufferIsPinned</name><parameter_list>(<parameter><type><name>bufnum</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>( \
	!BufferIsValid(bufnum) ? \
		false \
	: \
		BufferIsLocal(bufnum) ? \
			(LocalRefCount[-(bufnum) - 1] &gt; 0) \
		: \
	(GetPrivateRefCount(bufnum) &gt; 0) \
)</cpp:value></cpp:define>


<function_decl><type><specifier>static</specifier> <name>Buffer</name></type> <name>ReadBuffer_common</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>relpersistence</name></decl></parameter>,
								<parameter><decl><type><name>ForkNumber</name></type> <name>forkNum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blockNum</name></decl></parameter>,
								<parameter><decl><type><name>ReadBufferMode</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><name>BufferAccessStrategy</name></type> <name>strategy</name></decl></parameter>,
								<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hit</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>PinBuffer</name><parameter_list>(<parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>BufferAccessStrategy</name></type> <name>strategy</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PinBuffer_Locked</name><parameter_list>(<parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>UnpinBuffer</name><parameter_list>(<parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fixOwner</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>BufferSync</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>WaitBufHdrUnlocked</name><parameter_list>(<parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>SyncOneBuffer</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>buf_id</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skip_recently_used</name></decl></parameter>,
						  <parameter><decl><type><name>WritebackContext</name> <modifier>*</modifier></type><name>wb_context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WaitIO</name><parameter_list>(<parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>StartBufferIO</name><parameter_list>(<parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>forInput</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TerminateBufferIO</name><parameter_list>(<parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>clear_dirty</name></decl></parameter>,
							  <parameter><decl><type><name>uint32</name></type> <name>set_flag_bits</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>shared_buffer_write_error_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>local_buffer_write_error_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>BufferDesc</name> <modifier>*</modifier></type><name>BufferAlloc</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>smgr</name></decl></parameter>,
							   <parameter><decl><type><name>char</name></type> <name>relpersistence</name></decl></parameter>,
							   <parameter><decl><type><name>ForkNumber</name></type> <name>forkNum</name></decl></parameter>,
							   <parameter><decl><type><name>BlockNumber</name></type> <name>blockNum</name></decl></parameter>,
							   <parameter><decl><type><name>BufferAccessStrategy</name></type> <name>strategy</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>foundPtr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FlushBuffer</name><parameter_list>(<parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AtProcExit_Buffers</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CheckForBufferLeaks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>rnode_comparator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>buffertag_comparator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>ckpt_buforder_comparator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pa</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>ts_ckpt_progress_comparator</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Implementation of PrefetchBuffer() for shared buffers.
 */</comment>
<function><type><name>PrefetchBufferResult</name></type>
<name>PrefetchSharedBuffer</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>smgr_reln</name></decl></parameter>,
					 <parameter><decl><type><name>ForkNumber</name></type> <name>forkNum</name></decl></parameter>,
					 <parameter><decl><type><name>BlockNumber</name></type> <name>blockNum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PrefetchBufferResult</name></type> <name>result</name> <init>= <expr><block>{<expr><name>InvalidBuffer</name></expr>, <expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type>	<name>newTag</name></decl>;</decl_stmt>			<comment type="block">/* identity of requested block */</comment>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>newHash</name></decl>;</decl_stmt>		<comment type="block">/* hash value for newTag */</comment>
	<decl_stmt><decl><type><name>LWLock</name>	   <modifier>*</modifier></type><name>newPartitionLock</name></decl>;</decl_stmt>	<comment type="block">/* buffer partition lock for it */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>buf_id</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BlockNumberIsValid</name><argument_list>(<argument><expr><name>blockNum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* create a tag so we can lookup the buffer */</comment>
	<expr_stmt><expr><call><name>INIT_BUFFERTAG</name><argument_list>(<argument><expr><name>newTag</name></expr></argument>, <argument><expr><name><name>smgr_reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name></name></expr></argument>,
				   <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>blockNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* determine its hash code and partition lock ID */</comment>
	<expr_stmt><expr><name>newHash</name> <operator>=</operator> <call><name>BufTableHashCode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>newPartitionLock</name> <operator>=</operator> <call><name>BufMappingPartitionLock</name><argument_list>(<argument><expr><name>newHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* see if the block is in the buffer pool already */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>newPartitionLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>buf_id</name> <operator>=</operator> <call><name>BufTableLookup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newTag</name></expr></argument>, <argument><expr><name>newHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>newPartitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If not in buffers, initiate prefetch */</comment>
	<if_stmt><if>if <condition>(<expr><name>buf_id</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_PREFETCH</name></cpp:ifdef>
		<comment type="block">/*
		 * Try to initiate an asynchronous read.  This returns false in
		 * recovery if the relation file doesn't exist.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>smgrprefetch</name><argument_list>(<argument><expr><name>smgr_reln</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>blockNum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>result</name><operator>.</operator><name>initiated_io</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_PREFETCH */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Report the buffer it was in at that time.  The caller may be able
		 * to avoid a buffer table lookup, but it's not pinned and it must be
		 * rechecked!
		 */</comment>
		<expr_stmt><expr><name><name>result</name><operator>.</operator><name>recent_buffer</name></name> <operator>=</operator> <name>buf_id</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * If the block *is* in buffers, we do nothing.  This is not really ideal:
	 * the block might be just about to be evicted, which would be stupid
	 * since we know we are going to need it soon.  But the only easy answer
	 * is to bump the usage_count, which does not seem like a great solution:
	 * when the caller does ultimately touch the block, usage_count would get
	 * bumped again, resulting in too much favoritism for blocks that are
	 * involved in a prefetch sequence. A real fix would involve some
	 * additional per-buffer state, and it's not clear that there's enough of
	 * a problem to justify that.
	 */</comment>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PrefetchBuffer -- initiate asynchronous read of a block of a relation
 *
 * This is named by analogy to ReadBuffer but doesn't actually allocate a
 * buffer.  Instead it tries to ensure that a future ReadBuffer for the given
 * block will not be delayed by the I/O.  Prefetching is optional.
 *
 * There are three possible outcomes:
 *
 * 1.  If the block is already cached, the result includes a valid buffer that
 * could be used by the caller to avoid the need for a later buffer lookup, but
 * it's not pinned, so the caller must recheck it.
 *
 * 2.  If the kernel has been asked to initiate I/O, the initated_io member is
 * true.  Currently there is no way to know if the data was already cached by
 * the kernel and therefore didn't really initiate I/O, and no way to know when
 * the I/O completes other than using synchronous ReadBuffer().
 *
 * 3.  Otherwise, the buffer wasn't already cached by PostgreSQL, and either
 * USE_PREFETCH is not defined (this build doesn't support prefetching due to
 * lack of a kernel facility), or the underlying relation file wasn't found and
 * we are in recovery.  (If the relation file wasn't found and we are not in
 * recovery, an error is raised).
 */</comment>
<function><type><name>PrefetchBufferResult</name></type>
<name>PrefetchBuffer</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forkNum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blockNum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RelationIsValid</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BlockNumberIsValid</name><argument_list>(<argument><expr><name>blockNum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Open it at the smgr level if not already done */</comment>
	<expr_stmt><expr><call><name>RelationOpenSmgr</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RelationUsesLocalBuffers</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* see comments in ReadBufferExtended */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_OTHER_TEMP</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot access temporary tables of other sessions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* pass it off to localbuf.c */</comment>
		<return>return <expr><call><name>PrefetchLocalBuffer</name><argument_list>(<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>blockNum</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* pass it to the shared buffer version */</comment>
		<return>return <expr><call><name>PrefetchSharedBuffer</name><argument_list>(<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>blockNum</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ReadBuffer -- a shorthand for ReadBufferExtended, for reading from main
 *		fork with RBM_NORMAL mode and default strategy.
 */</comment>
<function><type><name>Buffer</name></type>
<name>ReadBuffer</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blockNum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ReadBufferExtended</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name>blockNum</name></expr></argument>, <argument><expr><name>RBM_NORMAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ReadBufferExtended -- returns a buffer containing the requested
 *		block of the requested relation.  If the blknum
 *		requested is P_NEW, extend the relation file and
 *		allocate a new block.  (Caller is responsible for
 *		ensuring that only one backend tries to extend a
 *		relation at the same time!)
 *
 * Returns: the buffer number for the buffer containing
 *		the block read.  The returned buffer has been pinned.
 *		Does not return on error --- elog's instead.
 *
 * Assume when this function is called, that reln has been opened already.
 *
 * In RBM_NORMAL mode, the page is read from disk, and the page header is
 * validated.  An error is thrown if the page header is not valid.  (But
 * note that an all-zero page is considered "valid"; see
 * PageIsVerifiedExtended().)
 *
 * RBM_ZERO_ON_ERROR is like the normal mode, but if the page header is not
 * valid, the page is zeroed instead of throwing an error. This is intended
 * for non-critical data, where the caller is prepared to repair errors.
 *
 * In RBM_ZERO_AND_LOCK mode, if the page isn't in buffer cache already, it's
 * filled with zeros instead of reading it from disk.  Useful when the caller
 * is going to fill the page from scratch, since this saves I/O and avoids
 * unnecessary failure if the page-on-disk has corrupt page headers.
 * The page is returned locked to ensure that the caller has a chance to
 * initialize the page before it's made visible to others.
 * Caution: do not use this mode to read a page that is beyond the relation's
 * current physical EOF; that is likely to cause problems in md.c when
 * the page is modified and written out. P_NEW is OK, though.
 *
 * RBM_ZERO_AND_CLEANUP_LOCK is the same as RBM_ZERO_AND_LOCK, but acquires
 * a cleanup-strength lock on the page.
 *
 * RBM_NORMAL_NO_LOG mode is treated the same as RBM_NORMAL here.
 *
 * If strategy is not NULL, a nondefault buffer access strategy is used.
 * See buffer/README for details.
 */</comment>
<function><type><name>Buffer</name></type>
<name>ReadBufferExtended</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forkNum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blockNum</name></decl></parameter>,
				   <parameter><decl><type><name>ReadBufferMode</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><name>BufferAccessStrategy</name></type> <name>strategy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buf</name></decl>;</decl_stmt>

	<comment type="block">/* Open it at the smgr level if not already done */</comment>
	<expr_stmt><expr><call><name>RelationOpenSmgr</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Reject attempts to read non-local temporary relations; we would be
	 * likely to get wrong data since we have no visibility into the owning
	 * session's local buffers.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_OTHER_TEMP</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot access temporary tables of other sessions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Read the buffer, and update pgstat counters to reflect a cache hit or
	 * miss.
	 */</comment>
	<expr_stmt><expr><call><name>pgstat_count_buffer_read</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ReadBuffer_common</name><argument_list>(<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name><name>reln</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>,
							<argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>blockNum</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>hit</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pgstat_count_buffer_hit</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ReadBufferWithoutRelcache -- like ReadBufferExtended, but doesn't require
 *		a relcache entry for the relation.
 *
 * NB: At present, this function may only be used on permanent relations, which
 * is OK, because we only use it during XLOG replay.  If in the future we
 * want to use it on temporary or unlogged relations, we could pass additional
 * parameters.
 */</comment>
<function><type><name>Buffer</name></type>
<name>ReadBufferWithoutRelcache</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forkNum</name></decl></parameter>,
						  <parameter><decl><type><name>BlockNumber</name></type> <name>blockNum</name></decl></parameter>, <parameter><decl><type><name>ReadBufferMode</name></type> <name>mode</name></decl></parameter>,
						  <parameter><decl><type><name>BufferAccessStrategy</name></type> <name>strategy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hit</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>SMgrRelation</name></type> <name>smgr</name> <init>= <expr><call><name>smgropen</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>InvalidBackendId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>InRecovery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>ReadBuffer_common</name><argument_list>(<argument><expr><name>smgr</name></expr></argument>, <argument><expr><name>RELPERSISTENCE_PERMANENT</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>blockNum</name></expr></argument>,
							 <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hit</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ReadBuffer_common -- common logic for all ReadBuffer variants
 *
 * *hit is set to true if the request was satisfied from shared buffer cache.
 */</comment>
<function><type><specifier>static</specifier> <name>Buffer</name></type>
<name>ReadBuffer_common</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>smgr</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>relpersistence</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forkNum</name></decl></parameter>,
				  <parameter><decl><type><name>BlockNumber</name></type> <name>blockNum</name></decl></parameter>, <parameter><decl><type><name>ReadBufferMode</name></type> <name>mode</name></decl></parameter>,
				  <parameter><decl><type><name>BufferAccessStrategy</name></type> <name>strategy</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>bufHdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Block</name></type>		<name>bufBlock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isExtend</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isLocalBuf</name> <init>= <expr><call><name>SmgrIsTemp</name><argument_list>(<argument><expr><name>smgr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>hit</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Make sure we will have room to remember the buffer pin */</comment>
	<expr_stmt><expr><call><name>ResourceOwnerEnlargeBuffers</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>isExtend</name> <operator>=</operator> <operator>(</operator><name>blockNum</name> <operator>==</operator> <name>P_NEW</name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_BUFFER_READ_START</name><argument_list>(<argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>blockNum</name></expr></argument>,
									   <argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>spcNode</name></name></expr></argument>,
									   <argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
									   <argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
									   <argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>backend</name></name></expr></argument>,
									   <argument><expr><name>isExtend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Substitute proper block number if caller asked for P_NEW */</comment>
	<if_stmt><if>if <condition>(<expr><name>isExtend</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>blockNum</name> <operator>=</operator> <call><name>smgrnblocks</name><argument_list>(<argument><expr><name>smgr</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Fail if relation is already at maximum possible length */</comment>
		<if_stmt><if>if <condition>(<expr><name>blockNum</name> <operator>==</operator> <name>P_NEW</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot extend relation %s beyond %u blocks"</literal></expr></argument>,
							<argument><expr><call><name>relpath</name><argument_list>(<argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name></name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>P_NEW</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>isLocalBuf</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>bufHdr</name> <operator>=</operator> <call><name>LocalBufferAlloc</name><argument_list>(<argument><expr><name>smgr</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>blockNum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pgBufferUsage</name><operator>.</operator><name>local_blks_hit</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>isExtend</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pgBufferUsage</name><operator>.</operator><name>local_blks_written</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>mode</name> <operator>==</operator> <name>RBM_NORMAL</name> <operator>||</operator> <name>mode</name> <operator>==</operator> <name>RBM_NORMAL_NO_LOG</name> <operator>||</operator>
				 <name>mode</name> <operator>==</operator> <name>RBM_ZERO_ON_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pgBufferUsage</name><operator>.</operator><name>local_blks_read</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * lookup the buffer.  IO_IN_PROGRESS is set if the requested block is
		 * not currently in memory.
		 */</comment>
		<expr_stmt><expr><name>bufHdr</name> <operator>=</operator> <call><name>BufferAlloc</name><argument_list>(<argument><expr><name>smgr</name></expr></argument>, <argument><expr><name>relpersistence</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>blockNum</name></expr></argument>,
							 <argument><expr><name>strategy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pgBufferUsage</name><operator>.</operator><name>shared_blks_hit</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>isExtend</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pgBufferUsage</name><operator>.</operator><name>shared_blks_written</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>mode</name> <operator>==</operator> <name>RBM_NORMAL</name> <operator>||</operator> <name>mode</name> <operator>==</operator> <name>RBM_NORMAL_NO_LOG</name> <operator>||</operator>
				 <name>mode</name> <operator>==</operator> <name>RBM_ZERO_ON_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pgBufferUsage</name><operator>.</operator><name>shared_blks_read</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* At this point we do NOT hold any locks. */</comment>

	<comment type="block">/* if it was already in the buffer pool, we're done */</comment>
	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isExtend</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Just need to update stats before we exit */</comment>
			<expr_stmt><expr><operator>*</operator><name>hit</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>VacuumPageHit</name><operator>++</operator></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>VacuumCostActive</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>VacuumCostBalance</name> <operator>+=</operator> <name>VacuumCostPageHit</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>TRACE_POSTGRESQL_BUFFER_READ_DONE</name><argument_list>(<argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>blockNum</name></expr></argument>,
											  <argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>spcNode</name></name></expr></argument>,
											  <argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
											  <argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
											  <argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>backend</name></name></expr></argument>,
											  <argument><expr><name>isExtend</name></expr></argument>,
											  <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * In RBM_ZERO_AND_LOCK mode the caller expects the page to be
			 * locked on return.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isLocalBuf</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>RBM_ZERO_AND_LOCK</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetContentLock</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>mode</name> <operator>==</operator> <name>RBM_ZERO_AND_CLEANUP_LOCK</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>LockBufferForCleanup</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetBuffer</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<return>return <expr><call><name>BufferDescriptorGetBuffer</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We get here only in the corner case where we are trying to extend
		 * the relation but we found a pre-existing buffer marked BM_VALID.
		 * This can happen because mdread doesn't complain about reads beyond
		 * EOF (when zero_damaged_pages is ON) and so a previous attempt to
		 * read a block beyond EOF could have left a "valid" zero-filled
		 * buffer.  Unfortunately, we have also seen this case occurring
		 * because of buggy Linux kernels that sometimes return an
		 * lseek(SEEK_END) result that doesn't account for a recent write. In
		 * that situation, the pre-existing buffer would contain valid data
		 * that we don't want to overwrite.  Since the legitimate case should
		 * always have left a zero-filled buffer, complain if not PageIsNew.
		 */</comment>
		<expr_stmt><expr><name>bufBlock</name> <operator>=</operator> <ternary><condition><expr><name>isLocalBuf</name></expr> ?</condition><then> <expr><call><name>LocalBufHdrGetBlock</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>BufHdrGetBlock</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PageIsNew</name><argument_list>(<argument><expr><operator>(</operator><name>Page</name><operator>)</operator> <name>bufBlock</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected data beyond EOF in block %u of relation %s"</literal></expr></argument>,
							<argument><expr><name>blockNum</name></expr></argument>, <argument><expr><call><name>relpath</name><argument_list>(<argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name></name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"This has been seen to occur with buggy kernels; consider updating your system."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We *must* do smgrextend before succeeding, else the page will not
		 * be reserved by the kernel, and the next P_NEW call will decide to
		 * return the same page.  Clear the BM_VALID bit, do the StartBufferIO
		 * call that BufferAlloc didn't, and proceed.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>isLocalBuf</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Only need to adjust flags */</comment>
			<decl_stmt><decl><type><name>uint32</name></type>		<name>buf_state</name> <init>= <expr><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufHdr</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>buf_state</name> <operator>&amp;</operator> <name>BM_VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>buf_state</name> <operator>&amp;=</operator> <operator>~</operator><name>BM_VALID</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_atomic_unlocked_write_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufHdr</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Loop to handle the very small possibility that someone re-sets
			 * BM_VALID between our clearing it and StartBufferIO inspecting
			 * it.
			 */</comment>
			<do>do
			<block>{<block_content>
				<decl_stmt><decl><type><name>uint32</name></type>		<name>buf_state</name> <init>= <expr><call><name>LockBufHdr</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>buf_state</name> <operator>&amp;</operator> <name>BM_VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>buf_state</name> <operator>&amp;=</operator> <operator>~</operator><name>BM_VALID</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block> while <condition>(<expr><operator>!</operator><call><name>StartBufferIO</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * if we have gotten to this point, we have allocated a buffer for the
	 * page but its contents are not yet valid.  IO_IN_PROGRESS is set for it,
	 * if it's a shared buffer.
	 *
	 * Note: if smgrextend fails, we will end up with a buffer that is
	 * allocated but not marked BM_VALID.  P_NEW will still select the same
	 * block number (because the relation didn't get any longer on disk) and
	 * so future attempts to extend the relation will find the same buffer (if
	 * it's not been recycled) but come right back here to try smgrextend
	 * again.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufHdr</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>BM_VALID</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* spinlock not needed */</comment>

	<expr_stmt><expr><name>bufBlock</name> <operator>=</operator> <ternary><condition><expr><name>isLocalBuf</name></expr> ?</condition><then> <expr><call><name>LocalBufHdrGetBlock</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>BufHdrGetBlock</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>isExtend</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* new buffers are zero-filled */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>bufBlock</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* don't set checksum for all-zero page */</comment>
		<expr_stmt><expr><call><name>smgrextend</name><argument_list>(<argument><expr><name>smgr</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>blockNum</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>bufBlock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * NB: we're *not* doing a ScheduleBufferTagForWriteback here;
		 * although we're essentially performing a write. At least on linux
		 * doing so defeats the 'delayed allocation' mechanism, leading to
		 * increased file fragmentation.
		 */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Read in the page, unless the caller intends to overwrite it and
		 * just wants us to allocate a buffer.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>RBM_ZERO_AND_LOCK</name> <operator>||</operator> <name>mode</name> <operator>==</operator> <name>RBM_ZERO_AND_CLEANUP_LOCK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>bufBlock</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>instr_time</name></type>	<name>io_start</name></decl>,
						<decl><type ref="prev"/><name>io_time</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>track_io_timing</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>io_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>smgrread</name><argument_list>(<argument><expr><name>smgr</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>blockNum</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>bufBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>track_io_timing</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>io_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>INSTR_TIME_SUBTRACT</name><argument_list>(<argument><expr><name>io_time</name></expr></argument>, <argument><expr><name>io_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pgstat_count_buffer_read_time</name><argument_list>(<argument><expr><call><name>INSTR_TIME_GET_MICROSEC</name><argument_list>(<argument><expr><name>io_time</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>INSTR_TIME_ADD</name><argument_list>(<argument><expr><name><name>pgBufferUsage</name><operator>.</operator><name>blk_read_time</name></name></expr></argument>, <argument><expr><name>io_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* check for garbage data */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PageIsVerifiedExtended</name><argument_list>(<argument><expr><operator>(</operator><name>Page</name><operator>)</operator> <name>bufBlock</name></expr></argument>, <argument><expr><name>blockNum</name></expr></argument>,
										<argument><expr><name>PIV_LOG_WARNING</name> <operator>|</operator> <name>PIV_REPORT_STAT</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>RBM_ZERO_ON_ERROR</name> <operator>||</operator> <name>zero_damaged_pages</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid page in block %u of relation %s; zeroing out page"</literal></expr></argument>,
									<argument><expr><name>blockNum</name></expr></argument>,
									<argument><expr><call><name>relpath</name><argument_list>(<argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name></name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>bufBlock</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid page in block %u of relation %s"</literal></expr></argument>,
									<argument><expr><name>blockNum</name></expr></argument>,
									<argument><expr><call><name>relpath</name><argument_list>(<argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name></name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * In RBM_ZERO_AND_LOCK mode, grab the buffer content lock before marking
	 * the page as valid, to make sure that no other backend sees the zeroed
	 * page before the caller has had a chance to initialize it.
	 *
	 * Since no-one else can be looking at the page contents yet, there is no
	 * difference between an exclusive lock and a cleanup-strength lock. (Note
	 * that we cannot use LockBuffer() or LockBufferForCleanup() here, because
	 * they assert that the buffer is already valid.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>mode</name> <operator>==</operator> <name>RBM_ZERO_AND_LOCK</name> <operator>||</operator> <name>mode</name> <operator>==</operator> <name>RBM_ZERO_AND_CLEANUP_LOCK</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>!</operator><name>isLocalBuf</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetContentLock</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>isLocalBuf</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Only need to adjust flags */</comment>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>buf_state</name> <init>= <expr><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufHdr</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>buf_state</name> <operator>|=</operator> <name>BM_VALID</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_unlocked_write_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufHdr</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Set BM_VALID, terminate IO, and wake up any waiters */</comment>
		<expr_stmt><expr><call><name>TerminateBufferIO</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>BM_VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>VacuumPageMiss</name><operator>++</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>VacuumCostActive</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>VacuumCostBalance</name> <operator>+=</operator> <name>VacuumCostPageMiss</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_BUFFER_READ_DONE</name><argument_list>(<argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>blockNum</name></expr></argument>,
									  <argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>spcNode</name></name></expr></argument>,
									  <argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
									  <argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
									  <argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>backend</name></name></expr></argument>,
									  <argument><expr><name>isExtend</name></expr></argument>,
									  <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>BufferDescriptorGetBuffer</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * BufferAlloc -- subroutine for ReadBuffer.  Handles lookup of a shared
 *		buffer.  If no buffer exists already, selects a replacement
 *		victim and evicts the old page, but does NOT read in new page.
 *
 * "strategy" can be a buffer replacement strategy object, or NULL for
 * the default strategy.  The selected buffer's usage_count is advanced when
 * using the default strategy, but otherwise possibly not (see PinBuffer).
 *
 * The returned buffer is pinned and is already marked as holding the
 * desired page.  If it already did have the desired page, *foundPtr is
 * set true.  Otherwise, *foundPtr is set false and the buffer is marked
 * as IO_IN_PROGRESS; ReadBuffer will now need to do I/O to fill it.
 *
 * *foundPtr is actually redundant with the buffer's BM_VALID flag, but
 * we keep it for simplicity in ReadBuffer.
 *
 * No locks are held either at entry or exit.
 */</comment>
<function><type><specifier>static</specifier> <name>BufferDesc</name> <modifier>*</modifier></type>
<name>BufferAlloc</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>smgr</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>relpersistence</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forkNum</name></decl></parameter>,
			<parameter><decl><type><name>BlockNumber</name></type> <name>blockNum</name></decl></parameter>,
			<parameter><decl><type><name>BufferAccessStrategy</name></type> <name>strategy</name></decl></parameter>,
			<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>foundPtr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferTag</name></type>	<name>newTag</name></decl>;</decl_stmt>			<comment type="block">/* identity of requested block */</comment>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>newHash</name></decl>;</decl_stmt>		<comment type="block">/* hash value for newTag */</comment>
	<decl_stmt><decl><type><name>LWLock</name>	   <modifier>*</modifier></type><name>newPartitionLock</name></decl>;</decl_stmt>	<comment type="block">/* buffer partition lock for it */</comment>
	<decl_stmt><decl><type><name>BufferTag</name></type>	<name>oldTag</name></decl>;</decl_stmt>			<comment type="block">/* previous identity of selected buffer */</comment>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>oldHash</name></decl>;</decl_stmt>		<comment type="block">/* hash value for oldTag */</comment>
	<decl_stmt><decl><type><name>LWLock</name>	   <modifier>*</modifier></type><name>oldPartitionLock</name></decl>;</decl_stmt>	<comment type="block">/* buffer partition lock for it */</comment>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>oldFlags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>buf_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>valid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>buf_state</name></decl>;</decl_stmt>

	<comment type="block">/* create a tag so we can lookup the buffer */</comment>
	<expr_stmt><expr><call><name>INIT_BUFFERTAG</name><argument_list>(<argument><expr><name>newTag</name></expr></argument>, <argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name></name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>blockNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* determine its hash code and partition lock ID */</comment>
	<expr_stmt><expr><name>newHash</name> <operator>=</operator> <call><name>BufTableHashCode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>newPartitionLock</name> <operator>=</operator> <call><name>BufMappingPartitionLock</name><argument_list>(<argument><expr><name>newHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* see if the block is in the buffer pool already */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>newPartitionLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>buf_id</name> <operator>=</operator> <call><name>BufTableLookup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newTag</name></expr></argument>, <argument><expr><name>newHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>buf_id</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Found it.  Now, pin the buffer so no one can steal it from the
		 * buffer pool, and check to see if the correct data has been loaded
		 * into the buffer.
		 */</comment>
		<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>buf_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>valid</name> <operator>=</operator> <call><name>PinBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Can release the mapping lock as soon as we've pinned it */</comment>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>newPartitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>foundPtr</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>valid</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We can only get here if (a) someone else is still reading in
			 * the page, or (b) a previous read attempt failed.  We have to
			 * wait for any active read attempt to finish, and then set up our
			 * own read attempt if the page is still not BM_VALID.
			 * StartBufferIO does it all.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>StartBufferIO</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * If we get here, previous attempts to read the buffer must
				 * have failed ... but we shall bravely try again.
				 */</comment>
				<expr_stmt><expr><operator>*</operator><name>foundPtr</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>buf</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Didn't find it in the buffer pool.  We'll have to initialize a new
	 * buffer.  Remember to unlock the mapping lock while doing the work.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>newPartitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Loop here in case we have to try another victim buffer */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * Ensure, while the spinlock's not yet held, that there's a free
		 * refcount entry.
		 */</comment>
		<expr_stmt><expr><call><name>ReservePrivateRefCountEntry</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Select a victim buffer.  The buffer is returned with its header
		 * spinlock still held!
		 */</comment>
		<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>StrategyGetBuffer</name><argument_list>(<argument><expr><name>strategy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BUF_STATE_GET_REFCOUNT</name><argument_list>(<argument><expr><name>buf_state</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Must copy buffer flags while we still hold the spinlock */</comment>
		<expr_stmt><expr><name>oldFlags</name> <operator>=</operator> <name>buf_state</name> <operator>&amp;</operator> <name>BUF_FLAG_MASK</name></expr>;</expr_stmt>

		<comment type="block">/* Pin the buffer and then release the buffer spinlock */</comment>
		<expr_stmt><expr><call><name>PinBuffer_Locked</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the buffer was dirty, try to write it out.  There is a race
		 * condition here, in that someone might dirty it after we released it
		 * above, or even while we are writing it out (since our share-lock
		 * won't prevent hint-bit updates).  We will recheck the dirty bit
		 * after re-locking the buffer header.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>oldFlags</name> <operator>&amp;</operator> <name>BM_DIRTY</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We need a share-lock on the buffer contents to write it out
			 * (else we might write invalid data, eg because someone else is
			 * compacting the page contents while we write).  We must use a
			 * conditional lock acquisition here to avoid deadlock.  Even
			 * though the buffer was not pinned (and therefore surely not
			 * locked) when StrategyGetBuffer returned it, someone else could
			 * have pinned and exclusive-locked it by the time we get here. If
			 * we try to get the lock unconditionally, we'd block waiting for
			 * them; if they later block waiting for us, deadlock ensues.
			 * (This has been observed to happen when two backends are both
			 * trying to split btree index pages, and the second one just
			 * happens to be trying to split the page the first one got from
			 * StrategyGetBuffer.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>LWLockConditionalAcquire</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetContentLock</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * If using a nondefault strategy, and writing the buffer
				 * would require a WAL flush, let the strategy decide whether
				 * to go ahead and write/reuse the buffer or to choose another
				 * victim.  We need lock to inspect the page LSN, so this
				 * can't be done inside StrategyGetBuffer.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>strategy</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lsn</name></decl>;</decl_stmt>

					<comment type="block">/* Read the LSN while holding buffer header lock */</comment>
					<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>LockBufHdr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>lsn</name> <operator>=</operator> <call><name>BufferGetLSN</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>XLogNeedsFlush</name><argument_list>(<argument><expr><name>lsn</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
						<call><name>StrategyRejectBuffer</name><argument_list>(<argument><expr><name>strategy</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* Drop lock/pin and loop around for another buffer */</comment>
						<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetContentLock</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>UnpinBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<continue>continue;</continue>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* OK, do the I/O */</comment>
				<expr_stmt><expr><call><name>TRACE_POSTGRESQL_BUFFER_WRITE_DIRTY_START</name><argument_list>(<argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>blockNum</name></expr></argument>,
														  <argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>spcNode</name></name></expr></argument>,
														  <argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
														  <argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>relNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>FlushBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetContentLock</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ScheduleBufferTagForWriteback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BackendWritebackContext</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name><name>buf</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>TRACE_POSTGRESQL_BUFFER_WRITE_DIRTY_DONE</name><argument_list>(<argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>blockNum</name></expr></argument>,
														 <argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>spcNode</name></name></expr></argument>,
														 <argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
														 <argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>relNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Someone else has locked the buffer, so give it up and loop
				 * back to get another one.
				 */</comment>
				<expr_stmt><expr><call><name>UnpinBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * To change the association of a valid buffer, we'll need to have
		 * exclusive lock on both the old and new mapping partitions.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>oldFlags</name> <operator>&amp;</operator> <name>BM_TAG_VALID</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Need to compute the old tag's hashcode and partition lock ID.
			 * XXX is it worth storing the hashcode in BufferDesc so we need
			 * not recompute it here?  Probably not.
			 */</comment>
			<expr_stmt><expr><name>oldTag</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>tag</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>oldHash</name> <operator>=</operator> <call><name>BufTableHashCode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oldTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>oldPartitionLock</name> <operator>=</operator> <call><name>BufMappingPartitionLock</name><argument_list>(<argument><expr><name>oldHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Must lock the lower-numbered partition first to avoid
			 * deadlocks.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>oldPartitionLock</name> <operator>&lt;</operator> <name>newPartitionLock</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>oldPartitionLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>newPartitionLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>oldPartitionLock</name> <operator>&gt;</operator> <name>newPartitionLock</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>newPartitionLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>oldPartitionLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* only one partition, only one lock */</comment>
				<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>newPartitionLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* if it wasn't valid, we need only the new partition */</comment>
			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>newPartitionLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* remember we have no old-partition lock or tag */</comment>
			<expr_stmt><expr><name>oldPartitionLock</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<comment type="block">/* keep the compiler quiet about uninitialized variables */</comment>
			<expr_stmt><expr><name>oldHash</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Try to make a hashtable entry for the buffer under its new tag.
		 * This could fail because while we were writing someone else
		 * allocated another buffer for the same block we want to read in.
		 * Note that we have not yet removed the hashtable entry for the old
		 * tag.
		 */</comment>
		<expr_stmt><expr><name>buf_id</name> <operator>=</operator> <call><name>BufTableInsert</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newTag</name></expr></argument>, <argument><expr><name>newHash</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>buf_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>buf_id</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Got a collision. Someone has already done what we were about to
			 * do. We'll just handle this as if it were found in the buffer
			 * pool in the first place.  First, give up the buffer we were
			 * planning to use.
			 */</comment>
			<expr_stmt><expr><call><name>UnpinBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Can give up that buffer's mapping partition lock now */</comment>
			<if_stmt><if>if <condition>(<expr><name>oldPartitionLock</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				<name>oldPartitionLock</name> <operator>!=</operator> <name>newPartitionLock</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>oldPartitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* remaining code should match code at top of routine */</comment>

			<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>buf_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>valid</name> <operator>=</operator> <call><name>PinBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Can release the mapping lock as soon as we've pinned it */</comment>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>newPartitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><operator>*</operator><name>foundPtr</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>valid</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * We can only get here if (a) someone else is still reading
				 * in the page, or (b) a previous read attempt failed.  We
				 * have to wait for any active read attempt to finish, and
				 * then set up our own read attempt if the page is still not
				 * BM_VALID.  StartBufferIO does it all.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>StartBufferIO</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * If we get here, previous attempts to read the buffer
					 * must have failed ... but we shall bravely try again.
					 */</comment>
					<expr_stmt><expr><operator>*</operator><name>foundPtr</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<return>return <expr><name>buf</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Need to lock the buffer header too in order to change its tag.
		 */</comment>
		<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>LockBufHdr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Somebody could have pinned or re-dirtied the buffer while we were
		 * doing the I/O and making the new hashtable entry.  If so, we can't
		 * recycle this buffer; we must undo everything we've done and start
		 * over with a new victim buffer.
		 */</comment>
		<expr_stmt><expr><name>oldFlags</name> <operator>=</operator> <name>buf_state</name> <operator>&amp;</operator> <name>BUF_FLAG_MASK</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>BUF_STATE_GET_REFCOUNT</name><argument_list>(<argument><expr><name>buf_state</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>oldFlags</name> <operator>&amp;</operator> <name>BM_DIRTY</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>BufTableDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newTag</name></expr></argument>, <argument><expr><name>newHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>oldPartitionLock</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name>oldPartitionLock</name> <operator>!=</operator> <name>newPartitionLock</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>oldPartitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>newPartitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UnpinBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Okay, it's finally safe to rename the buffer.
	 *
	 * Clearing BM_VALID here is necessary, clearing the dirtybits is just
	 * paranoia.  We also reset the usage_count since any recency of use of
	 * the old content is no longer relevant.  (The usage_count starts out at
	 * 1 so that the buffer can survive one clock-sweep pass.)
	 *
	 * Make sure BM_PERMANENT is set for buffers that must be written at every
	 * checkpoint.  Unlogged buffers only need to be written at shutdown
	 * checkpoints, except for their "init" forks, which need to be treated
	 * just like permanent relations.
	 */</comment>
	<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name></name> <operator>=</operator> <name>newTag</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>buf_state</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>BM_VALID</name> <operator>|</operator> <name>BM_DIRTY</name> <operator>|</operator> <name>BM_JUST_DIRTIED</name> <operator>|</operator>
				   <name>BM_CHECKPOINT_NEEDED</name> <operator>|</operator> <name>BM_IO_ERROR</name> <operator>|</operator> <name>BM_PERMANENT</name> <operator>|</operator>
				   <name>BUF_USAGECOUNT_MASK</name><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>relpersistence</name> <operator>==</operator> <name>RELPERSISTENCE_PERMANENT</name> <operator>||</operator> <name>forkNum</name> <operator>==</operator> <name>INIT_FORKNUM</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>buf_state</name> <operator>|=</operator> <name>BM_TAG_VALID</name> <operator>|</operator> <name>BM_PERMANENT</name> <operator>|</operator> <name>BUF_USAGECOUNT_ONE</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>buf_state</name> <operator>|=</operator> <name>BM_TAG_VALID</name> <operator>|</operator> <name>BUF_USAGECOUNT_ONE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>oldPartitionLock</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>BufTableDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oldTag</name></expr></argument>, <argument><expr><name>oldHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>oldPartitionLock</name> <operator>!=</operator> <name>newPartitionLock</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>oldPartitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>newPartitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Buffer contents are currently invalid.  Try to get the io_in_progress
	 * lock.  If StartBufferIO returns false, then someone else managed to
	 * read it before we did, so there's nothing left for BufferAlloc() to do.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>StartBufferIO</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>foundPtr</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>foundPtr</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * InvalidateBuffer -- mark a shared buffer invalid and return it to the
 * freelist.
 *
 * The buffer header spinlock must be held at entry.  We drop it before
 * returning.  (This is sane because the caller must have locked the
 * buffer in order to be sure it should be dropped.)
 *
 * This is used only in contexts such as dropping a relation.  We assume
 * that no other backend could possibly be interested in using the page,
 * so the only reason the buffer might be pinned is if someone else is
 * trying to write it out.  We have to let them finish before we can
 * reclaim the buffer.
 *
 * The buffer could get reclaimed by someone else while we are waiting
 * to acquire the necessary locks; if so, don't mess it up.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InvalidateBuffer</name><parameter_list>(<parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferTag</name></type>	<name>oldTag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>oldHash</name></decl>;</decl_stmt>		<comment type="block">/* hash value for oldTag */</comment>
	<decl_stmt><decl><type><name>LWLock</name>	   <modifier>*</modifier></type><name>oldPartitionLock</name></decl>;</decl_stmt>	<comment type="block">/* buffer partition lock for it */</comment>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>oldFlags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>buf_state</name></decl>;</decl_stmt>

	<comment type="block">/* Save the original buffer tag before dropping the spinlock */</comment>
	<expr_stmt><expr><name>oldTag</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>tag</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>buf_state</name> <operator>&amp;</operator> <name>BM_LOCKED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Need to compute the old tag's hashcode and partition lock ID. XXX is it
	 * worth storing the hashcode in BufferDesc so we need not recompute it
	 * here?  Probably not.
	 */</comment>
	<expr_stmt><expr><name>oldHash</name> <operator>=</operator> <call><name>BufTableHashCode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oldTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldPartitionLock</name> <operator>=</operator> <call><name>BufMappingPartitionLock</name><argument_list>(<argument><expr><name>oldHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>retry</name>:</label>

	<comment type="block">/*
	 * Acquire exclusive mapping lock in preparation for changing the buffer's
	 * association.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>oldPartitionLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Re-lock the buffer header */</comment>
	<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>LockBufHdr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If it's changed while we were waiting for lock, do nothing */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>, <argument><expr><name>oldTag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>oldPartitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We assume the only reason for it to be pinned is that someone else is
	 * flushing the page out.  Wait for them to finish.  (This could be an
	 * infinite loop if the refcount is messed up... it would be nice to time
	 * out after awhile, but there seems no way to be sure how many loops may
	 * be needed.  Note that if the other guy has pinned the buffer but not
	 * yet done StartBufferIO, WaitIO will fall through and we'll effectively
	 * be busy-looping here.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>BUF_STATE_GET_REFCOUNT</name><argument_list>(<argument><expr><name>buf_state</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>oldPartitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* safety check: should definitely not be our *own* pin */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>GetPrivateRefCount</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"buffer is pinned in InvalidateBuffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>WaitIO</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>retry</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Clear out the buffer's tag and flags.  We must do this to ensure that
	 * linear scans of the buffer array don't think the buffer is valid.
	 */</comment>
	<expr_stmt><expr><name>oldFlags</name> <operator>=</operator> <name>buf_state</name> <operator>&amp;</operator> <name>BUF_FLAG_MASK</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CLEAR_BUFFERTAG</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>buf_state</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>BUF_FLAG_MASK</name> <operator>|</operator> <name>BUF_USAGECOUNT_MASK</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Remove the buffer from the lookup hashtable, if it was in there.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>oldFlags</name> <operator>&amp;</operator> <name>BM_TAG_VALID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>BufTableDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oldTag</name></expr></argument>, <argument><expr><name>oldHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Done with mapping lock.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>oldPartitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Insert the buffer at the head of the list of free buffers.
	 */</comment>
	<expr_stmt><expr><call><name>StrategyFreeBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * MarkBufferDirty
 *
 *		Marks buffer contents as dirty (actual write happens later).
 *
 * Buffer must be pinned and exclusive-locked.  (If caller does not hold
 * exclusive lock, then somebody could be in process of writing the buffer,
 * leading to risk of bad data written to disk.)
 */</comment>
<function><type><name>void</name></type>
<name>MarkBufferDirty</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>bufHdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>buf_state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>old_buf_state</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bad buffer ID: %d"</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsLocal</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MarkLocalBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>bufHdr</name> <operator>=</operator> <call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsPinned</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetContentLock</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>old_buf_state</name> <operator>=</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufHdr</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>old_buf_state</name> <operator>&amp;</operator> <name>BM_LOCKED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>old_buf_state</name> <operator>=</operator> <call><name>WaitBufHdrUnlocked</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <name>old_buf_state</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BUF_STATE_GET_REFCOUNT</name><argument_list>(<argument><expr><name>buf_state</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>buf_state</name> <operator>|=</operator> <name>BM_DIRTY</name> <operator>|</operator> <name>BM_JUST_DIRTIED</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>pg_atomic_compare_exchange_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufHdr</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>old_buf_state</name></expr></argument>,
										   <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If the buffer was not dirty already, do vacuum accounting.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>old_buf_state</name> <operator>&amp;</operator> <name>BM_DIRTY</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>VacuumPageDirty</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pgBufferUsage</name><operator>.</operator><name>shared_blks_dirtied</name></name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>VacuumCostActive</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>VacuumCostBalance</name> <operator>+=</operator> <name>VacuumCostPageDirty</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ReleaseAndReadBuffer -- combine ReleaseBuffer() and ReadBuffer()
 *
 * Formerly, this saved one cycle of acquiring/releasing the BufMgrLock
 * compared to calling the two routines separately.  Now it's mainly just
 * a convenience function.  However, if the passed buffer is valid and
 * already contains the desired block, we just return it as-is; and that
 * does save considerable work compared to a full release and reacquire.
 *
 * Note: it is OK to pass buffer == InvalidBuffer, indicating that no old
 * buffer actually needs to be released.  This case is the same as ReadBuffer,
 * but can save some tests in the caller.
 */</comment>
<function><type><name>Buffer</name></type>
<name>ReleaseAndReadBuffer</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>,
					 <parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
					 <parameter><decl><type><name>BlockNumber</name></type> <name>blockNum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ForkNumber</name></type>	<name>forkNum</name> <init>= <expr><name>MAIN_FORKNUM</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>bufHdr</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsPinned</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>BufferIsLocal</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>bufHdr</name> <operator>=</operator> <call><name>GetLocalBufferDescriptor</name><argument_list>(<argument><expr><operator>-</operator><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>blockNum</name></name> <operator>==</operator> <name>blockNum</name> <operator>&amp;&amp;</operator>
				<call><name>RelFileNodeEquals</name><argument_list>(<argument><expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name></name></expr></argument>, <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>forkNum</name></name> <operator>==</operator> <name>forkNum</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>buffer</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>ResourceOwnerForgetBuffer</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>LocalRefCount</name><index>[<expr><operator>-</operator><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>bufHdr</name> <operator>=</operator> <call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* we have pin, so it's ok to examine tag without spinlock */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>blockNum</name></name> <operator>==</operator> <name>blockNum</name> <operator>&amp;&amp;</operator>
				<call><name>RelFileNodeEquals</name><argument_list>(<argument><expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name></name></expr></argument>, <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>forkNum</name></name> <operator>==</operator> <name>forkNum</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>buffer</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>UnpinBuffer</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>ReadBuffer</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>blockNum</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PinBuffer -- make buffer unavailable for replacement.
 *
 * For the default access strategy, the buffer's usage_count is incremented
 * when we first pin it; for other strategies we just make sure the usage_count
 * isn't zero.  (The idea of the latter is that we don't want synchronized
 * heap scans to inflate the count, but we need it to not be zero to discourage
 * other backends from stealing buffers from our ring.  As long as we cycle
 * through the ring faster than the global clock-sweep cycles, buffers in
 * our ring won't be chosen as victims for replacement by other backends.)
 *
 * This should be applied only to shared buffers, never local ones.
 *
 * Since buffers are pinned/unpinned very frequently, pin buffers without
 * taking the buffer header lock; instead update the state variable in loop of
 * CAS operations. Hopefully it's just a single CAS.
 *
 * Note that ResourceOwnerEnlargeBuffers must have been done already.
 *
 * Returns true if buffer is BM_VALID, else false.  This provision allows
 * some callers to avoid an extra spinlock cycle.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>PinBuffer</name><parameter_list>(<parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>BufferAccessStrategy</name></type> <name>strategy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>b</name> <init>= <expr><call><name>BufferDescriptorGetBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PrivateRefCountEntry</name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ref</name> <operator>=</operator> <call><name>GetPrivateRefCountEntry</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ref</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>buf_state</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>old_buf_state</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ReservePrivateRefCountEntry</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ref</name> <operator>=</operator> <call><name>NewPrivateRefCountEntry</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>old_buf_state</name> <operator>=</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>old_buf_state</name> <operator>&amp;</operator> <name>BM_LOCKED</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>old_buf_state</name> <operator>=</operator> <call><name>WaitBufHdrUnlocked</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <name>old_buf_state</name></expr>;</expr_stmt>

			<comment type="block">/* increase refcount */</comment>
			<expr_stmt><expr><name>buf_state</name> <operator>+=</operator> <name>BUF_REFCOUNT_ONE</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>strategy</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Default case: increase usagecount unless already max. */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>BUF_STATE_GET_USAGECOUNT</name><argument_list>(<argument><expr><name>buf_state</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>BM_MAX_USAGE_COUNT</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>buf_state</name> <operator>+=</operator> <name>BUF_USAGECOUNT_ONE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Ring buffers shouldn't evict others from pool.  Thus we
				 * don't make usagecount more than 1.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>BUF_STATE_GET_USAGECOUNT</name><argument_list>(<argument><expr><name>buf_state</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>buf_state</name> <operator>+=</operator> <name>BUF_USAGECOUNT_ONE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>pg_atomic_compare_exchange_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>old_buf_state</name></expr></argument>,
											   <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>buf_state</name> <operator>&amp;</operator> <name>BM_VALID</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* If we previously pinned the buffer, it must surely be valid */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>refcount</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>refcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ResourceOwnerRememberBuffer</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PinBuffer_Locked -- as above, but caller already locked the buffer header.
 * The spinlock is released before return.
 *
 * As this function is called with the spinlock held, the caller has to
 * previously call ReservePrivateRefCountEntry().
 *
 * Currently, no callers of this function want to modify the buffer's
 * usage_count at all, so there's no need for a strategy parameter.
 * Also we don't bother with a BM_VALID test (the caller could check that for
 * itself).
 *
 * Also all callers only ever use this function when it's known that the
 * buffer can't have a preexisting pin by this backend. That allows us to skip
 * searching the private refcount array &amp; hash, which is a boon, because the
 * spinlock is still held.
 *
 * Note: use of this routine is frequently mandatory, not just an optimization
 * to save a spin lock/unlock cycle, because we need to pin a buffer before
 * its state can change under us.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PinBuffer_Locked</name><parameter_list>(<parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>b</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PrivateRefCountEntry</name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>buf_state</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * As explained, We don't expect any preexisting pins. That allows us to
	 * manipulate the PrivateRefCount after releasing the spinlock
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>GetPrivateRefCountEntry</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since we hold the buffer spinlock, we can update the buffer state and
	 * release the lock in one operation.
	 */</comment>
	<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>buf_state</name> <operator>&amp;</operator> <name>BM_LOCKED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>buf_state</name> <operator>+=</operator> <name>BUF_REFCOUNT_ONE</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>BufferDescriptorGetBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ref</name> <operator>=</operator> <call><name>NewPrivateRefCountEntry</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>refcount</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ResourceOwnerRememberBuffer</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * UnpinBuffer -- make buffer available for replacement.
 *
 * This should be applied only to shared buffers, never local ones.
 *
 * Most but not all callers want CurrentResourceOwner to be adjusted.
 * Those that don't should pass fixOwner = false.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>UnpinBuffer</name><parameter_list>(<parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fixOwner</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PrivateRefCountEntry</name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>b</name> <init>= <expr><call><name>BufferDescriptorGetBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* not moving as we're likely deleting it soon anyway */</comment>
	<expr_stmt><expr><name>ref</name> <operator>=</operator> <call><name>GetPrivateRefCountEntry</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ref</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fixOwner</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResourceOwnerForgetBuffer</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>refcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>refcount</name></name><operator>--</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>ref</name><operator>-&gt;</operator><name>refcount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>buf_state</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>old_buf_state</name></decl>;</decl_stmt>

		<comment type="block">/* I'd better not still hold any locks on the buffer */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetContentLock</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetIOLock</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Decrement the shared reference count.
		 *
		 * Since buffer spinlock holder can update status using just write,
		 * it's not safe to use atomic decrement here; thus use a CAS loop.
		 */</comment>
		<expr_stmt><expr><name>old_buf_state</name> <operator>=</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>old_buf_state</name> <operator>&amp;</operator> <name>BM_LOCKED</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>old_buf_state</name> <operator>=</operator> <call><name>WaitBufHdrUnlocked</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <name>old_buf_state</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>buf_state</name> <operator>-=</operator> <name>BUF_REFCOUNT_ONE</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>pg_atomic_compare_exchange_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>old_buf_state</name></expr></argument>,
											   <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Support LockBufferForCleanup() */</comment>
		<if_stmt><if>if <condition>(<expr><name>buf_state</name> <operator>&amp;</operator> <name>BM_PIN_COUNT_WAITER</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Acquire the buffer header lock, re-check that there's a waiter.
			 * Another backend could have unpinned this buffer, and already
			 * woken up the waiter.  There's no danger of the buffer being
			 * replaced after we unpinned it above, as it's pinned by the
			 * waiter.
			 */</comment>
			<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>LockBufHdr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>buf_state</name> <operator>&amp;</operator> <name>BM_PIN_COUNT_WAITER</name><operator>)</operator> <operator>&amp;&amp;</operator>
				<call><name>BUF_STATE_GET_REFCOUNT</name><argument_list>(<argument><expr><name>buf_state</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* we just released the last pin other than the waiter's */</comment>
				<decl_stmt><decl><type><name>int</name></type>			<name>wait_backend_pid</name> <init>= <expr><name><name>buf</name><operator>-&gt;</operator><name>wait_backend_pid</name></name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>buf_state</name> <operator>&amp;=</operator> <operator>~</operator><name>BM_PIN_COUNT_WAITER</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ProcSendSignal</name><argument_list>(<argument><expr><name>wait_backend_pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>ForgetPrivateRefCountEntry</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * BufferSync -- Write out all dirty buffers in the pool.
 *
 * This is called at checkpoint time to write out all dirty shared buffers.
 * The checkpoint request flags should be passed in.  If CHECKPOINT_IMMEDIATE
 * is set, we disable delays between writes; if CHECKPOINT_IS_SHUTDOWN,
 * CHECKPOINT_END_OF_RECOVERY or CHECKPOINT_FLUSH_ALL is set, we write even
 * unlogged buffers, which are otherwise skipped.  The remaining flags
 * currently have no effect here.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>BufferSync</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>buf_state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>buf_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_to_scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_spaces</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_processed</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_written</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CkptTsStatus</name> <modifier>*</modifier></type><name>per_ts_stat</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>last_tsid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>binaryheap</name> <modifier>*</modifier></type><name>ts_heap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>mask</name> <init>= <expr><name>BM_DIRTY</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WritebackContext</name></type> <name>wb_context</name></decl>;</decl_stmt>

	<comment type="block">/* Make sure we can handle the pin inside SyncOneBuffer */</comment>
	<expr_stmt><expr><call><name>ResourceOwnerEnlargeBuffers</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Unless this is a shutdown checkpoint or we have been explicitly told,
	 * we write only permanent, dirty buffers.  But at shutdown or end of
	 * recovery, we write all dirty buffers.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>CHECKPOINT_IS_SHUTDOWN</name> <operator>|</operator> <name>CHECKPOINT_END_OF_RECOVERY</name> <operator>|</operator>
					<name>CHECKPOINT_FLUSH_ALL</name><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>mask</name> <operator>|=</operator> <name>BM_PERMANENT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Loop over all buffers, and mark the ones that need to be written with
	 * BM_CHECKPOINT_NEEDED.  Count them as we go (num_to_scan), so that we
	 * can estimate how much work needs to be done.
	 *
	 * This allows us to write only those pages that were dirty when the
	 * checkpoint began, and not those that get dirtied while it proceeds.
	 * Whenever a page with BM_CHECKPOINT_NEEDED is written out, either by us
	 * later in this function, or by normal backends or the bgwriter cleaning
	 * scan, the flag is cleared.  Any buffer dirtied after this point won't
	 * have the flag set.
	 *
	 * Note that if we fail to write some buffer, we may leave buffers with
	 * BM_CHECKPOINT_NEEDED still set.  This is OK since any such buffer would
	 * certainly need to be written for the next checkpoint attempt, too.
	 */</comment>
	<expr_stmt><expr><name>num_to_scan</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>buf_id</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>buf_id</name> <operator>&lt;</operator> <name>NBuffers</name></expr>;</condition> <incr><expr><name>buf_id</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>bufHdr</name> <init>= <expr><call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>buf_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Header spinlock is enough to examine BM_DIRTY, see comment in
		 * SyncOneBuffer.
		 */</comment>
		<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>LockBufHdr</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>buf_state</name> <operator>&amp;</operator> <name>mask</name><operator>)</operator> <operator>==</operator> <name>mask</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CkptSortItem</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>buf_state</name> <operator>|=</operator> <name>BM_CHECKPOINT_NEEDED</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>item</name> <operator>=</operator> <operator>&amp;</operator><name><name>CkptBufferIds</name><index>[<expr><name>num_to_scan</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>buf_id</name></name> <operator>=</operator> <name>buf_id</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>tsId</name></name> <operator>=</operator> <name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name><operator>.</operator><name>spcNode</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>relNode</name></name> <operator>=</operator> <name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name><operator>.</operator><name>relNode</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>forkNum</name></name> <operator>=</operator> <name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>forkNum</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>blockNum</name></name> <operator>=</operator> <name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>blockNum</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Check for barrier events in case NBuffers is large. */</comment>
		<if_stmt><if>if <condition>(<expr><name>ProcSignalBarrierPending</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ProcessProcSignalBarrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>num_to_scan</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* nothing to do */</comment>

	<expr_stmt><expr><call><name>WritebackContextInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>wb_context</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>checkpoint_flush_after</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_BUFFER_SYNC_START</name><argument_list>(<argument><expr><name>NBuffers</name></expr></argument>, <argument><expr><name>num_to_scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Sort buffers that need to be written to reduce the likelihood of random
	 * IO. The sorting is also important for the implementation of balancing
	 * writes between tablespaces. Without balancing writes we'd potentially
	 * end up writing to the tablespaces one-by-one; possibly overloading the
	 * underlying system.
	 */</comment>
	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>CkptBufferIds</name></expr></argument>, <argument><expr><name>num_to_scan</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CkptSortItem</name></expr></argument>)</argument_list></sizeof></expr></argument>,
		  <argument><expr><name>ckpt_buforder_comparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>num_spaces</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate progress status for each tablespace with buffers that need to
	 * be flushed. This requires the to-be-flushed array to be sorted.
	 */</comment>
	<expr_stmt><expr><name>last_tsid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_to_scan</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CkptTsStatus</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>cur_tsid</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>cur_tsid</name> <operator>=</operator> <name><name>CkptBufferIds</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tsId</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Grow array of per-tablespace status structs, every time a new
		 * tablespace is found.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>last_tsid</name> <operator>==</operator> <name>InvalidOid</name> <operator>||</operator> <name>last_tsid</name> <operator>!=</operator> <name>cur_tsid</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Size</name></type>		<name>sz</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>num_spaces</name><operator>++</operator></expr>;</expr_stmt>

			<comment type="block">/*
			 * Not worth adding grow-by-power-of-2 logic here - even with a
			 * few hundred tablespaces this should be fine.
			 */</comment>
			<expr_stmt><expr><name>sz</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CkptTsStatus</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>num_spaces</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>per_ts_stat</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>per_ts_stat</name> <operator>=</operator> <operator>(</operator><name>CkptTsStatus</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>per_ts_stat</name> <operator>=</operator> <operator>(</operator><name>CkptTsStatus</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name>per_ts_stat</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>per_ts_stat</name><index>[<expr><name>num_spaces</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tsId</name></name> <operator>=</operator> <name>cur_tsid</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * The first buffer in this tablespace. As CkptBufferIds is sorted
			 * by tablespace all (s-&gt;num_to_scan) buffers in this tablespace
			 * will follow afterwards.
			 */</comment>
			<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * progress_slice will be determined once we know how many buffers
			 * are in each tablespace, i.e. after this loop.
			 */</comment>

			<expr_stmt><expr><name>last_tsid</name> <operator>=</operator> <name>cur_tsid</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>per_ts_stat</name><index>[<expr><name>num_spaces</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>num_to_scan</name></name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/* Check for barrier events. */</comment>
		<if_stmt><if>if <condition>(<expr><name>ProcSignalBarrierPending</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ProcessProcSignalBarrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>num_spaces</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build a min-heap over the write-progress in the individual tablespaces,
	 * and compute how large a portion of the total progress a single
	 * processed buffer is.
	 */</comment>
	<expr_stmt><expr><name>ts_heap</name> <operator>=</operator> <call><name>binaryheap_allocate</name><argument_list>(<argument><expr><name>num_spaces</name></expr></argument>,
								  <argument><expr><name>ts_ckpt_progress_comparator</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_spaces</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CkptTsStatus</name> <modifier>*</modifier></type><name>ts_stat</name> <init>= <expr><operator>&amp;</operator><name><name>per_ts_stat</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>ts_stat</name><operator>-&gt;</operator><name>progress_slice</name></name> <operator>=</operator> <operator>(</operator><name>float8</name><operator>)</operator> <name>num_to_scan</name> <operator>/</operator> <name><name>ts_stat</name><operator>-&gt;</operator><name>num_to_scan</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>binaryheap_add_unordered</name><argument_list>(<argument><expr><name>ts_heap</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>ts_stat</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>binaryheap_build</name><argument_list>(<argument><expr><name>ts_heap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Iterate through to-be-checkpointed buffers and write the ones (still)
	 * marked with BM_CHECKPOINT_NEEDED. The writes are balanced between
	 * tablespaces; otherwise the sorting would lead to only one tablespace
	 * receiving writes at a time, making inefficient use of the hardware.
	 */</comment>
	<expr_stmt><expr><name>num_processed</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>num_written</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>!</operator><call><name>binaryheap_empty</name><argument_list>(<argument><expr><name>ts_heap</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>bufHdr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CkptTsStatus</name> <modifier>*</modifier></type><name>ts_stat</name> <init>= <expr><operator>(</operator><name>CkptTsStatus</name> <operator>*</operator><operator>)</operator>
		<call><name>DatumGetPointer</name><argument_list>(<argument><expr><call><name>binaryheap_first</name><argument_list>(<argument><expr><name>ts_heap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>buf_id</name> <operator>=</operator> <name><name>CkptBufferIds</name><index>[<expr><name><name>ts_stat</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>buf_id</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>buf_id</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>bufHdr</name> <operator>=</operator> <call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>buf_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>num_processed</name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * We don't need to acquire the lock here, because we're only looking
		 * at a single bit. It's possible that someone else writes the buffer
		 * and clears the flag right after we check, but that doesn't matter
		 * since SyncOneBuffer will then do nothing.  However, there is a
		 * further race condition: it's conceivable that between the time we
		 * examine the bit here and the time SyncOneBuffer acquires the lock,
		 * someone else not only wrote the buffer but replaced it with another
		 * page and dirtied it.  In that improbable case, SyncOneBuffer will
		 * write the buffer though we didn't need to.  It doesn't seem worth
		 * guarding against this, though.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufHdr</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>BM_CHECKPOINT_NEEDED</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>SyncOneBuffer</name><argument_list>(<argument><expr><name>buf_id</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wb_context</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>BUF_WRITTEN</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>TRACE_POSTGRESQL_BUFFER_SYNC_WRITTEN</name><argument_list>(<argument><expr><name>buf_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>BgWriterStats</name><operator>.</operator><name>m_buf_written_checkpoints</name></name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>num_written</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Measure progress independent of actually having to flush the buffer
		 * - otherwise writing become unbalanced.
		 */</comment>
		<expr_stmt><expr><name><name>ts_stat</name><operator>-&gt;</operator><name>progress</name></name> <operator>+=</operator> <name><name>ts_stat</name><operator>-&gt;</operator><name>progress_slice</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ts_stat</name><operator>-&gt;</operator><name>num_scanned</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ts_stat</name><operator>-&gt;</operator><name>index</name></name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/* Have all the buffers from the tablespace been processed? */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>ts_stat</name><operator>-&gt;</operator><name>num_scanned</name></name> <operator>==</operator> <name><name>ts_stat</name><operator>-&gt;</operator><name>num_to_scan</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>binaryheap_remove_first</name><argument_list>(<argument><expr><name>ts_heap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* update heap with the new progress */</comment>
			<expr_stmt><expr><call><name>binaryheap_replace_first</name><argument_list>(<argument><expr><name>ts_heap</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>ts_stat</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Sleep to throttle our I/O rate.
		 *
		 * (This will check for barrier events even if it doesn't sleep.)
		 */</comment>
		<expr_stmt><expr><call><name>CheckpointWriteDelay</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name>num_processed</name> <operator>/</operator> <name>num_to_scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* issue all pending flushes */</comment>
	<expr_stmt><expr><call><name>IssuePendingWritebacks</name><argument_list>(<argument><expr><operator>&amp;</operator><name>wb_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>per_ts_stat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>per_ts_stat</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>binaryheap_free</name><argument_list>(<argument><expr><name>ts_heap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Update checkpoint statistics. As noted above, this doesn't include
	 * buffers written by other backends or bgwriter scan.
	 */</comment>
	<expr_stmt><expr><name><name>CheckpointStats</name><operator>.</operator><name>ckpt_bufs_written</name></name> <operator>+=</operator> <name>num_written</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_BUFFER_SYNC_DONE</name><argument_list>(<argument><expr><name>NBuffers</name></expr></argument>, <argument><expr><name>num_written</name></expr></argument>, <argument><expr><name>num_to_scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * BgBufferSync -- Write out some dirty buffers in the pool.
 *
 * This is called periodically by the background writer process.
 *
 * Returns true if it's appropriate for the bgwriter process to go into
 * low-power hibernation mode.  (This happens if the strategy clock sweep
 * has been "lapped" and no buffer allocations have occurred recently,
 * or if the bgwriter has been effectively disabled by setting
 * bgwriter_lru_maxpages to 0.)
 */</comment>
<function><type><name>bool</name></type>
<name>BgBufferSync</name><parameter_list>(<parameter><decl><type><name>WritebackContext</name> <modifier>*</modifier></type><name>wb_context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* info obtained from freelist.c */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>strategy_buf_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>strategy_passes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>recent_alloc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Information saved between calls so we can determine the strategy
	 * point's advance rate and avoid scanning already-cleaned buffers.
	 */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>saved_info_valid</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>prev_strategy_buf_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>uint32</name></type> <name>prev_strategy_passes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>next_to_clean</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>uint32</name></type> <name>next_passes</name></decl>;</decl_stmt>

	<comment type="block">/* Moving averages of allocation rate and clean-buffer density */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name>smoothed_alloc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name>smoothed_density</name> <init>= <expr><literal type="number">10.0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Potentially these could be tunables, but for now, not */</comment>
	<decl_stmt><decl><type><name>float</name></type>		<name>smoothing_samples</name> <init>= <expr><literal type="number">16</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float</name></type>		<name>scan_whole_pool_milliseconds</name> <init>= <expr><literal type="number">120000.0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Used to compute how far we scan ahead */</comment>
	<decl_stmt><decl><type><name>long</name></type>		<name>strategy_delta</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bufs_to_lap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bufs_ahead</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float</name></type>		<name>scans_per_alloc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>reusable_buffers_est</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>upcoming_alloc_est</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>min_scan_buffers</name></decl>;</decl_stmt>

	<comment type="block">/* Variables for the scanning loop proper */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_to_scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_written</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>reusable_buffers</name></decl>;</decl_stmt>

	<comment type="block">/* Variables for final smoothed_density update */</comment>
	<decl_stmt><decl><type><name>long</name></type>		<name>new_strategy_delta</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>new_recent_alloc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Find out where the freelist clock sweep currently is, and how many
	 * buffer allocations have happened since our last call.
	 */</comment>
	<expr_stmt><expr><name>strategy_buf_id</name> <operator>=</operator> <call><name>StrategySyncStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>strategy_passes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>recent_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Report buffer alloc counts to pgstat */</comment>
	<expr_stmt><expr><name><name>BgWriterStats</name><operator>.</operator><name>m_buf_alloc</name></name> <operator>+=</operator> <name>recent_alloc</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we're not running the LRU scan, just stop after doing the stats
	 * stuff.  We mark the saved state invalid so that we can recover sanely
	 * if LRU scan is turned back on later.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>bgwriter_lru_maxpages</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>saved_info_valid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Compute strategy_delta = how many buffers have been scanned by the
	 * clock sweep since last time.  If first time through, assume none. Then
	 * see if we are still ahead of the clock sweep, and if so, how many
	 * buffers we could scan before we'd catch up with it and "lap" it. Note:
	 * weird-looking coding of xxx_passes comparisons are to avoid bogus
	 * behavior when the passes counts wrap around.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>saved_info_valid</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int32</name></type>		<name>passes_delta</name> <init>= <expr><name>strategy_passes</name> <operator>-</operator> <name>prev_strategy_passes</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>strategy_delta</name> <operator>=</operator> <name>strategy_buf_id</name> <operator>-</operator> <name>prev_strategy_buf_id</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>strategy_delta</name> <operator>+=</operator> <operator>(</operator><name>long</name><operator>)</operator> <name>passes_delta</name> <operator>*</operator> <name>NBuffers</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>strategy_delta</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int32</name><operator>)</operator> <operator>(</operator><name>next_passes</name> <operator>-</operator> <name>strategy_passes</name><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* we're one pass ahead of the strategy point */</comment>
			<expr_stmt><expr><name>bufs_to_lap</name> <operator>=</operator> <name>strategy_buf_id</name> <operator>-</operator> <name>next_to_clean</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BGW_DEBUG</name></cpp:ifdef>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"bgwriter ahead: bgw %u-%u strategy %u-%u delta=%ld lap=%d"</literal></expr></argument>,
				 <argument><expr><name>next_passes</name></expr></argument>, <argument><expr><name>next_to_clean</name></expr></argument>,
				 <argument><expr><name>strategy_passes</name></expr></argument>, <argument><expr><name>strategy_buf_id</name></expr></argument>,
				 <argument><expr><name>strategy_delta</name></expr></argument>, <argument><expr><name>bufs_to_lap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>next_passes</name> <operator>==</operator> <name>strategy_passes</name> <operator>&amp;&amp;</operator>
				 <name>next_to_clean</name> <operator>&gt;=</operator> <name>strategy_buf_id</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* on same pass, but ahead or at least not behind */</comment>
			<expr_stmt><expr><name>bufs_to_lap</name> <operator>=</operator> <name>NBuffers</name> <operator>-</operator> <operator>(</operator><name>next_to_clean</name> <operator>-</operator> <name>strategy_buf_id</name><operator>)</operator></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BGW_DEBUG</name></cpp:ifdef>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"bgwriter ahead: bgw %u-%u strategy %u-%u delta=%ld lap=%d"</literal></expr></argument>,
				 <argument><expr><name>next_passes</name></expr></argument>, <argument><expr><name>next_to_clean</name></expr></argument>,
				 <argument><expr><name>strategy_passes</name></expr></argument>, <argument><expr><name>strategy_buf_id</name></expr></argument>,
				 <argument><expr><name>strategy_delta</name></expr></argument>, <argument><expr><name>bufs_to_lap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * We're behind, so skip forward to the strategy point and start
			 * cleaning from there.
			 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BGW_DEBUG</name></cpp:ifdef>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"bgwriter behind: bgw %u-%u strategy %u-%u delta=%ld"</literal></expr></argument>,
				 <argument><expr><name>next_passes</name></expr></argument>, <argument><expr><name>next_to_clean</name></expr></argument>,
				 <argument><expr><name>strategy_passes</name></expr></argument>, <argument><expr><name>strategy_buf_id</name></expr></argument>,
				 <argument><expr><name>strategy_delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><name>next_to_clean</name> <operator>=</operator> <name>strategy_buf_id</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>next_passes</name> <operator>=</operator> <name>strategy_passes</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>bufs_to_lap</name> <operator>=</operator> <name>NBuffers</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Initializing at startup or after LRU scanning had been off. Always
		 * start at the strategy point.
		 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BGW_DEBUG</name></cpp:ifdef>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"bgwriter initializing: strategy %u-%u"</literal></expr></argument>,
			 <argument><expr><name>strategy_passes</name></expr></argument>, <argument><expr><name>strategy_buf_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name>strategy_delta</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>next_to_clean</name> <operator>=</operator> <name>strategy_buf_id</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>next_passes</name> <operator>=</operator> <name>strategy_passes</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bufs_to_lap</name> <operator>=</operator> <name>NBuffers</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Update saved info for next time */</comment>
	<expr_stmt><expr><name>prev_strategy_buf_id</name> <operator>=</operator> <name>strategy_buf_id</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev_strategy_passes</name> <operator>=</operator> <name>strategy_passes</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>saved_info_valid</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute how many buffers had to be scanned for each new allocation, ie,
	 * 1/density of reusable buffers, and track a moving average of that.
	 *
	 * If the strategy point didn't move, we don't update the density estimate
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>strategy_delta</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>recent_alloc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>scans_per_alloc</name> <operator>=</operator> <operator>(</operator><name>float</name><operator>)</operator> <name>strategy_delta</name> <operator>/</operator> <operator>(</operator><name>float</name><operator>)</operator> <name>recent_alloc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>smoothed_density</name> <operator>+=</operator> <operator>(</operator><name>scans_per_alloc</name> <operator>-</operator> <name>smoothed_density</name><operator>)</operator> <operator>/</operator>
			<name>smoothing_samples</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Estimate how many reusable buffers there are between the current
	 * strategy point and where we've scanned ahead to, based on the smoothed
	 * density estimate.
	 */</comment>
	<expr_stmt><expr><name>bufs_ahead</name> <operator>=</operator> <name>NBuffers</name> <operator>-</operator> <name>bufs_to_lap</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>reusable_buffers_est</name> <operator>=</operator> <operator>(</operator><name>float</name><operator>)</operator> <name>bufs_ahead</name> <operator>/</operator> <name>smoothed_density</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Track a moving average of recent buffer allocations.  Here, rather than
	 * a true average we want a fast-attack, slow-decline behavior: we
	 * immediately follow any increase.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>smoothed_alloc</name> <operator>&lt;=</operator> <operator>(</operator><name>float</name><operator>)</operator> <name>recent_alloc</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>smoothed_alloc</name> <operator>=</operator> <name>recent_alloc</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>smoothed_alloc</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name>float</name><operator>)</operator> <name>recent_alloc</name> <operator>-</operator> <name>smoothed_alloc</name><operator>)</operator> <operator>/</operator>
			<name>smoothing_samples</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Scale the estimate by a GUC to allow more aggressive tuning. */</comment>
	<expr_stmt><expr><name>upcoming_alloc_est</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>smoothed_alloc</name> <operator>*</operator> <name>bgwriter_lru_multiplier</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * If recent_alloc remains at zero for many cycles, smoothed_alloc will
	 * eventually underflow to zero, and the underflows produce annoying
	 * kernel warnings on some platforms.  Once upcoming_alloc_est has gone to
	 * zero, there's no point in tracking smaller and smaller values of
	 * smoothed_alloc, so just reset it to exactly zero to avoid this
	 * syndrome.  It will pop back up as soon as recent_alloc increases.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>upcoming_alloc_est</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>smoothed_alloc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Even in cases where there's been little or no buffer allocation
	 * activity, we want to make a small amount of progress through the buffer
	 * cache so that as many reusable buffers as possible are clean after an
	 * idle period.
	 *
	 * (scan_whole_pool_milliseconds / BgWriterDelay) computes how many times
	 * the BGW will be called during the scan_whole_pool time; slice the
	 * buffer pool into that many sections.
	 */</comment>
	<expr_stmt><expr><name>min_scan_buffers</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>NBuffers</name> <operator>/</operator> <operator>(</operator><name>scan_whole_pool_milliseconds</name> <operator>/</operator> <name>BgWriterDelay</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>upcoming_alloc_est</name> <operator>&lt;</operator> <operator>(</operator><name>min_scan_buffers</name> <operator>+</operator> <name>reusable_buffers_est</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BGW_DEBUG</name></cpp:ifdef>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"bgwriter: alloc_est=%d too small, using min=%d + reusable_est=%d"</literal></expr></argument>,
			 <argument><expr><name>upcoming_alloc_est</name></expr></argument>, <argument><expr><name>min_scan_buffers</name></expr></argument>, <argument><expr><name>reusable_buffers_est</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name>upcoming_alloc_est</name> <operator>=</operator> <name>min_scan_buffers</name> <operator>+</operator> <name>reusable_buffers_est</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now write out dirty reusable buffers, working forward from the
	 * next_to_clean point, until we have lapped the strategy scan, or cleaned
	 * enough buffers to match our estimate of the next cycle's allocation
	 * requirements, or hit the bgwriter_lru_maxpages limit.
	 */</comment>

	<comment type="block">/* Make sure we can handle the pin inside SyncOneBuffer */</comment>
	<expr_stmt><expr><call><name>ResourceOwnerEnlargeBuffers</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>num_to_scan</name> <operator>=</operator> <name>bufs_to_lap</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>num_written</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>reusable_buffers</name> <operator>=</operator> <name>reusable_buffers_est</name></expr>;</expr_stmt>

	<comment type="block">/* Execute the LRU scan */</comment>
	<while>while <condition>(<expr><name>num_to_scan</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>reusable_buffers</name> <operator>&lt;</operator> <name>upcoming_alloc_est</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>sync_state</name> <init>= <expr><call><name>SyncOneBuffer</name><argument_list>(<argument><expr><name>next_to_clean</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
											   <argument><expr><name>wb_context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>++</operator><name>next_to_clean</name> <operator>&gt;=</operator> <name>NBuffers</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>next_to_clean</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>next_passes</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>num_to_scan</name><operator>--</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>sync_state</name> <operator>&amp;</operator> <name>BUF_WRITTEN</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>reusable_buffers</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>++</operator><name>num_written</name> <operator>&gt;=</operator> <name>bgwriter_lru_maxpages</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>BgWriterStats</name><operator>.</operator><name>m_maxwritten_clean</name></name><operator>++</operator></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>sync_state</name> <operator>&amp;</operator> <name>BUF_REUSABLE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>reusable_buffers</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><name><name>BgWriterStats</name><operator>.</operator><name>m_buf_written_clean</name></name> <operator>+=</operator> <name>num_written</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BGW_DEBUG</name></cpp:ifdef>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"bgwriter: recent_alloc=%u smoothed=%.2f delta=%ld ahead=%d density=%.2f reusable_est=%d upcoming_est=%d scanned=%d wrote=%d reusable=%d"</literal></expr></argument>,
		 <argument><expr><name>recent_alloc</name></expr></argument>, <argument><expr><name>smoothed_alloc</name></expr></argument>, <argument><expr><name>strategy_delta</name></expr></argument>, <argument><expr><name>bufs_ahead</name></expr></argument>,
		 <argument><expr><name>smoothed_density</name></expr></argument>, <argument><expr><name>reusable_buffers_est</name></expr></argument>, <argument><expr><name>upcoming_alloc_est</name></expr></argument>,
		 <argument><expr><name>bufs_to_lap</name> <operator>-</operator> <name>num_to_scan</name></expr></argument>,
		 <argument><expr><name>num_written</name></expr></argument>,
		 <argument><expr><name>reusable_buffers</name> <operator>-</operator> <name>reusable_buffers_est</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Consider the above scan as being like a new allocation scan.
	 * Characterize its density and update the smoothed one based on it. This
	 * effectively halves the moving average period in cases where both the
	 * strategy and the background writer are doing some useful scanning,
	 * which is helpful because a long memory isn't as desirable on the
	 * density estimates.
	 */</comment>
	<expr_stmt><expr><name>new_strategy_delta</name> <operator>=</operator> <name>bufs_to_lap</name> <operator>-</operator> <name>num_to_scan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>new_recent_alloc</name> <operator>=</operator> <name>reusable_buffers</name> <operator>-</operator> <name>reusable_buffers_est</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>new_strategy_delta</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>new_recent_alloc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>scans_per_alloc</name> <operator>=</operator> <operator>(</operator><name>float</name><operator>)</operator> <name>new_strategy_delta</name> <operator>/</operator> <operator>(</operator><name>float</name><operator>)</operator> <name>new_recent_alloc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>smoothed_density</name> <operator>+=</operator> <operator>(</operator><name>scans_per_alloc</name> <operator>-</operator> <name>smoothed_density</name><operator>)</operator> <operator>/</operator>
			<name>smoothing_samples</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BGW_DEBUG</name></cpp:ifdef>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"bgwriter: cleaner density alloc=%u scan=%ld density=%.2f new smoothed=%.2f"</literal></expr></argument>,
			 <argument><expr><name>new_recent_alloc</name></expr></argument>, <argument><expr><name>new_strategy_delta</name></expr></argument>,
			 <argument><expr><name>scans_per_alloc</name></expr></argument>, <argument><expr><name>smoothed_density</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Return true if OK to hibernate */</comment>
	<return>return <expr><operator>(</operator><name>bufs_to_lap</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>recent_alloc</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SyncOneBuffer -- process a single buffer during syncing.
 *
 * If skip_recently_used is true, we don't write currently-pinned buffers, nor
 * buffers marked recently used, as these are not replacement candidates.
 *
 * Returns a bitmask containing the following flag bits:
 *	BUF_WRITTEN: we wrote the buffer.
 *	BUF_REUSABLE: buffer is available for replacement, ie, it has
 *		pin count 0 and usage count 0.
 *
 * (BUF_WRITTEN could be set in error if FlushBuffer finds the buffer clean
 * after locking it, but we don't care all that much.)
 *
 * Note: caller must have done ResourceOwnerEnlargeBuffers.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>SyncOneBuffer</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>buf_id</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skip_recently_used</name></decl></parameter>, <parameter><decl><type><name>WritebackContext</name> <modifier>*</modifier></type><name>wb_context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>bufHdr</name> <init>= <expr><call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>buf_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>buf_state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type>	<name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ReservePrivateRefCountEntry</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check whether buffer needs writing.
	 *
	 * We can make this check without taking the buffer content lock so long
	 * as we mark pages dirty in access methods *before* logging changes with
	 * XLogInsert(): if someone marks the buffer dirty just after our check we
	 * don't worry because our checkpoint.redo points before log record for
	 * upcoming changes and so we are not required to write such dirty buffer.
	 */</comment>
	<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>LockBufHdr</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUF_STATE_GET_REFCOUNT</name><argument_list>(<argument><expr><name>buf_state</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<call><name>BUF_STATE_GET_USAGECOUNT</name><argument_list>(<argument><expr><name>buf_state</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>|=</operator> <name>BUF_REUSABLE</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>skip_recently_used</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Caller told us not to write recently-used buffers */</comment>
		<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>buf_state</name> <operator>&amp;</operator> <name>BM_VALID</name><operator>)</operator> <operator>||</operator> <operator>!</operator><operator>(</operator><name>buf_state</name> <operator>&amp;</operator> <name>BM_DIRTY</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* It's clean, so nothing to do */</comment>
		<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Pin it, share-lock it, write it.  (FlushBuffer will do nothing if the
	 * buffer is clean by the time we've locked it.)
	 */</comment>
	<expr_stmt><expr><call><name>PinBuffer_Locked</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetContentLock</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FlushBuffer</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetContentLock</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tag</name> <operator>=</operator> <name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UnpinBuffer</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScheduleBufferTagForWriteback</name><argument_list>(<argument><expr><name>wb_context</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name> <operator>|</operator> <name>BUF_WRITTEN</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		AtEOXact_Buffers - clean up at end of transaction.
 *
 *		As of PostgreSQL 8.0, buffer pins should get released by the
 *		ResourceOwner mechanism.  This routine is just a debugging
 *		cross-check that no pins remain.
 */</comment>
<function><type><name>void</name></type>
<name>AtEOXact_Buffers</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckForBufferLeaks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AtEOXact_LocalBuffers</name><argument_list>(<argument><expr><name>isCommit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>PrivateRefCountOverflowed</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize access to shared buffer pool
 *
 * This is called during backend startup (whether standalone or under the
 * postmaster).  It sets up for this backend's access to the already-existing
 * buffer pool.
 *
 * NB: this is called before InitProcess(), so we do not have a PGPROC and
 * cannot do LWLockAcquire; hence we can't actually access stuff in
 * shared memory yet.  We are only initializing local data here.
 * (See also InitBufferPoolBackend)
 */</comment>
<function><type><name>void</name></type>
<name>InitBufferPoolAccess</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>hash_ctl</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>PrivateRefCountArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PrivateRefCountArray</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PrivateRefCountEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><name>PrivateRefCountHash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"PrivateRefCount"</literal></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
									  <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * InitBufferPoolBackend --- second-stage initialization of a new backend
 *
 * This is called after we have acquired a PGPROC and so can safely get
 * LWLocks.  We don't currently need to do anything at this stage ...
 * except register a shmem-exit callback.  AtProcExit_Buffers needs LWLock
 * access, and thereby has to be called at the corresponding phase of
 * backend shutdown.
 */</comment>
<function><type><name>void</name></type>
<name>InitBufferPoolBackend</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>on_shmem_exit</name><argument_list>(<argument><expr><name>AtProcExit_Buffers</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * During backend exit, ensure that we released all shared-buffer locks and
 * assert that we have no remaining pins.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AtProcExit_Buffers</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AbortBufferIO</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnlockBuffers</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CheckForBufferLeaks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* localbuf.c needs a chance too */</comment>
	<expr_stmt><expr><call><name>AtProcExit_LocalBuffers</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		CheckForBufferLeaks - ensure this backend holds no buffer pins
 *
 *		As of PostgreSQL 8.0, buffer pins should get released by the
 *		ResourceOwner mechanism.  This routine is just a debugging
 *		cross-check that no pins remain.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CheckForBufferLeaks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<decl_stmt><decl><type><name>int</name></type>			<name>RefCountErrors</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PrivateRefCountEntry</name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* check the array */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>REFCOUNT_ARRAY_ENTRIES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <operator>&amp;</operator><name><name>PrivateRefCountArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>buffer</name></name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PrintBufferLeakWarning</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>RefCountErrors</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* if necessary search the hash */</comment>
	<if_stmt><if>if <condition>(<expr><name>PrivateRefCountOverflowed</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>hstat</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hstat</name></expr></argument>, <argument><expr><name>PrivateRefCountHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <operator>(</operator><name>PrivateRefCountEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hstat</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PrintBufferLeakWarning</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>RefCountErrors</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>

	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>RefCountErrors</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Helper routine to issue warnings when a buffer is unexpectedly pinned
 */</comment>
<function><type><name>void</name></type>
<name>PrintBufferLeakWarning</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>loccount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BackendId</name></type>	<name>backend</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>buf_state</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsLocal</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>GetLocalBufferDescriptor</name><argument_list>(<argument><expr><operator>-</operator><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>loccount</name> <operator>=</operator> <name><name>LocalRefCount</name><index>[<expr><operator>-</operator><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>backend</name> <operator>=</operator> <name>MyBackendId</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>loccount</name> <operator>=</operator> <call><name>GetPrivateRefCount</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>backend</name> <operator>=</operator> <name>InvalidBackendId</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* theoretically we should lock the bufhdr here */</comment>
	<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>relpathbackend</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name></name></expr></argument>, <argument><expr><name>backend</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>forkNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
		 <argument><expr><literal type="string">"buffer refcount leak: [%03d] "</literal>
		 <literal type="string">"(rel=%s, blockNum=%u, flags=0x%x, refcount=%u %d)"</literal></expr></argument>,
		 <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
		 <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>blockNum</name></name></expr></argument>, <argument><expr><name>buf_state</name> <operator>&amp;</operator> <name>BUF_FLAG_MASK</name></expr></argument>,
		 <argument><expr><call><name>BUF_STATE_GET_REFCOUNT</name><argument_list>(<argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>loccount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * CheckPointBuffers
 *
 * Flush all dirty blocks in buffer pool to disk at checkpoint time.
 *
 * Note: temporary relations do not participate in checkpoints, so they don't
 * need to be flushed.
 */</comment>
<function><type><name>void</name></type>
<name>CheckPointBuffers</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_BUFFER_CHECKPOINT_START</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>CheckpointStats</name><operator>.</operator><name>ckpt_write_t</name></name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BufferSync</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>CheckpointStats</name><operator>.</operator><name>ckpt_sync_t</name></name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_BUFFER_CHECKPOINT_SYNC_START</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ProcessSyncRequests</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>CheckpointStats</name><operator>.</operator><name>ckpt_sync_end_t</name></name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_BUFFER_CHECKPOINT_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Do whatever is needed to prepare for commit at the bufmgr and smgr levels
 */</comment>
<function><type><name>void</name></type>
<name>BufmgrCommit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Nothing to do in bufmgr anymore... */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * BufferGetBlockNumber
 *		Returns the block number associated with a buffer.
 *
 * Note:
 *		Assumes that the buffer is valid and pinned, else the
 *		value may be obsolete immediately...
 */</comment>
<function><type><name>BlockNumber</name></type>
<name>BufferGetBlockNumber</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>bufHdr</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsPinned</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsLocal</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>bufHdr</name> <operator>=</operator> <call><name>GetLocalBufferDescriptor</name><argument_list>(<argument><expr><operator>-</operator><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>bufHdr</name> <operator>=</operator> <call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* pinned, so OK to read tag without spinlock */</comment>
	<return>return <expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>blockNum</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * BufferGetTag
 *		Returns the relfilenode, fork number and block number associated with
 *		a buffer.
 */</comment>
<function><type><name>void</name></type>
<name>BufferGetTag</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>RelFileNode</name> <modifier>*</modifier></type><name>rnode</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name> <modifier>*</modifier></type><name>forknum</name></decl></parameter>,
			 <parameter><decl><type><name>BlockNumber</name> <modifier>*</modifier></type><name>blknum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>bufHdr</name></decl>;</decl_stmt>

	<comment type="block">/* Do the same checks as BufferGetBlockNumber. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsPinned</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsLocal</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>bufHdr</name> <operator>=</operator> <call><name>GetLocalBufferDescriptor</name><argument_list>(<argument><expr><operator>-</operator><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>bufHdr</name> <operator>=</operator> <call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* pinned, so OK to read tag without spinlock */</comment>
	<expr_stmt><expr><operator>*</operator><name>rnode</name> <operator>=</operator> <name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>forknum</name> <operator>=</operator> <name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>forkNum</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>blknum</name> <operator>=</operator> <name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>blockNum</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * FlushBuffer
 *		Physically write out a shared buffer.
 *
 * NOTE: this actually just passes the buffer contents to the kernel; the
 * real write to disk won't happen until the kernel feels like it.  This
 * is okay from our point of view since we can redo the changes from WAL.
 * However, we will need to force the changes to disk via fsync before
 * we can checkpoint WAL.
 *
 * The caller must hold a pin on the buffer and have share-locked the
 * buffer contents.  (Note: a share-lock does not prevent updates of
 * hint bits in the buffer, so the page could change while the write
 * is in progress, but we assume that that will not invalidate the data
 * written.)
 *
 * If the caller has an smgr reference for the buffer's relation, pass it
 * as the second parameter.  If not, pass NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FlushBuffer</name><parameter_list>(<parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>errcallback</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>instr_time</name></type>	<name>io_start</name></decl>,
				<decl><type ref="prev"/><name>io_time</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Block</name></type>		<name>bufBlock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>bufToWrite</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>buf_state</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Acquire the buffer's io_in_progress lock.  If StartBufferIO returns
	 * false, then someone else flushed the buffer before we could, so we need
	 * not do anything.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>StartBufferIO</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Setup error traceback support for ereport() */</comment>
	<expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>shared_buffer_write_error_callback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>buf</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>errcallback</name></expr>;</expr_stmt>

	<comment type="block">/* Find smgr relation for buffer */</comment>
	<if_stmt><if>if <condition>(<expr><name>reln</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>reln</name> <operator>=</operator> <call><name>smgropen</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name></name></expr></argument>, <argument><expr><name>InvalidBackendId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_BUFFER_FLUSH_START</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>forkNum</name></name></expr></argument>,
										<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>blockNum</name></name></expr></argument>,
										<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>spcNode</name></name></expr></argument>,
										<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
										<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>relNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>LockBufHdr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Run PageGetLSN while holding header lock, since we don't have the
	 * buffer locked exclusively in all cases.
	 */</comment>
	<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>BufferGetLSN</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* To check if block content changes while flushing. - vadim 01/17/97 */</comment>
	<expr_stmt><expr><name>buf_state</name> <operator>&amp;=</operator> <operator>~</operator><name>BM_JUST_DIRTIED</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Force XLOG flush up to buffer's LSN.  This implements the basic WAL
	 * rule that log updates must hit disk before any of the data-file changes
	 * they describe do.
	 *
	 * However, this rule does not apply to unlogged relations, which will be
	 * lost after a crash anyway.  Most unlogged relation pages do not bear
	 * LSNs since we never emit WAL records for them, and therefore flushing
	 * up through the buffer LSN would be useless, but harmless.  However,
	 * GiST indexes use LSNs internally to track page-splits, and therefore
	 * unlogged GiST pages bear "fake" LSNs generated by
	 * GetFakeLSNForUnloggedRel.  It is unlikely but possible that the fake
	 * LSN counter could advance past the WAL insertion point; and if it did
	 * happen, attempting to flush WAL through that location would fail, with
	 * disastrous system-wide consequences.  To make sure that can't happen,
	 * skip the flush if the buffer isn't permanent.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>buf_state</name> <operator>&amp;</operator> <name>BM_PERMANENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>XLogFlush</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Now it's safe to write buffer to disk. Note that no one else should
	 * have been able to write it while we were busy with log flushing because
	 * we have the io_in_progress lock.
	 */</comment>
	<expr_stmt><expr><name>bufBlock</name> <operator>=</operator> <call><name>BufHdrGetBlock</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Update page checksum if desired.  Since we have only shared lock on the
	 * buffer, other processes might be updating hint bits in it, so we must
	 * copy the page to private storage if we do checksumming.
	 */</comment>
	<expr_stmt><expr><name>bufToWrite</name> <operator>=</operator> <call><name>PageSetChecksumCopy</name><argument_list>(<argument><expr><operator>(</operator><name>Page</name><operator>)</operator> <name>bufBlock</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>blockNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>track_io_timing</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>io_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * bufToWrite is either the shared buffer or a copy, as appropriate.
	 */</comment>
	<expr_stmt><expr><call><name>smgrwrite</name><argument_list>(<argument><expr><name>reln</name></expr></argument>,
			  <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>forkNum</name></name></expr></argument>,
			  <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>blockNum</name></name></expr></argument>,
			  <argument><expr><name>bufToWrite</name></expr></argument>,
			  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>track_io_timing</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>io_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>INSTR_TIME_SUBTRACT</name><argument_list>(<argument><expr><name>io_time</name></expr></argument>, <argument><expr><name>io_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgstat_count_buffer_write_time</name><argument_list>(<argument><expr><call><name>INSTR_TIME_GET_MICROSEC</name><argument_list>(<argument><expr><name>io_time</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>INSTR_TIME_ADD</name><argument_list>(<argument><expr><name><name>pgBufferUsage</name><operator>.</operator><name>blk_write_time</name></name></expr></argument>, <argument><expr><name>io_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>pgBufferUsage</name><operator>.</operator><name>shared_blks_written</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Mark the buffer as clean (unless BM_JUST_DIRTIED has become set) and
	 * end the io_in_progress state.
	 */</comment>
	<expr_stmt><expr><call><name>TerminateBufferIO</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_BUFFER_FLUSH_DONE</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>forkNum</name></name></expr></argument>,
									   <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>blockNum</name></name></expr></argument>,
									   <argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>spcNode</name></name></expr></argument>,
									   <argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
									   <argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>relNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Pop the error context stack */</comment>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>errcallback</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RelationGetNumberOfBlocksInFork
 *		Determines the current number of pages in the specified relation fork.
 *
 * Note that the accuracy of the result will depend on the details of the
 * relation's storage. For builtin AMs it'll be accurate, but for external AMs
 * it might not be.
 */</comment>
<function><type><name>BlockNumber</name></type>
<name>RelationGetNumberOfBlocksInFork</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forkNum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RELKIND_SEQUENCE</name></expr>:</case>
		<case>case <expr><name>RELKIND_INDEX</name></expr>:</case>
		<case>case <expr><name>RELKIND_PARTITIONED_INDEX</name></expr>:</case>
			<comment type="block">/* Open it at the smgr level if not already done */</comment>
			<expr_stmt><expr><call><name>RelationOpenSmgr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><call><name>smgrnblocks</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>RELKIND_RELATION</name></expr>:</case>
		<case>case <expr><name>RELKIND_TOASTVALUE</name></expr>:</case>
		<case>case <expr><name>RELKIND_MATVIEW</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * Not every table AM uses BLCKSZ wide fixed size blocks.
				 * Therefore tableam returns the size in bytes - but for the
				 * purpose of this routine, we want the number of blocks.
				 * Therefore divide, rounding up.
				 */</comment>
				<decl_stmt><decl><type><name>uint64</name></type>		<name>szbytes</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>szbytes</name> <operator>=</operator> <call><name>table_relation_size</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<return>return <expr><operator>(</operator><name>szbytes</name> <operator>+</operator> <operator>(</operator><name>BLCKSZ</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <name>BLCKSZ</name></expr>;</return>
			</block_content>}</block>
		<case>case <expr><name>RELKIND_VIEW</name></expr>:</case>
		<case>case <expr><name>RELKIND_COMPOSITE_TYPE</name></expr>:</case>
		<case>case <expr><name>RELKIND_FOREIGN_TABLE</name></expr>:</case>
		<case>case <expr><name>RELKIND_PARTITIONED_TABLE</name></expr>:</case>
		<default>default:</default>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><literal type="number">0</literal></expr>;</return>					<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * BufferIsPermanent
 *		Determines whether a buffer will potentially still be around after
 *		a crash.  Caller must hold a buffer pin.
 */</comment>
<function><type><name>bool</name></type>
<name>BufferIsPermanent</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>bufHdr</name></decl>;</decl_stmt>

	<comment type="block">/* Local buffers are used only for temp relations. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsLocal</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Make sure we've got a real buffer, and that we hold a pin on it. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsPinned</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * BM_PERMANENT can't be changed while we hold a pin on the buffer, so we
	 * need not bother with the buffer header spinlock.  Even if someone else
	 * changes the buffer header state while we're doing this, the state is
	 * changed atomically, so we'll read the old value or the new value, but
	 * not random garbage.
	 */</comment>
	<expr_stmt><expr><name>bufHdr</name> <operator>=</operator> <call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufHdr</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>BM_PERMANENT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * BufferGetLSNAtomic
 *		Retrieves the LSN of the buffer atomically using a buffer header lock.
 *		This is necessary for some callers who may not have an exclusive lock
 *		on the buffer.
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>BufferGetLSNAtomic</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>bufHdr</name> <init>= <expr><call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>buf_state</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If we don't need locking for correctness, fastpath out.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogHintBitIsNeeded</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>BufferIsLocal</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>PageGetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Make sure we've got a real buffer, and that we hold a pin on it. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsPinned</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>LockBufHdr</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lsn</name> <operator>=</operator> <call><name>PageGetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>lsn</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ---------------------------------------------------------------------
 *		DropRelFileNodeBuffers
 *
 *		This function removes from the buffer pool all the pages of the
 *		specified relation forks that have block numbers &gt;= firstDelBlock.
 *		(In particular, with firstDelBlock = 0, all pages are removed.)
 *		Dirty pages are simply dropped, without bothering to write them
 *		out first.  Therefore, this is NOT rollback-able, and so should be
 *		used only with extreme caution!
 *
 *		Currently, this is called only from smgr.c when the underlying file
 *		is about to be deleted or truncated (firstDelBlock is needed for
 *		the truncation case).  The data in the affected pages would therefore
 *		be deleted momentarily anyway, and there is no point in writing it.
 *		It is the responsibility of higher-level code to ensure that the
 *		deletion or truncation does not lose any data that could be needed
 *		later.  It is also the responsibility of higher-level code to ensure
 *		that no other process could be trying to load more pages of the
 *		relation into buffers.
 *
 *		XXX currently it sequentially searches the buffer pool, should be
 *		changed to more clever ways of searching.  However, this routine
 *		is used only in code paths that aren't very performance-critical,
 *		and we shouldn't slow down the hot paths to make it faster ...
 * --------------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>DropRelFileNodeBuffers</name><parameter_list>(<parameter><decl><type><name>RelFileNodeBackend</name></type> <name>rnode</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name> <modifier>*</modifier></type><name>forkNum</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>nforks</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name> <modifier>*</modifier></type><name>firstDelBlock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

	<comment type="block">/* If it's a local relation, it's localbuf.c's problem. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelFileNodeBackendIsTemp</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>rnode</name><operator>.</operator><name>backend</name></name> <operator>==</operator> <name>MyBackendId</name></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nforks</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>DropRelFileNodeLocalBuffers</name><argument_list>(<argument><expr><name><name>rnode</name><operator>.</operator><name>node</name></name></expr></argument>, <argument><expr><name><name>forkNum</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
											<argument><expr><name><name>firstDelBlock</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		</block_content>}</block></if></if_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NBuffers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>bufHdr</name> <init>= <expr><call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>buf_state</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We can make this a tad faster by prechecking the buffer tag before
		 * we attempt to lock the buffer; this saves a lot of lock
		 * acquisitions in typical cases.  It should be safe because the
		 * caller must have AccessExclusiveLock on the relation, or some other
		 * reason to be certain that no one is loading new pages of the rel
		 * into the buffer pool.  (Otherwise we might well miss such pages
		 * entirely.)  Therefore, while the tag might be changing while we
		 * look at it, it can't be changing *to* a value we care about, only
		 * *away* from such a value.  So false negatives are impossible, and
		 * false positives are safe because we'll recheck after getting the
		 * buffer lock.
		 *
		 * We could check forkNum and blockNum as well as the rnode, but the
		 * incremental win from doing so seems small.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelFileNodeEquals</name><argument_list>(<argument><expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>.</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>LockBufHdr</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nforks</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>RelFileNodeEquals</name><argument_list>(<argument><expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>.</operator><name>node</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>forkNum</name></name> <operator>==</operator> <name><name>forkNum</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&amp;&amp;</operator>
				<name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>blockNum</name></name> <operator>&gt;=</operator> <name><name>firstDelBlock</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>InvalidateBuffer</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* releases spinlock */</comment>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;=</operator> <name>nforks</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* ---------------------------------------------------------------------
 *		DropRelFileNodesAllBuffers
 *
 *		This function removes from the buffer pool all the pages of all
 *		forks of the specified relations.  It's equivalent to calling
 *		DropRelFileNodeBuffers once per fork per relation with
 *		firstDelBlock = 0.
 * --------------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>DropRelFileNodesAllBuffers</name><parameter_list>(<parameter><decl><type><name>RelFileNodeBackend</name> <modifier>*</modifier></type><name>rnodes</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nnodes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelFileNode</name> <modifier>*</modifier></type><name>nodes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>use_bsearch</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>nnodes</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>nodes</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNode</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nnodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* non-local relations */</comment>

	<comment type="block">/* If it's a local relation, it's localbuf.c's problem. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nnodes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>RelFileNodeBackendIsTemp</name><argument_list>(<argument><expr><name><name>rnodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>rnodes</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>backend</name> <operator>==</operator> <name>MyBackendId</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>DropRelFileNodeAllLocalBuffers</name><argument_list>(<argument><expr><name><name>rnodes</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nodes</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>rnodes</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>node</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If there are no non-local relations, then we're done. Release the
	 * memory and return.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * For low number of relations to drop just use a simple walk through, to
	 * save the bsearch overhead. The threshold to use is rather a guess than
	 * an exactly determined value, as it depends on many factors (CPU and RAM
	 * speeds, amount of shared buffers etc.).
	 */</comment>
	<expr_stmt><expr><name>use_bsearch</name> <operator>=</operator> <name>n</name> <operator>&gt;</operator> <name>RELS_BSEARCH_THRESHOLD</name></expr>;</expr_stmt>

	<comment type="block">/* sort the list of rnodes if necessary */</comment>
	<if_stmt><if>if <condition>(<expr><name>use_bsearch</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_qsort</name><argument_list>(<argument><expr><name>nodes</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNode</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>rnode_comparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NBuffers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelFileNode</name> <modifier>*</modifier></type><name>rnode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>bufHdr</name> <init>= <expr><call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>buf_state</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * As in DropRelFileNodeBuffers, an unlocked precheck should be safe
		 * and saves some cycles.
		 */</comment>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>use_bsearch</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>RelFileNodeEquals</name><argument_list>(<argument><expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name></name></expr></argument>, <argument><expr><name><name>nodes</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>rnode</name> <operator>=</operator> <operator>&amp;</operator><name><name>nodes</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>rnode</name> <operator>=</operator> <call><name>bsearch</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name></name><operator>)</operator></expr></argument>,
							<argument><expr><name>nodes</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNode</name></expr></argument>)</argument_list></sizeof></expr></argument>,
							<argument><expr><name>rnode_comparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* buffer doesn't belong to any of the given relfilenodes; skip it */</comment>
		<if_stmt><if>if <condition>(<expr><name>rnode</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>LockBufHdr</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>RelFileNodeEquals</name><argument_list>(<argument><expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>*</operator><name>rnode</name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>InvalidateBuffer</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* releases spinlock */</comment>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ---------------------------------------------------------------------
 *		DropDatabaseBuffers
 *
 *		This function removes all the buffers in the buffer cache for a
 *		particular database.  Dirty pages are simply dropped, without
 *		bothering to write them out first.  This is used when we destroy a
 *		database, to avoid trying to flush data to disk when the directory
 *		tree no longer exists.  Implementation is pretty similar to
 *		DropRelFileNodeBuffers() which is for destroying just one relation.
 * --------------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>DropDatabaseBuffers</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>dbid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We needn't consider local buffers, since by assumption the target
	 * database isn't our own.
	 */</comment>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NBuffers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>bufHdr</name> <init>= <expr><call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>buf_state</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * As in DropRelFileNodeBuffers, an unlocked precheck should be safe
		 * and saves some cycles.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name><operator>.</operator><name>dbNode</name></name> <operator>!=</operator> <name>dbid</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>LockBufHdr</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name><operator>.</operator><name>dbNode</name></name> <operator>==</operator> <name>dbid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>InvalidateBuffer</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* releases spinlock */</comment>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* -----------------------------------------------------------------
 *		PrintBufferDescs
 *
 *		this function prints all the buffer descriptors, for debugging
 *		use only.
 * -----------------------------------------------------------------
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
<function><type><name>void</name></type>
<name>PrintBufferDescs</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NBuffers</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>b</name> <init>= <expr><call><name>BufferDescriptorGetBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* theoretically we should lock the bufhdr here */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
			 <argument><expr><literal type="string">"[%02d] (freeNext=%d, rel=%s, "</literal>
			 <literal type="string">"blockNum=%u, flags=0x%x, refcount=%u %d)"</literal></expr></argument>,
			 <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>freeNext</name></name></expr></argument>,
			 <argument><expr><call><name>relpathbackend</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name></name></expr></argument>, <argument><expr><name>InvalidBackendId</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>forkNum</name></name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>blockNum</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>,
			 <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>refcount</name></name></expr></argument>, <argument><expr><call><name>GetPrivateRefCount</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
<function><type><name>void</name></type>
<name>PrintPinnedBufs</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NBuffers</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>b</name> <init>= <expr><call><name>BufferDescriptorGetBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>GetPrivateRefCount</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* theoretically we should lock the bufhdr here */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				 <argument><expr><literal type="string">"[%02d] (freeNext=%d, rel=%s, "</literal>
				 <literal type="string">"blockNum=%u, flags=0x%x, refcount=%u %d)"</literal></expr></argument>,
				 <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>freeNext</name></name></expr></argument>,
				 <argument><expr><call><name>relpathperm</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>forkNum</name></name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>blockNum</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>,
				 <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>refcount</name></name></expr></argument>, <argument><expr><call><name>GetPrivateRefCount</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* ---------------------------------------------------------------------
 *		FlushRelationBuffers
 *
 *		This function writes all dirty pages of a relation out to disk
 *		(or more accurately, out to kernel disk buffers), ensuring that the
 *		kernel has an up-to-date view of the relation.
 *
 *		Generally, the caller should be holding AccessExclusiveLock on the
 *		target relation to ensure that no other backend is busy dirtying
 *		more blocks of the relation; the effects can't be expected to last
 *		after the lock is released.
 *
 *		XXX currently it sequentially searches the buffer pool, should be
 *		changed to more clever ways of searching.  This routine is not
 *		used in any performance-critical code paths, so it's not worth
 *		adding additional overhead to normal paths to make it go faster;
 *		but see also DropRelFileNodeBuffers.
 * --------------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>FlushRelationBuffers</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>bufHdr</name></decl>;</decl_stmt>

	<comment type="block">/* Open rel at the smgr level if not already done */</comment>
	<expr_stmt><expr><call><name>RelationOpenSmgr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RelationUsesLocalBuffers</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NLocBuffer</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint32</name></type>		<name>buf_state</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>bufHdr</name> <operator>=</operator> <call><name>GetLocalBufferDescriptor</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>RelFileNodeEquals</name><argument_list>(<argument><expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<operator>(</operator><operator>(</operator><name>buf_state</name> <operator>=</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufHdr</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;</operator>
				 <operator>(</operator><name>BM_VALID</name> <operator>|</operator> <name>BM_DIRTY</name><operator>)</operator><operator>)</operator> <operator>==</operator> <operator>(</operator><name>BM_VALID</name> <operator>|</operator> <name>BM_DIRTY</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>errcallback</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Page</name></type>		<name>localpage</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>localpage</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>LocalBufHdrGetBlock</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Setup error traceback support for ereport() */</comment>
				<expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>local_buffer_write_error_callback</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>bufHdr</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>errcallback</name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>PageSetChecksumInplace</name><argument_list>(<argument><expr><name>localpage</name></expr></argument>, <argument><expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>blockNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>smgrwrite</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>,
						  <argument><expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>forkNum</name></name></expr></argument>,
						  <argument><expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>blockNum</name></name></expr></argument>,
						  <argument><expr><name>localpage</name></expr></argument>,
						  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>buf_state</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>BM_DIRTY</name> <operator>|</operator> <name>BM_JUST_DIRTIED</name><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pg_atomic_unlocked_write_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufHdr</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Pop the error context stack */</comment>
				<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>errcallback</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Make sure we can handle the pin inside the loop */</comment>
	<expr_stmt><expr><call><name>ResourceOwnerEnlargeBuffers</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NBuffers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>buf_state</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>bufHdr</name> <operator>=</operator> <call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * As in DropRelFileNodeBuffers, an unlocked precheck should be safe
		 * and saves some cycles.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelFileNodeEquals</name><argument_list>(<argument><expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ReservePrivateRefCountEntry</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>LockBufHdr</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>RelFileNodeEquals</name><argument_list>(<argument><expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>buf_state</name> <operator>&amp;</operator> <operator>(</operator><name>BM_VALID</name> <operator>|</operator> <name>BM_DIRTY</name><operator>)</operator><operator>)</operator> <operator>==</operator> <operator>(</operator><name>BM_VALID</name> <operator>|</operator> <name>BM_DIRTY</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PinBuffer_Locked</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetContentLock</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FlushBuffer</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetContentLock</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>UnpinBuffer</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* ---------------------------------------------------------------------
 *		FlushRelationsAllBuffers
 *
 *		This function flushes out of the buffer pool all the pages of all
 *		forks of the specified smgr relations.  It's equivalent to calling
 *		FlushRelationBuffers once per fork per relation.  The relations are
 *		assumed not to use local buffers.
 * --------------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>FlushRelationsAllBuffers</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name> <modifier>*</modifier></type><name>smgrs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nrels</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SMgrSortArray</name> <modifier>*</modifier></type><name>srels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>use_bsearch</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>nrels</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* fill-in array for qsort */</comment>
	<expr_stmt><expr><name>srels</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SMgrSortArray</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nrels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nrels</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>RelFileNodeBackendIsTemp</name><argument_list>(<argument><expr><name><name>smgrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>smgr_rnode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>srels</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rnode</name> <operator>=</operator> <name><name>smgrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>smgr_rnode</name><operator>.</operator><name>node</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>srels</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>srel</name> <operator>=</operator> <name><name>smgrs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Save the bsearch overhead for low number of relations to sync. See
	 * DropRelFileNodesAllBuffers for details.
	 */</comment>
	<expr_stmt><expr><name>use_bsearch</name> <operator>=</operator> <name>nrels</name> <operator>&gt;</operator> <name>RELS_BSEARCH_THRESHOLD</name></expr>;</expr_stmt>

	<comment type="block">/* sort the list of SMgrRelations if necessary */</comment>
	<if_stmt><if>if <condition>(<expr><name>use_bsearch</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_qsort</name><argument_list>(<argument><expr><name>srels</name></expr></argument>, <argument><expr><name>nrels</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SMgrSortArray</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>rnode_comparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Make sure we can handle the pin inside the loop */</comment>
	<expr_stmt><expr><call><name>ResourceOwnerEnlargeBuffers</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NBuffers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SMgrSortArray</name> <modifier>*</modifier></type><name>srelent</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>bufHdr</name> <init>= <expr><call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>buf_state</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * As in DropRelFileNodeBuffers, an unlocked precheck should be safe
		 * and saves some cycles.
		 */</comment>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>use_bsearch</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nrels</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>RelFileNodeEquals</name><argument_list>(<argument><expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name></name></expr></argument>, <argument><expr><name><name>srels</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>rnode</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>srelent</name> <operator>=</operator> <operator>&amp;</operator><name><name>srels</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>

		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>srelent</name> <operator>=</operator> <call><name>bsearch</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name></name><operator>)</operator></expr></argument>,
							  <argument><expr><name>srels</name></expr></argument>, <argument><expr><name>nrels</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SMgrSortArray</name></expr></argument>)</argument_list></sizeof></expr></argument>,
							  <argument><expr><name>rnode_comparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* buffer doesn't belong to any of the given relfilenodes; skip it */</comment>
		<if_stmt><if>if <condition>(<expr><name>srelent</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ReservePrivateRefCountEntry</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>LockBufHdr</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>RelFileNodeEquals</name><argument_list>(<argument><expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name></name></expr></argument>, <argument><expr><name><name>srelent</name><operator>-&gt;</operator><name>rnode</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>buf_state</name> <operator>&amp;</operator> <operator>(</operator><name>BM_VALID</name> <operator>|</operator> <name>BM_DIRTY</name><operator>)</operator><operator>)</operator> <operator>==</operator> <operator>(</operator><name>BM_VALID</name> <operator>|</operator> <name>BM_DIRTY</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PinBuffer_Locked</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetContentLock</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FlushBuffer</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>, <argument><expr><name><name>srelent</name><operator>-&gt;</operator><name>srel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetContentLock</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>UnpinBuffer</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>srels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ---------------------------------------------------------------------
 *		FlushDatabaseBuffers
 *
 *		This function writes all dirty pages of a database out to disk
 *		(or more accurately, out to kernel disk buffers), ensuring that the
 *		kernel has an up-to-date view of the database.
 *
 *		Generally, the caller should be holding an appropriate lock to ensure
 *		no other backend is active in the target database; otherwise more
 *		pages could get dirtied.
 *
 *		Note we don't worry about flushing any pages of temporary relations.
 *		It's assumed these wouldn't be interesting.
 * --------------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>FlushDatabaseBuffers</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>dbid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>bufHdr</name></decl>;</decl_stmt>

	<comment type="block">/* Make sure we can handle the pin inside the loop */</comment>
	<expr_stmt><expr><call><name>ResourceOwnerEnlargeBuffers</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NBuffers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>buf_state</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>bufHdr</name> <operator>=</operator> <call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * As in DropRelFileNodeBuffers, an unlocked precheck should be safe
		 * and saves some cycles.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name><operator>.</operator><name>dbNode</name></name> <operator>!=</operator> <name>dbid</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ReservePrivateRefCountEntry</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>LockBufHdr</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name><operator>.</operator><name>dbNode</name></name> <operator>==</operator> <name>dbid</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>buf_state</name> <operator>&amp;</operator> <operator>(</operator><name>BM_VALID</name> <operator>|</operator> <name>BM_DIRTY</name><operator>)</operator><operator>)</operator> <operator>==</operator> <operator>(</operator><name>BM_VALID</name> <operator>|</operator> <name>BM_DIRTY</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PinBuffer_Locked</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetContentLock</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FlushBuffer</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetContentLock</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>UnpinBuffer</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Flush a previously, shared or exclusively, locked and pinned buffer to the
 * OS.
 */</comment>
<function><type><name>void</name></type>
<name>FlushOneBuffer</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>bufHdr</name></decl>;</decl_stmt>

	<comment type="block">/* currently not needed, but no fundamental reason not to support */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>BufferIsLocal</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsPinned</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>bufHdr</name> <operator>=</operator> <call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetContentLock</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FlushBuffer</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ReleaseBuffer -- release the pin on a buffer
 */</comment>
<function><type><name>void</name></type>
<name>ReleaseBuffer</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bad buffer ID: %d"</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsLocal</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ResourceOwnerForgetBuffer</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>LocalRefCount</name><index>[<expr><operator>-</operator><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>LocalRefCount</name><index>[<expr><operator>-</operator><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>--</operator></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>UnpinBuffer</name><argument_list>(<argument><expr><call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * UnlockReleaseBuffer -- release the content lock and pin on a buffer
 *
 * This is just a shorthand for a common combination.
 */</comment>
<function><type><name>void</name></type>
<name>UnlockReleaseBuffer</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * IncrBufferRefCount
 *		Increment the pin count on a buffer that we have *already* pinned
 *		at least once.
 *
 *		This function cannot be used on a buffer we do not have pinned,
 *		because it doesn't change the shared buffer state.
 */</comment>
<function><type><name>void</name></type>
<name>IncrBufferRefCount</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsPinned</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ResourceOwnerEnlargeBuffers</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsLocal</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>LocalRefCount</name><index>[<expr><operator>-</operator><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>PrivateRefCountEntry</name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>ref</name> <operator>=</operator> <call><name>GetPrivateRefCountEntry</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ref</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>refcount</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>ResourceOwnerRememberBuffer</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * MarkBufferDirtyHint
 *
 *	Mark a buffer dirty for non-critical changes.
 *
 * This is essentially the same as MarkBufferDirty, except:
 *
 * 1. The caller does not write WAL; so if checksums are enabled, we may need
 *	  to write an XLOG_FPI WAL record to protect against torn pages.
 * 2. The caller might have only share-lock instead of exclusive-lock on the
 *	  buffer's content lock.
 * 3. This function does not guarantee that the buffer is always marked dirty
 *	  (due to a race condition), so it cannot be used for important changes.
 */</comment>
<function><type><name>void</name></type>
<name>MarkBufferDirtyHint</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>buffer_std</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>bufHdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bad buffer ID: %d"</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsLocal</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MarkLocalBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>bufHdr</name> <operator>=</operator> <call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>GetPrivateRefCount</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* here, either share or exclusive lock is OK */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetContentLock</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * This routine might get called many times on the same page, if we are
	 * making the first scan after commit of an xact that added/deleted many
	 * tuples. So, be as quick as we can if the buffer is already dirty.  We
	 * do this by not acquiring spinlock if it looks like the status bits are
	 * already set.  Since we make this test unlocked, there's a chance we
	 * might fail to notice that the flags have just been cleared, and failed
	 * to reset them, due to memory-ordering issues.  But since this function
	 * is only intended to be used in cases where failing to write out the
	 * data would be harmless anyway, it doesn't really matter.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufHdr</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>(</operator><name>BM_DIRTY</name> <operator>|</operator> <name>BM_JUST_DIRTIED</name><operator>)</operator><operator>)</operator> <operator>!=</operator>
		<operator>(</operator><name>BM_DIRTY</name> <operator>|</operator> <name>BM_JUST_DIRTIED</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>dirtied</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>delayChkpt</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>buf_state</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * If we need to protect hint bit updates from torn writes, WAL-log a
		 * full page image of the page. This full page image is only necessary
		 * if the hint bit update is the first change to the page since the
		 * last checkpoint.
		 *
		 * We don't check full_page_writes here because that logic is included
		 * when we call XLogInsert() since the value changes dynamically.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>XLogHintBitIsNeeded</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>(</operator><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufHdr</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>BM_PERMANENT</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If we must not write WAL, due to a relfilenode-specific
			 * condition or being in recovery, don't dirty the page.  We can
			 * set the hint, just not dirty the page as a result so the hint
			 * is lost when we evict the page or shutdown.
			 *
			 * See src/backend/storage/page/README for longer discussion.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call> <operator>||</operator>
				<call><name>RelFileNodeSkippingWAL</name><argument_list>(<argument><expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * If the block is already dirty because we either made a change
			 * or set a hint already, then we don't need to write a full page
			 * image.  Note that aggressive cleaning of blocks dirtied by hint
			 * bit setting would increase the call rate. Bulk setting of hint
			 * bits would reduce the call rate...
			 *
			 * We must issue the WAL record before we mark the buffer dirty.
			 * Otherwise we might write the page before we write the WAL. That
			 * causes a race condition, since a checkpoint might occur between
			 * writing the WAL record and marking the buffer dirty. We solve
			 * that with a kluge, but one that is already in use during
			 * transaction commit to prevent race conditions. Basically, we
			 * simply prevent the checkpoint WAL record from being written
			 * until we have marked the buffer dirty. We don't start the
			 * checkpoint flush until we have marked dirty, so our checkpoint
			 * must flush the change to disk successfully or the checkpoint
			 * never gets written, so crash recovery will fix.
			 *
			 * It's possible we may enter here without an xid, so it is
			 * essential that CreateCheckpoint waits for virtual transactions
			 * rather than full transactionids.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>MyProc</name><operator>-&gt;</operator><name>delayChkpt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>delayChkpt</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>delayChkpt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>lsn</name> <operator>=</operator> <call><name>XLogSaveBufferForHint</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>buffer_std</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>LockBufHdr</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BUF_STATE_GET_REFCOUNT</name><argument_list>(<argument><expr><name>buf_state</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>buf_state</name> <operator>&amp;</operator> <name>BM_DIRTY</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>dirtied</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>		<comment type="block">/* Means "will be dirtied by this action" */</comment>

			<comment type="block">/*
			 * Set the page LSN if we wrote a backup block. We aren't supposed
			 * to set this when only holding a share lock but as long as we
			 * serialise it somehow we're OK. We choose to set LSN while
			 * holding the buffer header lock, which causes any reader of an
			 * LSN who holds only a share lock to also obtain a buffer header
			 * lock before using PageGetLSN(), which is enforced in
			 * BufferGetLSNAtomic().
			 *
			 * If checksums are enabled, you might think we should reset the
			 * checksum here. That will happen when the page is written
			 * sometime later in this checkpoint cycle.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>buf_state</name> <operator>|=</operator> <name>BM_DIRTY</name> <operator>|</operator> <name>BM_JUST_DIRTIED</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>delayChkpt</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>delayChkpt</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>dirtied</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>VacuumPageDirty</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pgBufferUsage</name><operator>.</operator><name>shared_blks_dirtied</name></name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>VacuumCostActive</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>VacuumCostBalance</name> <operator>+=</operator> <name>VacuumCostPageDirty</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Release buffer content locks for shared buffers.
 *
 * Used to clean up after errors.
 *
 * Currently, we can expect that lwlock.c's LWLockReleaseAll() took care
 * of releasing buffer content locks per se; the only thing we need to deal
 * with here is clearing any PIN_COUNT request that was in progress.
 */</comment>
<function><type><name>void</name></type>
<name>UnlockBuffers</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><name>PinCountWaitBuf</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>buf_state</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>LockBufHdr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Don't complain if flag bit not set; it could have been reset but we
		 * got a cancel/die interrupt before getting the signal.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>buf_state</name> <operator>&amp;</operator> <name>BM_PIN_COUNT_WAITER</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>buf</name><operator>-&gt;</operator><name>wait_backend_pid</name></name> <operator>==</operator> <name>MyProcPid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>buf_state</name> <operator>&amp;=</operator> <operator>~</operator><name>BM_PIN_COUNT_WAITER</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>PinCountWaitBuf</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Acquire or release the content_lock for the buffer.
 */</comment>
<function><type><name>void</name></type>
<name>LockBuffer</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsLocal</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* local buffers need no lock */</comment>

	<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>BUFFER_LOCK_UNLOCK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetContentLock</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>mode</name> <operator>==</operator> <name>BUFFER_LOCK_SHARE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetContentLock</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>mode</name> <operator>==</operator> <name>BUFFER_LOCK_EXCLUSIVE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetContentLock</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized buffer lock mode: %d"</literal></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Acquire the content_lock for the buffer, but only if we don't have to wait.
 *
 * This assumes the caller wants BUFFER_LOCK_EXCLUSIVE mode.
 */</comment>
<function><type><name>bool</name></type>
<name>ConditionalLockBuffer</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsLocal</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* act as though we got it */</comment>

	<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>LWLockConditionalAcquire</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetContentLock</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * LockBufferForCleanup - lock a buffer in preparation for deleting items
 *
 * Items may be deleted from a disk page only when the caller (a) holds an
 * exclusive lock on the buffer and (b) has observed that no other backend
 * holds a pin on the buffer.  If there is a pin, then the other backend
 * might have a pointer into the buffer (for example, a heapscan reference
 * to an item --- see README for more details).  It's OK if a pin is added
 * after the cleanup starts, however; the newly-arrived backend will be
 * unable to look at the page until we release the exclusive lock.
 *
 * To implement this protocol, a would-be deleter must pin the buffer and
 * then call LockBufferForCleanup().  LockBufferForCleanup() is similar to
 * LockBuffer(buffer, BUFFER_LOCK_EXCLUSIVE), except that it loops until
 * it has successfully observed pin count = 1.
 */</comment>
<function><type><name>void</name></type>
<name>LockBufferForCleanup</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>bufHdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>new_status</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>PinCountWaitBuf</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsLocal</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* There should be exactly one pin */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>LocalRefCount</name><index>[<expr><operator>-</operator><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"incorrect local pin count: %d"</literal></expr></argument>,
				 <argument><expr><name><name>LocalRefCount</name><index>[<expr><operator>-</operator><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* Nobody else to wait for */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* There should be exactly one local pin */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>GetPrivateRefCount</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"incorrect local pin count: %d"</literal></expr></argument>,
			 <argument><expr><call><name>GetPrivateRefCount</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>bufHdr</name> <operator>=</operator> <call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>buf_state</name></decl>;</decl_stmt>

		<comment type="block">/* Try to acquire lock */</comment>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>LockBufHdr</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BUF_STATE_GET_REFCOUNT</name><argument_list>(<argument><expr><name>buf_state</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>BUF_STATE_GET_REFCOUNT</name><argument_list>(<argument><expr><name>buf_state</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Successfully acquired exclusive lock with pincount 1 */</comment>
			<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Report change to non-waiting status */</comment>
			<if_stmt><if>if <condition>(<expr><name>new_status</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><name>new_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Failed, so mark myself as waiting for pincount 1 */</comment>
		<if_stmt><if>if <condition>(<expr><name>buf_state</name> <operator>&amp;</operator> <name>BM_PIN_COUNT_WAITER</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"multiple backends attempting to wait for pincount 1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>bufHdr</name><operator>-&gt;</operator><name>wait_backend_pid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>PinCountWaitBuf</name> <operator>=</operator> <name>bufHdr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>buf_state</name> <operator>|=</operator> <name>BM_PIN_COUNT_WAITER</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Wait to be signaled by UnpinBuffer() */</comment>
		<if_stmt><if>if <condition>(<expr><name>InHotStandby</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Report change to waiting status */</comment>
			<if_stmt><if>if <condition>(<expr><name>update_process_title</name> <operator>&amp;&amp;</operator> <name>new_status</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>old_status</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>old_status</name> <operator>=</operator> <call><name>get_ps_display</name><argument_list>(<argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>new_status</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">8</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new_status</name></expr></argument>, <argument><expr><name>old_status</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>new_status</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><literal type="string">" waiting"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><name>new_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>new_status</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt> <comment type="block">/* truncate off " waiting" */</comment>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Publish the bufid that Startup process waits on */</comment>
			<expr_stmt><expr><call><name>SetStartupBufferPinWaitBufId</name><argument_list>(<argument><expr><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Set alarm and then wait to be signaled by UnpinBuffer() */</comment>
			<expr_stmt><expr><call><name>ResolveRecoveryConflictWithBufferPin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Reset the published bufid */</comment>
			<expr_stmt><expr><call><name>SetStartupBufferPinWaitBufId</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ProcWaitForSignal</name><argument_list>(<argument><expr><name>PG_WAIT_BUFFER_PIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * Remove flag marking us as waiter. Normally this will not be set
		 * anymore, but ProcWaitForSignal() can return for other signals as
		 * well.  We take care to only reset the flag if we're the waiter, as
		 * theoretically another backend could have started waiting. That's
		 * impossible with the current usages due to table level locking, but
		 * better be safe.
		 */</comment>
		<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>LockBufHdr</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>buf_state</name> <operator>&amp;</operator> <name>BM_PIN_COUNT_WAITER</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>bufHdr</name><operator>-&gt;</operator><name>wait_backend_pid</name></name> <operator>==</operator> <name>MyProcPid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>buf_state</name> <operator>&amp;=</operator> <operator>~</operator><name>BM_PIN_COUNT_WAITER</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>PinCountWaitBuf</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<comment type="block">/* Loop back and try again */</comment>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Check called from RecoveryConflictInterrupt handler when Startup
 * process requests cancellation of all pin holders that are blocking it.
 */</comment>
<function><type><name>bool</name></type>
<name>HoldingBufferPinThatDelaysRecovery</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>bufid</name> <init>= <expr><call><name>GetStartupBufferPinWaitBufId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If we get woken slowly then it's possible that the Startup process was
	 * already woken by other backends before we got here. Also possible that
	 * we get here by multiple interrupts or interrupts at inappropriate
	 * times, so make sure we do nothing if the bufid is not set.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>bufid</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>GetPrivateRefCount</name><argument_list>(<argument><expr><name>bufid</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ConditionalLockBufferForCleanup - as above, but don't wait to get the lock
 *
 * We won't loop, but just check once to see if the pin count is OK.  If
 * not, return false with no lock held.
 */</comment>
<function><type><name>bool</name></type>
<name>ConditionalLockBufferForCleanup</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>bufHdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>buf_state</name></decl>,
				<decl><type ref="prev"/><name>refcount</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsLocal</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>refcount</name> <operator>=</operator> <name><name>LocalRefCount</name><index>[<expr><operator>-</operator><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		<comment type="block">/* There should be exactly one pin */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>refcount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>refcount</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<comment type="block">/* Nobody else to wait for */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* There should be exactly one local pin */</comment>
	<expr_stmt><expr><name>refcount</name> <operator>=</operator> <call><name>GetPrivateRefCount</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>refcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>refcount</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Try to acquire lock */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ConditionalLockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>bufHdr</name> <operator>=</operator> <call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>LockBufHdr</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>refcount</name> <operator>=</operator> <call><name>BUF_STATE_GET_REFCOUNT</name><argument_list>(<argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>refcount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>refcount</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Successfully acquired exclusive lock with pincount 1 */</comment>
		<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Failed, so release the lock */</comment>
	<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * IsBufferCleanupOK - as above, but we already have the lock
 *
 * Check whether it's OK to perform cleanup on a buffer we've already
 * locked.  If we observe that the pin count is 1, our exclusive lock
 * happens to be a cleanup lock, and we can proceed with anything that
 * would have been allowable had we sought a cleanup lock originally.
 */</comment>
<function><type><name>bool</name></type>
<name>IsBufferCleanupOK</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>bufHdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>buf_state</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsLocal</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* There should be exactly one pin */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>LocalRefCount</name><index>[<expr><operator>-</operator><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<comment type="block">/* Nobody else to wait for */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* There should be exactly one local pin */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>GetPrivateRefCount</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>bufHdr</name> <operator>=</operator> <call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* caller must hold exclusive lock on buffer */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetContentLock</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>LockBufHdr</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BUF_STATE_GET_REFCOUNT</name><argument_list>(<argument><expr><name>buf_state</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BUF_STATE_GET_REFCOUNT</name><argument_list>(<argument><expr><name>buf_state</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* pincount is OK. */</comment>
		<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *	Functions for buffer I/O handling
 *
 *	Note: We assume that nested buffer I/O never occurs.
 *	i.e at most one io_in_progress lock is held per proc.
 *
 *	Also note that these are used only for shared buffers, not local ones.
 */</comment>

<comment type="block">/*
 * WaitIO -- Block until the IO_IN_PROGRESS flag on 'buf' is cleared.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WaitIO</name><parameter_list>(<parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Changed to wait until there's no IO - Inoue 01/13/2000
	 *
	 * Note this is *necessary* because an error abort in the process doing
	 * I/O could release the io_in_progress_lock prematurely. See
	 * AbortBufferIO.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>buf_state</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * It may not be necessary to acquire the spinlock to check the flag
		 * here, but since this test is essential for correctness, we'd better
		 * play it safe.
		 */</comment>
		<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>LockBufHdr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>buf_state</name> <operator>&amp;</operator> <name>BM_IO_IN_PROGRESS</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetIOLock</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetIOLock</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * StartBufferIO: begin I/O on this buffer
 *	(Assumptions)
 *	My process is executing no IO
 *	The buffer is Pinned
 *
 * In some scenarios there are race conditions in which multiple backends
 * could attempt the same I/O operation concurrently.  If someone else
 * has already started I/O on this buffer then we will block on the
 * io_in_progress lock until he's done.
 *
 * Input operations are only attempted on buffers that are not BM_VALID,
 * and output operations only on buffers that are BM_VALID and BM_DIRTY,
 * so we can always tell if the work is already done.
 *
 * Returns true if we successfully marked the buffer as I/O busy,
 * false if someone else already did the work.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>StartBufferIO</name><parameter_list>(<parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>forInput</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>buf_state</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>InProgressBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * Grab the io_in_progress lock so that other processes can wait for
		 * me to finish the I/O.
		 */</comment>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetIOLock</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>LockBufHdr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>buf_state</name> <operator>&amp;</operator> <name>BM_IO_IN_PROGRESS</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * The only way BM_IO_IN_PROGRESS could be set when the io_in_progress
		 * lock isn't held is if the process doing the I/O is recovering from
		 * an error (see AbortBufferIO).  If that's the case, we must wait for
		 * him to get unwedged.
		 */</comment>
		<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetIOLock</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WaitIO</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Once we get here, there is definitely no I/O active on this buffer */</comment>

	<if_stmt><if>if <condition>(<expr><ternary><condition><expr><name>forInput</name></expr> ?</condition><then> <expr><operator>(</operator><name>buf_state</name> <operator>&amp;</operator> <name>BM_VALID</name><operator>)</operator></expr> </then><else>: <expr><operator>!</operator><operator>(</operator><name>buf_state</name> <operator>&amp;</operator> <name>BM_DIRTY</name><operator>)</operator></expr></else></ternary></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* someone else already did the I/O */</comment>
		<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetIOLock</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>buf_state</name> <operator>|=</operator> <name>BM_IO_IN_PROGRESS</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>InProgressBuf</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>IsForInput</name> <operator>=</operator> <name>forInput</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * TerminateBufferIO: release a buffer we were doing I/O on
 *	(Assumptions)
 *	My process is executing IO for the buffer
 *	BM_IO_IN_PROGRESS bit is set for the buffer
 *	We hold the buffer's io_in_progress lock
 *	The buffer is Pinned
 *
 * If clear_dirty is true and BM_JUST_DIRTIED is not set, we clear the
 * buffer's BM_DIRTY flag.  This is appropriate when terminating a
 * successful write.  The check on BM_JUST_DIRTIED is necessary to avoid
 * marking the buffer clean if it was re-dirtied while we were writing.
 *
 * set_flag_bits gets ORed into the buffer's flags.  It must include
 * BM_IO_ERROR in a failure case.  For successful completion it could
 * be 0, or BM_VALID if we just finished reading in the page.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>TerminateBufferIO</name><parameter_list>(<parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>clear_dirty</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>set_flag_bits</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>buf_state</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>buf</name> <operator>==</operator> <name>InProgressBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>LockBufHdr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>buf_state</name> <operator>&amp;</operator> <name>BM_IO_IN_PROGRESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>buf_state</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>BM_IO_IN_PROGRESS</name> <operator>|</operator> <name>BM_IO_ERROR</name><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>clear_dirty</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>buf_state</name> <operator>&amp;</operator> <name>BM_JUST_DIRTIED</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>buf_state</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>BM_DIRTY</name> <operator>|</operator> <name>BM_CHECKPOINT_NEEDED</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>buf_state</name> <operator>|=</operator> <name>set_flag_bits</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>InProgressBuf</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetIOLock</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AbortBufferIO: Clean up any active buffer I/O after an error.
 *
 *	All LWLocks we might have held have been released,
 *	but we haven't yet released buffer pins, so the buffer is still pinned.
 *
 *	If I/O was in progress, we always set BM_IO_ERROR, even though it's
 *	possible the error condition wasn't related to the I/O.
 */</comment>
<function><type><name>void</name></type>
<name>AbortBufferIO</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><name>InProgressBuf</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>buf_state</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Since LWLockReleaseAll has already been called, we're not holding
		 * the buffer's io_in_progress_lock. We have to re-acquire it so that
		 * we can use TerminateBufferIO. Anyone who's executing WaitIO on the
		 * buffer will be in a busy spin until we succeed in doing this.
		 */</comment>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetIOLock</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>LockBufHdr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>buf_state</name> <operator>&amp;</operator> <name>BM_IO_IN_PROGRESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>IsForInput</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>buf_state</name> <operator>&amp;</operator> <name>BM_DIRTY</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* We'd better not think buffer is valid yet */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>buf_state</name> <operator>&amp;</operator> <name>BM_VALID</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>buf_state</name> <operator>&amp;</operator> <name>BM_DIRTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Issue notice if this is not the first failure... */</comment>
			<if_stmt><if>if <condition>(<expr><name>buf_state</name> <operator>&amp;</operator> <name>BM_IO_ERROR</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Buffer is pinned, so we can read tag without spinlock */</comment>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>relpathperm</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>forkNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_IO_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write block %u of %s"</literal></expr></argument>,
								<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>blockNum</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Multiple failures --- write error might be permanent."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>TerminateBufferIO</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>BM_IO_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Error context callback for errors occurring during shared buffer writes.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>shared_buffer_write_error_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>bufHdr</name> <init>= <expr><operator>(</operator><name>BufferDesc</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Buffer is pinned, so we can read the tag without locking the spinlock */</comment>
	<if_stmt><if>if <condition>(<expr><name>bufHdr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>relpathperm</name><argument_list>(<argument><expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name></name></expr></argument>, <argument><expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>forkNum</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"writing block %u of relation %s"</literal></expr></argument>,
				   <argument><expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>blockNum</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Error context callback for errors occurring during local buffer writes.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>local_buffer_write_error_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>bufHdr</name> <init>= <expr><operator>(</operator><name>BufferDesc</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>bufHdr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>relpathbackend</name><argument_list>(<argument><expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name></name></expr></argument>, <argument><expr><name>MyBackendId</name></expr></argument>,
										  <argument><expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>forkNum</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"writing block %u of relation %s"</literal></expr></argument>,
				   <argument><expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>blockNum</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RelFileNode qsort/bsearch comparator; see RelFileNodeEquals.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>rnode_comparator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelFileNode</name></type> <name>n1</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>RelFileNode</name> <operator>*</operator><operator>)</operator> <name>p1</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelFileNode</name></type> <name>n2</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>RelFileNode</name> <operator>*</operator><operator>)</operator> <name>p2</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>n1</name><operator>.</operator><name>relNode</name></name> <operator>&lt;</operator> <name><name>n2</name><operator>.</operator><name>relNode</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>n1</name><operator>.</operator><name>relNode</name></name> <operator>&gt;</operator> <name><name>n2</name><operator>.</operator><name>relNode</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>n1</name><operator>.</operator><name>dbNode</name></name> <operator>&lt;</operator> <name><name>n2</name><operator>.</operator><name>dbNode</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>n1</name><operator>.</operator><name>dbNode</name></name> <operator>&gt;</operator> <name><name>n2</name><operator>.</operator><name>dbNode</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>n1</name><operator>.</operator><name>spcNode</name></name> <operator>&lt;</operator> <name><name>n2</name><operator>.</operator><name>spcNode</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>n1</name><operator>.</operator><name>spcNode</name></name> <operator>&gt;</operator> <name><name>n2</name><operator>.</operator><name>spcNode</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Lock buffer header - set BM_LOCKED in buffer state.
 */</comment>
<function><type><name>uint32</name></type>
<name>LockBufHdr</name><parameter_list>(<parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SpinDelayStatus</name></type> <name>delayStatus</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>old_buf_state</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_local_spin_delay</name><argument_list>(<argument><expr><operator>&amp;</operator><name>delayStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* set BM_LOCKED flag */</comment>
		<expr_stmt><expr><name>old_buf_state</name> <operator>=</operator> <call><name>pg_atomic_fetch_or_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>BM_LOCKED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* if it wasn't set before we're OK */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>old_buf_state</name> <operator>&amp;</operator> <name>BM_LOCKED</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>perform_spin_delay</name><argument_list>(<argument><expr><operator>&amp;</operator><name>delayStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>finish_spin_delay</name><argument_list>(<argument><expr><operator>&amp;</operator><name>delayStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>old_buf_state</name> <operator>|</operator> <name>BM_LOCKED</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Wait until the BM_LOCKED flag isn't set anymore and return the buffer's
 * state at that point.
 *
 * Obviously the buffer could be locked by the time the value is returned, so
 * this is primarily useful in CAS style loops.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>WaitBufHdrUnlocked</name><parameter_list>(<parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SpinDelayStatus</name></type> <name>delayStatus</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>buf_state</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_local_spin_delay</name><argument_list>(<argument><expr><operator>&amp;</operator><name>delayStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>buf_state</name> <operator>&amp;</operator> <name>BM_LOCKED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>perform_spin_delay</name><argument_list>(<argument><expr><operator>&amp;</operator><name>delayStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>finish_spin_delay</name><argument_list>(<argument><expr><operator>&amp;</operator><name>delayStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>buf_state</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * BufferTag comparator.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>buffertag_comparator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>BufferTag</name> <modifier>*</modifier></type><name>ba</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BufferTag</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>BufferTag</name> <modifier>*</modifier></type><name>bb</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BufferTag</name> <operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rnode_comparator</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ba</name><operator>-&gt;</operator><name>rnode</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bb</name><operator>-&gt;</operator><name>rnode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ba</name><operator>-&gt;</operator><name>forkNum</name></name> <operator>&lt;</operator> <name><name>bb</name><operator>-&gt;</operator><name>forkNum</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>ba</name><operator>-&gt;</operator><name>forkNum</name></name> <operator>&gt;</operator> <name><name>bb</name><operator>-&gt;</operator><name>forkNum</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ba</name><operator>-&gt;</operator><name>blockNum</name></name> <operator>&lt;</operator> <name><name>bb</name><operator>-&gt;</operator><name>blockNum</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>ba</name><operator>-&gt;</operator><name>blockNum</name></name> <operator>&gt;</operator> <name><name>bb</name><operator>-&gt;</operator><name>blockNum</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Comparator determining the writeout order in a checkpoint.
 *
 * It is important that tablespaces are compared first, the logic balancing
 * writes between tablespaces relies on it.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ckpt_buforder_comparator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pa</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>CkptSortItem</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>CkptSortItem</name> <operator>*</operator><operator>)</operator> <name>pa</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>CkptSortItem</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>CkptSortItem</name> <operator>*</operator><operator>)</operator> <name>pb</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* compare tablespace */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>tsId</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>tsId</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>tsId</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>tsId</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* compare relation */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>relNode</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>relNode</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>relNode</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>relNode</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<comment type="block">/* compare fork */</comment>
	<if type="elseif">else if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>forkNum</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>forkNum</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>forkNum</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>forkNum</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<comment type="block">/* compare block number */</comment>
	<if type="elseif">else if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>blockNum</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>blockNum</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>blockNum</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>blockNum</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* equal page IDs are unlikely, but not impossible */</comment>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Comparator for a Min-Heap over the per-tablespace checkpoint completion
 * progress.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ts_ckpt_progress_comparator</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CkptTsStatus</name> <modifier>*</modifier></type><name>sa</name> <init>= <expr><operator>(</operator><name>CkptTsStatus</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CkptTsStatus</name> <modifier>*</modifier></type><name>sb</name> <init>= <expr><operator>(</operator><name>CkptTsStatus</name> <operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we want a min-heap, so return 1 for the a &lt; b */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>sa</name><operator>-&gt;</operator><name>progress</name></name> <operator>&lt;</operator> <name><name>sb</name><operator>-&gt;</operator><name>progress</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>sa</name><operator>-&gt;</operator><name>progress</name></name> <operator>==</operator> <name><name>sb</name><operator>-&gt;</operator><name>progress</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize a writeback context, discarding potential previous state.
 *
 * *max_pending is a pointer instead of an immediate value, so the coalesce
 * limits can easily changed by the GUC mechanism, and so calling code does
 * not have to check the current configuration. A value of 0 means that no
 * writeback control will be performed.
 */</comment>
<function><type><name>void</name></type>
<name>WritebackContextInit</name><parameter_list>(<parameter><decl><type><name>WritebackContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>max_pending</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>max_pending</name> <operator>&lt;=</operator> <name>WRITEBACK_MAX_PENDING_FLUSHES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>max_pending</name></name> <operator>=</operator> <name>max_pending</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>nr_pending</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add buffer to list of pending writeback requests.
 */</comment>
<function><type><name>void</name></type>
<name>ScheduleBufferTagForWriteback</name><parameter_list>(<parameter><decl><type><name>WritebackContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PendingWriteback</name> <modifier>*</modifier></type><name>pending</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Add buffer to the pending writeback array, unless writeback control is
	 * disabled.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>context</name><operator>-&gt;</operator><name>max_pending</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name><name>context</name><operator>-&gt;</operator><name>max_pending</name></name> <operator>&lt;=</operator> <name>WRITEBACK_MAX_PENDING_FLUSHES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>pending</name> <operator>=</operator> <operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>pending_writebacks</name><index>[<expr><name><name>context</name><operator>-&gt;</operator><name>nr_pending</name></name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>pending</name><operator>-&gt;</operator><name>tag</name></name> <operator>=</operator> <operator>*</operator><name>tag</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Perform pending flushes if the writeback limit is exceeded. This
	 * includes the case where previously an item has been added, but control
	 * is now disabled.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>nr_pending</name></name> <operator>&gt;=</operator> <operator>*</operator><name><name>context</name><operator>-&gt;</operator><name>max_pending</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>IssuePendingWritebacks</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Issue all pending writeback requests, previously scheduled with
 * ScheduleBufferTagForWriteback, to the OS.
 *
 * Because this is only used to improve the OSs IO scheduling we try to never
 * error out - it's just a hint.
 */</comment>
<function><type><name>void</name></type>
<name>IssuePendingWritebacks</name><parameter_list>(<parameter><decl><type><name>WritebackContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>nr_pending</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Executing the writes in-order can make them a lot faster, and allows to
	 * merge writeback requests to consecutive blocks into larger writebacks.
	 */</comment>
	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>pending_writebacks</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>nr_pending</name></name></expr></argument>,
		  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PendingWriteback</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>buffertag_comparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Coalesce neighbouring writes, but nothing else. For that we iterate
	 * through the, now sorted, array of pending flushes, and look forward to
	 * find all neighbouring (or identical) writes.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>context</name><operator>-&gt;</operator><name>nr_pending</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PendingWriteback</name> <modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PendingWriteback</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ahead</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BufferTag</name></type>	<name>tag</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type>		<name>nblocks</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>cur</name> <operator>=</operator> <operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>pending_writebacks</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>tag</name> <operator>=</operator> <name><name>cur</name><operator>-&gt;</operator><name>tag</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Peek ahead, into following writeback requests, to see if they can
		 * be combined with the current one.
		 */</comment>
		<for>for <control>(<init><expr><name>ahead</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>+</operator> <name>ahead</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>context</name><operator>-&gt;</operator><name>nr_pending</name></name></expr>;</condition> <incr><expr><name>ahead</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>next</name> <operator>=</operator> <operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>pending_writebacks</name><index>[<expr><name>i</name> <operator>+</operator> <name>ahead</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

			<comment type="block">/* different file, stop */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelFileNodeEquals</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name></name></expr></argument>, <argument><expr><name><name>next</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
				<name><name>cur</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>forkNum</name></name> <operator>!=</operator> <name><name>next</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>forkNum</name></name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<comment type="block">/* ok, block queued twice, skip */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>cur</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>blockNum</name></name> <operator>==</operator> <name><name>next</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>blockNum</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* only merge consecutive writes */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>cur</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>blockNum</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>!=</operator> <name><name>next</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>blockNum</name></name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>nblocks</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>cur</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name>i</name> <operator>+=</operator> <name>ahead</name></expr>;</expr_stmt>

		<comment type="block">/* and finally tell the kernel to write the data to storage */</comment>
		<expr_stmt><expr><name>reln</name> <operator>=</operator> <call><name>smgropen</name><argument_list>(<argument><expr><name><name>tag</name><operator>.</operator><name>rnode</name></name></expr></argument>, <argument><expr><name>InvalidBackendId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>smgrwriteback</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name><name>tag</name><operator>.</operator><name>forkNum</name></name></expr></argument>, <argument><expr><name><name>tag</name><operator>.</operator><name>blockNum</name></name></expr></argument>, <argument><expr><name>nblocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>nr_pending</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Implement slower/larger portions of TestForOldSnapshot
 *
 * Smaller/faster portions are put inline, but the entire set of logic is too
 * big for that.
 */</comment>
<function><type><name>void</name></type>
<name>TestForOldSnapshot_impl</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>RelationAllowsEarlyPruning</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call>
		<operator>&amp;&amp;</operator> <operator>(</operator><name>snapshot</name><operator>)</operator><operator>-&gt;</operator><name>whenTaken</name> <operator>&lt;</operator> <call><name>GetOldSnapshotThresholdTimestamp</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SNAPSHOT_TOO_OLD</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"snapshot too old"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
</unit>
