<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/storage/buffer/localbuf.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * localbuf.c
 *	  local buffer manager. Fast buffer manager for temporary tables,
 *	  which never need to be WAL-logged or checkpointed, etc.
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994-5, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/storage/buffer/localbuf.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/parallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/instrument.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/buf_internals.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resowner_private.h"</cpp:file></cpp:include>


<comment type="block">/*#define LBDEBUG*/</comment>

<comment type="block">/* entry for buffer lookup hashtable */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>BufferTag</name></type>	<name>key</name></decl>;</decl_stmt>			<comment type="block">/* Tag of a disk page */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>id</name></decl>;</decl_stmt>				<comment type="block">/* Associated local buffer's index */</comment>
}</block></struct></type> <name>LocalBufferLookupEnt</name>;</typedef>

<comment type="block">/* Note: this macro only works on local buffers, not shared ones! */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LocalBufHdrGetBlock</name><parameter_list>(<parameter><type><name>bufHdr</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>LocalBufferBlockPointers[-((bufHdr)-&gt;buf_id + 2)]</cpp:value></cpp:define>

<decl_stmt><decl><type><name>int</name></type>			<name>NLocBuffer</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* until buffers are initialized */</comment>

<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>LocalBufferDescriptors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Block</name>	   <modifier>*</modifier></type><name>LocalBufferBlockPointers</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32</name>	   <modifier>*</modifier></type><name>LocalRefCount</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>nextFreeLocalBuf</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>LocalBufHash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InitLocalBuffers</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Block</name></type> <name>GetLocalBufferStorage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * PrefetchLocalBuffer -
 *	  initiate asynchronous read of a block of a relation
 *
 * Do PrefetchBuffer's work for temporary relations.
 * No-op if prefetching isn't compiled in.
 */</comment>
<function><type><name>PrefetchBufferResult</name></type>
<name>PrefetchLocalBuffer</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>smgr</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forkNum</name></decl></parameter>,
					<parameter><decl><type><name>BlockNumber</name></type> <name>blockNum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PrefetchBufferResult</name></type> <name>result</name> <init>= <expr><block>{<expr><name>InvalidBuffer</name></expr>, <expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type>	<name>newTag</name></decl>;</decl_stmt>			<comment type="block">/* identity of requested block */</comment>
	<decl_stmt><decl><type><name>LocalBufferLookupEnt</name> <modifier>*</modifier></type><name>hresult</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>INIT_BUFFERTAG</name><argument_list>(<argument><expr><name>newTag</name></expr></argument>, <argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name></name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>blockNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize local buffers if first request in this session */</comment>
	<if_stmt><if>if <condition>(<expr><name>LocalBufHash</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InitLocalBuffers</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* See if the desired buffer already exists */</comment>
	<expr_stmt><expr><name>hresult</name> <operator>=</operator> <operator>(</operator><name>LocalBufferLookupEnt</name> <operator>*</operator><operator>)</operator>
		<call><name>hash_search</name><argument_list>(<argument><expr><name>LocalBufHash</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>newTag</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>hresult</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Yes, so nothing to do */</comment>
		<expr_stmt><expr><name><name>result</name><operator>.</operator><name>recent_buffer</name></name> <operator>=</operator> <operator>-</operator><name><name>hresult</name><operator>-&gt;</operator><name>id</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_PREFETCH</name></cpp:ifdef>
		<comment type="block">/* Not in buffers, so initiate prefetch */</comment>
		<expr_stmt><expr><call><name>smgrprefetch</name><argument_list>(<argument><expr><name>smgr</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>blockNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>.</operator><name>initiated_io</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_PREFETCH */</comment>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * LocalBufferAlloc -
 *	  Find or create a local buffer for the given page of the given relation.
 *
 * API is similar to bufmgr.c's BufferAlloc, except that we do not need
 * to do any locking since this is all local.   Also, IO_IN_PROGRESS
 * does not get set.  Lastly, we support only default access strategy
 * (hence, usage_count is always advanced).
 */</comment>
<function><type><name>BufferDesc</name> <modifier>*</modifier></type>
<name>LocalBufferAlloc</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>smgr</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forkNum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blockNum</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>foundPtr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferTag</name></type>	<name>newTag</name></decl>;</decl_stmt>			<comment type="block">/* identity of requested block */</comment>
	<decl_stmt><decl><type><name>LocalBufferLookupEnt</name> <modifier>*</modifier></type><name>hresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>bufHdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>b</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>trycounter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>buf_state</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>INIT_BUFFERTAG</name><argument_list>(<argument><expr><name>newTag</name></expr></argument>, <argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name></name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>blockNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize local buffers if first request in this session */</comment>
	<if_stmt><if>if <condition>(<expr><name>LocalBufHash</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InitLocalBuffers</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* See if the desired buffer already exists */</comment>
	<expr_stmt><expr><name>hresult</name> <operator>=</operator> <operator>(</operator><name>LocalBufferLookupEnt</name> <operator>*</operator><operator>)</operator>
		<call><name>hash_search</name><argument_list>(<argument><expr><name>LocalBufHash</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>newTag</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>hresult</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>b</name> <operator>=</operator> <name><name>hresult</name><operator>-&gt;</operator><name>id</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bufHdr</name> <operator>=</operator> <call><name>GetLocalBufferDescriptor</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>, <argument><expr><name>newTag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LBDEBUG</name></cpp:ifdef>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"LB ALLOC (%u,%d,%d) %d\n"</literal></expr></argument>,
				<argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>relNode</name></name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>blockNum</name></expr></argument>, <argument><expr><operator>-</operator><name>b</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufHdr</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* this part is equivalent to PinBuffer for a shared buffer */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>LocalRefCount</name><index>[<expr><name>b</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>BUF_STATE_GET_USAGECOUNT</name><argument_list>(<argument><expr><name>buf_state</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>BM_MAX_USAGE_COUNT</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>buf_state</name> <operator>+=</operator> <name>BUF_USAGECOUNT_ONE</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pg_atomic_unlocked_write_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufHdr</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>LocalRefCount</name><index>[<expr><name>b</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ResourceOwnerRememberBuffer</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>,
									<argument><expr><call><name>BufferDescriptorGetBuffer</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>buf_state</name> <operator>&amp;</operator> <name>BM_VALID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>foundPtr</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Previous read attempt must have failed; try again */</comment>
			<expr_stmt><expr><operator>*</operator><name>foundPtr</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<return>return <expr><name>bufHdr</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LBDEBUG</name></cpp:ifdef>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"LB ALLOC (%u,%d,%d) %d\n"</literal></expr></argument>,
			<argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>relNode</name></name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>blockNum</name></expr></argument>,
			<argument><expr><operator>-</operator><name>nextFreeLocalBuf</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Need to get a new buffer.  We use a clock sweep algorithm (essentially
	 * the same as what freelist.c does now...)
	 */</comment>
	<expr_stmt><expr><name>trycounter</name> <operator>=</operator> <name>NLocBuffer</name></expr>;</expr_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>b</name> <operator>=</operator> <name>nextFreeLocalBuf</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>++</operator><name>nextFreeLocalBuf</name> <operator>&gt;=</operator> <name>NLocBuffer</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nextFreeLocalBuf</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>bufHdr</name> <operator>=</operator> <call><name>GetLocalBufferDescriptor</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>LocalRefCount</name><index>[<expr><name>b</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufHdr</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>BUF_STATE_GET_USAGECOUNT</name><argument_list>(<argument><expr><name>buf_state</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>buf_state</name> <operator>-=</operator> <name>BUF_USAGECOUNT_ONE</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pg_atomic_unlocked_write_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufHdr</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>trycounter</name> <operator>=</operator> <name>NLocBuffer</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Found a usable buffer */</comment>
				<expr_stmt><expr><name><name>LocalRefCount</name><index>[<expr><name>b</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ResourceOwnerRememberBuffer</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>,
											<argument><expr><call><name>BufferDescriptorGetBuffer</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>--</operator><name>trycounter</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_RESOURCES</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no empty local buffer available"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * this buffer is not referenced but it might still be dirty. if that's
	 * the case, write it out before reusing it!
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>buf_state</name> <operator>&amp;</operator> <name>BM_DIRTY</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SMgrRelation</name></type> <name>oreln</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Page</name></type>		<name>localpage</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>LocalBufHdrGetBlock</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Find smgr relation for buffer */</comment>
		<expr_stmt><expr><name>oreln</name> <operator>=</operator> <call><name>smgropen</name><argument_list>(<argument><expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name></name></expr></argument>, <argument><expr><name>MyBackendId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageSetChecksumInplace</name><argument_list>(<argument><expr><name>localpage</name></expr></argument>, <argument><expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>blockNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* And write... */</comment>
		<expr_stmt><expr><call><name>smgrwrite</name><argument_list>(<argument><expr><name>oreln</name></expr></argument>,
				  <argument><expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>forkNum</name></name></expr></argument>,
				  <argument><expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>blockNum</name></name></expr></argument>,
				  <argument><expr><name>localpage</name></expr></argument>,
				  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Mark not-dirty now in case we error out below */</comment>
		<expr_stmt><expr><name>buf_state</name> <operator>&amp;=</operator> <operator>~</operator><name>BM_DIRTY</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_unlocked_write_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufHdr</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>pgBufferUsage</name><operator>.</operator><name>local_blks_written</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * lazy memory allocation: allocate space on first use of a buffer.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>LocalBufHdrGetBlock</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Set pointer for use by BufferGetBlock() macro */</comment>
		<expr_stmt><expr><call><name>LocalBufHdrGetBlock</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>GetLocalBufferStorage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Update the hash table: remove old entry, if any, and make new one.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>buf_state</name> <operator>&amp;</operator> <name>BM_TAG_VALID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>hresult</name> <operator>=</operator> <operator>(</operator><name>LocalBufferLookupEnt</name> <operator>*</operator><operator>)</operator>
			<call><name>hash_search</name><argument_list>(<argument><expr><name>LocalBufHash</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>,
						<argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hresult</name></expr>)</condition><block type="pseudo"><block_content>			<comment type="block">/* shouldn't happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"local buffer hash table corrupted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* mark buffer invalid just in case hash insert fails */</comment>
		<expr_stmt><expr><call><name>CLEAR_BUFFERTAG</name><argument_list>(<argument><expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>buf_state</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>BM_VALID</name> <operator>|</operator> <name>BM_TAG_VALID</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_unlocked_write_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufHdr</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>hresult</name> <operator>=</operator> <operator>(</operator><name>LocalBufferLookupEnt</name> <operator>*</operator><operator>)</operator>
		<call><name>hash_search</name><argument_list>(<argument><expr><name>LocalBufHash</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>newTag</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>					<comment type="block">/* shouldn't happen */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"local buffer hash table corrupted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>hresult</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * it's all ours now.
	 */</comment>
	<expr_stmt><expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name></name> <operator>=</operator> <name>newTag</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>buf_state</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>BM_VALID</name> <operator>|</operator> <name>BM_DIRTY</name> <operator>|</operator> <name>BM_JUST_DIRTIED</name> <operator>|</operator> <name>BM_IO_ERROR</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>buf_state</name> <operator>|=</operator> <name>BM_TAG_VALID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>buf_state</name> <operator>&amp;=</operator> <operator>~</operator><name>BUF_USAGECOUNT_MASK</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>buf_state</name> <operator>+=</operator> <name>BUF_USAGECOUNT_ONE</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_unlocked_write_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufHdr</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>foundPtr</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<return>return <expr><name>bufHdr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MarkLocalBufferDirty -
 *	  mark a local buffer dirty
 */</comment>
<function><type><name>void</name></type>
<name>MarkLocalBufferDirty</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>bufid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>bufHdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>buf_state</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsLocal</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LBDEBUG</name></cpp:ifdef>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"LB DIRTY %d\n"</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>bufid</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>buffer</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>LocalRefCount</name><index>[<expr><name>bufid</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>bufHdr</name> <operator>=</operator> <call><name>GetLocalBufferDescriptor</name><argument_list>(<argument><expr><name>bufid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufHdr</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>buf_state</name> <operator>&amp;</operator> <name>BM_DIRTY</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pgBufferUsage</name><operator>.</operator><name>local_blks_dirtied</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>buf_state</name> <operator>|=</operator> <name>BM_DIRTY</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_atomic_unlocked_write_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufHdr</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * DropRelFileNodeLocalBuffers
 *		This function removes from the buffer pool all the pages of the
 *		specified relation that have block numbers &gt;= firstDelBlock.
 *		(In particular, with firstDelBlock = 0, all pages are removed.)
 *		Dirty pages are simply dropped, without bothering to write them
 *		out first.  Therefore, this is NOT rollback-able, and so should be
 *		used only with extreme caution!
 *
 *		See DropRelFileNodeBuffers in bufmgr.c for more notes.
 */</comment>
<function><type><name>void</name></type>
<name>DropRelFileNodeLocalBuffers</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forkNum</name></decl></parameter>,
							<parameter><decl><type><name>BlockNumber</name></type> <name>firstDelBlock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NLocBuffer</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>bufHdr</name> <init>= <expr><call><name>GetLocalBufferDescriptor</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LocalBufferLookupEnt</name> <modifier>*</modifier></type><name>hresult</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>buf_state</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufHdr</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>buf_state</name> <operator>&amp;</operator> <name>BM_TAG_VALID</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<call><name>RelFileNodeEquals</name><argument_list>(<argument><expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name></name></expr></argument>, <argument><expr><name>rnode</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>forkNum</name></name> <operator>==</operator> <name>forkNum</name> <operator>&amp;&amp;</operator>
			<name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>blockNum</name></name> <operator>&gt;=</operator> <name>firstDelBlock</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>LocalRefCount</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"block %u of %s is still referenced (local %u)"</literal></expr></argument>,
					 <argument><expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>blockNum</name></name></expr></argument>,
					 <argument><expr><call><name>relpathbackend</name><argument_list>(<argument><expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name></name></expr></argument>, <argument><expr><name>MyBackendId</name></expr></argument>,
									<argument><expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>forkNum</name></name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name><name>LocalRefCount</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* Remove entry from hashtable */</comment>
			<expr_stmt><expr><name>hresult</name> <operator>=</operator> <operator>(</operator><name>LocalBufferLookupEnt</name> <operator>*</operator><operator>)</operator>
				<call><name>hash_search</name><argument_list>(<argument><expr><name>LocalBufHash</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>,
							<argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hresult</name></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* shouldn't happen */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"local buffer hash table corrupted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* Mark buffer invalid */</comment>
			<expr_stmt><expr><call><name>CLEAR_BUFFERTAG</name><argument_list>(<argument><expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>buf_state</name> <operator>&amp;=</operator> <operator>~</operator><name>BUF_FLAG_MASK</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>buf_state</name> <operator>&amp;=</operator> <operator>~</operator><name>BUF_USAGECOUNT_MASK</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_atomic_unlocked_write_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufHdr</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * DropRelFileNodeAllLocalBuffers
 *		This function removes from the buffer pool all pages of all forks
 *		of the specified relation.
 *
 *		See DropRelFileNodesAllBuffers in bufmgr.c for more notes.
 */</comment>
<function><type><name>void</name></type>
<name>DropRelFileNodeAllLocalBuffers</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NLocBuffer</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>bufHdr</name> <init>= <expr><call><name>GetLocalBufferDescriptor</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LocalBufferLookupEnt</name> <modifier>*</modifier></type><name>hresult</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>buf_state</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufHdr</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>buf_state</name> <operator>&amp;</operator> <name>BM_TAG_VALID</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<call><name>RelFileNodeEquals</name><argument_list>(<argument><expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name></name></expr></argument>, <argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>LocalRefCount</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"block %u of %s is still referenced (local %u)"</literal></expr></argument>,
					 <argument><expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>blockNum</name></name></expr></argument>,
					 <argument><expr><call><name>relpathbackend</name><argument_list>(<argument><expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name></name></expr></argument>, <argument><expr><name>MyBackendId</name></expr></argument>,
									<argument><expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>forkNum</name></name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name><name>LocalRefCount</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* Remove entry from hashtable */</comment>
			<expr_stmt><expr><name>hresult</name> <operator>=</operator> <operator>(</operator><name>LocalBufferLookupEnt</name> <operator>*</operator><operator>)</operator>
				<call><name>hash_search</name><argument_list>(<argument><expr><name>LocalBufHash</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>,
							<argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hresult</name></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* shouldn't happen */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"local buffer hash table corrupted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* Mark buffer invalid */</comment>
			<expr_stmt><expr><call><name>CLEAR_BUFFERTAG</name><argument_list>(<argument><expr><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>buf_state</name> <operator>&amp;=</operator> <operator>~</operator><name>BUF_FLAG_MASK</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>buf_state</name> <operator>&amp;=</operator> <operator>~</operator><name>BUF_USAGECOUNT_MASK</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_atomic_unlocked_write_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufHdr</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * InitLocalBuffers -
 *	  init the local buffer cache. Since most queries (esp. multi-user ones)
 *	  don't involve local buffers, we delay allocating actual memory for the
 *	  buffers until we need them; just make the buffer headers here.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitLocalBuffers</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nbufs</name> <init>= <expr><name>num_temp_buffers</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Parallel workers can't access data in temporary tables, because they
	 * have no visibility into the local buffers of their leader.  This is a
	 * convenient, low-cost place to provide a backstop check for that.  Note
	 * that we don't wish to prevent a parallel worker from accessing catalog
	 * metadata about a temp table, so checks at higher levels would be
	 * inappropriate.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsParallelWorker</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TRANSACTION_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot access temporary tables during a parallel operation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Allocate and zero buffer headers and auxiliary arrays */</comment>
	<expr_stmt><expr><name>LocalBufferDescriptors</name> <operator>=</operator> <operator>(</operator><name>BufferDesc</name> <operator>*</operator><operator>)</operator> <call><name>calloc</name><argument_list>(<argument><expr><name>nbufs</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BufferDesc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>LocalBufferBlockPointers</name> <operator>=</operator> <operator>(</operator><name>Block</name> <operator>*</operator><operator>)</operator> <call><name>calloc</name><argument_list>(<argument><expr><name>nbufs</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Block</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>LocalRefCount</name> <operator>=</operator> <operator>(</operator><name>int32</name> <operator>*</operator><operator>)</operator> <call><name>calloc</name><argument_list>(<argument><expr><name>nbufs</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>LocalBufferDescriptors</name> <operator>||</operator> <operator>!</operator><name>LocalBufferBlockPointers</name> <operator>||</operator> <operator>!</operator><name>LocalRefCount</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>nextFreeLocalBuf</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* initialize fields that need to start off nonzero */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nbufs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>GetLocalBufferDescriptor</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * negative to indicate local buffer. This is tricky: shared buffers
		 * start with 0. We have to start with -2. (Note that the routine
		 * BufferDescriptorGetBuffer adds 1 to buf_id so our first buffer id
		 * is -1.)
		 */</comment>
		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>buf_id</name></name> <operator>=</operator> <operator>-</operator><name>i</name> <operator>-</operator> <literal type="number">2</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * Intentionally do not initialize the buffer's atomic variable
		 * (besides zeroing the underlying memory above). That way we get
		 * errors on platforms without atomics, if somebody (re-)introduces
		 * atomic operations for local buffers.
		 */</comment>
	</block_content>}</block></for>

	<comment type="block">/* Create the lookup hash table */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BufferTag</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LocalBufferLookupEnt</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><name>LocalBufHash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"Local Buffer Lookup Table"</literal></expr></argument>,
							   <argument><expr><name>nbufs</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>,
							   <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>LocalBufHash</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not initialize local buffer hash table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Initialization done, mark buffers allocated */</comment>
	<expr_stmt><expr><name>NLocBuffer</name> <operator>=</operator> <name>nbufs</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * GetLocalBufferStorage - allocate memory for a local buffer
 *
 * The idea of this function is to aggregate our requests for storage
 * so that the memory manager doesn't see a whole lot of relatively small
 * requests.  Since we'll never give back a local buffer once it's created
 * within a particular process, no point in burdening memmgr with separately
 * managed chunks.
 */</comment>
<function><type><specifier>static</specifier> <name>Block</name></type>
<name>GetLocalBufferStorage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>cur_block</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>next_buf_in_block</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>num_bufs_in_block</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>total_bufs_allocated</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>LocalBufferContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>this_buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>total_bufs_allocated</name> <operator>&lt;</operator> <name>NLocBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>next_buf_in_block</name> <operator>&gt;=</operator> <name>num_bufs_in_block</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Need to make a new request to memmgr */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>num_bufs</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We allocate local buffers in a context of their own, so that the
		 * space eaten for them is easily recognizable in MemoryContextStats
		 * output.  Create the context on first use.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>LocalBufferContext</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>LocalBufferContext</name> <operator>=</operator>
				<call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
									  <argument><expr><literal type="string">"LocalBufferContext"</literal></expr></argument>,
									  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Start with a 16-buffer request; subsequent ones double each time */</comment>
		<expr_stmt><expr><name>num_bufs</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>num_bufs_in_block</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* But not more than what we need for all remaining local bufs */</comment>
		<expr_stmt><expr><name>num_bufs</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>num_bufs</name></expr></argument>, <argument><expr><name>NLocBuffer</name> <operator>-</operator> <name>total_bufs_allocated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* And don't overflow MaxAllocSize, either */</comment>
		<expr_stmt><expr><name>num_bufs</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>num_bufs</name></expr></argument>, <argument><expr><name>MaxAllocSize</name> <operator>/</operator> <name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>cur_block</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>LocalBufferContext</name></expr></argument>,
												<argument><expr><name>num_bufs</name> <operator>*</operator> <name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>next_buf_in_block</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>num_bufs_in_block</name> <operator>=</operator> <name>num_bufs</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Allocate next buffer in current memory block */</comment>
	<expr_stmt><expr><name>this_buf</name> <operator>=</operator> <name>cur_block</name> <operator>+</operator> <name>next_buf_in_block</name> <operator>*</operator> <name>BLCKSZ</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>next_buf_in_block</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>total_bufs_allocated</name><operator>++</operator></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Block</name><operator>)</operator> <name>this_buf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CheckForLocalBufferLeaks - ensure this backend holds no local buffer pins
 *
 * This is just like CheckForBufferLeaks(), but for local buffers.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CheckForLocalBufferLeaks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>LocalRefCount</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>RefCountErrors</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NLocBuffer</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>LocalRefCount</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Buffer</name></type>		<name>b</name> <init>= <expr><operator>-</operator><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>PrintBufferLeakWarning</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>RefCountErrors</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>RefCountErrors</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * AtEOXact_LocalBuffers - clean up at end of transaction.
 *
 * This is just like AtEOXact_Buffers, but for local buffers.
 */</comment>
<function><type><name>void</name></type>
<name>AtEOXact_LocalBuffers</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckForLocalBufferLeaks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AtProcExit_LocalBuffers - ensure we have dropped pins during backend exit.
 *
 * This is just like AtProcExit_Buffers, but for local buffers.
 */</comment>
<function><type><name>void</name></type>
<name>AtProcExit_LocalBuffers</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We shouldn't be holding any remaining pins; if we are, and assertions
	 * aren't enabled, we'll fail later in DropRelFileNodeBuffers while trying
	 * to drop the temp rels.
	 */</comment>
	<expr_stmt><expr><call><name>CheckForLocalBufferLeaks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
