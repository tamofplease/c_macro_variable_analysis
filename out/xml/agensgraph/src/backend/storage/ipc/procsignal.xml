<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/storage/ipc/procsignal.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * procsignal.c
 *	  Routines for interprocess signaling
 *
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/storage/ipc/procsignal.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/parallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/async.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walsender.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/latch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/sinval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>

<comment type="block">/*
 * The SIGUSR1 signal is multiplexed to support signaling multiple event
 * types. The specific reason is communicated via flags in shared memory.
 * We keep a boolean flag for each possible "reason", so that different
 * reasons can be signaled to a process concurrently.  (However, if the same
 * reason is signaled more than once nearly simultaneously, the process may
 * observe it only once.)
 *
 * Each process that wants to receive signals registers its process ID
 * in the ProcSignalSlots array. The array is indexed by backend ID to make
 * slot allocation simple, and to avoid having to search the array when you
 * know the backend ID of the process you're signaling.  (We do support
 * signaling without backend ID, but it's a bit less efficient.)
 *
 * The flags are actually declared as "volatile sig_atomic_t" for maximum
 * portability.  This should ensure that loads and stores of the flag
 * values are atomic, allowing us to dispense with any explicit locking.
 *
 * pss_signalFlags are intended to be set in cases where we don't need to
 * keep track of whether or not the target process has handled the signal,
 * but sometimes we need confirmation, as when making a global state change
 * that cannot be considered complete until all backends have taken notice
 * of it. For such use cases, we set a bit in pss_barrierCheckMask and then
 * increment the current "barrier generation"; when the new barrier generation
 * (or greater) appears in the pss_barrierGeneration flag of every process,
 * we know that the message has been received everywhere.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>pid_t</name></type>		<name>pss_pid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sig_atomic_t</name></type> <name><name>pss_signalFlags</name><index>[<expr><name>NUM_PROCSIGNALS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_atomic_uint64</name></type> <name>pss_barrierGeneration</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_atomic_uint32</name></type> <name>pss_barrierCheckMask</name></decl>;</decl_stmt>
}</block></struct></type> <name>ProcSignalSlot</name>;</typedef>

<comment type="block">/*
 * Information that is global to the entire ProcSignal system can be stored
 * here.
 *
 * psh_barrierGeneration is the highest barrier generation in existence.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>pg_atomic_uint64</name></type> <name>psh_barrierGeneration</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ProcSignalSlot</name></type> <name><name>psh_slot</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>ProcSignalHeader</name>;</typedef>

<comment type="block">/*
 * We reserve a slot for each possible BackendId, plus one for each
 * possible auxiliary process type.  (This scheme assumes there is not
 * more than one of any auxiliary process type at a time.)
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NumProcSignalSlots</name></cpp:macro>	<cpp:value>(MaxBackends + NUM_AUXPROCTYPES)</cpp:value></cpp:define>

<comment type="block">/* Check whether the relevant type bit is set in the flags. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BARRIER_SHOULD_CHECK</name><parameter_list>(<parameter><type><name>flags</name></type></parameter>, <parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(((flags) &amp; (((uint32) 1) &lt;&lt; (uint32) (type))) != 0)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>ProcSignalHeader</name> <modifier>*</modifier></type><name>ProcSignal</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>ProcSignalSlot</name> <modifier>*</modifier></type><name>MyProcSignalSlot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CheckProcSignal</name><parameter_list>(<parameter><decl><type><name>ProcSignalReason</name></type> <name>reason</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CleanupProcSignalState</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ProcessBarrierPlaceholder</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * ProcSignalShmemSize
 *		Compute space needed for procsignal's shared memory
 */</comment>
<function><type><name>Size</name></type>
<name>ProcSignalShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>mul_size</name><argument_list>(<argument><expr><name>NumProcSignalSlots</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ProcSignalSlot</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ProcSignalHeader</name></expr></argument>, <argument><expr><name>psh_slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ProcSignalShmemInit
 *		Allocate and initialize procsignal's shared memory
 */</comment>
<function><type><name>void</name></type>
<name>ProcSignalShmemInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name> <init>= <expr><call><name>ProcSignalShmemSize</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ProcSignal</name> <operator>=</operator> <operator>(</operator><name>ProcSignalHeader</name> <operator>*</operator><operator>)</operator>
		<call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"ProcSignal"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If we're first, initialize. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ProcSignal</name><operator>-&gt;</operator><name>psh_barrierGeneration</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NumProcSignalSlots</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ProcSignalSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><operator>&amp;</operator><name><name>ProcSignal</name><operator>-&gt;</operator><name>psh_slot</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>pss_pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>pss_signalFlags</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>pss_signalFlags</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>pss_barrierGeneration</name></name></expr></argument>, <argument><expr><name>PG_UINT64_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_atomic_init_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>pss_barrierCheckMask</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ProcSignalInit
 *		Register the current process in the procsignal array
 *
 * The passed index should be my BackendId if the process has one,
 * or MaxBackends + aux process type if not.
 */</comment>
<function><type><name>void</name></type>
<name>ProcSignalInit</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pss_idx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>ProcSignalSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>barrier_generation</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pss_idx</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>pss_idx</name> <operator>&lt;=</operator> <name>NumProcSignalSlots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>slot</name> <operator>=</operator> <operator>&amp;</operator><name><name>ProcSignal</name><operator>-&gt;</operator><name>psh_slot</name><index>[<expr><name>pss_idx</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* sanity check */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>pss_pid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"process %d taking over ProcSignal slot %d, but it's not empty"</literal></expr></argument>,
			 <argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><name>pss_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Clear out any leftover signal reasons */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>pss_signalFlags</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NUM_PROCSIGNALS</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sig_atomic_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize barrier state. Since we're a brand-new process, there
	 * shouldn't be any leftover backend-private state that needs to be
	 * updated. Therefore, we can broadcast the latest barrier generation and
	 * disregard any previously-set check bits.
	 *
	 * NB: This only works if this initialization happens early enough in the
	 * startup sequence that we haven't yet cached any state that might need
	 * to be invalidated. That's also why we have a memory barrier here, to be
	 * sure that any later reads of memory happen strictly after this.
	 */</comment>
	<expr_stmt><expr><call><name>pg_atomic_write_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>pss_barrierCheckMask</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>barrier_generation</name> <operator>=</operator>
		<call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ProcSignal</name><operator>-&gt;</operator><name>psh_barrierGeneration</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>pss_barrierGeneration</name></name></expr></argument>, <argument><expr><name>barrier_generation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_memory_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Mark slot with my PID */</comment>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>pss_pid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>

	<comment type="block">/* Remember slot location for CheckProcSignal */</comment>
	<expr_stmt><expr><name>MyProcSignalSlot</name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>

	<comment type="block">/* Set up to release the slot on process exit */</comment>
	<expr_stmt><expr><call><name>on_shmem_exit</name><argument_list>(<argument><expr><name>CleanupProcSignalState</name></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>pss_idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * CleanupProcSignalState
 *		Remove current process from ProcSignal mechanism
 *
 * This function is called via on_shmem_exit() during backend shutdown.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CleanupProcSignalState</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>pss_idx</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>ProcSignalSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>slot</name> <operator>=</operator> <operator>&amp;</operator><name><name>ProcSignal</name><operator>-&gt;</operator><name>psh_slot</name><index>[<expr><name>pss_idx</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slot</name> <operator>==</operator> <name>MyProcSignalSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Clear MyProcSignalSlot, so that a SIGUSR1 received after this point
	 * won't try to access it after it's no longer ours (and perhaps even
	 * after we've unmapped the shared memory segment).
	 */</comment>
	<expr_stmt><expr><name>MyProcSignalSlot</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* sanity check */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>pss_pid</name></name> <operator>!=</operator> <name>MyProcPid</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * don't ERROR here. We're exiting anyway, and don't want to get into
		 * infinite loop trying to exit
		 */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"process %d releasing ProcSignal slot %d, but it contains %d"</literal></expr></argument>,
			 <argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><name>pss_idx</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>slot</name><operator>-&gt;</operator><name>pss_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>					<comment type="block">/* XXX better to zero the slot anyway? */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Make this slot look like it's absorbed all possible barriers, so that
	 * no barrier waits block on it.
	 */</comment>
	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>pss_barrierGeneration</name></name></expr></argument>, <argument><expr><name>PG_UINT64_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>pss_pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SendProcSignal
 *		Send a signal to a Postgres process
 *
 * Providing backendId is optional, but it will speed up the operation.
 *
 * On success (a signal was sent), zero is returned.
 * On error, -1 is returned, and errno is set (typically to ESRCH or EPERM).
 *
 * Not to be confused with ProcSendSignal
 */</comment>
<function><type><name>int</name></type>
<name>SendProcSignal</name><parameter_list>(<parameter><decl><type><name>pid_t</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><name>ProcSignalReason</name></type> <name>reason</name></decl></parameter>, <parameter><decl><type><name>BackendId</name></type> <name>backendId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>ProcSignalSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>backendId</name> <operator>!=</operator> <name>InvalidBackendId</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <operator>&amp;</operator><name><name>ProcSignal</name><operator>-&gt;</operator><name>psh_slot</name><index>[<expr><name>backendId</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Note: Since there's no locking, it's possible that the target
		 * process detaches from shared memory and exits right after this
		 * test, before we set the flag and send signal. And the signal slot
		 * might even be recycled by a new process, so it's remotely possible
		 * that we set a flag for a wrong process. That's OK, all the signals
		 * are such that no harm is done if they're mistakenly fired.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>pss_pid</name></name> <operator>==</operator> <name>pid</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Atomically set the proper flag */</comment>
			<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>pss_signalFlags</name><index>[<expr><name>reason</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<comment type="block">/* Send signal */</comment>
			<return>return <expr><call><name>kill</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>SIGUSR1</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * BackendId not provided, so search the array using pid.  We search
		 * the array back to front so as to reduce search overhead.  Passing
		 * InvalidBackendId means that the target is most likely an auxiliary
		 * process, which will have a slot near the end of the array.
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>NumProcSignalSlots</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>slot</name> <operator>=</operator> <operator>&amp;</operator><name><name>ProcSignal</name><operator>-&gt;</operator><name>psh_slot</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>pss_pid</name></name> <operator>==</operator> <name>pid</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* the above note about race conditions applies here too */</comment>

				<comment type="block">/* Atomically set the proper flag */</comment>
				<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>pss_signalFlags</name><index>[<expr><name>reason</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<comment type="block">/* Send signal */</comment>
				<return>return <expr><call><name>kill</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>SIGUSR1</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ESRCH</name></expr>;</expr_stmt>
	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * EmitProcSignalBarrier
 *		Send a signal to every Postgres process
 *
 * The return value of this function is the barrier "generation" created
 * by this operation. This value can be passed to WaitForProcSignalBarrier
 * to wait until it is known that every participant in the ProcSignal
 * mechanism has absorbed the signal (or started afterwards).
 *
 * Note that it would be a bad idea to use this for anything that happens
 * frequently, as interrupting every backend could cause a noticeable
 * performance hit.
 *
 * Callers are entitled to assume that this function will not throw ERROR
 * or FATAL.
 */</comment>
<function><type><name>uint64</name></type>
<name>EmitProcSignalBarrier</name><parameter_list>(<parameter><decl><type><name>ProcSignalBarrierType</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>flagbit</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>generation</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Set all the flags.
	 *
	 * Note that pg_atomic_fetch_or_u32 has full barrier semantics, so this is
	 * totally ordered with respect to anything the caller did before, and
	 * anything that we do afterwards. (This is also true of the later call to
	 * pg_atomic_add_fetch_u64.)
	 */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NumProcSignalSlots</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>volatile</specifier> <name>ProcSignalSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><operator>&amp;</operator><name><name>ProcSignal</name><operator>-&gt;</operator><name>psh_slot</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_atomic_fetch_or_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>pss_barrierCheckMask</name></name></expr></argument>, <argument><expr><name>flagbit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Increment the generation counter.
	 */</comment>
	<expr_stmt><expr><name>generation</name> <operator>=</operator>
		<call><name>pg_atomic_add_fetch_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ProcSignal</name><operator>-&gt;</operator><name>psh_barrierGeneration</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Signal all the processes, so that they update their advertised barrier
	 * generation.
	 *
	 * Concurrency is not a problem here. Backends that have exited don't
	 * matter, and new backends that have joined since we entered this
	 * function must already have current state, since the caller is
	 * responsible for making sure that the relevant state is entirely visible
	 * before calling this function in the first place. We still have to wake
	 * them up - because we can't distinguish between such backends and older
	 * backends that need to update state - but they won't actually need to
	 * change any state.
	 */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>NumProcSignalSlots</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>volatile</specifier> <name>ProcSignalSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><operator>&amp;</operator><name><name>ProcSignal</name><operator>-&gt;</operator><name>psh_slot</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>pid_t</name></type>		<name>pid</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>pss_pid</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* see SendProcSignal for details */</comment>
			<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>pss_signalFlags</name><index>[<expr><name>PROCSIG_BARRIER</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>SIGUSR1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>generation</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * WaitForProcSignalBarrier - wait until it is guaranteed that all changes
 * requested by a specific call to EmitProcSignalBarrier() have taken effect.
 *
 * We expect that the barrier will normally be absorbed very quickly by other
 * backends, so we start by waiting just 1/8 of a second and then back off
 * by a factor of two every time we time out, to a maximum wait time of
 * 1 second.
 */</comment>
<function><type><name>void</name></type>
<name>WaitForProcSignalBarrier</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>generation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>long</name></type>		<name>timeout</name> <init>= <expr><literal type="number">125L</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>generation</name> <operator>&lt;=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ProcSignal</name><operator>-&gt;</operator><name>psh_barrierGeneration</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>NumProcSignalSlots</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>volatile</specifier> <name>ProcSignalSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><operator>&amp;</operator><name><name>ProcSignal</name><operator>-&gt;</operator><name>psh_slot</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>oldval</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>oldval</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>pss_barrierGeneration</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>oldval</name> <operator>&lt;</operator> <name>generation</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>events</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>events</name> <operator>=</operator>
				<call><name>WaitLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>,
						  <argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_TIMEOUT</name> <operator>|</operator> <name>WL_EXIT_ON_PM_DEATH</name></expr></argument>,
						  <argument><expr><name>timeout</name></expr></argument>, <argument><expr><name>WAIT_EVENT_PROC_SIGNAL_BARRIER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>oldval</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>pss_barrierGeneration</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>events</name> <operator>&amp;</operator> <name>WL_TIMEOUT</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>timeout</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>timeout</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">1000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></while>
	</block_content>}</block></for>

	<comment type="block">/*
	 * The caller is probably calling this function because it wants to read
	 * the shared state or perform further writes to shared state once all
	 * backends are known to have absorbed the barrier. However, the read of
	 * pss_barrierGeneration was performed unlocked; insert a memory barrier
	 * to separate it from whatever follows.
	 */</comment>
	<expr_stmt><expr><call><name>pg_memory_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Handle receipt of an interrupt indicating a global barrier event.
 *
 * All the actual work is deferred to ProcessProcSignalBarrier(), because we
 * cannot safely access the barrier generation inside the signal handler as
 * 64bit atomics might use spinlock based emulation, even for reads. As this
 * routine only gets called when PROCSIG_BARRIER is sent that won't cause a
 * lot fo unnecessary work.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>HandleProcSignalBarrierInterrupt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>InterruptPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ProcSignalBarrierPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<comment type="block">/* latch will be set by procsignal_sigusr1_handler */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Perform global barrier related interrupt checking.
 *
 * Any backend that participates in ProcSignal signaling must arrange to
 * call this function periodically. It is called from CHECK_FOR_INTERRUPTS(),
 * which is enough for normal backends, but not necessarily for all types of
 * background processes.
 */</comment>
<function><type><name>void</name></type>
<name>ProcessProcSignalBarrier</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>local_gen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>shared_gen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>flags</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MyProcSignalSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Exit quickly if there's no work to do. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ProcSignalBarrierPending</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>ProcSignalBarrierPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * It's not unlikely to process multiple barriers at once, before the
	 * signals for all the barriers have arrived. To avoid unnecessary work in
	 * response to subsequent signals, exit early if we already have processed
	 * all of them.
	 */</comment>
	<expr_stmt><expr><name>local_gen</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProcSignalSlot</name><operator>-&gt;</operator><name>pss_barrierGeneration</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>shared_gen</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ProcSignal</name><operator>-&gt;</operator><name>psh_barrierGeneration</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>local_gen</name> <operator>&lt;=</operator> <name>shared_gen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>local_gen</name> <operator>==</operator> <name>shared_gen</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Get and clear the flags that are set for this backend. Note that
	 * pg_atomic_exchange_u32 is a full barrier, so we're guaranteed that the
	 * read of the barrier generation above happens before we atomically
	 * extract the flags, and that any subsequent state changes happen
	 * afterward.
	 */</comment>
	<expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>pg_atomic_exchange_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProcSignalSlot</name><operator>-&gt;</operator><name>pss_barrierCheckMask</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Process each type of barrier. It's important that nothing we call from
	 * here throws an error, because pss_barrierCheckMask has already been
	 * cleared. If we jumped out of here before processing all barrier types,
	 * then we'd forget about the need to do so later.
	 *
	 * NB: It ought to be OK to call the barrier-processing functions
	 * unconditionally, but it's more efficient to call only the ones that
	 * might need us to do something based on the flags.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>BARRIER_SHOULD_CHECK</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>PROCSIGNAL_BARRIER_PLACEHOLDER</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ProcessBarrierPlaceholder</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * State changes related to all types of barriers that might have been
	 * emitted have now been handled, so we can update our notion of the
	 * generation to the one we observed before beginning the updates. If
	 * things have changed further, it'll get fixed up when this function is
	 * next called.
	 */</comment>
	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProcSignalSlot</name><operator>-&gt;</operator><name>pss_barrierGeneration</name></name></expr></argument>, <argument><expr><name>shared_gen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ProcessBarrierPlaceholder</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * XXX. This is just a placeholder until the first real user of this
	 * machinery gets committed. Rename PROCSIGNAL_BARRIER_PLACEHOLDER to
	 * PROCSIGNAL_BARRIER_SOMETHING_ELSE where SOMETHING_ELSE is something
	 * appropriately descriptive. Get rid of this function and instead have
	 * ProcessBarrierSomethingElse. Most likely, that function should live in
	 * the file pertaining to that subsystem, rather than here.
	 */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * CheckProcSignal - check to see if a particular reason has been
 * signaled, and clear the signal flag.  Should be called after receiving
 * SIGUSR1.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CheckProcSignal</name><parameter_list>(<parameter><decl><type><name>ProcSignalReason</name></type> <name>reason</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>ProcSignalSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name>MyProcSignalSlot</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Careful here --- don't clear flag if we haven't seen it set */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>pss_signalFlags</name><index>[<expr><name>reason</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>pss_signalFlags</name><index>[<expr><name>reason</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * procsignal_sigusr1_handler - handle SIGUSR1 signal.
 */</comment>
<function><type><name>void</name></type>
<name>procsignal_sigusr1_handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CheckProcSignal</name><argument_list>(<argument><expr><name>PROCSIG_CATCHUP_INTERRUPT</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>HandleCatchupInterrupt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CheckProcSignal</name><argument_list>(<argument><expr><name>PROCSIG_NOTIFY_INTERRUPT</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>HandleNotifyInterrupt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CheckProcSignal</name><argument_list>(<argument><expr><name>PROCSIG_PARALLEL_MESSAGE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>HandleParallelMessageInterrupt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CheckProcSignal</name><argument_list>(<argument><expr><name>PROCSIG_WALSND_INIT_STOPPING</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>HandleWalSndInitStopping</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CheckProcSignal</name><argument_list>(<argument><expr><name>PROCSIG_BARRIER</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>HandleProcSignalBarrierInterrupt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CheckProcSignal</name><argument_list>(<argument><expr><name>PROCSIG_RECOVERY_CONFLICT_DATABASE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RecoveryConflictInterrupt</name><argument_list>(<argument><expr><name>PROCSIG_RECOVERY_CONFLICT_DATABASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CheckProcSignal</name><argument_list>(<argument><expr><name>PROCSIG_RECOVERY_CONFLICT_TABLESPACE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RecoveryConflictInterrupt</name><argument_list>(<argument><expr><name>PROCSIG_RECOVERY_CONFLICT_TABLESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CheckProcSignal</name><argument_list>(<argument><expr><name>PROCSIG_RECOVERY_CONFLICT_LOCK</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RecoveryConflictInterrupt</name><argument_list>(<argument><expr><name>PROCSIG_RECOVERY_CONFLICT_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CheckProcSignal</name><argument_list>(<argument><expr><name>PROCSIG_RECOVERY_CONFLICT_SNAPSHOT</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RecoveryConflictInterrupt</name><argument_list>(<argument><expr><name>PROCSIG_RECOVERY_CONFLICT_SNAPSHOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CheckProcSignal</name><argument_list>(<argument><expr><name>PROCSIG_RECOVERY_CONFLICT_STARTUP_DEADLOCK</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RecoveryConflictInterrupt</name><argument_list>(<argument><expr><name>PROCSIG_RECOVERY_CONFLICT_STARTUP_DEADLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CheckProcSignal</name><argument_list>(<argument><expr><name>PROCSIG_RECOVERY_CONFLICT_BUFFERPIN</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RecoveryConflictInterrupt</name><argument_list>(<argument><expr><name>PROCSIG_RECOVERY_CONFLICT_BUFFERPIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>latch_sigusr1_handler</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
