<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/storage/ipc/sinvaladt.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * sinvaladt.c
 *	  POSTGRES shared cache invalidation data manager.
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/storage/ipc/sinvaladt.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/backendid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/sinvaladt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/spin.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Conceptually, the shared cache invalidation messages are stored in an
 * infinite array, where maxMsgNum is the next array subscript to store a
 * submitted message in, minMsgNum is the smallest array subscript containing
 * a message not yet read by all backends, and we always have maxMsgNum &gt;=
 * minMsgNum.  (They are equal when there are no messages pending.)  For each
 * active backend, there is a nextMsgNum pointer indicating the next message it
 * needs to read; we have maxMsgNum &gt;= nextMsgNum &gt;= minMsgNum for every
 * backend.
 *
 * (In the current implementation, minMsgNum is a lower bound for the
 * per-process nextMsgNum values, but it isn't rigorously kept equal to the
 * smallest nextMsgNum --- it may lag behind.  We only update it when
 * SICleanupQueue is called, and we try not to do that often.)
 *
 * In reality, the messages are stored in a circular buffer of MAXNUMMESSAGES
 * entries.  We translate MsgNum values into circular-buffer indexes by
 * computing MsgNum % MAXNUMMESSAGES (this should be fast as long as
 * MAXNUMMESSAGES is a constant and a power of 2).  As long as maxMsgNum
 * doesn't exceed minMsgNum by more than MAXNUMMESSAGES, we have enough space
 * in the buffer.  If the buffer does overflow, we recover by setting the
 * "reset" flag for each backend that has fallen too far behind.  A backend
 * that is in "reset" state is ignored while determining minMsgNum.  When
 * it does finally attempt to receive inval messages, it must discard all
 * its invalidatable state, since it won't know what it missed.
 *
 * To reduce the probability of needing resets, we send a "catchup" interrupt
 * to any backend that seems to be falling unreasonably far behind.  The
 * normal behavior is that at most one such interrupt is in flight at a time;
 * when a backend completes processing a catchup interrupt, it executes
 * SICleanupQueue, which will signal the next-furthest-behind backend if
 * needed.  This avoids undue contention from multiple backends all trying
 * to catch up at once.  However, the furthest-back backend might be stuck
 * in a state where it can't catch up.  Eventually it will get reset, so it
 * won't cause any more problems for anyone but itself.  But we don't want
 * to find that a bunch of other backends are now too close to the reset
 * threshold to be saved.  So SICleanupQueue is designed to occasionally
 * send extra catchup interrupts as the queue gets fuller, to backends that
 * are far behind and haven't gotten one yet.  As long as there aren't a lot
 * of "stuck" backends, we won't need a lot of extra interrupts, since ones
 * that aren't stuck will propagate their interrupts to the next guy.
 *
 * We would have problems if the MsgNum values overflow an integer, so
 * whenever minMsgNum exceeds MSGNUMWRAPAROUND, we subtract MSGNUMWRAPAROUND
 * from all the MsgNum variables simultaneously.  MSGNUMWRAPAROUND can be
 * large so that we don't need to do this often.  It must be a multiple of
 * MAXNUMMESSAGES so that the existing circular-buffer entries don't need
 * to be moved when we do it.
 *
 * Access to the shared sinval array is protected by two locks, SInvalReadLock
 * and SInvalWriteLock.  Readers take SInvalReadLock in shared mode; this
 * authorizes them to modify their own ProcState but not to modify or even
 * look at anyone else's.  When we need to perform array-wide updates,
 * such as in SICleanupQueue, we take SInvalReadLock in exclusive mode to
 * lock out all readers.  Writers take SInvalWriteLock (always in exclusive
 * mode) to serialize adding messages to the queue.  Note that a writer
 * can operate in parallel with one or more readers, because the writer
 * has no need to touch anyone's ProcState, except in the infrequent cases
 * when SICleanupQueue is needed.  The only point of overlap is that
 * the writer wants to change maxMsgNum while readers need to read it.
 * We deal with that by having a spinlock that readers must take for just
 * long enough to read maxMsgNum, while writers take it for just long enough
 * to write maxMsgNum.  (The exact rule is that you need the spinlock to
 * read maxMsgNum if you are not holding SInvalWriteLock, and you need the
 * spinlock to write maxMsgNum unless you are holding both locks.)
 *
 * Note: since maxMsgNum is an int and hence presumably atomically readable/
 * writable, the spinlock might seem unnecessary.  The reason it is needed
 * is to provide a memory barrier: we need to be sure that messages written
 * to the array are actually there before maxMsgNum is increased, and that
 * readers will see that data after fetching maxMsgNum.  Multiprocessors
 * that have weak memory-ordering guarantees can fail without the memory
 * barrier instructions that are included in the spinlock sequences.
 */</comment>


<comment type="block">/*
 * Configurable parameters.
 *
 * MAXNUMMESSAGES: max number of shared-inval messages we can buffer.
 * Must be a power of 2 for speed.
 *
 * MSGNUMWRAPAROUND: how often to reduce MsgNum variables to avoid overflow.
 * Must be a multiple of MAXNUMMESSAGES.  Should be large.
 *
 * CLEANUP_MIN: the minimum number of messages that must be in the buffer
 * before we bother to call SICleanupQueue.
 *
 * CLEANUP_QUANTUM: how often (in messages) to call SICleanupQueue once
 * we exceed CLEANUP_MIN.  Should be a power of 2 for speed.
 *
 * SIG_THRESHOLD: the minimum number of messages a backend must have fallen
 * behind before we'll send it PROCSIG_CATCHUP_INTERRUPT.
 *
 * WRITE_QUANTUM: the max number of messages to push into the buffer per
 * iteration of SIInsertDataEntries.  Noncritical but should be less than
 * CLEANUP_QUANTUM, because we only consider calling SICleanupQueue once
 * per iteration.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXNUMMESSAGES</name></cpp:macro> <cpp:value>4096</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MSGNUMWRAPAROUND</name></cpp:macro> <cpp:value>(MAXNUMMESSAGES * 262144)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLEANUP_MIN</name></cpp:macro> <cpp:value>(MAXNUMMESSAGES / 2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLEANUP_QUANTUM</name></cpp:macro> <cpp:value>(MAXNUMMESSAGES / 16)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIG_THRESHOLD</name></cpp:macro> <cpp:value>(MAXNUMMESSAGES / 2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_QUANTUM</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>

<comment type="block">/* Per-backend state in shared invalidation structure */</comment>
<typedef>typedef <type><struct>struct <name>ProcState</name>
<block>{
	<comment type="block">/* procPid is zero in an inactive ProcState array entry. */</comment>
	<decl_stmt><decl><type><name>pid_t</name></type>		<name>procPid</name></decl>;</decl_stmt>		<comment type="block">/* PID of backend, for signaling */</comment>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>			<comment type="block">/* PGPROC of backend */</comment>
	<comment type="block">/* nextMsgNum is meaningless if procPid == 0 or resetState is true. */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nextMsgNum</name></decl>;</decl_stmt>		<comment type="block">/* next message number to read */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>resetState</name></decl>;</decl_stmt>		<comment type="block">/* backend needs to reset its state */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>signaled</name></decl>;</decl_stmt>		<comment type="block">/* backend has been sent catchup signal */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hasMessages</name></decl>;</decl_stmt>	<comment type="block">/* backend has unread messages */</comment>

	<comment type="block">/*
	 * Backend only sends invalidations, never receives them. This only makes
	 * sense for Startup process during recovery because it doesn't maintain a
	 * relcache, yet it fires inval messages to allow query backends to see
	 * schema changes.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>sendOnly</name></decl>;</decl_stmt>		<comment type="block">/* backend only sends, never receives */</comment>

	<comment type="block">/*
	 * Next LocalTransactionId to use for each idle backend slot.  We keep
	 * this here because it is indexed by BackendId and it is convenient to
	 * copy the value to and from local memory when MyBackendId is set. It's
	 * meaningless in an active ProcState entry.
	 */</comment>
	<decl_stmt><decl><type><name>LocalTransactionId</name></type> <name>nextLXID</name></decl>;</decl_stmt>
}</block></struct></type> <name>ProcState</name>;</typedef>

<comment type="block">/* Shared cache invalidation memory segment */</comment>
<typedef>typedef <type><struct>struct <name>SISeg</name>
<block>{
	<comment type="block">/*
	 * General state information
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>minMsgNum</name></decl>;</decl_stmt>		<comment type="block">/* oldest message still needed */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxMsgNum</name></decl>;</decl_stmt>		<comment type="block">/* next message number to be assigned */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nextThreshold</name></decl>;</decl_stmt>	<comment type="block">/* # of messages to call SICleanupQueue */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>lastBackend</name></decl>;</decl_stmt>	<comment type="block">/* index of last active procState entry, +1 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxBackends</name></decl>;</decl_stmt>	<comment type="block">/* size of procState array */</comment>

	<decl_stmt><decl><type><name>slock_t</name></type>		<name>msgnumLock</name></decl>;</decl_stmt>		<comment type="block">/* spinlock protecting maxMsgNum */</comment>

	<comment type="block">/*
	 * Circular buffer holding shared-inval messages
	 */</comment>
	<decl_stmt><decl><type><name>SharedInvalidationMessage</name></type> <name><name>buffer</name><index>[<expr><name>MAXNUMMESSAGES</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Per-backend invalidation state info (has MaxBackends entries).
	 */</comment>
	<decl_stmt><decl><type><name>ProcState</name></type>	<name><name>procState</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>SISeg</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>SISeg</name> <modifier>*</modifier></type><name>shmInvalBuffer</name></decl>;</decl_stmt>	<comment type="block">/* pointer to the shared inval buffer */</comment>


<decl_stmt><decl><type><specifier>static</specifier> <name>LocalTransactionId</name></type> <name>nextLocalTransactionId</name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CleanupInvalidationState</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * SInvalShmemSize --- return shared-memory space needed
 */</comment>
<function><type><name>Size</name></type>
<name>SInvalShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>SISeg</name></expr></argument>, <argument><expr><name>procState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ProcState</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>MaxBackends</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CreateSharedInvalidationState
 *		Create and initialize the SI message buffer
 */</comment>
<function><type><name>void</name></type>
<name>CreateSharedInvalidationState</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<comment type="block">/* Allocate space in shared memory */</comment>
	<expr_stmt><expr><name>shmInvalBuffer</name> <operator>=</operator> <operator>(</operator><name>SISeg</name> <operator>*</operator><operator>)</operator>
		<call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"shmInvalBuffer"</literal></expr></argument>, <argument><expr><call><name>SInvalShmemSize</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Clear message counters, save size of procState array, init spinlock */</comment>
	<expr_stmt><expr><name><name>shmInvalBuffer</name><operator>-&gt;</operator><name>minMsgNum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shmInvalBuffer</name><operator>-&gt;</operator><name>maxMsgNum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shmInvalBuffer</name><operator>-&gt;</operator><name>nextThreshold</name></name> <operator>=</operator> <name>CLEANUP_MIN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shmInvalBuffer</name><operator>-&gt;</operator><name>lastBackend</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shmInvalBuffer</name><operator>-&gt;</operator><name>maxBackends</name></name> <operator>=</operator> <name>MaxBackends</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shmInvalBuffer</name><operator>-&gt;</operator><name>msgnumLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The buffer[] array is initially all unused, so we need not fill it */</comment>

	<comment type="block">/* Mark all backends inactive, and initialize nextLXID */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>shmInvalBuffer</name><operator>-&gt;</operator><name>maxBackends</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>shmInvalBuffer</name><operator>-&gt;</operator><name>procState</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>procPid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/* inactive */</comment>
		<expr_stmt><expr><name><name>shmInvalBuffer</name><operator>-&gt;</operator><name>procState</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>proc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shmInvalBuffer</name><operator>-&gt;</operator><name>procState</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nextMsgNum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/* meaningless */</comment>
		<expr_stmt><expr><name><name>shmInvalBuffer</name><operator>-&gt;</operator><name>procState</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>resetState</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shmInvalBuffer</name><operator>-&gt;</operator><name>procState</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>signaled</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shmInvalBuffer</name><operator>-&gt;</operator><name>procState</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hasMessages</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shmInvalBuffer</name><operator>-&gt;</operator><name>procState</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nextLXID</name> <operator>=</operator> <name>InvalidLocalTransactionId</name></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * SharedInvalBackendInit
 *		Initialize a new backend to operate on the sinval buffer
 */</comment>
<function><type><name>void</name></type>
<name>SharedInvalBackendInit</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>sendOnly</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ProcState</name>  <modifier>*</modifier></type><name>stateP</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SISeg</name>	   <modifier>*</modifier></type><name>segP</name> <init>= <expr><name>shmInvalBuffer</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * This can run in parallel with read operations, but not with write
	 * operations, since SIInsertDataEntries relies on lastBackend to set
	 * hasMessages appropriately.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SInvalWriteLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Look for a free entry in the procState array */</comment>
	<for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>segP</name><operator>-&gt;</operator><name>lastBackend</name></name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>segP</name><operator>-&gt;</operator><name>procState</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>procPid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>	<comment type="block">/* inactive slot? */</comment>
		<block>{<block_content>
			<expr_stmt><expr><name>stateP</name> <operator>=</operator> <operator>&amp;</operator><name><name>segP</name><operator>-&gt;</operator><name>procState</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>stateP</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>segP</name><operator>-&gt;</operator><name>lastBackend</name></name> <operator>&lt;</operator> <name><name>segP</name><operator>-&gt;</operator><name>maxBackends</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>stateP</name> <operator>=</operator> <operator>&amp;</operator><name><name>segP</name><operator>-&gt;</operator><name>procState</name><index>[<expr><name><name>segP</name><operator>-&gt;</operator><name>lastBackend</name></name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stateP</name><operator>-&gt;</operator><name>procPid</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>segP</name><operator>-&gt;</operator><name>lastBackend</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * out of procState slots: MaxBackends exceeded -- report normally
			 */</comment>
			<expr_stmt><expr><name>MyBackendId</name> <operator>=</operator> <name>InvalidBackendId</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SInvalWriteLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_CONNECTIONS</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"sorry, too many clients already"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>MyBackendId</name> <operator>=</operator> <operator>(</operator><name>stateP</name> <operator>-</operator> <operator>&amp;</operator><name><name>segP</name><operator>-&gt;</operator><name>procState</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* Advertise assigned backend ID in MyProc */</comment>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>backendId</name></name> <operator>=</operator> <name>MyBackendId</name></expr>;</expr_stmt>

	<comment type="block">/* Fetch next local transaction ID into local memory */</comment>
	<expr_stmt><expr><name>nextLocalTransactionId</name> <operator>=</operator> <name><name>stateP</name><operator>-&gt;</operator><name>nextLXID</name></name></expr>;</expr_stmt>

	<comment type="block">/* mark myself active, with all extant messages already read */</comment>
	<expr_stmt><expr><name><name>stateP</name><operator>-&gt;</operator><name>procPid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stateP</name><operator>-&gt;</operator><name>proc</name></name> <operator>=</operator> <name>MyProc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stateP</name><operator>-&gt;</operator><name>nextMsgNum</name></name> <operator>=</operator> <name><name>segP</name><operator>-&gt;</operator><name>maxMsgNum</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stateP</name><operator>-&gt;</operator><name>resetState</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stateP</name><operator>-&gt;</operator><name>signaled</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stateP</name><operator>-&gt;</operator><name>hasMessages</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stateP</name><operator>-&gt;</operator><name>sendOnly</name></name> <operator>=</operator> <name>sendOnly</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SInvalWriteLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* register exit routine to mark my entry inactive at exit */</comment>
	<expr_stmt><expr><call><name>on_shmem_exit</name><argument_list>(<argument><expr><name>CleanupInvalidationState</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>segP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><literal type="string">"my backend ID is %d"</literal></expr></argument>, <argument><expr><name>MyBackendId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * CleanupInvalidationState
 *		Mark the current backend as no longer active.
 *
 * This function is called via on_shmem_exit() during backend shutdown.
 *
 * arg is really of type "SISeg*".
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CleanupInvalidationState</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SISeg</name>	   <modifier>*</modifier></type><name>segP</name> <init>= <expr><operator>(</operator><name>SISeg</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ProcState</name>  <modifier>*</modifier></type><name>stateP</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><name>segP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SInvalWriteLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>stateP</name> <operator>=</operator> <operator>&amp;</operator><name><name>segP</name><operator>-&gt;</operator><name>procState</name><index>[<expr><name>MyBackendId</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* Update next local transaction ID for next holder of this backendID */</comment>
	<expr_stmt><expr><name><name>stateP</name><operator>-&gt;</operator><name>nextLXID</name></name> <operator>=</operator> <name>nextLocalTransactionId</name></expr>;</expr_stmt>

	<comment type="block">/* Mark myself inactive */</comment>
	<expr_stmt><expr><name><name>stateP</name><operator>-&gt;</operator><name>procPid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stateP</name><operator>-&gt;</operator><name>proc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stateP</name><operator>-&gt;</operator><name>nextMsgNum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stateP</name><operator>-&gt;</operator><name>resetState</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stateP</name><operator>-&gt;</operator><name>signaled</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Recompute index of last active backend */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>segP</name><operator>-&gt;</operator><name>lastBackend</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>segP</name><operator>-&gt;</operator><name>procState</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>procPid</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>segP</name><operator>-&gt;</operator><name>lastBackend</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SInvalWriteLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * BackendIdGetProc
 *		Get the PGPROC structure for a backend, given the backend ID.
 *		The result may be out of date arbitrarily quickly, so the caller
 *		must be careful about how this information is used.  NULL is
 *		returned if the backend is not active.
 */</comment>
<function><type><name>PGPROC</name> <modifier>*</modifier></type>
<name>BackendIdGetProc</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>backendID</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SISeg</name>	   <modifier>*</modifier></type><name>segP</name> <init>= <expr><name>shmInvalBuffer</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Need to lock out additions/removals of backends */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SInvalWriteLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>backendID</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>backendID</name> <operator>&lt;=</operator> <name><name>segP</name><operator>-&gt;</operator><name>lastBackend</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ProcState</name>  <modifier>*</modifier></type><name>stateP</name> <init>= <expr><operator>&amp;</operator><name><name>segP</name><operator>-&gt;</operator><name>procState</name><index>[<expr><name>backendID</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>stateP</name><operator>-&gt;</operator><name>proc</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SInvalWriteLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * BackendIdGetTransactionIds
 *		Get the xid and xmin of the backend. The result may be out of date
 *		arbitrarily quickly, so the caller must be careful about how this
 *		information is used.
 */</comment>
<function><type><name>void</name></type>
<name>BackendIdGetTransactionIds</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>backendID</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>xid</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>xmin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SISeg</name>	   <modifier>*</modifier></type><name>segP</name> <init>= <expr><name>shmInvalBuffer</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>xid</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>xmin</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>

	<comment type="block">/* Need to lock out additions/removals of backends */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SInvalWriteLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>backendID</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>backendID</name> <operator>&lt;=</operator> <name><name>segP</name><operator>-&gt;</operator><name>lastBackend</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ProcState</name>  <modifier>*</modifier></type><name>stateP</name> <init>= <expr><operator>&amp;</operator><name><name>segP</name><operator>-&gt;</operator><name>procState</name><index>[<expr><name>backendID</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>proc</name> <init>= <expr><name><name>stateP</name><operator>-&gt;</operator><name>proc</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>proc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PGXACT</name>	   <modifier>*</modifier></type><name>xact</name> <init>= <expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allPgXact</name><index>[<expr><name><name>proc</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><operator>*</operator><name>xid</name> <operator>=</operator> <name><name>xact</name><operator>-&gt;</operator><name>xid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>xmin</name> <operator>=</operator> <name><name>xact</name><operator>-&gt;</operator><name>xmin</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SInvalWriteLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SIInsertDataEntries
 *		Add new invalidation message(s) to the buffer.
 */</comment>
<function><type><name>void</name></type>
<name>SIInsertDataEntries</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SharedInvalidationMessage</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SISeg</name>	   <modifier>*</modifier></type><name>segP</name> <init>= <expr><name>shmInvalBuffer</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * N can be arbitrarily large.  We divide the work into groups of no more
	 * than WRITE_QUANTUM messages, to be sure that we don't hold the lock for
	 * an unreasonably long time.  (This is not so much because we care about
	 * letting in other writers, as that some just-caught-up backend might be
	 * trying to do SICleanupQueue to pass on its signal, and we don't want it
	 * to have to wait a long time.)  Also, we need to consider calling
	 * SICleanupQueue every so often.
	 */</comment>
	<while>while <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>nthistime</name> <init>= <expr><call><name>Min</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>WRITE_QUANTUM</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>numMsgs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>max</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>n</name> <operator>-=</operator> <name>nthistime</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SInvalWriteLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the buffer is full, we *must* acquire some space.  Clean the
		 * queue and reset anyone who is preventing space from being freed.
		 * Otherwise, clean the queue only when it's exceeded the next
		 * fullness threshold.  We have to loop and recheck the buffer state
		 * after any call of SICleanupQueue.
		 */</comment>
		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>numMsgs</name> <operator>=</operator> <name><name>segP</name><operator>-&gt;</operator><name>maxMsgNum</name></name> <operator>-</operator> <name><name>segP</name><operator>-&gt;</operator><name>minMsgNum</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>numMsgs</name> <operator>+</operator> <name>nthistime</name> <operator>&gt;</operator> <name>MAXNUMMESSAGES</name> <operator>||</operator>
				<name>numMsgs</name> <operator>&gt;=</operator> <name><name>segP</name><operator>-&gt;</operator><name>nextThreshold</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>SICleanupQueue</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>nthistime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<break>break;</break></block_content></block></else></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Insert new message(s) into proper slot of circular buffer
		 */</comment>
		<expr_stmt><expr><name>max</name> <operator>=</operator> <name><name>segP</name><operator>-&gt;</operator><name>maxMsgNum</name></name></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>nthistime</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>segP</name><operator>-&gt;</operator><name>buffer</name><index>[<expr><name>max</name> <operator>%</operator> <name>MAXNUMMESSAGES</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>data</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>max</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>

		<comment type="block">/* Update current value of maxMsgNum using spinlock */</comment>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>segP</name><operator>-&gt;</operator><name>msgnumLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>segP</name><operator>-&gt;</operator><name>maxMsgNum</name></name> <operator>=</operator> <name>max</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>segP</name><operator>-&gt;</operator><name>msgnumLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now that the maxMsgNum change is globally visible, we give everyone
		 * a swift kick to make sure they read the newly added messages.
		 * Releasing SInvalWriteLock will enforce a full memory barrier, so
		 * these (unlocked) changes will be committed to memory before we exit
		 * the function.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>segP</name><operator>-&gt;</operator><name>lastBackend</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ProcState</name>  <modifier>*</modifier></type><name>stateP</name> <init>= <expr><operator>&amp;</operator><name><name>segP</name><operator>-&gt;</operator><name>procState</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>stateP</name><operator>-&gt;</operator><name>hasMessages</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SInvalWriteLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * SIGetDataEntries
 *		get next SI message(s) for current backend, if there are any
 *
 * Possible return values:
 *	0:	 no SI message available
 *	n&gt;0: next n SI messages have been extracted into data[]
 * -1:	 SI reset message extracted
 *
 * If the return value is less than the array size "datasize", the caller
 * can assume that there are no more SI messages after the one(s) returned.
 * Otherwise, another call is needed to collect more messages.
 *
 * NB: this can run in parallel with other instances of SIGetDataEntries
 * executing on behalf of other backends, since each instance will modify only
 * fields of its own backend's ProcState, and no instance will look at fields
 * of other backends' ProcStates.  We express this by grabbing SInvalReadLock
 * in shared mode.  Note that this is not exactly the normal (read-only)
 * interpretation of a shared lock! Look closely at the interactions before
 * allowing SInvalReadLock to be grabbed in shared mode for any other reason!
 *
 * NB: this can also run in parallel with SIInsertDataEntries.  It is not
 * guaranteed that we will return any messages added after the routine is
 * entered.
 *
 * Note: we assume that "datasize" is not so large that it might be important
 * to break our hold on SInvalReadLock into segments.
 */</comment>
<function><type><name>int</name></type>
<name>SIGetDataEntries</name><parameter_list>(<parameter><decl><type><name>SharedInvalidationMessage</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>datasize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SISeg</name>	   <modifier>*</modifier></type><name>segP</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ProcState</name>  <modifier>*</modifier></type><name>stateP</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>max</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>segP</name> <operator>=</operator> <name>shmInvalBuffer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>stateP</name> <operator>=</operator> <operator>&amp;</operator><name><name>segP</name><operator>-&gt;</operator><name>procState</name><index>[<expr><name>MyBackendId</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Before starting to take locks, do a quick, unlocked test to see whether
	 * there can possibly be anything to read.  On a multiprocessor system,
	 * it's possible that this load could migrate backwards and occur before
	 * we actually enter this function, so we might miss a sinval message that
	 * was just added by some other processor.  But they can't migrate
	 * backwards over a preceding lock acquisition, so it should be OK.  If we
	 * haven't acquired a lock preventing against further relevant
	 * invalidations, any such occurrence is not much different than if the
	 * invalidation had arrived slightly later in the first place.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stateP</name><operator>-&gt;</operator><name>hasMessages</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SInvalReadLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We must reset hasMessages before determining how many messages we're
	 * going to read.  That way, if new messages arrive after we have
	 * determined how many we're reading, the flag will get reset and we'll
	 * notice those messages part-way through.
	 *
	 * Note that, if we don't end up reading all of the messages, we had
	 * better be certain to reset this flag before exiting!
	 */</comment>
	<expr_stmt><expr><name><name>stateP</name><operator>-&gt;</operator><name>hasMessages</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Fetch current value of maxMsgNum using spinlock */</comment>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>segP</name><operator>-&gt;</operator><name>msgnumLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>max</name> <operator>=</operator> <name><name>segP</name><operator>-&gt;</operator><name>maxMsgNum</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>segP</name><operator>-&gt;</operator><name>msgnumLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stateP</name><operator>-&gt;</operator><name>resetState</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Force reset.  We can say we have dealt with any messages added
		 * since the reset, as well; and that means we should clear the
		 * signaled flag, too.
		 */</comment>
		<expr_stmt><expr><name><name>stateP</name><operator>-&gt;</operator><name>nextMsgNum</name></name> <operator>=</operator> <name>max</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stateP</name><operator>-&gt;</operator><name>resetState</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stateP</name><operator>-&gt;</operator><name>signaled</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SInvalReadLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Retrieve messages and advance backend's counter, until data array is
	 * full or there are no more messages.
	 *
	 * There may be other backends that haven't read the message(s), so we
	 * cannot delete them here.  SICleanupQueue() will eventually remove them
	 * from the queue.
	 */</comment>
	<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>n</name> <operator>&lt;</operator> <name>datasize</name> <operator>&amp;&amp;</operator> <name><name>stateP</name><operator>-&gt;</operator><name>nextMsgNum</name></name> <operator>&lt;</operator> <name>max</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>data</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>segP</name><operator>-&gt;</operator><name>buffer</name><index>[<expr><name><name>stateP</name><operator>-&gt;</operator><name>nextMsgNum</name></name> <operator>%</operator> <name>MAXNUMMESSAGES</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stateP</name><operator>-&gt;</operator><name>nextMsgNum</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * If we have caught up completely, reset our "signaled" flag so that
	 * we'll get another signal if we fall behind again.
	 *
	 * If we haven't caught up completely, reset the hasMessages flag so that
	 * we see the remaining messages next time.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stateP</name><operator>-&gt;</operator><name>nextMsgNum</name></name> <operator>&gt;=</operator> <name>max</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>stateP</name><operator>-&gt;</operator><name>signaled</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>stateP</name><operator>-&gt;</operator><name>hasMessages</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SInvalReadLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SICleanupQueue
 *		Remove messages that have been consumed by all active backends
 *
 * callerHasWriteLock is true if caller is holding SInvalWriteLock.
 * minFree is the minimum number of message slots to make free.
 *
 * Possible side effects of this routine include marking one or more
 * backends as "reset" in the array, and sending PROCSIG_CATCHUP_INTERRUPT
 * to some backend that seems to be getting too far behind.  We signal at
 * most one backend at a time, for reasons explained at the top of the file.
 *
 * Caution: because we transiently release write lock when we have to signal
 * some other backend, it is NOT guaranteed that there are still minFree
 * free message slots at exit.  Caller must recheck and perhaps retry.
 */</comment>
<function><type><name>void</name></type>
<name>SICleanupQueue</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>callerHasWriteLock</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>minFree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SISeg</name>	   <modifier>*</modifier></type><name>segP</name> <init>= <expr><name>shmInvalBuffer</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>min</name></decl>,
				<decl><type ref="prev"/><name>minsig</name></decl>,
				<decl><type ref="prev"/><name>lowbound</name></decl>,
				<decl><type ref="prev"/><name>numMsgs</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ProcState</name>  <modifier>*</modifier></type><name>needSig</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Lock out all writers and readers */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>callerHasWriteLock</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SInvalWriteLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SInvalReadLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Recompute minMsgNum = minimum of all backends' nextMsgNum, identify the
	 * furthest-back backend that needs signaling (if any), and reset any
	 * backends that are too far back.  Note that because we ignore sendOnly
	 * backends here it is possible for them to keep sending messages without
	 * a problem even when they are the only active backend.
	 */</comment>
	<expr_stmt><expr><name>min</name> <operator>=</operator> <name><name>segP</name><operator>-&gt;</operator><name>maxMsgNum</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>minsig</name> <operator>=</operator> <name>min</name> <operator>-</operator> <name>SIG_THRESHOLD</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>lowbound</name> <operator>=</operator> <name>min</name> <operator>-</operator> <name>MAXNUMMESSAGES</name> <operator>+</operator> <name>minFree</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>segP</name><operator>-&gt;</operator><name>lastBackend</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ProcState</name>  <modifier>*</modifier></type><name>stateP</name> <init>= <expr><operator>&amp;</operator><name><name>segP</name><operator>-&gt;</operator><name>procState</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>n</name> <init>= <expr><name><name>stateP</name><operator>-&gt;</operator><name>nextMsgNum</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Ignore if inactive or already in reset state */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>stateP</name><operator>-&gt;</operator><name>procPid</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>stateP</name><operator>-&gt;</operator><name>resetState</name></name> <operator>||</operator> <name><name>stateP</name><operator>-&gt;</operator><name>sendOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If we must free some space and this backend is preventing it, force
		 * him into reset state and then ignore until he catches up.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <name>lowbound</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>stateP</name><operator>-&gt;</operator><name>resetState</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<comment type="block">/* no point in signaling him ... */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Track the global minimum nextMsgNum */</comment>
		<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <name>min</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>min</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Also see who's furthest back of the unsignaled backends */</comment>
		<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <name>minsig</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>stateP</name><operator>-&gt;</operator><name>signaled</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>minsig</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>needSig</name> <operator>=</operator> <name>stateP</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>segP</name><operator>-&gt;</operator><name>minMsgNum</name></name> <operator>=</operator> <name>min</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * When minMsgNum gets really large, decrement all message counters so as
	 * to forestall overflow of the counters.  This happens seldom enough that
	 * folding it into the previous loop would be a loser.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>min</name> <operator>&gt;=</operator> <name>MSGNUMWRAPAROUND</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>segP</name><operator>-&gt;</operator><name>minMsgNum</name></name> <operator>-=</operator> <name>MSGNUMWRAPAROUND</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>segP</name><operator>-&gt;</operator><name>maxMsgNum</name></name> <operator>-=</operator> <name>MSGNUMWRAPAROUND</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>segP</name><operator>-&gt;</operator><name>lastBackend</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/* we don't bother skipping inactive entries here */</comment>
			<expr_stmt><expr><name><name>segP</name><operator>-&gt;</operator><name>procState</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nextMsgNum</name> <operator>-=</operator> <name>MSGNUMWRAPAROUND</name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Determine how many messages are still in the queue, and set the
	 * threshold at which we should repeat SICleanupQueue().
	 */</comment>
	<expr_stmt><expr><name>numMsgs</name> <operator>=</operator> <name><name>segP</name><operator>-&gt;</operator><name>maxMsgNum</name></name> <operator>-</operator> <name><name>segP</name><operator>-&gt;</operator><name>minMsgNum</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>numMsgs</name> <operator>&lt;</operator> <name>CLEANUP_MIN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>segP</name><operator>-&gt;</operator><name>nextThreshold</name></name> <operator>=</operator> <name>CLEANUP_MIN</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>segP</name><operator>-&gt;</operator><name>nextThreshold</name></name> <operator>=</operator> <operator>(</operator><name>numMsgs</name> <operator>/</operator> <name>CLEANUP_QUANTUM</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>CLEANUP_QUANTUM</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Lastly, signal anyone who needs a catchup interrupt.  Since
	 * SendProcSignal() might not be fast, we don't want to hold locks while
	 * executing it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>needSig</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>pid_t</name></type>		<name>his_pid</name> <init>= <expr><name><name>needSig</name><operator>-&gt;</operator><name>procPid</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BackendId</name></type>	<name>his_backendId</name> <init>= <expr><operator>(</operator><name>needSig</name> <operator>-</operator> <operator>&amp;</operator><name><name>segP</name><operator>-&gt;</operator><name>procState</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>needSig</name><operator>-&gt;</operator><name>signaled</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SInvalReadLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SInvalWriteLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><literal type="string">"sending sinval catchup signal to PID %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>his_pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SendProcSignal</name><argument_list>(<argument><expr><name>his_pid</name></expr></argument>, <argument><expr><name>PROCSIG_CATCHUP_INTERRUPT</name></expr></argument>, <argument><expr><name>his_backendId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>callerHasWriteLock</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SInvalWriteLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SInvalReadLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>callerHasWriteLock</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SInvalWriteLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetNextLocalTransactionId --- allocate a new LocalTransactionId
 *
 * We split VirtualTransactionIds into two parts so that it is possible
 * to allocate a new one without any contention for shared memory, except
 * for a bit of additional overhead during backend startup/shutdown.
 * The high-order part of a VirtualTransactionId is a BackendId, and the
 * low-order part is a LocalTransactionId, which we assign from a local
 * counter.  To avoid the risk of a VirtualTransactionId being reused
 * within a short interval, successive procs occupying the same backend ID
 * slot should use a consecutive sequence of local IDs, which is implemented
 * by copying nextLocalTransactionId as seen above.
 */</comment>
<function><type><name>LocalTransactionId</name></type>
<name>GetNextLocalTransactionId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LocalTransactionId</name></type> <name>result</name></decl>;</decl_stmt>

	<comment type="block">/* loop to avoid returning InvalidLocalTransactionId at wraparound */</comment>
	<do>do
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>nextLocalTransactionId</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><operator>!</operator><call><name>LocalTransactionIdIsValid</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
</unit>
