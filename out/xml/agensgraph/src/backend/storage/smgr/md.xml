<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/storage/smgr/md.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * md.c
 *	  This code manages relations that reside on magnetic disk.
 *
 * Or at least, that was what the Berkeley folk had in mind when they named
 * this file.  In reality, what this code provides is an interface from
 * the smgr API to Unix-like filesystem APIs, so it will work with any type
 * of device for which the operating system provides filesystem support.
 * It doesn't matter whether the bits are on spinning rust or some other
 * storage technology.
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/storage/smgr/md.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/file.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlogutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_trace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/bgwriter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/md.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/relfilenode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/sync.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/hsearch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>

<comment type="block">/*
 *	The magnetic disk storage manager keeps track of open file
 *	descriptors in its own descriptor pool.  This is done to make it
 *	easier to support relations that are larger than the operating
 *	system's file size limit (often 2GBytes).  In order to do that,
 *	we break relations up into "segment" files that are each shorter than
 *	the OS file size limit.  The segment size is set by the RELSEG_SIZE
 *	configuration constant in pg_config.h.
 *
 *	On disk, a relation must consist of consecutively numbered segment
 *	files in the pattern
 *		-- Zero or more full segments of exactly RELSEG_SIZE blocks each
 *		-- Exactly one partial segment of size 0 &lt;= size &lt; RELSEG_SIZE blocks
 *		-- Optionally, any number of inactive segments of size 0 blocks.
 *	The full and partial segments are collectively the "active" segments.
 *	Inactive segments are those that once contained data but are currently
 *	not needed because of an mdtruncate() operation.  The reason for leaving
 *	them present at size zero, rather than unlinking them, is that other
 *	backends and/or the checkpointer might be holding open file references to
 *	such segments.  If the relation expands again after mdtruncate(), such
 *	that a deactivated segment becomes active again, it is important that
 *	such file references still be valid --- else data might get written
 *	out to an unlinked old copy of a segment file that will eventually
 *	disappear.
 *
 *	File descriptors are stored in the per-fork md_seg_fds arrays inside
 *	SMgrRelation. The length of these arrays is stored in md_num_open_segs.
 *	Note that a fork's md_num_open_segs having a specific value does not
 *	necessarily mean the relation doesn't have additional segments; we may
 *	just not have opened the next segment yet.  (We could not have "all
 *	segments are in the array" as an invariant anyway, since another backend
 *	could extend the relation while we aren't looking.)  We do not have
 *	entries for inactive segments, however; as soon as we find a partial
 *	segment, we assume that any subsequent segments are inactive.
 *
 *	The entire MdfdVec array is palloc'd in the MdCxt memory context.
 */</comment>

<typedef>typedef <type><struct>struct <name>_MdfdVec</name>
<block>{
	<decl_stmt><decl><type><name>File</name></type>		<name>mdfd_vfd</name></decl>;</decl_stmt>		<comment type="block">/* fd number in fd.c's pool */</comment>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>mdfd_segno</name></decl>;</decl_stmt>		<comment type="block">/* segment number, from 0 */</comment>
}</block></struct></type> <name>MdfdVec</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>MdCxt</name></decl>;</decl_stmt>		<comment type="block">/* context for all MdfdVec objects */</comment>


<comment type="block">/* Populate a file tag describing an md.c segment file. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INIT_MD_FILETAG</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>xx_rnode</name></type></parameter>,<parameter><type><name>xx_forknum</name></type></parameter>,<parameter><type><name>xx_segno</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>( \
	memset(&amp;(a), 0, sizeof(FileTag)), \
	(a).handler = SYNC_HANDLER_MD, \
	(a).rnode = (xx_rnode), \
	(a).forknum = (xx_forknum), \
	(a).segno = (xx_segno) \
)</cpp:value></cpp:define>


<comment type="block" format="doxygen">/*** behavior for mdopen &amp; _mdfd_getseg ***/</comment>
<comment type="block">/* ereport if segment not present */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXTENSION_FAIL</name></cpp:macro>				<cpp:value>(1 &lt;&lt; 0)</cpp:value></cpp:define>
<comment type="block">/* return NULL if segment not present */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXTENSION_RETURN_NULL</name></cpp:macro>		<cpp:value>(1 &lt;&lt; 1)</cpp:value></cpp:define>
<comment type="block">/* create new segments as needed */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXTENSION_CREATE</name></cpp:macro>			<cpp:value>(1 &lt;&lt; 2)</cpp:value></cpp:define>
<comment type="block">/* create new segments if needed during recovery */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXTENSION_CREATE_RECOVERY</name></cpp:macro>	<cpp:value>(1 &lt;&lt; 3)</cpp:value></cpp:define>
<comment type="block">/*
 * Allow opening segments which are preceded by segments smaller than
 * RELSEG_SIZE, e.g. inactive segments (see above). Note that this breaks
 * mdnblocks() and related functionality henceforth - which currently is ok,
 * because this is only required in the checkpointer which never uses
 * mdnblocks().
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXTENSION_DONT_CHECK_SIZE</name></cpp:macro>	<cpp:value>(1 &lt;&lt; 4)</cpp:value></cpp:define>


<comment type="block">/* local routines */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>mdunlinkfork</name><parameter_list>(<parameter><decl><type><name>RelFileNodeBackend</name></type> <name>rnode</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forkNum</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>isRedo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MdfdVec</name> <modifier>*</modifier></type><name>mdopenfork</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>behavior</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>register_dirty_segment</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>,
								   <parameter><decl><type><name>MdfdVec</name> <modifier>*</modifier></type><name>seg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>register_unlink_segment</name><parameter_list>(<parameter><decl><type><name>RelFileNodeBackend</name></type> <name>rnode</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>,
									<parameter><decl><type><name>BlockNumber</name></type> <name>segno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>register_forget_request</name><parameter_list>(<parameter><decl><type><name>RelFileNodeBackend</name></type> <name>rnode</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>,
									<parameter><decl><type><name>BlockNumber</name></type> <name>segno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_fdvec_resize</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>,
						  <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>,
						  <parameter><decl><type><name>int</name></type> <name>nseg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>_mdfd_segpath</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>,
						   <parameter><decl><type><name>BlockNumber</name></type> <name>segno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MdfdVec</name> <modifier>*</modifier></type><name>_mdfd_openseg</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forkno</name></decl></parameter>,
							  <parameter><decl><type><name>BlockNumber</name></type> <name>segno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>oflags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MdfdVec</name> <modifier>*</modifier></type><name>_mdfd_getseg</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forkno</name></decl></parameter>,
							 <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skipFsync</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>behavior</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>BlockNumber</name></type> <name>_mdnblocks</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>,
							  <parameter><decl><type><name>MdfdVec</name> <modifier>*</modifier></type><name>seg</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 *	mdinit() -- Initialize private state for magnetic disk storage manager.
 */</comment>
<function><type><name>void</name></type>
<name>mdinit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>MdCxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
								  <argument><expr><literal type="string">"MdSmgr"</literal></expr></argument>,
								  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	mdexists() -- Does the physical file exist?
 *
 * Note: this will return true for lingering files, with pending deletions
 */</comment>
<function><type><name>bool</name></type>
<name>mdexists</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forkNum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Close it first, to ensure that we notice if the fork has been unlinked
	 * since we opened it.
	 */</comment>
	<expr_stmt><expr><call><name>mdclose</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><call><name>mdopenfork</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>EXTENSION_RETURN_NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	mdcreate() -- Create a new relation on magnetic disk.
 *
 * If isRedo is true, it's okay for the relation to exist already.
 */</comment>
<function><type><name>void</name></type>
<name>mdcreate</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forkNum</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isRedo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MdfdVec</name>    <modifier>*</modifier></type><name>mdfd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>File</name></type>		<name>fd</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>isRedo</name> <operator>&amp;&amp;</operator> <name><name>reln</name><operator>-&gt;</operator><name>md_num_open_segs</name><index>[<expr><name>forkNum</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* created and opened already... */</comment>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>md_num_open_segs</name><index>[<expr><name>forkNum</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We may be using the target table space for the first time in this
	 * database, so create a per-database subdirectory if needed.
	 *
	 * XXX this is a fairly ugly violation of module layering, but this seems
	 * to be the best place to put the check.  Maybe TablespaceCreateDbspace
	 * should be here and not in commands/tablespace.c?  But that would imply
	 * importing a lot of stuff that smgr.c oughtn't know, either.
	 */</comment>
	<expr_stmt><expr><call><name>TablespaceCreateDbspace</name><argument_list>(<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>spcNode</name></name></expr></argument>,
							<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
							<argument><expr><name>isRedo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>relpath</name><argument_list>(<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name></name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>O_EXCL</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>isRedo</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* be sure to report the error reported by create, not open */</comment>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_fdvec_resize</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mdfd</name> <operator>=</operator> <operator>&amp;</operator><name><name>reln</name><operator>-&gt;</operator><name>md_seg_fds</name><index>[<expr><name>forkNum</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mdfd</name><operator>-&gt;</operator><name>mdfd_vfd</name></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mdfd</name><operator>-&gt;</operator><name>mdfd_segno</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	mdunlink() -- Unlink a relation.
 *
 * Note that we're passed a RelFileNodeBackend --- by the time this is called,
 * there won't be an SMgrRelation hashtable entry anymore.
 *
 * forkNum can be a fork number to delete a specific fork, or InvalidForkNumber
 * to delete all forks.
 *
 * For regular relations, we don't unlink the first segment file of the rel,
 * but just truncate it to zero length, and record a request to unlink it after
 * the next checkpoint.  Additional segments can be unlinked immediately,
 * however.  Leaving the empty file in place prevents that relfilenode
 * number from being reused.  The scenario this protects us from is:
 * 1. We delete a relation (and commit, and actually remove its file).
 * 2. We create a new relation, which by chance gets the same relfilenode as
 *	  the just-deleted one (OIDs must've wrapped around for that to happen).
 * 3. We crash before another checkpoint occurs.
 * During replay, we would delete the file and then recreate it, which is fine
 * if the contents of the file were repopulated by subsequent WAL entries.
 * But if we didn't WAL-log insertions, but instead relied on fsyncing the
 * file after populating it (as we do at wal_level=minimal), the contents of
 * the file would be lost forever.  By leaving the empty file until after the
 * next checkpoint, we prevent reassignment of the relfilenode number until
 * it's safe, because relfilenode assignment skips over any existing file.
 *
 * We do not need to go through this dance for temp relations, though, because
 * we never make WAL entries for temp rels, and so a temp rel poses no threat
 * to the health of a regular rel that has taken over its relfilenode number.
 * The fact that temp rels and regular rels have different file naming
 * patterns provides additional safety.
 *
 * All the above applies only to the relation's main fork; other forks can
 * just be removed immediately, since they are not needed to prevent the
 * relfilenode number from being recycled.  Also, we do not carefully
 * track whether other forks have been created or not, but just attempt to
 * unlink them unconditionally; so we should never complain about ENOENT.
 *
 * If isRedo is true, it's unsurprising for the relation to be already gone.
 * Also, we should remove the file immediately instead of queuing a request
 * for later, since during redo there's no possibility of creating a
 * conflicting relation.
 *
 * Note: any failure should be reported as WARNING not ERROR, because
 * we are usually not in a transaction anymore when this is called.
 */</comment>
<function><type><name>void</name></type>
<name>mdunlink</name><parameter_list>(<parameter><decl><type><name>RelFileNodeBackend</name></type> <name>rnode</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forkNum</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isRedo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Now do the per-fork work */</comment>
	<if_stmt><if>if <condition>(<expr><name>forkNum</name> <operator>==</operator> <name>InvalidForkNumber</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>forkNum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>forkNum</name> <operator>&lt;=</operator> <name>MAX_FORKNUM</name></expr>;</condition> <incr><expr><name>forkNum</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>mdunlinkfork</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>isRedo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>mdunlinkfork</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>isRedo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Truncate a file to release disk space.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>do_truncate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>

	<comment type="block">/* truncate(2) would be easier here, but Windows hasn't got it */</comment>
	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>OpenTransientFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ftruncate</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>save_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Log a warning here to avoid repetition in callers. */</comment>
	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>save_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not truncate file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>mdunlinkfork</name><parameter_list>(<parameter><decl><type><name>RelFileNodeBackend</name></type> <name>rnode</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forkNum</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isRedo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>relpath</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Delete or truncate the first segment.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isRedo</name> <operator>||</operator> <name>forkNum</name> <operator>!=</operator> <name>MAIN_FORKNUM</name> <operator>||</operator> <call><name>RelFileNodeBackendIsTemp</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelFileNodeBackendIsTemp</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Prevent other backends' fds from holding on to the disk space */</comment>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>do_truncate</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Forget any pending sync requests for the first segment */</comment>
			<expr_stmt><expr><call><name>register_forget_request</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* first seg */</comment> )</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Next unlink the file, unless it was already found to be missing */</comment>
		<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>unlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Prevent other backends' fds from holding on to the disk space */</comment>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>do_truncate</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Register request to unlink first segment later */</comment>
		<expr_stmt><expr><call><name>register_unlink_segment</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* first seg */</comment> )</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Delete any additional segments.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>segpath</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">12</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>segno</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Note that because we loop until getting ENOENT, we will correctly
		 * remove all inactive segments as well as active ones.
		 */</comment>
		<for>for <control>(<init><expr><name>segno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init><condition>;</condition> <incr><expr><name>segno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>segpath</name></expr></argument>, <argument><expr><literal type="string">"%s.%u"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelFileNodeBackendIsTemp</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Prevent other backends' fds from holding on to the disk
				 * space.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>do_truncate</name><argument_list>(<argument><expr><name>segpath</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Forget any pending sync requests for this segment before we
				 * try to unlink.
				 */</comment>
				<expr_stmt><expr><call><name>register_forget_request</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>segpath</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* ENOENT is expected after the last segment... */</comment>
				<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>segpath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>segpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	mdextend() -- Add a block to the specified relation.
 *
 *		The semantics are nearly the same as mdwrite(): write at the
 *		specified position.  However, this is to be used for the case of
 *		extending a relation (i.e., blocknum is at or beyond the current
 *		EOF).  Note that we assume writing a block beyond current EOF
 *		causes intervening file space to become filled with zeroes.
 */</comment>
<function><type><name>void</name></type>
<name>mdextend</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>,
		 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skipFsync</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>off_t</name></type>		<name>seekpos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nbytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MdfdVec</name>    <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

	<comment type="block">/* This assert is too expensive to have on normally ... */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CHECK_WRITE_VS_EXTEND</name></cpp:ifdef>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>blocknum</name> <operator>&gt;=</operator> <call><name>mdnblocks</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * If a relation manages to grow to 2^32-1 blocks, refuse to extend it any
	 * more --- we mustn't create a block whose number actually is
	 * InvalidBlockNumber.  (Note that this failure should be unreachable
	 * because of upstream checks in bufmgr.c.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>blocknum</name> <operator>==</operator> <name>InvalidBlockNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot extend file \"%s\" beyond %u blocks"</literal></expr></argument>,
						<argument><expr><call><name>relpath</name><argument_list>(<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name></name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>InvalidBlockNumber</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>_mdfd_getseg</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>, <argument><expr><name>skipFsync</name></expr></argument>, <argument><expr><name>EXTENSION_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>seekpos</name> <operator>=</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>BLCKSZ</name> <operator>*</operator> <operator>(</operator><name>blocknum</name> <operator>%</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>seekpos</name> <operator>&lt;</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>BLCKSZ</name> <operator>*</operator> <name>RELSEG_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>nbytes</name> <operator>=</operator> <call><name>FileWrite</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>, <argument><expr><name>seekpos</name></expr></argument>, <argument><expr><name>WAIT_EVENT_DATA_FILE_EXTEND</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>BLCKSZ</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not extend file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><call><name>FilePathName</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Check free disk space."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* short write: complain appropriately */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DISK_FULL</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not extend file \"%s\": wrote only %d of %d bytes at block %u"</literal></expr></argument>,
						<argument><expr><call><name>FilePathName</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Check free disk space."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>skipFsync</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>SmgrIsTemp</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>register_dirty_segment</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>_mdnblocks</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	mdopenfork() -- Open one fork of the specified relation.
 *
 * Note we only open the first segment, when there are multiple segments.
 *
 * If first segment is not present, either ereport or return NULL according
 * to "behavior".  We treat EXTENSION_CREATE the same as EXTENSION_FAIL;
 * EXTENSION_CREATE means it's OK to extend an existing relation, not to
 * invent one out of whole cloth.
 */</comment>
<function><type><specifier>static</specifier> <name>MdfdVec</name> <modifier>*</modifier></type>
<name>mdopenfork</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>behavior</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MdfdVec</name>    <modifier>*</modifier></type><name>mdfd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>File</name></type>		<name>fd</name></decl>;</decl_stmt>

	<comment type="block">/* No work if already open */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>reln</name><operator>-&gt;</operator><name>md_num_open_segs</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>&amp;</operator><name><name>reln</name><operator>-&gt;</operator><name>md_seg_fds</name><index>[<expr><name>forknum</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>relpath</name><argument_list>(<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name></name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>behavior</name> <operator>&amp;</operator> <name>EXTENSION_RETURN_NULL</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<call><name>FILE_POSSIBLY_DELETED</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_fdvec_resize</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mdfd</name> <operator>=</operator> <operator>&amp;</operator><name><name>reln</name><operator>-&gt;</operator><name>md_seg_fds</name><index>[<expr><name>forknum</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mdfd</name><operator>-&gt;</operator><name>mdfd_vfd</name></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mdfd</name><operator>-&gt;</operator><name>mdfd_segno</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>_mdnblocks</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>mdfd</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>mdfd</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *  mdopen() -- Initialize newly-opened relation.
 */</comment>
<function><type><name>void</name></type>
<name>mdopen</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* mark it not open */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>forknum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>forknum</name> <operator>&lt;=</operator> <name>MAX_FORKNUM</name></expr>;</condition> <incr><expr><name>forknum</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>md_num_open_segs</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/*
 *	mdclose() -- Close the specified relation, if it isn't closed already.
 */</comment>
<function><type><name>void</name></type>
<name>mdclose</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nopensegs</name> <init>= <expr><name><name>reln</name><operator>-&gt;</operator><name>md_num_open_segs</name><index>[<expr><name>forknum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* No work if already closed */</comment>
	<if_stmt><if>if <condition>(<expr><name>nopensegs</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* close segments starting from the end */</comment>
	<while>while <condition>(<expr><name>nopensegs</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MdfdVec</name>    <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>&amp;</operator><name><name>reln</name><operator>-&gt;</operator><name>md_seg_fds</name><index>[<expr><name>forknum</name></expr>]</index><index>[<expr><name>nopensegs</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_fdvec_resize</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>nopensegs</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nopensegs</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 *	mdprefetch() -- Initiate asynchronous read of the specified block of a relation
 */</comment>
<function><type><name>bool</name></type>
<name>mdprefetch</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_PREFETCH</name></cpp:ifdef>
	<decl_stmt><decl><type><name>off_t</name></type>		<name>seekpos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MdfdVec</name>    <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>_mdfd_getseg</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
					 <argument><expr><ternary><condition><expr><name>InRecovery</name></expr> ?</condition><then> <expr><name>EXTENSION_RETURN_NULL</name></expr> </then><else>: <expr><name>EXTENSION_FAIL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>seekpos</name> <operator>=</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>BLCKSZ</name> <operator>*</operator> <operator>(</operator><name>blocknum</name> <operator>%</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>seekpos</name> <operator>&lt;</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>BLCKSZ</name> <operator>*</operator> <name>RELSEG_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>FilePrefetch</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>, <argument><expr><name>seekpos</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>, <argument><expr><name>WAIT_EVENT_DATA_FILE_PREFETCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_PREFETCH */</comment>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * mdwriteback() -- Tell the kernel to write pages back to storage.
 *
 * This accepts a range of blocks because flushing several pages at once is
 * considerably more efficient than doing so individually.
 */</comment>
<function><type><name>void</name></type>
<name>mdwriteback</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>,
			<parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>nblocks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Issue flush requests in as few requests as possible; have to split at
	 * segment boundaries though, since those are actually separate files.
	 */</comment>
	<while>while <condition>(<expr><name>nblocks</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>nflush</name> <init>= <expr><name>nblocks</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>off_t</name></type>		<name>seekpos</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MdfdVec</name>    <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>segnum_start</name></decl>,
					<decl><type ref="prev"/><name>segnum_end</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>_mdfd_getseg</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>, <argument><expr><name>true</name></expr></argument> <comment type="block">/* not used */</comment> ,
						 <argument><expr><name>EXTENSION_RETURN_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We might be flushing buffers of already removed relations, that's
		 * ok, just ignore that case.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>v</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/* compute offset inside the current segment */</comment>
		<expr_stmt><expr><name>segnum_start</name> <operator>=</operator> <name>blocknum</name> <operator>/</operator> <name>RELSEG_SIZE</name></expr>;</expr_stmt>

		<comment type="block">/* compute number of desired writes within the current segment */</comment>
		<expr_stmt><expr><name>segnum_end</name> <operator>=</operator> <operator>(</operator><name>blocknum</name> <operator>+</operator> <name>nblocks</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>RELSEG_SIZE</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>segnum_start</name> <operator>!=</operator> <name>segnum_end</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nflush</name> <operator>=</operator> <name>RELSEG_SIZE</name> <operator>-</operator> <operator>(</operator><name>blocknum</name> <operator>%</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nflush</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nflush</name> <operator>&lt;=</operator> <name>nblocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>seekpos</name> <operator>=</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>BLCKSZ</name> <operator>*</operator> <operator>(</operator><name>blocknum</name> <operator>%</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>FileWriteback</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>, <argument><expr><name>seekpos</name></expr></argument>, <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator> <name>BLCKSZ</name> <operator>*</operator> <name>nflush</name></expr></argument>, <argument><expr><name>WAIT_EVENT_DATA_FILE_FLUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>nblocks</name> <operator>-=</operator> <name>nflush</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>blocknum</name> <operator>+=</operator> <name>nflush</name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 *	mdread() -- Read the specified block from a relation.
 */</comment>
<function><type><name>void</name></type>
<name>mdread</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>,
	   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>off_t</name></type>		<name>seekpos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nbytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MdfdVec</name>    <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_SMGR_MD_READ_START</name><argument_list>(<argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>,
										<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>spcNode</name></name></expr></argument>,
										<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
										<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
										<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>backend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>_mdfd_getseg</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
					 <argument><expr><name>EXTENSION_FAIL</name> <operator>|</operator> <name>EXTENSION_CREATE_RECOVERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>seekpos</name> <operator>=</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>BLCKSZ</name> <operator>*</operator> <operator>(</operator><name>blocknum</name> <operator>%</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>seekpos</name> <operator>&lt;</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>BLCKSZ</name> <operator>*</operator> <name>RELSEG_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>FileRead</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>, <argument><expr><name>seekpos</name></expr></argument>, <argument><expr><name>WAIT_EVENT_DATA_FILE_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_SMGR_MD_READ_DONE</name><argument_list>(<argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>,
									   <argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>spcNode</name></name></expr></argument>,
									   <argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
									   <argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
									   <argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>backend</name></name></expr></argument>,
									   <argument><expr><name>nbytes</name></expr></argument>,
									   <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>!=</operator> <name>BLCKSZ</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read block %u in file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>blocknum</name></expr></argument>, <argument><expr><call><name>FilePathName</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Short read: we are at or past EOF, or we read a partial block at
		 * EOF.  Normally this is an error; upper levels should never try to
		 * read a nonexistent block.  However, if zero_damaged_pages is ON or
		 * we are InRecovery, we should instead return zeroes without
		 * complaining.  This allows, for example, the case of trying to
		 * update a block that was later truncated away.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>zero_damaged_pages</name> <operator>||</operator> <name>InRecovery</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read block %u in file \"%s\": read only %d of %d bytes"</literal></expr></argument>,
							<argument><expr><name>blocknum</name></expr></argument>, <argument><expr><call><name>FilePathName</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	mdwrite() -- Write the supplied block at the appropriate location.
 *
 *		This is to be used only for updating already-existing blocks of a
 *		relation (ie, those before the current EOF).  To extend a relation,
 *		use mdextend().
 */</comment>
<function><type><name>void</name></type>
<name>mdwrite</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>,
		<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skipFsync</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>off_t</name></type>		<name>seekpos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nbytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MdfdVec</name>    <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

	<comment type="block">/* This assert is too expensive to have on normally ... */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CHECK_WRITE_VS_EXTEND</name></cpp:ifdef>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>blocknum</name> <operator>&lt;</operator> <call><name>mdnblocks</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_SMGR_MD_WRITE_START</name><argument_list>(<argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>,
										 <argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>spcNode</name></name></expr></argument>,
										 <argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
										 <argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
										 <argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>backend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>_mdfd_getseg</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>, <argument><expr><name>skipFsync</name></expr></argument>,
					 <argument><expr><name>EXTENSION_FAIL</name> <operator>|</operator> <name>EXTENSION_CREATE_RECOVERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>seekpos</name> <operator>=</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>BLCKSZ</name> <operator>*</operator> <operator>(</operator><name>blocknum</name> <operator>%</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>seekpos</name> <operator>&lt;</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>BLCKSZ</name> <operator>*</operator> <name>RELSEG_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>FileWrite</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>, <argument><expr><name>seekpos</name></expr></argument>, <argument><expr><name>WAIT_EVENT_DATA_FILE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_SMGR_MD_WRITE_DONE</name><argument_list>(<argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>,
										<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>spcNode</name></name></expr></argument>,
										<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
										<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
										<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>backend</name></name></expr></argument>,
										<argument><expr><name>nbytes</name></expr></argument>,
										<argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>!=</operator> <name>BLCKSZ</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write block %u in file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>blocknum</name></expr></argument>, <argument><expr><call><name>FilePathName</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* short write: complain appropriately */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DISK_FULL</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write block %u in file \"%s\": wrote only %d of %d bytes"</literal></expr></argument>,
						<argument><expr><name>blocknum</name></expr></argument>,
						<argument><expr><call><name>FilePathName</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Check free disk space."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>skipFsync</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>SmgrIsTemp</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>register_dirty_segment</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	mdnblocks() -- Get the number of blocks stored in a relation.
 *
 *		Important side effect: all active segments of the relation are opened
 *		and added to the md_seg_fds array.  If this routine has not been
 *		called, then only segments up to the last one actually touched
 *		are present in the array.
 */</comment>
<function><type><name>BlockNumber</name></type>
<name>mdnblocks</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MdfdVec</name>    <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>mdopenfork</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>EXTENSION_FAIL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>nblocks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>segno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* mdopen has opened the first segment */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>md_num_open_segs</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Start from the last open segments, to avoid redundant seeks.  We have
	 * previously verified that these segments are exactly RELSEG_SIZE long,
	 * and it's useless to recheck that each time.
	 *
	 * NOTE: this assumption could only be wrong if another backend has
	 * truncated the relation.  We rely on higher code levels to handle that
	 * scenario by closing and re-opening the md fd, which is handled via
	 * relcache flush.  (Since the checkpointer doesn't participate in
	 * relcache flush, it could have segment entries for inactive segments;
	 * that's OK because the checkpointer never needs to compute relation
	 * size.)
	 */</comment>
	<expr_stmt><expr><name>segno</name> <operator>=</operator> <name><name>reln</name><operator>-&gt;</operator><name>md_num_open_segs</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>&amp;</operator><name><name>reln</name><operator>-&gt;</operator><name>md_seg_fds</name><index>[<expr><name>forknum</name></expr>]</index><index>[<expr><name>segno</name></expr>]</index></name></expr>;</expr_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>nblocks</name> <operator>=</operator> <call><name>_mdnblocks</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>nblocks</name> <operator>&gt;</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"segment too big"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>nblocks</name> <operator>&lt;</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>(</operator><name>segno</name> <operator>*</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator><operator>)</operator> <operator>+</operator> <name>nblocks</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If segment is exactly RELSEG_SIZE, advance to next one.
		 */</comment>
		<expr_stmt><expr><name>segno</name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * We used to pass O_CREAT here, but that has the disadvantage that it
		 * might create a segment which has vanished through some operating
		 * system misadventure.  In such a case, creating the segment here
		 * undermines _mdfd_getseg's attempts to notice and report an error
		 * upon access to a missing segment.
		 */</comment>
		<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>_mdfd_openseg</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>segno</name> <operator>*</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 *	mdtruncate() -- Truncate relation to specified number of blocks.
 */</comment>
<function><type><name>void</name></type>
<name>mdtruncate</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>nblocks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>curnblk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>priorblocks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>curopensegs</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * NOTE: mdnblocks makes sure we have opened all active segments, so that
	 * truncation loop will get them all!
	 */</comment>
	<expr_stmt><expr><name>curnblk</name> <operator>=</operator> <call><name>mdnblocks</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nblocks</name> <operator>&gt;</operator> <name>curnblk</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Bogus request ... but no complaint if InRecovery */</comment>
		<if_stmt><if>if <condition>(<expr><name>InRecovery</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not truncate file \"%s\" to %u blocks: it's only %u blocks now"</literal></expr></argument>,
						<argument><expr><call><name>relpath</name><argument_list>(<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name></name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>nblocks</name></expr></argument>, <argument><expr><name>curnblk</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>nblocks</name> <operator>==</operator> <name>curnblk</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* no work */</comment>

	<comment type="block">/*
	 * Truncate segments, starting at the last one. Starting at the end makes
	 * managing the memory for the fd array easier, should there be errors.
	 */</comment>
	<expr_stmt><expr><name>curopensegs</name> <operator>=</operator> <name><name>reln</name><operator>-&gt;</operator><name>md_num_open_segs</name><index>[<expr><name>forknum</name></expr>]</index></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>curopensegs</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MdfdVec</name>    <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>priorblocks</name> <operator>=</operator> <operator>(</operator><name>curopensegs</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>RELSEG_SIZE</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>&amp;</operator><name><name>reln</name><operator>-&gt;</operator><name>md_seg_fds</name><index>[<expr><name>forknum</name></expr>]</index><index>[<expr><name>curopensegs</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>priorblocks</name> <operator>&gt;</operator> <name>nblocks</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * This segment is no longer active. We truncate the file, but do
			 * not delete it, for reasons explained in the header comments.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>FileTruncate</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>WAIT_EVENT_DATA_FILE_TRUNCATE</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not truncate file \"%s\": %m"</literal></expr></argument>,
								<argument><expr><call><name>FilePathName</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SmgrIsTemp</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>register_dirty_segment</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* we never drop the 1st segment */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>v</name> <operator>!=</operator> <operator>&amp;</operator><name><name>reln</name><operator>-&gt;</operator><name>md_seg_fds</name><index>[<expr><name>forknum</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>_fdvec_resize</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>curopensegs</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>priorblocks</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator> <operator>&gt;</operator> <name>nblocks</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * This is the last segment we want to keep. Truncate the file to
			 * the right length. NOTE: if nblocks is exactly a multiple K of
			 * RELSEG_SIZE, we will truncate the K+1st segment to 0 length but
			 * keep it. This adheres to the invariant given in the header
			 * comments.
			 */</comment>
			<decl_stmt><decl><type><name>BlockNumber</name></type> <name>lastsegblocks</name> <init>= <expr><name>nblocks</name> <operator>-</operator> <name>priorblocks</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>FileTruncate</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>, <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator> <name>lastsegblocks</name> <operator>*</operator> <name>BLCKSZ</name></expr></argument>, <argument><expr><name>WAIT_EVENT_DATA_FILE_TRUNCATE</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not truncate file \"%s\" to %u blocks: %m"</literal></expr></argument>,
								<argument><expr><call><name>FilePathName</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>nblocks</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SmgrIsTemp</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>register_dirty_segment</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * We still need this segment, so nothing to do for this and any
			 * earlier segment.
			 */</comment>
			<break>break;</break>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>curopensegs</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 *	mdimmedsync() -- Immediately sync a relation to stable storage.
 *
 * Note that only writes already issued are synced; this routine knows
 * nothing of dirty buffers that may exist inside the buffer manager.  We
 * sync active and inactive segments; smgrDoPendingSyncs() relies on this.
 * Consider a relation skipping WAL.  Suppose a checkpoint syncs blocks of
 * some segment, then mdtruncate() renders that segment inactive.  If we
 * crash before the next checkpoint syncs the newly-inactive segment, that
 * segment may survive recovery, reintroducing unwanted data into the table.
 */</comment>
<function><type><name>void</name></type>
<name>mdimmedsync</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>segno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>min_inactive_seg</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * NOTE: mdnblocks makes sure we have opened all active segments, so that
	 * fsync loop will get them all!
	 */</comment>
	<expr_stmt><expr><call><name>mdnblocks</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>min_inactive_seg</name> <operator>=</operator> <name>segno</name> <operator>=</operator> <name><name>reln</name><operator>-&gt;</operator><name>md_num_open_segs</name><index>[<expr><name>forknum</name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Temporarily open inactive segments, then close them after sync.  There
	 * may be some inactive segments left opened after fsync() error, but that
	 * is harmless.  We don't bother to clean them up and take a risk of
	 * further trouble.  The next mdclose() will soon close them.
	 */</comment>
	<while>while <condition>(<expr><call><name>_mdfd_openseg</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>segno</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

	<while>while <condition>(<expr><name>segno</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MdfdVec</name>    <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>&amp;</operator><name><name>reln</name><operator>-&gt;</operator><name>md_seg_fds</name><index>[<expr><name>forknum</name></expr>]</index><index>[<expr><name>segno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>FileSync</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>, <argument><expr><name>WAIT_EVENT_DATA_FILE_IMMEDIATE_SYNC</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><call><name>data_sync_elevel</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fsync file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><call><name>FilePathName</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Close inactive segments immediately */</comment>
		<if_stmt><if>if <condition>(<expr><name>segno</name> <operator>&gt;</operator> <name>min_inactive_seg</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>_fdvec_resize</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>segno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>segno</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * register_dirty_segment() -- Mark a relation segment as needing fsync
 *
 * If there is a local pending-ops table, just make an entry in it for
 * ProcessSyncRequests to process later.  Otherwise, try to pass off the
 * fsync request to the checkpointer process.  If that fails, just do the
 * fsync locally before returning (we hope this will not happen often
 * enough to be a performance problem).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>register_dirty_segment</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>MdfdVec</name> <modifier>*</modifier></type><name>seg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FileTag</name></type>		<name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>INIT_MD_FILETAG</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name></name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name><name>seg</name><operator>-&gt;</operator><name>mdfd_segno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Temp relations should never be fsync'd */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>SmgrIsTemp</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RegisterSyncRequest</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>SYNC_REQUEST</name></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* retryOnError */</comment> )</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not forward fsync request because request queue is full"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>FileSync</name><argument_list>(<argument><expr><name><name>seg</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>, <argument><expr><name>WAIT_EVENT_DATA_FILE_SYNC</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><call><name>data_sync_elevel</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fsync file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><call><name>FilePathName</name><argument_list>(<argument><expr><name><name>seg</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * register_unlink_segment() -- Schedule a file to be deleted after next checkpoint
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>register_unlink_segment</name><parameter_list>(<parameter><decl><type><name>RelFileNodeBackend</name></type> <name>rnode</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>,
						<parameter><decl><type><name>BlockNumber</name></type> <name>segno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FileTag</name></type>		<name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>INIT_MD_FILETAG</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name><name>rnode</name><operator>.</operator><name>node</name></name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Should never be used with temp relations */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>RelFileNodeBackendIsTemp</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>RegisterSyncRequest</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>SYNC_UNLINK_REQUEST</name></expr></argument>, <argument><expr><name>true</name></expr></argument> <comment type="block">/* retryOnError */</comment> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * register_forget_request() -- forget any fsyncs for a relation fork's segment
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>register_forget_request</name><parameter_list>(<parameter><decl><type><name>RelFileNodeBackend</name></type> <name>rnode</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>,
						<parameter><decl><type><name>BlockNumber</name></type> <name>segno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FileTag</name></type>		<name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>INIT_MD_FILETAG</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name><name>rnode</name><operator>.</operator><name>node</name></name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>RegisterSyncRequest</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>SYNC_FORGET_REQUEST</name></expr></argument>, <argument><expr><name>true</name></expr></argument> <comment type="block">/* retryOnError */</comment> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ForgetDatabaseSyncRequests -- forget any fsyncs and unlinks for a DB
 */</comment>
<function><type><name>void</name></type>
<name>ForgetDatabaseSyncRequests</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>dbid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FileTag</name></type>		<name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>dbNode</name></name> <operator>=</operator> <name>dbid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>spcNode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>relNode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>INIT_MD_FILETAG</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>InvalidForkNumber</name></expr></argument>, <argument><expr><name>InvalidBlockNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>RegisterSyncRequest</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>SYNC_FILTER_REQUEST</name></expr></argument>, <argument><expr><name>true</name></expr></argument> <comment type="block">/* retryOnError */</comment> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * DropRelationFiles -- drop files of all given relations
 */</comment>
<function><type><name>void</name></type>
<name>DropRelationFiles</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name> <modifier>*</modifier></type><name>delrels</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ndelrels</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isRedo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SMgrRelation</name> <modifier>*</modifier></type><name>srels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>srels</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SMgrRelation</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ndelrels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndelrels</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SMgrRelation</name></type> <name>srel</name> <init>= <expr><call><name>smgropen</name><argument_list>(<argument><expr><name><name>delrels</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>InvalidBackendId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>isRedo</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ForkNumber</name></type>	<name>fork</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>fork</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>fork</name> <operator>&lt;=</operator> <name>MAX_FORKNUM</name></expr>;</condition> <incr><expr><name>fork</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>XLogDropRelation</name><argument_list>(<argument><expr><name><name>delrels</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>fork</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>srels</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>srel</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>smgrdounlinkall</name><argument_list>(<argument><expr><name>srels</name></expr></argument>, <argument><expr><name>ndelrels</name></expr></argument>, <argument><expr><name>isRedo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndelrels</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>smgrclose</name><argument_list>(<argument><expr><name><name>srels</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>srels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *	_fdvec_resize() -- Resize the fork's open segments array
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_fdvec_resize</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>,
			  <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>nseg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>nseg</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>reln</name><operator>-&gt;</operator><name>md_num_open_segs</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>md_seg_fds</name><index>[<expr><name>forknum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>md_seg_fds</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>reln</name><operator>-&gt;</operator><name>md_num_open_segs</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>md_seg_fds</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>=</operator>
			<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>MdCxt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MdfdVec</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nseg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * It doesn't seem worthwhile complicating the code to amortize
		 * repalloc() calls.  Those are far faster than PathNameOpenFile() or
		 * FileClose(), and the memory context internally will sometimes avoid
		 * doing an actual reallocation.
		 */</comment>
		<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>md_seg_fds</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>=</operator>
			<call><name>repalloc</name><argument_list>(<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>md_seg_fds</name><index>[<expr><name>forknum</name></expr>]</index></name></expr></argument>,
					 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MdfdVec</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nseg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>md_num_open_segs</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>=</operator> <name>nseg</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return the filename for the specified segment of the relation. The
 * returned string is palloc'd.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>_mdfd_segpath</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>segno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>path</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>fullpath</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>relpath</name><argument_list>(<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name></name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>segno</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>fullpath</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s.%u"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>fullpath</name> <operator>=</operator> <name>path</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>fullpath</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Open the specified segment of the relation,
 * and make a MdfdVec object for it.  Returns NULL on failure.
 */</comment>
<function><type><specifier>static</specifier> <name>MdfdVec</name> <modifier>*</modifier></type>
<name>_mdfd_openseg</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>segno</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>oflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MdfdVec</name>    <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>File</name></type>		<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fullpath</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>fullpath</name> <operator>=</operator> <call><name>_mdfd_segpath</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* open the file */</comment>
	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>fullpath</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>PG_BINARY</name> <operator>|</operator> <name>oflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>fullpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Segments are always opened in order from lowest to highest, so we must
	 * be adding a new one at the end.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>segno</name> <operator>==</operator> <name><name>reln</name><operator>-&gt;</operator><name>md_num_open_segs</name><index>[<expr><name>forknum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_fdvec_resize</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>segno</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* fill the entry */</comment>
	<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>&amp;</operator><name><name>reln</name><operator>-&gt;</operator><name>md_seg_fds</name><index>[<expr><name>forknum</name></expr>]</index><index>[<expr><name>segno</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_segno</name></name> <operator>=</operator> <name>segno</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>_mdnblocks</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* all done */</comment>
	<return>return <expr><name>v</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	_mdfd_getseg() -- Find the segment of the relation holding the
 *		specified block.
 *
 * If the segment doesn't exist, we ereport, return NULL, or create the
 * segment, according to "behavior".  Note: skipFsync is only used in the
 * EXTENSION_CREATE case.
 */</comment>
<function><type><specifier>static</specifier> <name>MdfdVec</name> <modifier>*</modifier></type>
<name>_mdfd_getseg</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>,
			 <parameter><decl><type><name>bool</name></type> <name>skipFsync</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>behavior</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MdfdVec</name>    <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>targetseg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>nextsegno</name></decl>;</decl_stmt>

	<comment type="block">/* some way to handle non-existent segments needs to be specified */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>behavior</name> <operator>&amp;</operator>
		   <operator>(</operator><name>EXTENSION_FAIL</name> <operator>|</operator> <name>EXTENSION_CREATE</name> <operator>|</operator> <name>EXTENSION_RETURN_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>targetseg</name> <operator>=</operator> <name>blkno</name> <operator>/</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* if an existing and opened segment, we're done */</comment>
	<if_stmt><if>if <condition>(<expr><name>targetseg</name> <operator>&lt;</operator> <name><name>reln</name><operator>-&gt;</operator><name>md_num_open_segs</name><index>[<expr><name>forknum</name></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>&amp;</operator><name><name>reln</name><operator>-&gt;</operator><name>md_seg_fds</name><index>[<expr><name>forknum</name></expr>]</index><index>[<expr><name>targetseg</name></expr>]</index></name></expr>;</expr_stmt>
		<return>return <expr><name>v</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The target segment is not yet open. Iterate over all the segments
	 * between the last opened and the target segment. This way missing
	 * segments either raise an error, or get created (according to
	 * 'behavior'). Start with either the last opened, or the first segment if
	 * none was opened before.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>reln</name><operator>-&gt;</operator><name>md_num_open_segs</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>&amp;</operator><name><name>reln</name><operator>-&gt;</operator><name>md_seg_fds</name><index>[<expr><name>forknum</name></expr>]</index><index>[<expr><name><name>reln</name><operator>-&gt;</operator><name>md_num_open_segs</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>mdopenfork</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>behavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>v</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* if behavior &amp; EXTENSION_RETURN_NULL */</comment>
	</block_content>}</block></else></if_stmt>

	<for>for <control>(<init><expr><name>nextsegno</name> <operator>=</operator> <name><name>reln</name><operator>-&gt;</operator><name>md_num_open_segs</name><index>[<expr><name>forknum</name></expr>]</index></name></expr>;</init>
		 <condition><expr><name>nextsegno</name> <operator>&lt;=</operator> <name>targetseg</name></expr>;</condition> <incr><expr><name>nextsegno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>nblocks</name> <init>= <expr><call><name>_mdnblocks</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nextsegno</name> <operator>==</operator> <name><name>v</name><operator>-&gt;</operator><name>mdfd_segno</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>nblocks</name> <operator>&gt;</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"segment too big"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>behavior</name> <operator>&amp;</operator> <name>EXTENSION_CREATE</name><operator>)</operator> <operator>||</operator>
			<operator>(</operator><name>InRecovery</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>behavior</name> <operator>&amp;</operator> <name>EXTENSION_CREATE_RECOVERY</name><operator>)</operator><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Normally we will create new segments only if authorized by the
			 * caller (i.e., we are doing mdextend()).  But when doing WAL
			 * recovery, create segments anyway; this allows cases such as
			 * replaying WAL data that has a write into a high-numbered
			 * segment of a relation that was later deleted. We want to go
			 * ahead and create the segments so we can finish out the replay.
			 *
			 * We have to maintain the invariant that segments before the last
			 * active segment are of size RELSEG_SIZE; therefore, if
			 * extending, pad them out with zeroes if needed.  (This only
			 * matters if in recovery, or if the caller is extending the
			 * relation discontiguously, but that can happen in hash indexes.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>nblocks</name> <operator>&lt;</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>zerobuf</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>mdextend</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>,
						 <argument><expr><name>nextsegno</name> <operator>*</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
						 <argument><expr><name>zerobuf</name></expr></argument>, <argument><expr><name>skipFsync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>zerobuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>O_CREAT</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><name>behavior</name> <operator>&amp;</operator> <name>EXTENSION_DONT_CHECK_SIZE</name><operator>)</operator> <operator>&amp;&amp;</operator>
				 <name>nblocks</name> <operator>&lt;</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * When not extending (or explicitly including truncated
			 * segments), only open the next segment if the current one is
			 * exactly RELSEG_SIZE.  If not (this branch), either return NULL
			 * or fail.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>behavior</name> <operator>&amp;</operator> <name>EXTENSION_RETURN_NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Some callers discern between reasons for _mdfd_getseg()
				 * returning NULL based on errno. As there's no failing
				 * syscall involved in this case, explicitly set errno to
				 * ENOENT, as that seems the closest interpretation.
				 */</comment>
				<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOENT</name></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\" (target block %u): previous segment is only %u blocks"</literal></expr></argument>,
							<argument><expr><call><name>_mdfd_segpath</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>nextsegno</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>nblocks</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>_mdfd_openseg</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>nextsegno</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>behavior</name> <operator>&amp;</operator> <name>EXTENSION_RETURN_NULL</name><operator>)</operator> <operator>&amp;&amp;</operator>
				<call><name>FILE_POSSIBLY_DELETED</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\" (target block %u): %m"</literal></expr></argument>,
							<argument><expr><call><name>_mdfd_segpath</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>nextsegno</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>blkno</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>v</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get number of blocks present in a single disk file
 */</comment>
<function><type><specifier>static</specifier> <name>BlockNumber</name></type>
<name>_mdnblocks</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>MdfdVec</name> <modifier>*</modifier></type><name>seg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>off_t</name></type>		<name>len</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>FileSize</name><argument_list>(<argument><expr><name><name>seg</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not seek to end of file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><call><name>FilePathName</name><argument_list>(<argument><expr><name><name>seg</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* note that this calculation will ignore any partial block at EOF */</comment>
	<return>return <expr><operator>(</operator><name>BlockNumber</name><operator>)</operator> <operator>(</operator><name>len</name> <operator>/</operator> <name>BLCKSZ</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Sync a file to disk, given a file tag.  Write the path into an output
 * buffer so the caller can use it in error messages.
 *
 * Return 0 on success, -1 on failure, with errno set.
 */</comment>
<function><type><name>int</name></type>
<name>mdsyncfiletag</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FileTag</name> <modifier>*</modifier></type><name>ftag</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SMgrRelation</name></type> <name>reln</name> <init>= <expr><call><name>smgropen</name><argument_list>(<argument><expr><name><name>ftag</name><operator>-&gt;</operator><name>rnode</name></name></expr></argument>, <argument><expr><name>InvalidBackendId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>File</name></type>		<name>file</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>need_to_close</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>,
				<decl><type ref="prev"/><name>save_errno</name></decl>;</decl_stmt>

	<comment type="block">/* See if we already have the file open, or need to open it. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ftag</name><operator>-&gt;</operator><name>segno</name></name> <operator>&lt;</operator> <name><name>reln</name><operator>-&gt;</operator><name>md_num_open_segs</name><index>[<expr><name><name>ftag</name><operator>-&gt;</operator><name>forknum</name></name></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>file</name> <operator>=</operator> <name><name>reln</name><operator>-&gt;</operator><name>md_seg_fds</name><index>[<expr><name><name>ftag</name><operator>-&gt;</operator><name>forknum</name></name></expr>]</index><index>[<expr><name><name>ftag</name><operator>-&gt;</operator><name>segno</name></name></expr>]</index></name><operator>.</operator><name>mdfd_vfd</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>FilePathName</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>need_to_close</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>_mdfd_segpath</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name><name>ftag</name><operator>-&gt;</operator><name>forknum</name></name></expr></argument>, <argument><expr><name><name>ftag</name><operator>-&gt;</operator><name>segno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>file</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>need_to_close</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Sync the file. */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>FileSync</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>WAIT_EVENT_DATA_FILE_SYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>save_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>need_to_close</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Unlink a file, given a file tag.  Write the path into an output
 * buffer so the caller can use it in error messages.
 *
 * Return 0 on success, -1 on failure, with errno set.
 */</comment>
<function><type><name>int</name></type>
<name>mdunlinkfiletag</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FileTag</name> <modifier>*</modifier></type><name>ftag</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

	<comment type="block">/* Compute the path. */</comment>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>relpathperm</name><argument_list>(<argument><expr><name><name>ftag</name><operator>-&gt;</operator><name>rnode</name></name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Try to unlink the file. */</comment>
	<return>return <expr><call><name>unlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check if a given candidate request matches a given tag, when processing
 * a SYNC_FILTER_REQUEST request.  This will be called for all pending
 * requests to find out whether to forget them.
 */</comment>
<function><type><name>bool</name></type>
<name>mdfiletagmatches</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FileTag</name> <modifier>*</modifier></type><name>ftag</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FileTag</name> <modifier>*</modifier></type><name>candidate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * For now we only use filter requests as a way to drop all scheduled
	 * callbacks relating to a given database, when dropping the database.
	 * We'll return true for all candidates that have the same database OID as
	 * the ftag from the SYNC_FILTER_REQUEST request, so they're forgotten.
	 */</comment>
	<return>return <expr><name><name>ftag</name><operator>-&gt;</operator><name>rnode</name><operator>.</operator><name>dbNode</name></name> <operator>==</operator> <name><name>candidate</name><operator>-&gt;</operator><name>rnode</name><operator>.</operator><name>dbNode</name></name></expr>;</return>
</block_content>}</block></function>
</unit>
