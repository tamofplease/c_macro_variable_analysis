<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/executor/nodeSubplan.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * nodeSubplan.c
 *	  routines to support sub-selects appearing in expressions
 *
 * This module is concerned with executing SubPlan expression nodes, which
 * should not be confused with sub-SELECTs appearing in FROM.  SubPlans are
 * divided into "initplans", which are those that need only one evaluation per
 * query (among other restrictions, this requires that they don't use any
 * direct correlation variables from the parent plan level), and "regular"
 * subplans, which are re-evaluated every time their result is required.
 *
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/executor/nodeSubplan.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<comment type="block">/*
 *	 INTERFACE ROUTINES
 *		ExecSubPlan  - process a subselect
 *		ExecInitSubPlan - initialize a subselect
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSubplan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>ExecHashSubPlan</name><parameter_list>(<parameter><decl><type><name>SubPlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
							 <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>ExecScanSubPlan</name><parameter_list>(<parameter><decl><type><name>SubPlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
							 <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>buildSubPlanHash</name><parameter_list>(<parameter><decl><type><name>SubPlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>findPartialMatch</name><parameter_list>(<parameter><decl><type><name>TupleHashTable</name></type> <name>hashtable</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
							 <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>eqfunctions</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>slotAllNulls</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>slotNoNulls</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* ----------------------------------------------------------------
 *		ExecSubPlan
 *
 * This is the main entry point for execution of a regular SubPlan.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>Datum</name></type>
<name>ExecSubPlan</name><parameter_list>(<parameter><decl><type><name>SubPlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
			<parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>,
			<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>subplan</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>subplan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>planstate</name><operator>-&gt;</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanDirection</name></type> <name>dir</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>es_direction</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>retval</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set non-null as default */</comment>
	<expr_stmt><expr><operator>*</operator><name>isNull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Sanity checks */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>subplan</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>CTE_SUBLINK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"CTE subplans should not be executed via ExecSubPlan"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>subplan</name><operator>-&gt;</operator><name>setParam</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name><name>subplan</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>!=</operator> <name>MULTIEXPR_SUBLINK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot set parent params from subquery"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Force forward-scan mode for evaluation */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_direction</name></name> <operator>=</operator> <name>ForwardScanDirection</name></expr>;</expr_stmt>

	<comment type="block">/* Select appropriate evaluation strategy */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>subplan</name><operator>-&gt;</operator><name>useHashTable</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>ExecHashSubPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>ExecScanSubPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* restore scan direction */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_direction</name></name> <operator>=</operator> <name>dir</name></expr>;</expr_stmt>

	<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecHashSubPlan: store subselect result in an in-memory hash table
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>ExecHashSubPlan</name><parameter_list>(<parameter><decl><type><name>SubPlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
				<parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>,
				<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>subplan</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>subplan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>planstate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>planstate</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

	<comment type="block">/* Shouldn't have any direct correlation Vars */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>subplan</name><operator>-&gt;</operator><name>parParam</name></name> <operator>!=</operator> <name>NIL</name> <operator>||</operator> <name><name>node</name><operator>-&gt;</operator><name>args</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"hashed subplan with direct correlation not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If first time through or we need to rescan the subplan, build the hash
	 * table.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>hashtable</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>planstate</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>buildSubPlanHash</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The result for an empty subplan is always FALSE; no need to evaluate
	 * lefthand side.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>isNull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>havehashrows</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>havenullrows</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Evaluate lefthand expressions and form a projection tuple. First we
	 * have to set the econtext to use (hack alert!).
	 */</comment>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>projLeft</name><operator>-&gt;</operator><name>pi_exprContext</name></name> <operator>=</operator> <name>econtext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecProject</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>projLeft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note: because we are typically called in a per-tuple context, we have
	 * to explicitly clear the projected tuple before returning. Otherwise,
	 * we'll have a double-free situation: the per-tuple context will probably
	 * be reset before we're called again, and then the tuple slot will think
	 * it still needs to free the tuple.
	 */</comment>

	<comment type="block">/*
	 * If the LHS is all non-null, probe for an exact match in the main hash
	 * table.  If we find one, the result is TRUE. Otherwise, scan the
	 * partly-null table to see if there are any rows that aren't provably
	 * unequal to the LHS; if so, the result is UNKNOWN.  (We skip that part
	 * if we don't care about UNKNOWN.) Otherwise, the result is FALSE.
	 *
	 * Note: the reason we can avoid a full scan of the main hash table is
	 * that the combining operators are assumed never to yield NULL when both
	 * inputs are non-null.  If they were to do so, we might need to produce
	 * UNKNOWN instead of FALSE because of an UNKNOWN result in comparing the
	 * LHS to some main-table entry --- which is a comparison we will not even
	 * make, unless there's a chance match of hash keys.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>slotNoNulls</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>havehashrows</name></name> <operator>&amp;&amp;</operator>
			<call><name>FindTupleHashEntry</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hashtable</name></name></expr></argument>,
							   <argument><expr><name>slot</name></expr></argument>,
							   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>cur_eq_comp</name></name></expr></argument>,
							   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>lhs_hash_funcs</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>havenullrows</name></name> <operator>&amp;&amp;</operator>
			<call><name>findPartialMatch</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hashnulls</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>cur_eq_funcs</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>isNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<return>return <expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * When the LHS is partly or wholly NULL, we can never return TRUE. If we
	 * don't care about UNKNOWN, just return FALSE.  Otherwise, if the LHS is
	 * wholly NULL, immediately return UNKNOWN.  (Since the combining
	 * operators are strict, the result could only be FALSE if the sub-select
	 * were empty, but we already handled that case.) Otherwise, we must scan
	 * both the main and partly-null tables to see if there are any rows that
	 * aren't provably unequal to the LHS; if so, the result is UNKNOWN.
	 * Otherwise, the result is FALSE.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>hashnulls</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>slotAllNulls</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>isNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Scan partly-null table first, since more likely to get a match */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>havenullrows</name></name> <operator>&amp;&amp;</operator>
		<call><name>findPartialMatch</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hashnulls</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>cur_eq_funcs</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>isNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>havehashrows</name></name> <operator>&amp;&amp;</operator>
		<call><name>findPartialMatch</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hashtable</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>cur_eq_funcs</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>isNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecScanSubPlan: default case where we have to rescan subplan each time
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>ExecScanSubPlan</name><parameter_list>(<parameter><decl><type><name>SubPlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
				<parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>,
				<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>subplan</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>subplan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>planstate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>planstate</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SubLinkType</name></type> <name>subLinkType</name> <init>= <expr><name><name>subplan</name><operator>-&gt;</operator><name>subLinkType</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* true if got at least one subplan tuple */</comment>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>pvar</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayBuildStateAny</name> <modifier>*</modifier></type><name>astate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * MULTIEXPR subplans, when "executed", just return NULL; but first we
	 * mark the subplan's output parameters as needing recalculation.  (This
	 * is a bit of a hack: it relies on the subplan appearing later in its
	 * targetlist than any of the referencing Params, so that all the Params
	 * have been evaluated before we re-mark them for the next evaluation
	 * cycle.  But in general resjunk tlist items appear after non-resjunk
	 * ones, so this should be safe.)  Unlike ExecReScanSetParamPlan, we do
	 * *not* set bits in the parent plan node's chgParam, because we don't
	 * want to cause a rescan of the parent.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>subLinkType</name> <operator>==</operator> <name>MULTIEXPR_SUBLINK</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>state</name></name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>subplan-&gt;setParam</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>paramid</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ParamExecData</name> <modifier>*</modifier></type><name>prm</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_param_exec_vals</name><index>[<expr><name>paramid</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>execPlan</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><operator>*</operator><name>isNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Initialize ArrayBuildStateAny in caller's context, if needed */</comment>
	<if_stmt><if>if <condition>(<expr><name>subLinkType</name> <operator>==</operator> <name>ARRAY_SUBLINK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>astate</name> <operator>=</operator> <call><name>initArrayResultAny</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>firstColType</name></name></expr></argument>,
									<argument><expr><name>CurrentMemoryContext</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We are probably in a short-lived expression-evaluation context. Switch
	 * to the per-query context for manipulating the child plan's chgParam,
	 * calling ExecProcNode on it, etc.
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set Params of this plan from parent plan correlation values. (Any
	 * calculation we have to do is done in the parent econtext, since the
	 * Param values don't need to have per-query lifetime.)
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>parParam</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>forboth</name><argument_list>(<argument>l</argument>, <argument>subplan-&gt;parParam</argument>, <argument>pvar</argument>, <argument>node-&gt;args</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>paramid</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ParamExecData</name> <modifier>*</modifier></type><name>prm</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_param_exec_vals</name><index>[<expr><name>paramid</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>ExecEvalExprSwitchContext</name><argument_list>(<argument><expr><operator>(</operator><name>ExprState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>pvar</name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><name>econtext</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>planstate</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>chgParam</name></name></expr></argument>, <argument><expr><name>paramid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Now that we've set up its parameters, we can reset the subplan.
	 */</comment>
	<expr_stmt><expr><call><name>ExecReScan</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For all sublink types except EXPR_SUBLINK and ARRAY_SUBLINK, the result
	 * is boolean as are the results of the combining operators. We combine
	 * results across tuples (if the subplan produces more than one) using OR
	 * semantics for ANY_SUBLINK or AND semantics for ALL_SUBLINK.
	 * (ROWCOMPARE_SUBLINK doesn't allow multiple tuples from the subplan.)
	 * NULL results from the combining operators are handled according to the
	 * usual SQL semantics for OR and AND.  The result for no input tuples is
	 * FALSE for ANY_SUBLINK, TRUE for ALL_SUBLINK, NULL for
	 * ROWCOMPARE_SUBLINK.
	 *
	 * For EXPR_SUBLINK we require the subplan to produce no more than one
	 * tuple, else an error is raised.  If zero tuples are produced, we return
	 * NULL.  Assuming we get a tuple, we just use its first column (there can
	 * be only one non-junk column in this case).
	 *
	 * For ARRAY_SUBLINK we allow the subplan to produce any number of tuples,
	 * and form an array of the first column's values.  Note in particular
	 * that we produce a zero-element array if no tuples are produced (this is
	 * a change from pre-8.3 behavior of returning NULL).
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>subLinkType</name> <operator>==</operator> <name>ALL_SUBLINK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>isNull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>slot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>;</init>
		 <condition><expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</condition>
		 <incr><expr><name>slot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tdesc</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>rowresult</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>rownull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>col</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>plst</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>subLinkType</name> <operator>==</operator> <name>EXISTS_SUBLINK</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>subLinkType</name> <operator>==</operator> <name>EXPR_SUBLINK</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* cannot allow multiple input tuples for EXPR sublink */</comment>
			<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CARDINALITY_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"more than one row returned by a subquery used as an expression"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * We need to copy the subplan's tuple in case the result is of
			 * pass-by-ref type --- our return value will point into this
			 * copied tuple!  Can't use the subplan's instance of the tuple
			 * since it won't still be valid after next ExecProcNode() call.
			 * node-&gt;curTuple keeps track of the copied tuple for eventual
			 * freeing.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>curTuple</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>curTuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>curTuple</name></name> <operator>=</operator> <call><name>ExecCopySlotHeapTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>curTuple</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>tdesc</name></expr></argument>, <argument><expr><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* keep scanning subplan to make sure there's only one tuple */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>subLinkType</name> <operator>==</operator> <name>ARRAY_SUBLINK</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>dvalue</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>disnull</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<comment type="block">/* stash away current value */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>firstColType</name></name> <operator>==</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tdesc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>dvalue</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>disnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>astate</name> <operator>=</operator> <call><name>accumArrayResultAny</name><argument_list>(<argument><expr><name>astate</name></expr></argument>, <argument><expr><name>dvalue</name></expr></argument>, <argument><expr><name>disnull</name></expr></argument>,
										 <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>firstColType</name></name></expr></argument>, <argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* keep scanning subplan to collect all values */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* cannot allow multiple input tuples for ROWCOMPARE sublink either */</comment>
		<if_stmt><if>if <condition>(<expr><name>subLinkType</name> <operator>==</operator> <name>ROWCOMPARE_SUBLINK</name> <operator>&amp;&amp;</operator> <name>found</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CARDINALITY_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"more than one row returned by a subquery used as an expression"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * For ALL, ANY, and ROWCOMPARE sublinks, load up the Params
		 * representing the columns of the sub-select, and then evaluate the
		 * combining expression.
		 */</comment>
		<expr_stmt><expr><name>col</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>plst</argument>, <argument>subplan-&gt;paramIds</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>paramid</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>plst</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ParamExecData</name> <modifier>*</modifier></type><name>prmdata</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>prmdata</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_param_exec_vals</name><index>[<expr><name>paramid</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>prmdata</name><operator>-&gt;</operator><name>execPlan</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>prmdata</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>col</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>prmdata</name><operator>-&gt;</operator><name>isnull</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>col</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><name>rowresult</name> <operator>=</operator> <call><name>ExecEvalExprSwitchContext</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>rownull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>subLinkType</name> <operator>==</operator> <name>ANY_SUBLINK</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* combine across rows per OR semantics */</comment>
			<if_stmt><if>if <condition>(<expr><name>rownull</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>isNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>rowresult</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>isNull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>			<comment type="block">/* needn't look at any more rows */</comment>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>subLinkType</name> <operator>==</operator> <name>ALL_SUBLINK</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* combine across rows per AND semantics */</comment>
			<if_stmt><if>if <condition>(<expr><name>rownull</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>isNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>rowresult</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>isNull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>			<comment type="block">/* needn't look at any more rows */</comment>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* must be ROWCOMPARE_SUBLINK */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>rowresult</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>isNull</name> <operator>=</operator> <name>rownull</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>subLinkType</name> <operator>==</operator> <name>ARRAY_SUBLINK</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We return the result in the caller's context */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeArrayResultAny</name><argument_list>(<argument><expr><name>astate</name></expr></argument>, <argument><expr><name>oldcontext</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * deal with empty subplan result.  result/isNull were previously
		 * initialized correctly for all sublink types except EXPR and
		 * ROWCOMPARE; for those, return NULL.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>subLinkType</name> <operator>==</operator> <name>EXPR_SUBLINK</name> <operator>||</operator>
			<name>subLinkType</name> <operator>==</operator> <name>ROWCOMPARE_SUBLINK</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>isNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * buildSubPlanHash: load hash table by scanning subplan output.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>buildSubPlanHash</name><parameter_list>(<parameter><decl><type><name>SubPlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>subplan</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>subplan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>planstate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>planstate</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ncols</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>innerecontext</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>innerecontext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>nbuckets</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>ANY_SUBLINK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we already had any hash tables, reset 'em; otherwise create empty
	 * hash table(s).
	 *
	 * If we need to distinguish accurately between FALSE and UNKNOWN (i.e.,
	 * NULL) results of the IN operation, then we have to store subplan output
	 * rows that are partly or wholly NULL.  We store such rows in a separate
	 * hash table that we expect will be much smaller than the main table. (We
	 * can use hashing to eliminate partly-null rows that are not distinct. We
	 * keep them separate to minimize the cost of the inevitable full-table
	 * searches; see findPartialMatch.)
	 *
	 * If it's not necessary to distinguish FALSE and UNKNOWN, then we don't
	 * need to store subplan output rows that contain NULL.
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hashtablecxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>havehashrows</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>havenullrows</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>nbuckets</name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>plan_rows</name></name></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name>LONG_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nbuckets</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nbuckets</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>hashtable</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResetTupleHashTable</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hashtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hashtable</name></name> <operator>=</operator> <call><name>BuildTupleHashTableExt</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>,
												 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>descRight</name></name></expr></argument>,
												 <argument><expr><name>ncols</name></expr></argument>,
												 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>keyColIdx</name></name></expr></argument>,
												 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>tab_eq_funcoids</name></name></expr></argument>,
												 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>tab_hash_funcs</name></name></expr></argument>,
												 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>tab_collations</name></name></expr></argument>,
												 <argument><expr><name>nbuckets</name></expr></argument>,
												 <argument><expr><literal type="number">0</literal></expr></argument>,
												 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>planstate</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>,
												 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>hashtablecxt</name></name></expr></argument>,
												 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>hashtempcxt</name></name></expr></argument>,
												 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>subplan</name><operator>-&gt;</operator><name>unknownEqFalse</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>ncols</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nbuckets</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>		<comment type="block">/* there can only be one entry */</comment>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>nbuckets</name> <operator>/=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>nbuckets</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>nbuckets</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>hashnulls</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ResetTupleHashTable</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hashnulls</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hashnulls</name></name> <operator>=</operator> <call><name>BuildTupleHashTableExt</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>,
													 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>descRight</name></name></expr></argument>,
													 <argument><expr><name>ncols</name></expr></argument>,
													 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>keyColIdx</name></name></expr></argument>,
													 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>tab_eq_funcoids</name></name></expr></argument>,
													 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>tab_hash_funcs</name></name></expr></argument>,
													 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>tab_collations</name></name></expr></argument>,
													 <argument><expr><name>nbuckets</name></expr></argument>,
													 <argument><expr><literal type="number">0</literal></expr></argument>,
													 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>planstate</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>,
													 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>hashtablecxt</name></name></expr></argument>,
													 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>hashtempcxt</name></name></expr></argument>,
													 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hashnulls</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * We are probably in a short-lived expression-evaluation context. Switch
	 * to the per-query context for manipulating the child plan.
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Reset subplan to start.
	 */</comment>
	<expr_stmt><expr><call><name>ExecReScan</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Scan the subplan and load the hash table(s).  Note that when there are
	 * duplicate rows coming out of the sub-select, only one copy is stored.
	 */</comment>
	<for>for <control>(<init><expr><name>slot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>;</init>
		 <condition><expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</condition>
		 <incr><expr><name>slot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>col</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>plst</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnew</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Load up the Params representing the raw sub-select outputs, then
		 * form the projection tuple to store in the hashtable.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>plst</argument>, <argument>subplan-&gt;paramIds</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>paramid</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>plst</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ParamExecData</name> <modifier>*</modifier></type><name>prmdata</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>prmdata</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>innerecontext</name><operator>-&gt;</operator><name>ecxt_param_exec_vals</name><index>[<expr><name>paramid</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>prmdata</name><operator>-&gt;</operator><name>execPlan</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>prmdata</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>col</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>prmdata</name><operator>-&gt;</operator><name>isnull</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>col</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecProject</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>projRight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If result contains any nulls, store separately or not at all.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>slotNoNulls</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>LookupTupleHashEntry</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hashtable</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnew</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>havehashrows</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>hashnulls</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>LookupTupleHashEntry</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hashnulls</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnew</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>havenullrows</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Reset innerecontext after each inner tuple to free any memory used
		 * during ExecProject.
		 */</comment>
		<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>innerecontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Since the projected tuples are in the sub-query's context and not the
	 * main context, we'd better clear the tuple slot before there's any
	 * chance of a reset of the sub-query's context.  Else we will have the
	 * potential for a double free attempt.  (XXX possibly no longer needed,
	 * but can't hurt.)
	 */</comment>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>projRight</name><operator>-&gt;</operator><name>pi_state</name><operator>.</operator><name>resultslot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * execTuplesUnequal
 *		Return true if two tuples are definitely unequal in the indicated
 *		fields.
 *
 * Nulls are neither equal nor unequal to anything else.  A true result
 * is obtained only if there are non-null fields that compare not-equal.
 *
 * slot1, slot2: the tuples to compare (must have same columns!)
 * numCols: the number of attributes to be examined
 * matchColIdx: array of attribute column numbers
 * eqFunctions: array of fmgr lookup info for the equality functions to use
 * evalContext: short-term memory context for executing the functions
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>execTuplesUnequal</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot1</name></decl></parameter>,
				  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot2</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>numCols</name></decl></parameter>,
				  <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>matchColIdx</name></decl></parameter>,
				  <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>eqfunctions</name></decl></parameter>,
				  <parameter><decl><type><specifier>const</specifier> <name>Oid</name> <modifier>*</modifier></type><name>collations</name></decl></parameter>,
				  <parameter><decl><type><name>MemoryContext</name></type> <name>evalContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Reset and switch into the temp context. */</comment>
	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>evalContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>evalContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We cannot report a match without checking all the fields, but we can
	 * report a non-match as soon as we find unequal fields.  So, start
	 * comparing at the last field (least significant sort key). That's the
	 * most likely to be different if we are dealing with sorted input.
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>numCols</name></expr>;</init> <condition><expr><operator>--</operator><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>att</name> <init>= <expr><name><name>matchColIdx</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>attr1</name></decl>,
					<decl><type ref="prev"/><name>attr2</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull1</name></decl>,
					<decl><type ref="prev"/><name>isNull2</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>attr1</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot1</name></expr></argument>, <argument><expr><name>att</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>isNull1</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* can't prove anything here */</comment>

		<expr_stmt><expr><name>attr2</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot2</name></expr></argument>, <argument><expr><name>att</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>isNull2</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* can't prove anything here */</comment>

		<comment type="block">/* Apply the type-specific equality function */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>eqfunctions</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
											<argument><expr><name><name>collations</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
											<argument><expr><name>attr1</name></expr></argument>, <argument><expr><name>attr2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>		<comment type="block">/* they are unequal */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * findPartialMatch: does the hashtable contain an entry that is not
 * provably distinct from the tuple?
 *
 * We have to scan the whole hashtable; we can't usefully use hashkeys
 * to guide probing, since we might get partial matches on tuples with
 * hashkeys quite unrelated to what we'd get from the given tuple.
 *
 * Caller must provide the equality functions to use, since in cross-type
 * cases these are different from the hashtable's internal functions.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>findPartialMatch</name><parameter_list>(<parameter><decl><type><name>TupleHashTable</name></type> <name>hashtable</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
				 <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>eqfunctions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>numCols</name> <init>= <expr><name><name>hashtable</name><operator>-&gt;</operator><name>numCols</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>keyColIdx</name> <init>= <expr><name><name>hashtable</name><operator>-&gt;</operator><name>keyColIdx</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleHashIterator</name></type> <name>hashiter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleHashEntry</name></type> <name>entry</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>InitTupleHashIterator</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hashiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <call><name>ScanTupleHashTable</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hashiter</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExecStoreMinimalTuple</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>firstTuple</name></name></expr></argument>, <argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>tableslot</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>execTuplesUnequal</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>tableslot</name></name></expr></argument>,
							   <argument><expr><name>numCols</name></expr></argument>, <argument><expr><name>keyColIdx</name></expr></argument>,
							   <argument><expr><name>eqfunctions</name></expr></argument>,
							   <argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>tab_collations</name></name></expr></argument>,
							   <argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>tempcxt</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>TermTupleHashIterator</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hashiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
	<comment type="block">/* No TermTupleHashIterator call needed here */</comment>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * slotAllNulls: is the slot completely NULL?
 *
 * This does not test for dropped columns, which is OK because we only
 * use it on projected tuples.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>slotAllNulls</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ncols</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>ncols</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>slot_attisnull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * slotNoNulls: is the slot entirely not NULL?
 *
 * This does not test for dropped columns, which is OK because we only
 * use it on projected tuples.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>slotNoNulls</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ncols</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>ncols</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>slot_attisnull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecInitSubPlan
 *
 * Create a SubPlanState for a SubPlan; this is the SubPlan-specific part
 * of ExecInitExpr().  We split it out so that it can be used for InitPlans
 * as well as regular SubPlans.  Note that we don't link the SubPlan into
 * the parent's subPlan list, because that shouldn't happen for InitPlans.
 * Instead, ExecInitExpr() does that one part.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>SubPlanState</name> <modifier>*</modifier></type>
<name>ExecInitSubPlan</name><parameter_list>(<parameter><decl><type><name>SubPlan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>, <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SubPlanState</name> <modifier>*</modifier></type><name>sstate</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>SubPlanState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>parent</name><operator>-&gt;</operator><name>state</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>subplan</name></name> <operator>=</operator> <name>subplan</name></expr>;</expr_stmt>

	<comment type="block">/* Link the SubPlanState to already-initialized subplan */</comment>
	<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>planstate</name></name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_subplanstates</name></name></expr></argument>,
											   <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>plan_id</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * This check can fail if the planner mistakenly puts a parallel-unsafe
	 * subplan into a parallelized subquery; see ExecSerializePlan.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>sstate</name><operator>-&gt;</operator><name>planstate</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"subplan \"%s\" was not initialized"</literal></expr></argument>,
			 <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>plan_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Link to parent's state, too */</comment>
	<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>parent</name></expr>;</expr_stmt>

	<comment type="block">/* Initialize subexpressions */</comment>
	<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>testexpr</name></name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name><name>subplan</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>ExecInitExprList</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * initialize my state
	 */</comment>
	<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>curTuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>curArray</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>projLeft</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>projRight</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>hashtable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>hashnulls</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>hashtablecxt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>hashtempcxt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>innerecontext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>keyColIdx</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>tab_eq_funcoids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>tab_hash_funcs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>tab_eq_funcs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>tab_collations</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>lhs_hash_funcs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>cur_eq_funcs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If this is an initplan or MULTIEXPR subplan, it has output parameters
	 * that the parent plan will use, so mark those parameters as needing
	 * evaluation.  We don't actually run the subplan until we first need one
	 * of its outputs.
	 *
	 * A CTE subplan's output parameter is never to be evaluated in the normal
	 * way, so skip this in that case.
	 *
	 * Note that we don't set parent-&gt;chgParam here: the parent plan hasn't
	 * been run yet, so no need to force it to re-run.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>subplan</name><operator>-&gt;</operator><name>setParam</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name><name>subplan</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>!=</operator> <name>CTE_SUBLINK</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lst</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lst</argument>, <argument>subplan-&gt;setParam</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>paramid</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lst</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ParamExecData</name> <modifier>*</modifier></type><name>prm</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_param_exec_vals</name><index>[<expr><name>paramid</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>execPlan</name></name> <operator>=</operator> <name>sstate</name></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we are going to hash the subquery output, initialize relevant stuff.
	 * (We don't create the hashtable until needed, though.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>subplan</name><operator>-&gt;</operator><name>useHashTable</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>ncols</name></decl>,
					<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDescLeft</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDescRight</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>cross_eq_funcoids</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>oplist</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>lefttlist</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>righttlist</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<comment type="block">/* We need a memory context to hold the hash table(s) */</comment>
		<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>hashtablecxt</name></name> <operator>=</operator>
			<call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
								  <argument><expr><literal type="string">"Subplan HashTable Context"</literal></expr></argument>,
								  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* and a small one for the hash tables to use as temp storage */</comment>
		<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>hashtempcxt</name></name> <operator>=</operator>
			<call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
								  <argument><expr><literal type="string">"Subplan HashTable Temp Context"</literal></expr></argument>,
								  <argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* and a short-lived exprcontext for function evaluation */</comment>
		<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>innerecontext</name></name> <operator>=</operator> <call><name>CreateExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We use ExecProject to evaluate the lefthand and righthand
		 * expression lists and form tuples.  (You might think that we could
		 * use the sub-select's output tuples directly, but that is not the
		 * case if we had to insert any run-time coercions of the sub-select's
		 * output datatypes; anyway this avoids storing any resjunk columns
		 * that might be in the sub-select's output.)  Run through the
		 * combining expressions to build tlists for the lefthand and
		 * righthand sides.
		 *
		 * We also extract the combining operators themselves to initialize
		 * the equality and hashing functions for the hash tables.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* single combining operator */</comment>
			<expr_stmt><expr><name>oplist</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>is_andclause</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* multiple combining operators */</comment>
			<expr_stmt><expr><name>oplist</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>BoolExpr</name></expr></argument>, <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>args</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* shouldn't see anything else in a hashable subplan */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized testexpr type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>oplist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>		<comment type="block">/* keep compiler quiet */</comment>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>ncols</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>oplist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>lefttlist</name> <operator>=</operator> <name>righttlist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>numCols</name></name> <operator>=</operator> <name>ncols</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>keyColIdx</name></name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>ncols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>tab_eq_funcoids</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>ncols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>tab_collations</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>ncols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>tab_hash_funcs</name></name> <operator>=</operator> <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>ncols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>tab_eq_funcs</name></name> <operator>=</operator> <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>ncols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>lhs_hash_funcs</name></name> <operator>=</operator> <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>ncols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>cur_eq_funcs</name></name> <operator>=</operator> <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>ncols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* we'll need the cross-type equality fns below, but not in sstate */</comment>
		<expr_stmt><expr><name>cross_eq_funcoids</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>ncols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>oplist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>opexpr</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>rhs_eq_oper</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>left_hashfn</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>right_hashfn</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Process lefthand argument */</comment>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><name>expr</name></expr></argument>,
								  <argument><expr><name>i</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>lefttlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>lefttlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Process righthand argument */</comment>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><name>expr</name></expr></argument>,
								  <argument><expr><name>i</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>righttlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>righttlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Lookup the equality function (potentially cross-type) */</comment>
			<expr_stmt><expr><name><name>cross_eq_funcoids</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>opexpr</name><operator>-&gt;</operator><name>opfuncid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>opfuncid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sstate</name><operator>-&gt;</operator><name>cur_eq_funcs</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fmgr_info_set_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>opexpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sstate</name><operator>-&gt;</operator><name>cur_eq_funcs</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Look up the equality function for the RHS type */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_compatible_hash_operators</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>,
											   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rhs_eq_oper</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find compatible hash operator for operator %u"</literal></expr></argument>,
					 <argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>tab_eq_funcoids</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>get_opcode</name><argument_list>(<argument><expr><name>rhs_eq_oper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name><name>sstate</name><operator>-&gt;</operator><name>tab_eq_funcoids</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name><name>sstate</name><operator>-&gt;</operator><name>tab_eq_funcs</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Lookup the associated hash functions */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_op_hash_functions</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>left_hashfn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>right_hashfn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find hash function for hash operator %u"</literal></expr></argument>,
					 <argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>left_hashfn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sstate</name><operator>-&gt;</operator><name>lhs_hash_funcs</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>right_hashfn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sstate</name><operator>-&gt;</operator><name>tab_hash_funcs</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Set collation */</comment>
			<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>tab_collations</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>opexpr</name><operator>-&gt;</operator><name>inputcollid</name></name></expr>;</expr_stmt>

			<comment type="block">/* keyColIdx is just column numbers 1..n */</comment>
			<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>keyColIdx</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * Construct tupdescs, slots and projection nodes for left and right
		 * sides.  The lefthand expressions will be evaluated in the parent
		 * plan node's exprcontext, which we don't have access to here.
		 * Fortunately we can just pass NULL for now and fill it in later
		 * (hack alert!).  The righthand expressions will be evaluated in our
		 * own innerecontext.
		 */</comment>
		<expr_stmt><expr><name>tupDescLeft</name> <operator>=</operator> <call><name>ExecTypeFromTL</name><argument_list>(<argument><expr><name>lefttlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>tupDescLeft</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>projLeft</name></name> <operator>=</operator> <call><name>ExecBuildProjectionInfo</name><argument_list>(<argument><expr><name>lefttlist</name></expr></argument>,
												   <argument><expr><name>NULL</name></expr></argument>,
												   <argument><expr><name>slot</name></expr></argument>,
												   <argument><expr><name>parent</name></expr></argument>,
												   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>descRight</name></name> <operator>=</operator> <name>tupDescRight</name> <operator>=</operator> <call><name>ExecTypeFromTL</name><argument_list>(<argument><expr><name>righttlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>tupDescRight</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>projRight</name></name> <operator>=</operator> <call><name>ExecBuildProjectionInfo</name><argument_list>(<argument><expr><name>righttlist</name></expr></argument>,
													<argument><expr><name><name>sstate</name><operator>-&gt;</operator><name>innerecontext</name></name></expr></argument>,
													<argument><expr><name>slot</name></expr></argument>,
													<argument><expr><name><name>sstate</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>,
													<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Create comparator for lookups of rows in the table (potentially
		 * cross-type comparisons).
		 */</comment>
		<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>cur_eq_comp</name></name> <operator>=</operator> <call><name>ExecBuildGroupingEqual</name><argument_list>(<argument><expr><name>tupDescLeft</name></expr></argument>, <argument><expr><name>tupDescRight</name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr></argument>,
													 <argument><expr><name>ncols</name></expr></argument>,
													 <argument><expr><name><name>sstate</name><operator>-&gt;</operator><name>keyColIdx</name></name></expr></argument>,
													 <argument><expr><name>cross_eq_funcoids</name></expr></argument>,
													 <argument><expr><name><name>sstate</name><operator>-&gt;</operator><name>tab_collations</name></name></expr></argument>,
													 <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>sstate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecSetParamPlan
 *
 *		Executes a subplan and sets its output parameters.
 *
 * This is called from ExecEvalParamExec() when the value of a PARAM_EXEC
 * parameter is requested and the param's execPlan field is set (indicating
 * that the param has not yet been evaluated).  This allows lazy evaluation
 * of initplans: we don't run the subplan until/unless we need its output.
 * Note that this routine MUST clear the execPlan fields of the plan's
 * output parameters after evaluating them!
 *
 * The results of this function are stored in the EState associated with the
 * ExprContext (particularly, its ecxt_param_exec_vals); any pass-by-ref
 * result Datums are allocated in the EState's per-query memory.  The passed
 * econtext can be any ExprContext belonging to that EState; which one is
 * important only to the extent that the ExprContext's per-tuple memory
 * context is used to evaluate any parameters passed down to the subplan.
 * (Thus in principle, the shorter-lived the ExprContext the better, since
 * that data isn't needed after we return.  In practice, because initplan
 * parameters are never more complex than Vars, Aggrefs, etc, evaluating them
 * currently never leaks any memory anyway.)
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecSetParamPlan</name><parameter_list>(<parameter><decl><type><name>SubPlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>subplan</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>subplan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>planstate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>planstate</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SubLinkType</name></type> <name>subLinkType</name> <init>= <expr><name><name>subplan</name><operator>-&gt;</operator><name>subLinkType</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>planstate</name><operator>-&gt;</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanDirection</name></type> <name>dir</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>es_direction</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>pvar</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayBuildStateAny</name> <modifier>*</modifier></type><name>astate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>subLinkType</name> <operator>==</operator> <name>ANY_SUBLINK</name> <operator>||</operator>
		<name>subLinkType</name> <operator>==</operator> <name>ALL_SUBLINK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ANY/ALL subselect unsupported as initplan"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>subLinkType</name> <operator>==</operator> <name>CTE_SUBLINK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"CTE subplans should not be executed via ExecSetParamPlan"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Enforce forward scan direction regardless of caller. It's hard but not
	 * impossible to get here in backward scan, so make it work anyway.
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_direction</name></name> <operator>=</operator> <name>ForwardScanDirection</name></expr>;</expr_stmt>

	<comment type="block">/* Initialize ArrayBuildStateAny in caller's context, if needed */</comment>
	<if_stmt><if>if <condition>(<expr><name>subLinkType</name> <operator>==</operator> <name>ARRAY_SUBLINK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>astate</name> <operator>=</operator> <call><name>initArrayResultAny</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>firstColType</name></name></expr></argument>,
									<argument><expr><name>CurrentMemoryContext</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Must switch to per-query memory context.
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set Params of this plan from parent plan correlation values. (Any
	 * calculation we have to do is done in the parent econtext, since the
	 * Param values don't need to have per-query lifetime.)  Currently, we
	 * expect only MULTIEXPR_SUBLINK plans to have any correlation values.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>parParam</name></name> <operator>==</operator> <name>NIL</name> <operator>||</operator> <name>subLinkType</name> <operator>==</operator> <name>MULTIEXPR_SUBLINK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>parParam</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>forboth</name><argument_list>(<argument>l</argument>, <argument>subplan-&gt;parParam</argument>, <argument>pvar</argument>, <argument>node-&gt;args</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>paramid</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ParamExecData</name> <modifier>*</modifier></type><name>prm</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_param_exec_vals</name><index>[<expr><name>paramid</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>ExecEvalExprSwitchContext</name><argument_list>(<argument><expr><operator>(</operator><name>ExprState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>pvar</name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><name>econtext</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>planstate</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>chgParam</name></name></expr></argument>, <argument><expr><name>paramid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Run the plan.  (If it needs to be rescanned, the first ExecProcNode
	 * call will take care of that.)
	 */</comment>
	<for>for <control>(<init><expr><name>slot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>;</init>
		 <condition><expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</condition>
		 <incr><expr><name>slot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tdesc</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>subLinkType</name> <operator>==</operator> <name>EXISTS_SUBLINK</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* There can be only one setParam... */</comment>
			<decl_stmt><decl><type><name>int</name></type>			<name>paramid</name> <init>= <expr><call><name>linitial_int</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>setParam</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ParamExecData</name> <modifier>*</modifier></type><name>prm</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_param_exec_vals</name><index>[<expr><name>paramid</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>execPlan</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>subLinkType</name> <operator>==</operator> <name>ARRAY_SUBLINK</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>dvalue</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>disnull</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<comment type="block">/* stash away current value */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>firstColType</name></name> <operator>==</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tdesc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>dvalue</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>disnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>astate</name> <operator>=</operator> <call><name>accumArrayResultAny</name><argument_list>(<argument><expr><name>astate</name></expr></argument>, <argument><expr><name>dvalue</name></expr></argument>, <argument><expr><name>disnull</name></expr></argument>,
										 <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>firstColType</name></name></expr></argument>, <argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* keep scanning subplan to collect all values */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>found</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>subLinkType</name> <operator>==</operator> <name>EXPR_SUBLINK</name> <operator>||</operator>
			 <name>subLinkType</name> <operator>==</operator> <name>MULTIEXPR_SUBLINK</name> <operator>||</operator>
			 <name>subLinkType</name> <operator>==</operator> <name>ROWCOMPARE_SUBLINK</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CARDINALITY_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"more than one row returned by a subquery used as an expression"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * We need to copy the subplan's tuple into our own context, in case
		 * any of the params are pass-by-ref type --- the pointers stored in
		 * the param structs will point at this copied tuple! node-&gt;curTuple
		 * keeps track of the copied tuple for eventual freeing.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>curTuple</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>curTuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>curTuple</name></name> <operator>=</operator> <call><name>ExecCopySlotHeapTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now set all the setParam params from the columns of the tuple
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>subplan-&gt;setParam</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>paramid</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ParamExecData</name> <modifier>*</modifier></type><name>prm</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_param_exec_vals</name><index>[<expr><name>paramid</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>execPlan</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>curTuple</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>tdesc</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>subLinkType</name> <operator>==</operator> <name>ARRAY_SUBLINK</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* There can be only one setParam... */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>paramid</name> <init>= <expr><call><name>linitial_int</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>setParam</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ParamExecData</name> <modifier>*</modifier></type><name>prm</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_param_exec_vals</name><index>[<expr><name>paramid</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * We build the result array in query context so it won't disappear;
		 * to avoid leaking memory across repeated calls, we have to remember
		 * the latest value, much as for curTuple above.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>curArray</name></name> <operator>!=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>curArray</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>curArray</name></name> <operator>=</operator> <call><name>makeArrayResultAny</name><argument_list>(<argument><expr><name>astate</name></expr></argument>,
											<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr></argument>,
											<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>execPlan</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>curArray</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>subLinkType</name> <operator>==</operator> <name>EXISTS_SUBLINK</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* There can be only one setParam... */</comment>
			<decl_stmt><decl><type><name>int</name></type>			<name>paramid</name> <init>= <expr><call><name>linitial_int</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>setParam</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ParamExecData</name> <modifier>*</modifier></type><name>prm</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_param_exec_vals</name><index>[<expr><name>paramid</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>execPlan</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* For other sublink types, set all the output params to NULL */</comment>
			<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>subplan-&gt;setParam</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>paramid</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ParamExecData</name> <modifier>*</modifier></type><name>prm</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_param_exec_vals</name><index>[<expr><name>paramid</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>execPlan</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* restore scan direction */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_direction</name></name> <operator>=</operator> <name>dir</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecSetParamPlanMulti
 *
 * Apply ExecSetParamPlan to evaluate any not-yet-evaluated initplan output
 * parameters whose ParamIDs are listed in "params".  Any listed params that
 * are not initplan outputs are ignored.
 *
 * As with ExecSetParamPlan, any ExprContext belonging to the current EState
 * can be used, but in principle a shorter-lived ExprContext is better than a
 * longer-lived one.
 */</comment>
<function><type><name>void</name></type>
<name>ExecSetParamPlanMulti</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>params</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>paramid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>paramid</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>paramid</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>paramid</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ParamExecData</name> <modifier>*</modifier></type><name>prm</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_param_exec_vals</name><index>[<expr><name>paramid</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>prm</name><operator>-&gt;</operator><name>execPlan</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Parameter not evaluated yet, so go do it */</comment>
			<expr_stmt><expr><call><name>ExecSetParamPlan</name><argument_list>(<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>execPlan</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* ExecSetParamPlan should have processed this param... */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>execPlan</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Mark an initplan as needing recalculation
 */</comment>
<function><type><name>void</name></type>
<name>ExecReScanSetParamPlan</name><parameter_list>(<parameter><decl><type><name>SubPlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>planstate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>planstate</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>subplan</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>subplan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>parent</name><operator>-&gt;</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/* sanity checks */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>subplan</name><operator>-&gt;</operator><name>parParam</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"direct correlated subquery unsupported as initplan"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>subplan</name><operator>-&gt;</operator><name>setParam</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"setParam list of initplan is empty"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>extParam</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"extParam set of initplan is empty"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Don't actually re-scan: it'll happen inside ExecSetParamPlan if needed.
	 */</comment>

	<comment type="block">/*
	 * Mark this subplan's output parameters as needing recalculation.
	 *
	 * CTE subplans are never executed via parameter recalculation; instead
	 * they get run when called by nodeCtescan.c.  So don't mark the output
	 * parameter of a CTE subplan as dirty, but do set the chgParam bit for it
	 * so that dependent plan nodes will get told to rescan.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>subplan-&gt;setParam</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>paramid</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ParamExecData</name> <modifier>*</modifier></type><name>prm</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_param_exec_vals</name><index>[<expr><name>paramid</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>subplan</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>!=</operator> <name>CTE_SUBLINK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>execPlan</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>chgParam</name></name></expr></argument>, <argument><expr><name>paramid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * ExecInitAlternativeSubPlan
 *
 * Initialize for execution of one of a set of alternative subplans.
 */</comment>
<function><type><name>AlternativeSubPlanState</name> <modifier>*</modifier></type>
<name>ExecInitAlternativeSubPlan</name><parameter_list>(<parameter><decl><type><name>AlternativeSubPlan</name> <modifier>*</modifier></type><name>asplan</name></decl></parameter>, <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlternativeSubPlanState</name> <modifier>*</modifier></type><name>asstate</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AlternativeSubPlanState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>num_calls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>subplan1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>subplan2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>cost1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>cost2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>asstate</name><operator>-&gt;</operator><name>subplan</name></name> <operator>=</operator> <name>asplan</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize subplans.  (Can we get away with only initializing the one
	 * we're going to use?)
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>asplan-&gt;subplans</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>sp</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>SubPlan</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SubPlanState</name> <modifier>*</modifier></type><name>sps</name> <init>= <expr><call><name>ExecInitSubPlan</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>asstate</name><operator>-&gt;</operator><name>subplans</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>asstate</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>, <argument><expr><name>sps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>subPlan</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>subPlan</name></name></expr></argument>, <argument><expr><name>sps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Select the one to be used.  For this, we need an estimate of the number
	 * of executions of the subplan.  We use the number of output rows
	 * expected from the parent plan node.  This is a good estimate if we are
	 * in the parent's targetlist, and an underestimate (but probably not by
	 * more than a factor of 2) if we are in the qual.
	 */</comment>
	<expr_stmt><expr><name>num_calls</name> <operator>=</operator> <name><name>parent</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>plan_rows</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * The planner saved enough info so that we don't have to work very hard
	 * to estimate the total cost, given the number-of-calls estimate.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>asplan</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>subplan1</name> <operator>=</operator> <operator>(</operator><name>SubPlan</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>asplan</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>subplan2</name> <operator>=</operator> <operator>(</operator><name>SubPlan</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>asplan</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>cost1</name> <operator>=</operator> <name><name>subplan1</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>+</operator> <name>num_calls</name> <operator>*</operator> <name><name>subplan1</name><operator>-&gt;</operator><name>per_call_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cost2</name> <operator>=</operator> <name><name>subplan2</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>+</operator> <name>num_calls</name> <operator>*</operator> <name><name>subplan2</name><operator>-&gt;</operator><name>per_call_cost</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>cost1</name> <operator>&lt;</operator> <name>cost2</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>asstate</name><operator>-&gt;</operator><name>active</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>asstate</name><operator>-&gt;</operator><name>active</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>asstate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecAlternativeSubPlan
 *
 * Execute one of a set of alternative subplans.
 *
 * Note: in future we might consider changing to different subplans on the
 * fly, in case the original rowcount estimate turns out to be way off.
 */</comment>
<function><type><name>Datum</name></type>
<name>ExecAlternativeSubPlan</name><parameter_list>(<parameter><decl><type><name>AlternativeSubPlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
					   <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Just pass control to the active subplan */</comment>
	<decl_stmt><decl><type><name>SubPlanState</name> <modifier>*</modifier></type><name>activesp</name> <init>= <expr><call><name>list_nth_node</name><argument_list>(<argument><expr><name>SubPlanState</name></expr></argument>,
										   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>active</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>ExecSubPlan</name><argument_list>(<argument><expr><name>activesp</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><name>isNull</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
