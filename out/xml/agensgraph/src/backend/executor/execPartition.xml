<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/executor/execPartition.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * execPartition.c
 *	  Support routines for partitioning.
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/executor/execPartition.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tableam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/partition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execPartition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"foreign/fdwapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning/partbounds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning/partdesc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning/partprune.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteManip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/partcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rls.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ruleutils.h"</cpp:file></cpp:include>


<comment type="block">/*-----------------------
 * PartitionTupleRouting - Encapsulates all information required to
 * route a tuple inserted into a partitioned table to one of its leaf
 * partitions.
 *
 * partition_root
 *		The partitioned table that's the target of the command.
 *
 * partition_dispatch_info
 *		Array of 'max_dispatch' elements containing a pointer to a
 *		PartitionDispatch object for every partitioned table touched by tuple
 *		routing.  The entry for the target partitioned table is *always*
 *		present in the 0th element of this array.  See comment for
 *		PartitionDispatchData-&gt;indexes for details on how this array is
 *		indexed.
 *
 * nonleaf_partitions
 *		Array of 'max_dispatch' elements containing pointers to fake
 *		ResultRelInfo objects for nonleaf partitions, useful for checking
 *		the partition constraint.
 *
 * num_dispatch
 *		The current number of items stored in the 'partition_dispatch_info'
 *		array.  Also serves as the index of the next free array element for
 *		new PartitionDispatch objects that need to be stored.
 *
 * max_dispatch
 *		The current allocated size of the 'partition_dispatch_info' array.
 *
 * partitions
 *		Array of 'max_partitions' elements containing a pointer to a
 *		ResultRelInfo for every leaf partitions touched by tuple routing.
 *		Some of these are pointers to ResultRelInfos which are borrowed out of
 *		'subplan_resultrel_htab'.  The remainder have been built especially
 *		for tuple routing.  See comment for PartitionDispatchData-&gt;indexes for
 *		details on how this array is indexed.
 *
 * num_partitions
 *		The current number of items stored in the 'partitions' array.  Also
 *		serves as the index of the next free array element for new
 *		ResultRelInfo objects that need to be stored.
 *
 * max_partitions
 *		The current allocated size of the 'partitions' array.
 *
 * subplan_resultrel_htab
 *		Hash table to store subplan ResultRelInfos by Oid.  This is used to
 *		cache ResultRelInfos from subplans of an UPDATE ModifyTable node;
 *		NULL in other cases.  Some of these may be useful for tuple routing
 *		to save having to build duplicates.
 *
 * memcxt
 *		Memory context used to allocate subsidiary structs.
 *-----------------------
 */</comment>
<struct>struct <name>PartitionTupleRouting</name>
<block>{
	<decl_stmt><decl><type><name>Relation</name></type>	<name>partition_root</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionDispatch</name> <modifier>*</modifier></type><name>partition_dispatch_info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>nonleaf_partitions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_dispatch</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>max_dispatch</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>partitions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_partitions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>max_partitions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HTAB</name>	   <modifier>*</modifier></type><name>subplan_resultrel_htab</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>memcxt</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*-----------------------
 * PartitionDispatch - information about one partitioned table in a partition
 * hierarchy required to route a tuple to any of its partitions.  A
 * PartitionDispatch is always encapsulated inside a PartitionTupleRouting
 * struct and stored inside its 'partition_dispatch_info' array.
 *
 * reldesc
 *		Relation descriptor of the table
 *
 * key
 *		Partition key information of the table
 *
 * keystate
 *		Execution state required for expressions in the partition key
 *
 * partdesc
 *		Partition descriptor of the table
 *
 * tupslot
 *		A standalone TupleTableSlot initialized with this table's tuple
 *		descriptor, or NULL if no tuple conversion between the parent is
 *		required.
 *
 * tupmap
 *		TupleConversionMap to convert from the parent's rowtype to this table's
 *		rowtype  (when extracting the partition key of a tuple just before
 *		routing it through this table). A NULL value is stored if no tuple
 *		conversion is required.
 *
 * indexes
 *		Array of partdesc-&gt;nparts elements.  For leaf partitions the index
 *		corresponds to the partition's ResultRelInfo in the encapsulating
 *		PartitionTupleRouting's partitions array.  For partitioned partitions,
 *		the index corresponds to the PartitionDispatch for it in its
 *		partition_dispatch_info array.  -1 indicates we've not yet allocated
 *		anything in PartitionTupleRouting for the partition.
 *-----------------------
 */</comment>
<typedef>typedef <type><struct>struct <name>PartitionDispatchData</name>
<block>{
	<decl_stmt><decl><type><name>Relation</name></type>	<name>reldesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionKey</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>keystate</name></decl>;</decl_stmt>		<comment type="block">/* list of ExprState */</comment>
	<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>partdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>tupslot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrMap</name>    <modifier>*</modifier></type><name>tupmap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>indexes</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type>			<name>PartitionDispatchData</name>;</typedef>

<comment type="block">/* struct to hold result relations coming from UPDATE subplans */</comment>
<typedef>typedef <type><struct>struct <name>SubplanResultRelHashElem</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>			<comment type="block">/* hash key -- must be first */</comment>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rri</name></decl>;</decl_stmt>
}</block></struct></type> <name>SubplanResultRelHashElem</name>;</typedef>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecHashSubPlanResultRelsByOid</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>,
										   <parameter><decl><type><name>PartitionTupleRouting</name> <modifier>*</modifier></type><name>proute</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ResultRelInfo</name> <modifier>*</modifier></type><name>ExecInitPartitionInfo</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>,
											<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PartitionTupleRouting</name> <modifier>*</modifier></type><name>proute</name></decl></parameter>,
											<parameter><decl><type><name>PartitionDispatch</name></type> <name>dispatch</name></decl></parameter>,
											<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rootResultRelInfo</name></decl></parameter>,
											<parameter><decl><type><name>int</name></type> <name>partidx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecInitRoutingInfo</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>,
								<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
								<parameter><decl><type><name>PartitionTupleRouting</name> <modifier>*</modifier></type><name>proute</name></decl></parameter>,
								<parameter><decl><type><name>PartitionDispatch</name></type> <name>dispatch</name></decl></parameter>,
								<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>partRelInfo</name></decl></parameter>,
								<parameter><decl><type><name>int</name></type> <name>partidx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PartitionDispatch</name></type> <name>ExecInitPartitionDispatchInfo</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
													   <parameter><decl><type><name>PartitionTupleRouting</name> <modifier>*</modifier></type><name>proute</name></decl></parameter>,
													   <parameter><decl><type><name>Oid</name></type> <name>partoid</name></decl></parameter>, <parameter><decl><type><name>PartitionDispatch</name></type> <name>parent_pd</name></decl></parameter>,
													   <parameter><decl><type><name>int</name></type> <name>partidx</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rootResultRelInfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FormPartitionKeyDatum</name><parameter_list>(<parameter><decl><type><name>PartitionDispatch</name></type> <name>pd</name></decl></parameter>,
								  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
								  <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
								  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
								  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>get_partition_for_tuple</name><parameter_list>(<parameter><decl><type><name>PartitionDispatch</name></type> <name>pd</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
									<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>ExecBuildSlotPartitionKeyDescription</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
												  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
												  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>,
												  <parameter><decl><type><name>int</name></type> <name>maxfieldlen</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>adjust_partition_tlist</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>map</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecInitPruningContext</name><parameter_list>(<parameter><decl><type><name>PartitionPruneContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
								   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pruning_steps</name></decl></parameter>,
								   <parameter><decl><type><name>PartitionDesc</name></type> <name>partdesc</name></decl></parameter>,
								   <parameter><decl><type><name>PartitionKey</name></type> <name>partkey</name></decl></parameter>,
								   <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>find_matching_subplans_recurse</name><parameter_list>(<parameter><decl><type><name>PartitionPruningData</name> <modifier>*</modifier></type><name>prunedata</name></decl></parameter>,
										   <parameter><decl><type><name>PartitionedRelPruningData</name> <modifier>*</modifier></type><name>pprune</name></decl></parameter>,
										   <parameter><decl><type><name>bool</name></type> <name>initial_prune</name></decl></parameter>,
										   <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier><modifier>*</modifier></type><name>validsubplans</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * ExecSetupPartitionTupleRouting - sets up information needed during
 * tuple routing for partitioned tables, encapsulates it in
 * PartitionTupleRouting, and returns it.
 *
 * Callers must use the returned PartitionTupleRouting during calls to
 * ExecFindPartition().  The actual ResultRelInfo for a partition is only
 * allocated when the partition is found for the first time.
 *
 * The current memory context is used to allocate this struct and all
 * subsidiary structs that will be allocated from it later on.  Typically
 * it should be estate-&gt;es_query_cxt.
 */</comment>
<function><type><name>PartitionTupleRouting</name> <modifier>*</modifier></type>
<name>ExecSetupPartitionTupleRouting</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>,
							   <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionTupleRouting</name> <modifier>*</modifier></type><name>proute</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><ternary><condition><expr><name>mtstate</name></expr> ?</condition><then> <expr><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Here we attempt to expend as little effort as possible in setting up
	 * the PartitionTupleRouting.  Each partition's ResultRelInfo is built on
	 * demand, only when we actually need to route a tuple to that partition.
	 * The reason for this is that a common case is for INSERT to insert a
	 * single tuple into a partitioned table and this must be fast.
	 */</comment>
	<expr_stmt><expr><name>proute</name> <operator>=</operator> <operator>(</operator><name>PartitionTupleRouting</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionTupleRouting</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>partition_root</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>memcxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	<comment type="block">/* Rest of members initialized by zeroing */</comment>

	<comment type="block">/*
	 * Initialize this table's PartitionDispatch object.  Here we pass in the
	 * parent as NULL as we don't need to care about any parent of the target
	 * partitioned table.
	 */</comment>
	<expr_stmt><expr><call><name>ExecInitPartitionDispatchInfo</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>proute</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If performing an UPDATE with tuple routing, we can reuse partition
	 * sub-plan result rels.  We build a hash table to map the OIDs of
	 * partitions present in mtstate-&gt;resultRelInfo to their ResultRelInfos.
	 * Every time a tuple is routed to a partition that we've yet to set the
	 * ResultRelInfo for, before we go to the trouble of making one, we check
	 * for a pre-made one in the hash table.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_UPDATE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecHashSubPlanResultRelsByOid</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>, <argument><expr><name>proute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>proute</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecFindPartition -- Return the ResultRelInfo for the leaf partition that
 * the tuple contained in *slot should belong to.
 *
 * If the partition's ResultRelInfo does not yet exist in 'proute' then we set
 * one up or reuse one from mtstate's resultRelInfo array.  When reusing a
 * ResultRelInfo from the mtstate we verify that the relation is a valid
 * target for INSERTs and then set up a PartitionRoutingInfo for it.
 *
 * rootResultRelInfo is the relation named in the query.
 *
 * estate must be non-NULL; we'll need it to compute any expressions in the
 * partition keys.  Also, its per-tuple contexts are used as evaluation
 * scratch space.
 *
 * If no leaf partition is found, this routine errors out with the appropriate
 * error message.  An error may also be raised if the found target partition
 * is not a valid target for an INSERT.
 */</comment>
<function><type><name>ResultRelInfo</name> <modifier>*</modifier></type>
<name>ExecFindPartition</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>,
				  <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rootResultRelInfo</name></decl></parameter>,
				  <parameter><decl><type><name>PartitionTupleRouting</name> <modifier>*</modifier></type><name>proute</name></decl></parameter>,
				  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionDispatch</name> <modifier>*</modifier></type><name>pd</name> <init>= <expr><name><name>proute</name><operator>-&gt;</operator><name>partition_dispatch_info</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>PARTITION_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>isnull</name><index>[<expr><name>PARTITION_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionDispatch</name></type> <name>dispatch</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>partdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>ecxt</name> <init>= <expr><call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>ecxt_scantuple_saved</name> <init>= <expr><name><name>ecxt</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>rootslot</name> <init>= <expr><name>slot</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>myslot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rri</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* use per-tuple context here to avoid leaking memory */</comment>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>GetPerTupleMemoryContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * First check the root table's partition constraint, if any.  No point in
	 * routing the tuple if it doesn't belong in the root table itself.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rootResultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionCheck</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecPartitionCheck</name><argument_list>(<argument><expr><name>rootResultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* start with the root partitioned table */</comment>
	<expr_stmt><expr><name>dispatch</name> <operator>=</operator> <name><name>pd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>dispatch</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>partidx</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>rel</name> <operator>=</operator> <name><name>dispatch</name><operator>-&gt;</operator><name>reldesc</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>partdesc</name> <operator>=</operator> <name><name>dispatch</name><operator>-&gt;</operator><name>partdesc</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Extract partition key from tuple. Expression evaluation machinery
		 * that FormPartitionKeyDatum() invokes expects ecxt_scantuple to
		 * point to the correct tuple slot.  The slot might have changed from
		 * what was used for the parent table if the table of the current
		 * partitioning level has different tuple descriptor from the parent.
		 * So update ecxt_scantuple accordingly.
		 */</comment>
		<expr_stmt><expr><name><name>ecxt</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FormPartitionKeyDatum</name><argument_list>(<argument><expr><name>dispatch</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If this partitioned table has no partitions or no partition for
		 * these values, error out.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<operator>(</operator><name>partidx</name> <operator>=</operator> <call><name>get_partition_for_tuple</name><argument_list>(<argument><expr><name>dispatch</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val_desc</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>val_desc</name> <operator>=</operator> <call><name>ExecBuildSlotPartitionKeyDescription</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
															<argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CHECK_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no partition of relation \"%s\" found for row"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <ternary><condition><expr><name>val_desc</name></expr> ?</condition><then>
					 <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Partition key of the failing row contains %s."</literal></expr></argument>,
							   <argument><expr><name>val_desc</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
					 <call><name>errtable</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>partdesc</name><operator>-&gt;</operator><name>is_leaf</name><index>[<expr><name>partidx</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We've reached the leaf -- hurray, we're done.  Look to see if
			 * we've already got a ResultRelInfo for this partition.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><name><name>dispatch</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>partidx</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* ResultRelInfo already built */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>dispatch</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>partidx</name></expr>]</index></name> <operator>&lt;</operator> <name><name>proute</name><operator>-&gt;</operator><name>num_partitions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>rri</name> <operator>=</operator> <name><name>proute</name><operator>-&gt;</operator><name>partitions</name><index>[<expr><name><name>dispatch</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>partidx</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * We have not yet set up a ResultRelInfo for this partition,
				 * but if we have a subplan hash table, we might have one
				 * there.  If not, we'll have to create one.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>proute</name><operator>-&gt;</operator><name>subplan_resultrel_htab</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>partoid</name> <init>= <expr><name><name>partdesc</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name>partidx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>SubplanResultRelHashElem</name> <modifier>*</modifier></type><name>elem</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>elem</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>proute</name><operator>-&gt;</operator><name>subplan_resultrel_htab</name></name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>partoid</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>elem</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>rri</name> <operator>=</operator> <name><name>elem</name><operator>-&gt;</operator><name>rri</name></name></expr>;</expr_stmt>

						<comment type="block">/* Verify this ResultRelInfo allows INSERTs */</comment>
						<expr_stmt><expr><call><name>CheckValidResultRel</name><argument_list>(<argument><expr><name>rri</name></expr></argument>, <argument><expr><name>CMD_INSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/* Set up the PartitionRoutingInfo for it */</comment>
						<expr_stmt><expr><call><name>ExecInitRoutingInfo</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>proute</name></expr></argument>, <argument><expr><name>dispatch</name></expr></argument>,
											<argument><expr><name>rri</name></expr></argument>, <argument><expr><name>partidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* We need to create a new one. */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>rri</name> <operator>=</operator> <call><name>ExecInitPartitionInfo</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>proute</name></expr></argument>,
												<argument><expr><name>dispatch</name></expr></argument>,
												<argument><expr><name>rootResultRelInfo</name></expr></argument>, <argument><expr><name>partidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rri</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Signal to terminate the loop */</comment>
			<expr_stmt><expr><name>dispatch</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Partition is a sub-partitioned table; get the PartitionDispatch
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><name><name>dispatch</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>partidx</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Already built. */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>dispatch</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>partidx</name></expr>]</index></name> <operator>&lt;</operator> <name><name>proute</name><operator>-&gt;</operator><name>num_dispatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>rri</name> <operator>=</operator> <name><name>proute</name><operator>-&gt;</operator><name>nonleaf_partitions</name><index>[<expr><name><name>dispatch</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>partidx</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Move down to the next partition level and search again
				 * until we find a leaf partition that matches this tuple
				 */</comment>
				<expr_stmt><expr><name>dispatch</name> <operator>=</operator> <name><name>pd</name><index>[<expr><name><name>dispatch</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>partidx</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Not yet built. Do that now. */</comment>
				<decl_stmt><decl><type><name>PartitionDispatch</name></type> <name>subdispatch</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * Create the new PartitionDispatch.  We pass the current one
				 * in as the parent PartitionDispatch
				 */</comment>
				<expr_stmt><expr><name>subdispatch</name> <operator>=</operator> <call><name>ExecInitPartitionDispatchInfo</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
															<argument><expr><name>proute</name></expr></argument>,
															<argument><expr><name><name>partdesc</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name>partidx</name></expr>]</index></name></expr></argument>,
															<argument><expr><name>dispatch</name></expr></argument>, <argument><expr><name>partidx</name></expr></argument>,
															<argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>rootResultRelInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>dispatch</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>partidx</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
					   <name><name>dispatch</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>partidx</name></expr>]</index></name> <operator>&lt;</operator> <name><name>proute</name><operator>-&gt;</operator><name>num_dispatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>rri</name> <operator>=</operator> <name><name>proute</name><operator>-&gt;</operator><name>nonleaf_partitions</name><index>[<expr><name><name>dispatch</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>partidx</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>dispatch</name> <operator>=</operator> <name>subdispatch</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/*
			 * Convert the tuple to the new parent's layout, if different from
			 * the previous parent.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>dispatch</name><operator>-&gt;</operator><name>tupslot</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AttrMap</name>    <modifier>*</modifier></type><name>map</name> <init>= <expr><name><name>dispatch</name><operator>-&gt;</operator><name>tupmap</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>tempslot</name> <init>= <expr><name>myslot</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>myslot</name> <operator>=</operator> <name><name>dispatch</name><operator>-&gt;</operator><name>tupslot</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>execute_attr_map_slot</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>myslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>tempslot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>tempslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * If this partition is the default one, we must check its partition
		 * constraint now, which may have changed concurrently due to
		 * partitions being added to the parent.
		 *
		 * (We do this here, and do not rely on ExecInsert doing it, because
		 * we don't want to miss doing it for non-leaf partitions.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>partidx</name> <operator>==</operator> <name><name>partdesc</name><operator>-&gt;</operator><name>boundinfo</name><operator>-&gt;</operator><name>default_index</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PartitionRoutingInfo</name> <modifier>*</modifier></type><name>partrouteinfo</name> <init>= <expr><name><name>rri</name><operator>-&gt;</operator><name>ri_PartitionInfo</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * The tuple must match the partition's layout for the constraint
			 * expression to be evaluated successfully.  If the partition is
			 * sub-partitioned, that would already be the case due to the code
			 * above, but for a leaf partition the tuple still matches the
			 * parent's layout.
			 *
			 * Note that we have a map to convert from root to current
			 * partition, but not from immediate parent to current partition.
			 * So if we have to convert, do it from the root slot; if not, use
			 * the root slot as-is.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>partrouteinfo</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>map</name> <init>= <expr><name><name>partrouteinfo</name><operator>-&gt;</operator><name>pi_RootToPartitionMap</name></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>map</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>execute_attr_map_slot</name><argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>attrMap</name></name></expr></argument>, <argument><expr><name>rootslot</name></expr></argument>,
												 <argument><expr><name><name>partrouteinfo</name><operator>-&gt;</operator><name>pi_PartitionTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>slot</name> <operator>=</operator> <name>rootslot</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>ExecPartitionCheck</name><argument_list>(<argument><expr><name>rri</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Release the tuple in the lowest parent's dedicated slot. */</comment>
	<if_stmt><if>if <condition>(<expr><name>myslot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>myslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* and restore ecxt's scantuple */</comment>
	<expr_stmt><expr><name><name>ecxt</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>ecxt_scantuple_saved</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rri</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecHashSubPlanResultRelsByOid
 *		Build a hash table to allow fast lookups of subplan ResultRelInfos by
 *		partition Oid.  We also populate the subplan ResultRelInfo with an
 *		ri_PartitionRoot.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecHashSubPlanResultRelsByOid</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>,
							   <parameter><decl><type><name>PartitionTupleRouting</name> <modifier>*</modifier></type><name>proute</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>ctl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HTAB</name>	   <modifier>*</modifier></type><name>htab</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SubplanResultRelHashElem</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>htab</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"PartitionTupleRouting table"</literal></expr></argument>, <argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_nplans</name></name></expr></argument>,
					   <argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>subplan_resultrel_htab</name></name> <operator>=</operator> <name>htab</name></expr>;</expr_stmt>

	<comment type="block">/* Hash all subplans by their Oid */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>mt_nplans</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rri</name> <init>= <expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>resultRelInfo</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>partoid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>rri</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SubplanResultRelHashElem</name> <modifier>*</modifier></type><name>elem</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>elem</name> <operator>=</operator> <operator>(</operator><name>SubplanResultRelHashElem</name> <operator>*</operator><operator>)</operator>
			<call><name>hash_search</name><argument_list>(<argument><expr><name>htab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>partoid</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>elem</name><operator>-&gt;</operator><name>rri</name></name> <operator>=</operator> <name>rri</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * This is required in order to convert the partition's tuple to be
		 * compatible with the root partitioned table's tuple descriptor. When
		 * generating the per-subplan result rels, this was not set.
		 */</comment>
		<expr_stmt><expr><name><name>rri</name><operator>-&gt;</operator><name>ri_RootResultRelInfo</name></name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>rootResultRelInfo</name></name></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * ExecInitPartitionInfo
 *		Lock the partition and initialize ResultRelInfo.  Also setup other
 *		information for the partition and store it in the next empty slot in
 *		the proute-&gt;partitions array.
 *
 * Returns the ResultRelInfo
 */</comment>
<function><type><specifier>static</specifier> <name>ResultRelInfo</name> <modifier>*</modifier></type>
<name>ExecInitPartitionInfo</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
					  <parameter><decl><type><name>PartitionTupleRouting</name> <modifier>*</modifier></type><name>proute</name></decl></parameter>,
					  <parameter><decl><type><name>PartitionDispatch</name></type> <name>dispatch</name></decl></parameter>,
					  <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rootResultRelInfo</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>partidx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>partrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>firstVarno</name> <init>= <expr><name><name>mtstate</name><operator>-&gt;</operator><name>resultRelInfo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>ri_RangeTableIndex</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>firstResultRel</name> <init>= <expr><name><name>mtstate</name><operator>-&gt;</operator><name>resultRelInfo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>ri_RelationDesc</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>leaf_part_rri</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrMap</name>    <modifier>*</modifier></type><name>part_attmap</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found_whole_row</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>proute</name><operator>-&gt;</operator><name>memcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>partrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>dispatch</name><operator>-&gt;</operator><name>partdesc</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name>partidx</name></expr>]</index></name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>leaf_part_rri</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ResultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InitResultRelInfo</name><argument_list>(<argument><expr><name>leaf_part_rri</name></expr></argument>,
					  <argument><expr><name>partrel</name></expr></argument>,
					  <argument><expr><literal type="number">0</literal></expr></argument>,
					  <argument><expr><name>rootResultRelInfo</name></expr></argument>,
					  <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_instrument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Verify result relation is a valid target for an INSERT.  An UPDATE of a
	 * partition-key becomes a DELETE+INSERT operation, so this check is still
	 * required when the operation is CMD_UPDATE.
	 */</comment>
	<expr_stmt><expr><call><name>CheckValidResultRel</name><argument_list>(<argument><expr><name>leaf_part_rri</name></expr></argument>, <argument><expr><name>CMD_INSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Open partition indices.  The user may have asked to check for conflicts
	 * within this leaf partition and do "nothing" instead of throwing an
	 * error.  Be prepared in that case by initializing the index information
	 * needed by ExecInsert() to perform speculative insertions.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>partrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasindex</name></name> <operator>&amp;&amp;</operator>
		<name><name>leaf_part_rri</name><operator>-&gt;</operator><name>ri_IndexRelationDescs</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecOpenIndices</name><argument_list>(<argument><expr><name>leaf_part_rri</name></expr></argument>,
						<argument><expr><operator>(</operator><name>node</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
						 <name><name>node</name><operator>-&gt;</operator><name>onConflictAction</name></name> <operator>!=</operator> <name>ONCONFLICT_NONE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Build WITH CHECK OPTION constraints for the partition.  Note that we
	 * didn't build the withCheckOptionList for partitions within the planner,
	 * but simple translation of varattnos will suffice.  This only occurs for
	 * the INSERT case or in the case of UPDATE tuple routing where we didn't
	 * find a result rel to reuse in ExecSetupPartitionTupleRouting().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>withCheckOptionLists</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>wcoList</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>wcoExprs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ll</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * In the case of INSERT on a partitioned table, there is only one
		 * plan.  Likewise, there is only one WCO list, not one per partition.
		 * For UPDATE, there are as many WCO lists as there are plans.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_INSERT</name> <operator>&amp;&amp;</operator>
				<call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>withCheckOptionLists</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
				<call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>plans</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal><operator>)</operator> <operator>||</operator>
			   <operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>&amp;&amp;</operator>
				<call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>withCheckOptionLists</name></name></expr></argument>)</argument_list></call> <operator>==</operator>
				<call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>plans</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Use the WCO list of the first plan as a reference to calculate
		 * attno's for the WCO list of this partition.  In the INSERT case,
		 * that refers to the root partitioned table, whereas in the UPDATE
		 * tuple routing case, that refers to the first partition in the
		 * mtstate-&gt;resultRelInfo array.  In any case, both that relation and
		 * this partition should have the same columns, so we should be able
		 * to map attributes successfully.
		 */</comment>
		<expr_stmt><expr><name>wcoList</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>withCheckOptionLists</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Convert Vars in it to contain this partition's attribute numbers.
		 */</comment>
		<expr_stmt><expr><name>part_attmap</name> <operator>=</operator>
			<call><name>build_attrmap_by_name</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>firstResultRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>wcoList</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>map_variable_attnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>wcoList</name></expr></argument>,
								<argument><expr><name>firstVarno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
								<argument><expr><name>part_attmap</name></expr></argument>,
								<argument><expr><call><name>RelationGetForm</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>reltype</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* We ignore the value of found_whole_row. */</comment>

		<macro><name>foreach</name><argument_list>(<argument>ll</argument>, <argument>wcoList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>WithCheckOption</name> <modifier>*</modifier></type><name>wco</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>WithCheckOption</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>ll</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>wcoExpr</name> <init>= <expr><call><name>ExecInitQual</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name><name>wco</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>wcoExprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>wcoExprs</name></expr></argument>, <argument><expr><name>wcoExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><name><name>leaf_part_rri</name><operator>-&gt;</operator><name>ri_WithCheckOptions</name></name> <operator>=</operator> <name>wcoList</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>leaf_part_rri</name><operator>-&gt;</operator><name>ri_WithCheckOptionExprs</name></name> <operator>=</operator> <name>wcoExprs</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Build the RETURNING projection for the partition.  Note that we didn't
	 * build the returningList for partitions within the planner, but simple
	 * translation of varattnos will suffice.  This only occurs for the INSERT
	 * case or in the case of UPDATE tuple routing where we didn't find a
	 * result rel to reuse in ExecSetupPartitionTupleRouting().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>returningLists</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>returningList</name></decl>;</decl_stmt>

		<comment type="block">/* See the comment above for WCO lists. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_INSERT</name> <operator>&amp;&amp;</operator>
				<call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>returningLists</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
				<call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>plans</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal><operator>)</operator> <operator>||</operator>
			   <operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>&amp;&amp;</operator>
				<call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>returningLists</name></name></expr></argument>)</argument_list></call> <operator>==</operator>
				<call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>plans</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Use the RETURNING list of the first plan as a reference to
		 * calculate attno's for the RETURNING list of this partition.  See
		 * the comment above for WCO lists for more details on why this is
		 * okay.
		 */</comment>
		<expr_stmt><expr><name>returningList</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>returningLists</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Convert Vars in it to contain this partition's attribute numbers.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>part_attmap</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>part_attmap</name> <operator>=</operator>
				<call><name>build_attrmap_by_name</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>firstResultRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>returningList</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>map_variable_attnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>returningList</name></expr></argument>,
								<argument><expr><name>firstVarno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
								<argument><expr><name>part_attmap</name></expr></argument>,
								<argument><expr><call><name>RelationGetForm</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>reltype</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* We ignore the value of found_whole_row. */</comment>

		<expr_stmt><expr><name><name>leaf_part_rri</name><operator>-&gt;</operator><name>ri_returningList</name></name> <operator>=</operator> <name>returningList</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Initialize the projection itself.
		 *
		 * Use the slot and the expression context that would have been set up
		 * in ExecInitModifyTable() for projection's output.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>leaf_part_rri</name><operator>-&gt;</operator><name>ri_projectReturning</name></name> <operator>=</operator>
			<call><name>ExecBuildProjectionInfo</name><argument_list>(<argument><expr><name>returningList</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Set up information needed for routing tuples to the partition. */</comment>
	<expr_stmt><expr><call><name>ExecInitRoutingInfo</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>proute</name></expr></argument>, <argument><expr><name>dispatch</name></expr></argument>,
						<argument><expr><name>leaf_part_rri</name></expr></argument>, <argument><expr><name>partidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there is an ON CONFLICT clause, initialize state for it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>onConflictAction</name></name> <operator>!=</operator> <name>ONCONFLICT_NONE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>partrelDesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>arbiterIndexes</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If there is a list of arbiter indexes, map it to a list of indexes
		 * in the partition.  We do that by scanning the partition's index
		 * list and searching for ancestry relationships to each index in the
		 * ancestor table.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rootResultRelInfo</name><operator>-&gt;</operator><name>ri_onConflictArbiterIndexes</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>childIdxs</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>childIdxs</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name><name>leaf_part_rri</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>childIdxs</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>childIdx</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>ancestors</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>ancestors</name> <operator>=</operator> <call><name>get_partition_ancestors</name><argument_list>(<argument><expr><name>childIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>rootResultRelInfo-&gt;ri_onConflictArbiterIndexes</argument>)</argument_list></macro>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>list_member_oid</name><argument_list>(<argument><expr><name>ancestors</name></expr></argument>, <argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>arbiterIndexes</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>arbiterIndexes</name></expr></argument>, <argument><expr><name>childIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block>
				<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>ancestors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If the resulting lists are of inequal length, something is wrong.
		 * (This shouldn't happen, since arbiter index selection should not
		 * pick up an invalid index.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rootResultRelInfo</name><operator>-&gt;</operator><name>ri_onConflictArbiterIndexes</name></name></expr></argument>)</argument_list></call> <operator>!=</operator>
			<call><name>list_length</name><argument_list>(<argument><expr><name>arbiterIndexes</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid arbiter index list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>leaf_part_rri</name><operator>-&gt;</operator><name>ri_onConflictArbiterIndexes</name></name> <operator>=</operator> <name>arbiterIndexes</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * In the DO UPDATE case, we have some more state to initialize.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>onConflictAction</name></name> <operator>==</operator> <name>ONCONFLICT_UPDATE</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OnConflictSetState</name> <modifier>*</modifier></type><name>onconfl</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>OnConflictSetState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>map</name> <operator>=</operator> <name><name>leaf_part_rri</name><operator>-&gt;</operator><name>ri_PartitionInfo</name><operator>-&gt;</operator><name>pi_RootToPartitionMap</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>onConflictSet</name></name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rootResultRelInfo</name><operator>-&gt;</operator><name>ri_onConflict</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>leaf_part_rri</name><operator>-&gt;</operator><name>ri_onConflict</name></name> <operator>=</operator> <name>onconfl</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Need a separate existing slot for each partition, as the
			 * partition could be of a different AM, even if the tuple
			 * descriptors match.
			 */</comment>
			<expr_stmt><expr><name><name>onconfl</name><operator>-&gt;</operator><name>oc_Existing</name></name> <operator>=</operator>
				<call><name>table_slot_create</name><argument_list>(<argument><expr><name><name>leaf_part_rri</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>es_tupleTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If the partition's tuple descriptor matches exactly the root
			 * parent (the common case), we can re-use most of the parent's ON
			 * CONFLICT SET state, skipping a bunch of work.  Otherwise, we
			 * need to create state specific to this partition.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>map</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * It's safe to reuse these from the partition root, as we
				 * only process one tuple at a time (therefore we won't
				 * overwrite needed data in slots), and the results of
				 * projections are independent of the underlying storage.
				 * Projections and where clauses themselves don't store state
				 * / are independent of the underlying storage.
				 */</comment>
				<expr_stmt><expr><name><name>onconfl</name><operator>-&gt;</operator><name>oc_ProjSlot</name></name> <operator>=</operator>
					<name><name>rootResultRelInfo</name><operator>-&gt;</operator><name>ri_onConflict</name><operator>-&gt;</operator><name>oc_ProjSlot</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>onconfl</name><operator>-&gt;</operator><name>oc_ProjInfo</name></name> <operator>=</operator>
					<name><name>rootResultRelInfo</name><operator>-&gt;</operator><name>ri_onConflict</name><operator>-&gt;</operator><name>oc_ProjInfo</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>onconfl</name><operator>-&gt;</operator><name>oc_WhereClause</name></name> <operator>=</operator>
					<name><name>rootResultRelInfo</name><operator>-&gt;</operator><name>ri_onConflict</name><operator>-&gt;</operator><name>oc_WhereClause</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>onconflset</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>found_whole_row</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * Translate expressions in onConflictSet to account for
				 * different attribute numbers.  For that, map partition
				 * varattnos twice: first to catch the EXCLUDED
				 * pseudo-relation (INNER_VAR), and second to handle the main
				 * target relation (firstVarno).
				 */</comment>
				<expr_stmt><expr><name>onconflset</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>onConflictSet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>part_attmap</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>part_attmap</name> <operator>=</operator>
						<call><name>build_attrmap_by_name</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>firstResultRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>onconflset</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
					<call><name>map_variable_attnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>onconflset</name></expr></argument>,
										<argument><expr><name>INNER_VAR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
										<argument><expr><name>part_attmap</name></expr></argument>,
										<argument><expr><call><name>RelationGetForm</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>reltype</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* We ignore the value of found_whole_row. */</comment>
				<expr_stmt><expr><name>onconflset</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
					<call><name>map_variable_attnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>onconflset</name></expr></argument>,
										<argument><expr><name>firstVarno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
										<argument><expr><name>part_attmap</name></expr></argument>,
										<argument><expr><call><name>RelationGetForm</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>reltype</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* We ignore the value of found_whole_row. */</comment>

				<comment type="block">/* Finally, reorder the tlist to match the partition. */</comment>
				<expr_stmt><expr><name>onconflset</name> <operator>=</operator> <call><name>adjust_partition_tlist</name><argument_list>(<argument><expr><name>onconflset</name></expr></argument>, <argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* create the tuple slot for the UPDATE SET projection */</comment>
				<expr_stmt><expr><name><name>onconfl</name><operator>-&gt;</operator><name>oc_ProjSlot</name></name> <operator>=</operator>
					<call><name>table_slot_create</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>es_tupleTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* build UPDATE SET projection state */</comment>
				<expr_stmt><expr><name><name>onconfl</name><operator>-&gt;</operator><name>oc_ProjInfo</name></name> <operator>=</operator>
					<call><name>ExecBuildProjectionInfoExt</name><argument_list>(<argument><expr><name>onconflset</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>,
											   <argument><expr><name><name>onconfl</name><operator>-&gt;</operator><name>oc_ProjSlot</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>, <argument><expr><name>partrelDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If there is a WHERE clause, initialize state where it will
				 * be evaluated, mapping the attribute numbers appropriately.
				 * As with onConflictSet, we need to map partition varattnos
				 * to the partition's tupdesc.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>onConflictWhere</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>clause</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>clause</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>onConflictWhere</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>clause</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
						<call><name>map_variable_attnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>,
											<argument><expr><name>INNER_VAR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
											<argument><expr><name>part_attmap</name></expr></argument>,
											<argument><expr><call><name>RelationGetForm</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>reltype</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* We ignore the value of found_whole_row. */</comment>
					<expr_stmt><expr><name>clause</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
						<call><name>map_variable_attnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>,
											<argument><expr><name>firstVarno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
											<argument><expr><name>part_attmap</name></expr></argument>,
											<argument><expr><call><name>RelationGetForm</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>reltype</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* We ignore the value of found_whole_row. */</comment>
					<expr_stmt><expr><name><name>onconfl</name><operator>-&gt;</operator><name>oc_WhereClause</name></name> <operator>=</operator>
						<call><name>ExecInitQual</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Since we've just initialized this ResultRelInfo, it's not in any list
	 * attached to the estate as yet.  Add it, so that it can be found later.
	 *
	 * Note that the entries in this list appear in no predetermined order,
	 * because partition result rels are initialized as and when they're
	 * needed.
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_tuple_routing_result_relations</name></name> <operator>=</operator>
		<call><name>lappend</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_tuple_routing_result_relations</name></name></expr></argument>,
				<argument><expr><name>leaf_part_rri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>leaf_part_rri</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecInitRoutingInfo
 *		Set up information needed for translating tuples between root
 *		partitioned table format and partition format, and keep track of it
 *		in PartitionTupleRouting.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecInitRoutingInfo</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>,
					<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
					<parameter><decl><type><name>PartitionTupleRouting</name> <modifier>*</modifier></type><name>proute</name></decl></parameter>,
					<parameter><decl><type><name>PartitionDispatch</name></type> <name>dispatch</name></decl></parameter>,
					<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>partRelInfo</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>partidx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rootRelInfo</name> <init>= <expr><name><name>partRelInfo</name><operator>-&gt;</operator><name>ri_RootResultRelInfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionRoutingInfo</name> <modifier>*</modifier></type><name>partrouteinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rri_index</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>proute</name><operator>-&gt;</operator><name>memcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>partrouteinfo</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionRoutingInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up a tuple conversion map to convert a tuple routed to the
	 * partition from the parent's type to the partition's.
	 */</comment>
	<expr_stmt><expr><name><name>partrouteinfo</name><operator>-&gt;</operator><name>pi_RootToPartitionMap</name></name> <operator>=</operator>
		<call><name>convert_tuples_by_name</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>rootRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>partRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If a partition has a different rowtype than the root parent, initialize
	 * a slot dedicated to storing this partition's tuples.  The slot is used
	 * for various operations that are applied to tuples after routing, such
	 * as checking constraints.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>partrouteinfo</name><operator>-&gt;</operator><name>pi_RootToPartitionMap</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>partrel</name> <init>= <expr><name><name>partRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Initialize the slot itself setting its descriptor to this
		 * partition's TupleDesc; TupleDesc reference will be released at the
		 * end of the command.
		 */</comment>
		<expr_stmt><expr><name><name>partrouteinfo</name><operator>-&gt;</operator><name>pi_PartitionTupleSlot</name></name> <operator>=</operator>
			<call><name>table_slot_create</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>estate</name><operator>-&gt;</operator><name>es_tupleTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>partrouteinfo</name><operator>-&gt;</operator><name>pi_PartitionTupleSlot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Also, if transition capture is required, store a map to convert tuples
	 * from partition's rowtype to the root partition table's.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>mtstate</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name></name> <operator>||</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>mt_oc_transition_capture</name></name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>partrouteinfo</name><operator>-&gt;</operator><name>pi_PartitionToRootMap</name></name> <operator>=</operator>
			<call><name>convert_tuples_by_name</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>partRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>rootRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>partrouteinfo</name><operator>-&gt;</operator><name>pi_PartitionToRootMap</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * If the partition is a foreign table, let the FDW init itself for
	 * routing tuples to the partition.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>partRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<name><name>partRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name><operator>-&gt;</operator><name>BeginForeignInsert</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>partRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name><operator>-&gt;</operator><name>BeginForeignInsert</name></name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>, <argument><expr><name>partRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>partRelInfo</name><operator>-&gt;</operator><name>ri_PartitionInfo</name></name> <operator>=</operator> <name>partrouteinfo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>partRelInfo</name><operator>-&gt;</operator><name>ri_CopyMultiInsertBuffer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Keep track of it in the PartitionTupleRouting-&gt;partitions array.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>dispatch</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>partidx</name></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rri_index</name> <operator>=</operator> <name><name>proute</name><operator>-&gt;</operator><name>num_partitions</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/* Allocate or enlarge the array, as needed */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>proute</name><operator>-&gt;</operator><name>num_partitions</name></name> <operator>&gt;=</operator> <name><name>proute</name><operator>-&gt;</operator><name>max_partitions</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>proute</name><operator>-&gt;</operator><name>max_partitions</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>max_partitions</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>partitions</name></name> <operator>=</operator> <operator>(</operator><name>ResultRelInfo</name> <operator>*</operator><operator>*</operator><operator>)</operator>
				<call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ResultRelInfo</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>proute</name><operator>-&gt;</operator><name>max_partitions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>max_partitions</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>partitions</name></name> <operator>=</operator> <operator>(</operator><name>ResultRelInfo</name> <operator>*</operator><operator>*</operator><operator>)</operator>
				<call><name>repalloc</name><argument_list>(<argument><expr><name><name>proute</name><operator>-&gt;</operator><name>partitions</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ResultRelInfo</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator>
						 <name><name>proute</name><operator>-&gt;</operator><name>max_partitions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>partitions</name><index>[<expr><name>rri_index</name></expr>]</index></name> <operator>=</operator> <name>partRelInfo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dispatch</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>partidx</name></expr>]</index></name> <operator>=</operator> <name>rri_index</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecInitPartitionDispatchInfo
 *		Lock the partitioned table (if not locked already) and initialize
 *		PartitionDispatch for a partitioned table and store it in the next
 *		available slot in the proute-&gt;partition_dispatch_info array.  Also,
 *		record the index into this array in the parent_pd-&gt;indexes[] array in
 *		the partidx element so that we can properly retrieve the newly created
 *		PartitionDispatch later.
 */</comment>
<function><type><specifier>static</specifier> <name>PartitionDispatch</name></type>
<name>ExecInitPartitionDispatchInfo</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
							  <parameter><decl><type><name>PartitionTupleRouting</name> <modifier>*</modifier></type><name>proute</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>partoid</name></decl></parameter>,
							  <parameter><decl><type><name>PartitionDispatch</name></type> <name>parent_pd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>partidx</name></decl></parameter>,
							  <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rootResultRelInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>partdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionDispatch</name></type> <name>pd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dispatchidx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_partition_directory</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_partition_directory</name></name> <operator>=</operator>
			<call><name>CreatePartitionDirectory</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>proute</name><operator>-&gt;</operator><name>memcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Only sub-partitioned tables need to be locked here.  The root
	 * partitioned table will already have been locked as it's referenced in
	 * the query's rtable.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>partoid</name> <operator>!=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>proute</name><operator>-&gt;</operator><name>partition_root</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>partoid</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>rel</name> <operator>=</operator> <name><name>proute</name><operator>-&gt;</operator><name>partition_root</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>partdesc</name> <operator>=</operator> <call><name>PartitionDirectoryLookup</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_partition_directory</name></name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pd</name> <operator>=</operator> <operator>(</operator><name>PartitionDispatch</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PartitionDispatchData</name></expr></argument>, <argument><expr><name>indexes</name></expr></argument>)</argument_list></call> <operator>+</operator>
									<name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pd</name><operator>-&gt;</operator><name>reldesc</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pd</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pd</name><operator>-&gt;</operator><name>keystate</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pd</name><operator>-&gt;</operator><name>partdesc</name></name> <operator>=</operator> <name>partdesc</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>parent_pd</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * For sub-partitioned tables where the column order differs from its
		 * direct parent partitioned table, we must store a tuple table slot
		 * initialized with its tuple descriptor and a tuple conversion map to
		 * convert a tuple from its parent's rowtype to its own.  This is to
		 * make sure that we are looking at the correct row using the correct
		 * tuple descriptor when computing its partition key for tuple
		 * routing.
		 */</comment>
		<expr_stmt><expr><name><name>pd</name><operator>-&gt;</operator><name>tupmap</name></name> <operator>=</operator> <call><name>build_attrmap_by_name_if_req</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>parent_pd</name><operator>-&gt;</operator><name>reldesc</name></name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pd</name><operator>-&gt;</operator><name>tupslot</name></name> <operator>=</operator> <ternary><condition><expr><name><name>pd</name><operator>-&gt;</operator><name>tupmap</name></name></expr> ?</condition><then>
			<expr><call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Not required for the root partitioned table */</comment>
		<expr_stmt><expr><name><name>pd</name><operator>-&gt;</operator><name>tupmap</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pd</name><operator>-&gt;</operator><name>tupslot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Initialize with -1 to signify that the corresponding partition's
	 * ResultRelInfo or PartitionDispatch has not been created yet.
	 */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>pd</name><operator>-&gt;</operator><name>indexes</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Track in PartitionTupleRouting for later use */</comment>
	<expr_stmt><expr><name>dispatchidx</name> <operator>=</operator> <name><name>proute</name><operator>-&gt;</operator><name>num_dispatch</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/* Allocate or enlarge the array, as needed */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>proute</name><operator>-&gt;</operator><name>num_dispatch</name></name> <operator>&gt;=</operator> <name><name>proute</name><operator>-&gt;</operator><name>max_dispatch</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>proute</name><operator>-&gt;</operator><name>max_dispatch</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>max_dispatch</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>partition_dispatch_info</name></name> <operator>=</operator> <operator>(</operator><name>PartitionDispatch</name> <operator>*</operator><operator>)</operator>
				<call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionDispatch</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>proute</name><operator>-&gt;</operator><name>max_dispatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>nonleaf_partitions</name></name> <operator>=</operator> <operator>(</operator><name>ResultRelInfo</name> <operator>*</operator><operator>*</operator><operator>)</operator>
				<call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ResultRelInfo</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>proute</name><operator>-&gt;</operator><name>max_dispatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>max_dispatch</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>partition_dispatch_info</name></name> <operator>=</operator> <operator>(</operator><name>PartitionDispatch</name> <operator>*</operator><operator>)</operator>
				<call><name>repalloc</name><argument_list>(<argument><expr><name><name>proute</name><operator>-&gt;</operator><name>partition_dispatch_info</name></name></expr></argument>,
						 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionDispatch</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>proute</name><operator>-&gt;</operator><name>max_dispatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>nonleaf_partitions</name></name> <operator>=</operator> <operator>(</operator><name>ResultRelInfo</name> <operator>*</operator><operator>*</operator><operator>)</operator>
				<call><name>repalloc</name><argument_list>(<argument><expr><name><name>proute</name><operator>-&gt;</operator><name>nonleaf_partitions</name></name></expr></argument>,
						 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ResultRelInfo</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>proute</name><operator>-&gt;</operator><name>max_dispatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>partition_dispatch_info</name><index>[<expr><name>dispatchidx</name></expr>]</index></name> <operator>=</operator> <name>pd</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If setting up a PartitionDispatch for a sub-partitioned table, we may
	 * also need a minimally valid ResultRelInfo for checking the partition
	 * constraint later; set that up now.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>parent_pd</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rri</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ResultRelInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>InitResultRelInfo</name><argument_list>(<argument><expr><name>rri</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>rootResultRelInfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>nonleaf_partitions</name><index>[<expr><name>dispatchidx</name></expr>]</index></name> <operator>=</operator> <name>rri</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>proute</name><operator>-&gt;</operator><name>nonleaf_partitions</name><index>[<expr><name>dispatchidx</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Finally, if setting up a PartitionDispatch for a sub-partitioned table,
	 * install a downlink in the parent to allow quick descent.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>parent_pd</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parent_pd</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>partidx</name></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parent_pd</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>partidx</name></expr>]</index></name> <operator>=</operator> <name>dispatchidx</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>pd</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecCleanupTupleRouting -- Clean up objects allocated for partition tuple
 * routing.
 *
 * Close all the partitioned tables, leaf partitions, and their indices.
 */</comment>
<function><type><name>void</name></type>
<name>ExecCleanupTupleRouting</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>,
						<parameter><decl><type><name>PartitionTupleRouting</name> <modifier>*</modifier></type><name>proute</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HTAB</name>	   <modifier>*</modifier></type><name>htab</name> <init>= <expr><name><name>proute</name><operator>-&gt;</operator><name>subplan_resultrel_htab</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Remember, proute-&gt;partition_dispatch_info[0] corresponds to the root
	 * partitioned table, which we must not try to close, because it is the
	 * main target table of the query that will be closed by callers such as
	 * ExecEndPlan() or DoCopy(). Also, tupslot is NULL for the root
	 * partitioned table.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>proute</name><operator>-&gt;</operator><name>num_dispatch</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionDispatch</name></type> <name>pd</name> <init>= <expr><name><name>proute</name><operator>-&gt;</operator><name>partition_dispatch_info</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name><name>pd</name><operator>-&gt;</operator><name>reldesc</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>pd</name><operator>-&gt;</operator><name>tupslot</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name><name>pd</name><operator>-&gt;</operator><name>tupslot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>proute</name><operator>-&gt;</operator><name>num_partitions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name> <init>= <expr><name><name>proute</name><operator>-&gt;</operator><name>partitions</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Allow any FDWs to shut down */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name><operator>-&gt;</operator><name>EndForeignInsert</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name><operator>-&gt;</operator><name>EndForeignInsert</name></name><argument_list>(<argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>,
														   <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Check if this result rel is one belonging to the node's subplans,
		 * if so, let ExecEndPlan() clean it up.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>htab</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>partoid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>partoid</name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>htab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>partoid</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ExecCloseIndices</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *		FormPartitionKeyDatum
 *			Construct values[] and isnull[] arrays for the partition key
 *			of a tuple.
 *
 *	pd				Partition dispatch object of the partitioned table
 *	slot			Heap tuple from which to extract partition key
 *	estate			executor state for evaluating any partition key
 *					expressions (must be non-NULL)
 *	values			Array of partition key Datums (output area)
 *	isnull			Array of is-null indicators (output area)
 *
 * the ecxt_scantuple slot of estate's per-tuple expr context must point to
 * the heap tuple passed in.
 * ----------------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FormPartitionKeyDatum</name><parameter_list>(<parameter><decl><type><name>PartitionDispatch</name></type> <name>pd</name></decl></parameter>,
					  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
					  <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
					  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>partexpr_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pd</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>partexprs</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name><name>pd</name><operator>-&gt;</operator><name>keystate</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Check caller has set up context correctly */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>estate</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			   <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ecxt_scantuple</name> <operator>==</operator> <name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* First time through, set up expression evaluation state */</comment>
		<expr_stmt><expr><name><name>pd</name><operator>-&gt;</operator><name>keystate</name></name> <operator>=</operator> <call><name>ExecPrepareExprList</name><argument_list>(<argument><expr><name><name>pd</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>partexprs</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>partexpr_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>pd</name><operator>-&gt;</operator><name>keystate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pd</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>keycol</name> <init>= <expr><name><name>pd</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>keycol</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Plain column; get the value directly from the heap tuple */</comment>
			<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>keycol</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Expression; need to evaluate it */</comment>
			<if_stmt><if>if <condition>(<expr><name>partexpr_item</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"wrong number of partition key expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>ExecEvalExprSwitchContext</name><argument_list>(<argument><expr><operator>(</operator><name>ExprState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>partexpr_item</name></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>partexpr_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name><name>pd</name><operator>-&gt;</operator><name>keystate</name></name></expr></argument>, <argument><expr><name>partexpr_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>datum</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>isNull</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>partexpr_item</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"wrong number of partition key expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_partition_for_tuple
 *		Finds partition of relation which accepts the partition key specified
 *		in values and isnull
 *
 * Return value is index of the partition (&gt;= 0 and &lt; partdesc-&gt;nparts) if one
 * found or -1 if none found.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_partition_for_tuple</name><parameter_list>(<parameter><decl><type><name>PartitionDispatch</name></type> <name>pd</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>bound_offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>part_index</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionKey</name></type> <name>key</name> <init>= <expr><name><name>pd</name><operator>-&gt;</operator><name>key</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>partdesc</name> <init>= <expr><name><name>pd</name><operator>-&gt;</operator><name>partdesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionBoundInfo</name></type> <name>boundinfo</name> <init>= <expr><name><name>partdesc</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Route as appropriate based on partitioning strategy. */</comment>
	<switch>switch <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PARTITION_STRATEGY_HASH</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>uint64</name></type>		<name>rowHash</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>rowHash</name> <operator>=</operator> <call><name>compute_partition_hash_value</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr></argument>,
													   <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partsupfunc</name></name></expr></argument>,
													   <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partcollation</name></name></expr></argument>,
													   <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>part_index</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>rowHash</name> <operator>%</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>nindexes</name></name></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PARTITION_STRATEGY_LIST</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>isnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>partition_bound_accepts_nulls</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>part_index</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>null_index</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type>		<name>equal</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>bound_offset</name> <operator>=</operator> <call><name>partition_list_bsearch</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partsupfunc</name></name></expr></argument>,
													  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partcollation</name></name></expr></argument>,
													  <argument><expr><name>boundinfo</name></expr></argument>,
													  <argument><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>equal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>bound_offset</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>equal</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>part_index</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>bound_offset</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>

		<case>case <expr><name>PARTITION_STRATEGY_RANGE</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type>		<name>equal</name> <init>= <expr><name>false</name></expr></init></decl>,
							<decl><type ref="prev"/><name>range_partkey_has_null</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * No range includes NULL, so this will be accepted by the
				 * default partition if there is one, and otherwise rejected.
				 */</comment>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>range_partkey_has_null</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>range_partkey_has_null</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>bound_offset</name> <operator>=</operator> <call><name>partition_range_datum_bsearch</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partsupfunc</name></name></expr></argument>,
																 <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partcollation</name></name></expr></argument>,
																 <argument><expr><name>boundinfo</name></expr></argument>,
																 <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr></argument>,
																 <argument><expr><name>values</name></expr></argument>,
																 <argument><expr><operator>&amp;</operator><name>equal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * The bound at bound_offset is less than or equal to the
					 * tuple value, so the bound at offset+1 is the upper
					 * bound of the partition we're looking for, if there
					 * actually exists one.
					 */</comment>
					<expr_stmt><expr><name>part_index</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>bound_offset</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected partition strategy: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>key</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * part_index &lt; 0 means we failed to find a partition of this parent. Use
	 * the default partition, if there is one.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>part_index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>part_index</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>default_index</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>part_index</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecBuildSlotPartitionKeyDescription
 *
 * This works very much like BuildIndexValueDescription() and is currently
 * used for building error messages when ExecFindPartition() fails to find
 * partition for a row.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ExecBuildSlotPartitionKeyDescription</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
									 <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
									 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>,
									 <parameter><decl><type><name>int</name></type> <name>maxfieldlen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionKey</name></type> <name>key</name> <init>= <expr><call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>partnatts</name> <init>= <expr><call><name>get_partition_natts</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>check_enable_rls</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RLS_ENABLED</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If the user has table-level access, just go build the description. */</comment>
	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_class_aclcheck</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Step through the columns of the partition key and make sure the
		 * user has SELECT rights on all of them.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>partnatts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name> <init>= <expr><call><name>get_partition_col_attnum</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * If this partition key column is an expression, we return no
			 * detail rather than try to figure out what column(s) the
			 * expression includes and if the user has SELECT rights on them.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <name>InvalidAttrNumber</name> <operator>||</operator>
				<call><name>pg_attribute_aclcheck</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
									  <argument><expr><name>ACL_SELECT</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"(%s) = ("</literal></expr></argument>,
					 <argument><expr><call><name>pg_get_partkeydef_columns</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>partnatts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>vallen</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <literal type="string">"null"</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>foutoid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>typisvarlena</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><call><name>get_partition_col_typid</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>foutoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typisvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>foutoid</name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* truncate if needed */</comment>
		<expr_stmt><expr><name>vallen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>vallen</name> <operator>&lt;=</operator> <name>maxfieldlen</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>vallen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>vallen</name> <operator>=</operator> <call><name>pg_mbcliplen</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>vallen</name></expr></argument>, <argument><expr><name>maxfieldlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>vallen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * adjust_partition_tlist
 *		Re-order the targetlist entries for a given partition to account for
 *		column position differences between the parent and the partition.
 *
 * The expressions have already been fixed, but we must now re-order the
 * entries in case the partition has different column order, and possibly
 * add or remove dummy entries for dropped columns.
 *
 * Although a new List is returned, this feels free to scribble on resno
 * fields of the given tlist, so that should be a working copy.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>adjust_partition_tlist</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>map</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>new_tlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><name><name>map</name><operator>-&gt;</operator><name>outdesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrMap</name>    <modifier>*</modifier></type><name>attrMap</name> <init>= <expr><name><name>map</name><operator>-&gt;</operator><name>attrMap</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attrno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>==</operator> <name><name>attrMap</name><operator>-&gt;</operator><name>maplen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>attrno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>attrno</name> <operator>&lt;=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>attrno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att_tup</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>attrno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>parentattrno</name> <init>= <expr><name><name>attrMap</name><operator>-&gt;</operator><name>attnums</name><index>[<expr><name>attrno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>parentattrno</name> <operator>!=</operator> <name>InvalidAttrNumber</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Use the corresponding entry from the parent's tlist, adjusting
			 * the resno to match the partition's attno.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>att_tup</name><operator>-&gt;</operator><name>attisdropped</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tle</name> <operator>=</operator> <operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>parentattrno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>==</operator> <name>parentattrno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <name>attrno</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * For a dropped attribute in the partition, generate a dummy
			 * entry with resno matching the partition's attno.  This should
			 * match what expand_targetlist() does.
			 */</comment>
			<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>attisdropped</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>,
							 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
							 <argument><expr><name>InvalidOid</name></expr></argument>,
							 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>,
							 <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>,
							 <argument><expr><name>true</name></expr></argument>,	<comment type="block">/* isnull */</comment>
							 <argument><expr><name>true</name></expr></argument> <comment type="block">/* byval */</comment> )</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>,
								  <argument><expr><name>attrno</name></expr></argument>,
								  <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>new_tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_tlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Finally, attach any resjunk entries to the end of the new tlist */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>tlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>new_tlist</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>new_tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_tlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>new_tlist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*-------------------------------------------------------------------------
 * Run-Time Partition Pruning Support.
 *
 * The following series of functions exist to support the removal of unneeded
 * subplans for queries against partitioned tables.  The supporting functions
 * here are designed to work with any plan type which supports an arbitrary
 * number of subplans, e.g. Append, MergeAppend.
 *
 * When pruning involves comparison of a partition key to a constant, it's
 * done by the planner.  However, if we have a comparison to a non-constant
 * but not volatile expression, that presents an opportunity for run-time
 * pruning by the executor, allowing irrelevant partitions to be skipped
 * dynamically.
 *
 * We must distinguish expressions containing PARAM_EXEC Params from
 * expressions that don't contain those.  Even though a PARAM_EXEC Param is
 * considered to be a stable expression, it can change value from one plan
 * node scan to the next during query execution.  Stable comparison
 * expressions that don't involve such Params allow partition pruning to be
 * done once during executor startup.  Expressions that do involve such Params
 * require us to prune separately for each scan of the parent plan node.
 *
 * Note that pruning away unneeded subplans during executor startup has the
 * added benefit of not having to initialize the unneeded subplans at all.
 *
 *
 * Functions:
 *
 * ExecCreatePartitionPruneState:
 *		Creates the PartitionPruneState required by each of the two pruning
 *		functions.  Details stored include how to map the partition index
 *		returned by the partition pruning code into subplan indexes.
 *
 * ExecFindInitialMatchingSubPlans:
 *		Returns indexes of matching subplans.  Partition pruning is attempted
 *		without any evaluation of expressions containing PARAM_EXEC Params.
 *		This function must be called during executor startup for the parent
 *		plan before the subplans themselves are initialized.  Subplans which
 *		are found not to match by this function must be removed from the
 *		plan's list of subplans during execution, as this function performs a
 *		remap of the partition index to subplan index map and the newly
 *		created map provides indexes only for subplans which remain after
 *		calling this function.
 *
 * ExecFindMatchingSubPlans:
 *		Returns indexes of matching subplans after evaluating all available
 *		expressions.  This function can only be called during execution and
 *		must be called again each time the value of a Param listed in
 *		PartitionPruneState's 'execparamids' changes.
 *-------------------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * ExecCreatePartitionPruneState
 *		Build the data structure required for calling
 *		ExecFindInitialMatchingSubPlans and ExecFindMatchingSubPlans.
 *
 * 'planstate' is the parent plan node's execution state.
 *
 * 'partitionpruneinfo' is a PartitionPruneInfo as generated by
 * make_partition_pruneinfo.  Here we build a PartitionPruneState containing a
 * PartitionPruningData for each partitioning hierarchy (i.e., each sublist of
 * partitionpruneinfo-&gt;prune_infos), each of which contains a
 * PartitionedRelPruningData for each PartitionedRelPruneInfo appearing in
 * that sublist.  This two-level system is needed to keep from confusing the
 * different hierarchies when a UNION ALL contains multiple partitioned tables
 * as children.  The data stored in each PartitionedRelPruningData can be
 * re-used each time we re-evaluate which partitions match the pruning steps
 * provided in each PartitionedRelPruneInfo.
 */</comment>
<function><type><name>PartitionPruneState</name> <modifier>*</modifier></type>
<name>ExecCreatePartitionPruneState</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
							  <parameter><decl><type><name>PartitionPruneInfo</name> <modifier>*</modifier></type><name>partitionpruneinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>planstate</name><operator>-&gt;</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionPruneState</name> <modifier>*</modifier></type><name>prunestate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>n_part_hierarchies</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_partition_directory</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_partition_directory</name></name> <operator>=</operator>
			<call><name>CreatePartitionDirectory</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>n_part_hierarchies</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>partitionpruneinfo</name><operator>-&gt;</operator><name>prune_infos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>n_part_hierarchies</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate the data structure
	 */</comment>
	<expr_stmt><expr><name>prunestate</name> <operator>=</operator> <operator>(</operator><name>PartitionPruneState</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PartitionPruneState</name></expr></argument>, <argument><expr><name>partprunedata</name></expr></argument>)</argument_list></call> <operator>+</operator>
			   <sizeof>sizeof<argument_list>(<argument><expr><name>PartitionPruningData</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>n_part_hierarchies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>prunestate</name><operator>-&gt;</operator><name>execparamids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<comment type="block">/* other_subplans can change at runtime, so we need our own copy */</comment>
	<expr_stmt><expr><name><name>prunestate</name><operator>-&gt;</operator><name>other_subplans</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>partitionpruneinfo</name><operator>-&gt;</operator><name>other_subplans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prunestate</name><operator>-&gt;</operator><name>do_initial_prune</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* may be set below */</comment>
	<expr_stmt><expr><name><name>prunestate</name><operator>-&gt;</operator><name>do_exec_prune</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* may be set below */</comment>
	<expr_stmt><expr><name><name>prunestate</name><operator>-&gt;</operator><name>num_partprunedata</name></name> <operator>=</operator> <name>n_part_hierarchies</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create a short-term memory context which we'll use when making calls to
	 * the partition pruning functions.  This avoids possible memory leaks,
	 * since the pruning functions call comparison functions that aren't under
	 * our control.
	 */</comment>
	<expr_stmt><expr><name><name>prunestate</name><operator>-&gt;</operator><name>prune_context</name></name> <operator>=</operator>
		<call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
							  <argument><expr><literal type="string">"Partition Prune"</literal></expr></argument>,
							  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>partitionpruneinfo-&gt;prune_infos</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>partrelpruneinfos</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>npartrelpruneinfos</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>partrelpruneinfos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PartitionPruningData</name> <modifier>*</modifier></type><name>prunedata</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>prunedata</name> <operator>=</operator> <operator>(</operator><name>PartitionPruningData</name> <operator>*</operator><operator>)</operator>
			<call><name>palloc</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PartitionPruningData</name></expr></argument>, <argument><expr><name>partrelprunedata</name></expr></argument>)</argument_list></call> <operator>+</operator>
				   <name>npartrelpruneinfos</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PartitionedRelPruningData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prunestate</name><operator>-&gt;</operator><name>partprunedata</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>prunedata</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prunedata</name><operator>-&gt;</operator><name>num_partrelprunedata</name></name> <operator>=</operator> <name>npartrelpruneinfos</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>partrelpruneinfos</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PartitionedRelPruneInfo</name> <modifier>*</modifier></type><name>pinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>PartitionedRelPruneInfo</name></expr></argument>, <argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PartitionedRelPruningData</name> <modifier>*</modifier></type><name>pprune</name> <init>= <expr><operator>&amp;</operator><name><name>prunedata</name><operator>-&gt;</operator><name>partrelprunedata</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>partrel</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>partdesc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PartitionKey</name></type> <name>partkey</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * We can rely on the copies of the partitioned table's partition
			 * key and partition descriptor appearing in its relcache entry,
			 * because that entry will be held open and locked for the
			 * duration of this executor run.
			 */</comment>
			<expr_stmt><expr><name>partrel</name> <operator>=</operator> <call><name>ExecGetRangeTableRelation</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>pinfo</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>partkey</name> <operator>=</operator> <call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>partdesc</name> <operator>=</operator> <call><name>PartitionDirectoryLookup</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_partition_directory</name></name></expr></argument>,
												<argument><expr><name>partrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Initialize the subplan_map and subpart_map.  Since detaching a
			 * partition requires AccessExclusiveLock, no partitions can have
			 * disappeared, nor can the bounds for any partition have changed.
			 * However, new partitions may have been added.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name> <operator>&gt;=</operator> <name><name>pinfo</name><operator>-&gt;</operator><name>nparts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pprune</name><operator>-&gt;</operator><name>nparts</name></name> <operator>=</operator> <name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pprune</name><operator>-&gt;</operator><name>subplan_map</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name> <operator>==</operator> <name><name>pinfo</name><operator>-&gt;</operator><name>nparts</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * There are no new partitions, so this is simple.  We can
				 * simply point to the subpart_map from the plan, but we must
				 * copy the subplan_map since we may change it later.
				 */</comment>
				<expr_stmt><expr><name><name>pprune</name><operator>-&gt;</operator><name>subpart_map</name></name> <operator>=</operator> <name><name>pinfo</name><operator>-&gt;</operator><name>subpart_map</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pprune</name><operator>-&gt;</operator><name>subplan_map</name></name></expr></argument>, <argument><expr><name><name>pinfo</name><operator>-&gt;</operator><name>subplan_map</name></name></expr></argument>,
					   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>pinfo</name><operator>-&gt;</operator><name>nparts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Double-check that the list of unpruned relations has not
				 * changed.  (Pruned partitions are not in relid_map[].)
				 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
				<for>for <control>(<init><decl><type><name>int</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>pinfo</name><operator>-&gt;</operator><name>nparts</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>partdesc</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name>k</name></expr>]</index></name> <operator>==</operator> <name><name>pinfo</name><operator>-&gt;</operator><name>relid_map</name><index>[<expr><name>k</name></expr>]</index></name> <operator>||</operator>
						   <name><name>pinfo</name><operator>-&gt;</operator><name>subplan_map</name><index>[<expr><name>k</name></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>pd_idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>pp_idx</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * Some new partitions have appeared since plan time, and
				 * those are reflected in our PartitionDesc but were not
				 * present in the one used to construct subplan_map and
				 * subpart_map.  So we must construct new and longer arrays
				 * where the partitions that were originally present map to
				 * the same sub-structures, and any added partitions map to
				 * -1, as if the new partitions had been pruned.
				 *
				 * Note: pinfo-&gt;relid_map[] may contain InvalidOid entries for
				 * partitions pruned by the planner.  We cannot tell exactly
				 * which of the partdesc entries these correspond to, but we
				 * don't have to; just skip over them.  The non-pruned
				 * relid_map entries, however, had better be a subset of the
				 * partdesc entries and in the same order.
				 */</comment>
				<expr_stmt><expr><name><name>pprune</name><operator>-&gt;</operator><name>subpart_map</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>pp_idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>pp_idx</name> <operator>&lt;</operator> <name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name></expr>;</condition> <incr><expr><name>pp_idx</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<comment type="block">/* Skip any InvalidOid relid_map entries */</comment>
					<while>while <condition>(<expr><name>pd_idx</name> <operator>&lt;</operator> <name><name>pinfo</name><operator>-&gt;</operator><name>nparts</name></name> <operator>&amp;&amp;</operator>
						   <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>pinfo</name><operator>-&gt;</operator><name>relid_map</name><index>[<expr><name>pd_idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>pd_idx</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

					<if_stmt><if>if <condition>(<expr><name>pd_idx</name> <operator>&lt;</operator> <name><name>pinfo</name><operator>-&gt;</operator><name>nparts</name></name> <operator>&amp;&amp;</operator>
						<name><name>pinfo</name><operator>-&gt;</operator><name>relid_map</name><index>[<expr><name>pd_idx</name></expr>]</index></name> <operator>==</operator> <name><name>partdesc</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name>pp_idx</name></expr>]</index></name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* match... */</comment>
						<expr_stmt><expr><name><name>pprune</name><operator>-&gt;</operator><name>subplan_map</name><index>[<expr><name>pp_idx</name></expr>]</index></name> <operator>=</operator>
							<name><name>pinfo</name><operator>-&gt;</operator><name>subplan_map</name><index>[<expr><name>pd_idx</name></expr>]</index></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>pprune</name><operator>-&gt;</operator><name>subpart_map</name><index>[<expr><name>pp_idx</name></expr>]</index></name> <operator>=</operator>
							<name><name>pinfo</name><operator>-&gt;</operator><name>subpart_map</name><index>[<expr><name>pd_idx</name></expr>]</index></name></expr>;</expr_stmt>
						<expr_stmt><expr><name>pd_idx</name><operator>++</operator></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* this partdesc entry is not in the plan */</comment>
						<expr_stmt><expr><name><name>pprune</name><operator>-&gt;</operator><name>subplan_map</name><index>[<expr><name>pp_idx</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>pprune</name><operator>-&gt;</operator><name>subpart_map</name><index>[<expr><name>pp_idx</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></for>

				<comment type="block">/*
				 * It might seem that we need to skip any trailing InvalidOid
				 * entries in pinfo-&gt;relid_map before checking that we scanned
				 * all of the relid_map.  But we will have skipped them above,
				 * because they must correspond to some partdesc-&gt;oids
				 * entries; we just couldn't tell which.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>pd_idx</name> <operator>!=</operator> <name><name>pinfo</name><operator>-&gt;</operator><name>nparts</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not match partition child tables to plan elements"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/* present_parts is also subject to later modification */</comment>
			<expr_stmt><expr><name><name>pprune</name><operator>-&gt;</operator><name>present_parts</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>pinfo</name><operator>-&gt;</operator><name>present_parts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Initialize pruning contexts as needed.
			 */</comment>
			<expr_stmt><expr><name><name>pprune</name><operator>-&gt;</operator><name>initial_pruning_steps</name></name> <operator>=</operator> <name><name>pinfo</name><operator>-&gt;</operator><name>initial_pruning_steps</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>pinfo</name><operator>-&gt;</operator><name>initial_pruning_steps</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ExecInitPruningContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pprune</name><operator>-&gt;</operator><name>initial_context</name></name></expr></argument>,
									   <argument><expr><name><name>pinfo</name><operator>-&gt;</operator><name>initial_pruning_steps</name></name></expr></argument>,
									   <argument><expr><name>partdesc</name></expr></argument>, <argument><expr><name>partkey</name></expr></argument>, <argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Record whether initial pruning is needed at any level */</comment>
				<expr_stmt><expr><name><name>prunestate</name><operator>-&gt;</operator><name>do_initial_prune</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>pprune</name><operator>-&gt;</operator><name>exec_pruning_steps</name></name> <operator>=</operator> <name><name>pinfo</name><operator>-&gt;</operator><name>exec_pruning_steps</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>pinfo</name><operator>-&gt;</operator><name>exec_pruning_steps</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ExecInitPruningContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pprune</name><operator>-&gt;</operator><name>exec_context</name></name></expr></argument>,
									   <argument><expr><name><name>pinfo</name><operator>-&gt;</operator><name>exec_pruning_steps</name></name></expr></argument>,
									   <argument><expr><name>partdesc</name></expr></argument>, <argument><expr><name>partkey</name></expr></argument>, <argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Record whether exec pruning is needed at any level */</comment>
				<expr_stmt><expr><name><name>prunestate</name><operator>-&gt;</operator><name>do_exec_prune</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Accumulate the IDs of all PARAM_EXEC Params affecting the
			 * partitioning decisions at this plan node.
			 */</comment>
			<expr_stmt><expr><name><name>prunestate</name><operator>-&gt;</operator><name>execparamids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>prunestate</name><operator>-&gt;</operator><name>execparamids</name></name></expr></argument>,
													   <argument><expr><name><name>pinfo</name><operator>-&gt;</operator><name>execparamids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>prunestate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize a PartitionPruneContext for the given list of pruning steps.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecInitPruningContext</name><parameter_list>(<parameter><decl><type><name>PartitionPruneContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pruning_steps</name></decl></parameter>,
					   <parameter><decl><type><name>PartitionDesc</name></type> <name>partdesc</name></decl></parameter>,
					   <parameter><decl><type><name>PartitionKey</name></type> <name>partkey</name></decl></parameter>,
					   <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>n_steps</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>partnatts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>n_steps</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>pruning_steps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name><name>partkey</name><operator>-&gt;</operator><name>strategy</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>=</operator> <name>partnatts</name> <operator>=</operator> <name><name>partkey</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>nparts</name></name> <operator>=</operator> <name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>boundinfo</name></name> <operator>=</operator> <name><name>partdesc</name><operator>-&gt;</operator><name>boundinfo</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>partcollation</name></name> <operator>=</operator> <name><name>partkey</name><operator>-&gt;</operator><name>partcollation</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>partsupfunc</name></name> <operator>=</operator> <name><name>partkey</name><operator>-&gt;</operator><name>partsupfunc</name></name></expr>;</expr_stmt>

	<comment type="block">/* We'll look up type-specific support functions as needed */</comment>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>stepcmpfuncs</name></name> <operator>=</operator> <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>n_steps</name> <operator>*</operator> <name>partnatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>ppccontext</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>planstate</name></name> <operator>=</operator> <name>planstate</name></expr>;</expr_stmt>

	<comment type="block">/* Initialize expression state for each expression we need */</comment>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>exprstates</name></name> <operator>=</operator> <operator>(</operator><name>ExprState</name> <operator>*</operator><operator>*</operator><operator>)</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExprState</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>n_steps</name> <operator>*</operator> <name>partnatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>pruning_steps</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionPruneStepOp</name> <modifier>*</modifier></type><name>step</name> <init>= <expr><operator>(</operator><name>PartitionPruneStepOp</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>keyno</name></decl>;</decl_stmt>

		<comment type="block">/* not needed for other step kinds */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>step</name></expr></argument>, <argument><expr><name>PartitionPruneStepOp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>partnatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>keyno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>step-&gt;exprs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* not needed for Consts */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>stateidx</name> <init>= <expr><call><name>PruneCxtStateIdx</name><argument_list>(<argument><expr><name>partnatts</name></expr></argument>,
														<argument><expr><name><name>step</name><operator>-&gt;</operator><name>step</name><operator>.</operator><name>step_id</name></name></expr></argument>,
														<argument><expr><name>keyno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>exprstates</name><index>[<expr><name>stateidx</name></expr>]</index></name> <operator>=</operator>
					<call><name>ExecInitExpr</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>keyno</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * ExecFindInitialMatchingSubPlans
 *		Identify the set of subplans that cannot be eliminated by initial
 *		pruning, disregarding any pruning constraints involving PARAM_EXEC
 *		Params.
 *
 * If additional pruning passes will be required (because of PARAM_EXEC
 * Params), we must also update the translation data that allows conversion
 * of partition indexes into subplan indexes to account for the unneeded
 * subplans having been removed.
 *
 * Must only be called once per 'prunestate', and only if initial pruning
 * is required.
 *
 * 'nsubplans' must be passed as the total number of unpruned subplans.
 */</comment>
<function><type><name>Bitmapset</name> <modifier>*</modifier></type>
<name>ExecFindInitialMatchingSubPlans</name><parameter_list>(<parameter><decl><type><name>PartitionPruneState</name> <modifier>*</modifier></type><name>prunestate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nsubplans</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Caller error if we get here without do_initial_prune */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>prunestate</name><operator>-&gt;</operator><name>do_initial_prune</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Switch to a temp context to avoid leaking memory in the executor's
	 * query-lifespan memory context.
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>prunestate</name><operator>-&gt;</operator><name>prune_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For each hierarchy, do the pruning tests, and add nondeletable
	 * subplans' indexes to "result".
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>prunestate</name><operator>-&gt;</operator><name>num_partprunedata</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionPruningData</name> <modifier>*</modifier></type><name>prunedata</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PartitionedRelPruningData</name> <modifier>*</modifier></type><name>pprune</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>prunedata</name> <operator>=</operator> <name><name>prunestate</name><operator>-&gt;</operator><name>partprunedata</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pprune</name> <operator>=</operator> <operator>&amp;</operator><name><name>prunedata</name><operator>-&gt;</operator><name>partrelprunedata</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/* Perform pruning without using PARAM_EXEC Params */</comment>
		<expr_stmt><expr><call><name>find_matching_subplans_recurse</name><argument_list>(<argument><expr><name>prunedata</name></expr></argument>, <argument><expr><name>pprune</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Expression eval may have used space in node's ps_ExprContext too */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pprune</name><operator>-&gt;</operator><name>initial_pruning_steps</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name><name>pprune</name><operator>-&gt;</operator><name>initial_context</name><operator>.</operator><name>planstate</name><operator>-&gt;</operator><name>ps_ExprContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Add in any subplans that partition pruning didn't account for */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>prunestate</name><operator>-&gt;</operator><name>other_subplans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Copy result out of the temp context before we reset it */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>prunestate</name><operator>-&gt;</operator><name>prune_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If exec-time pruning is required and we pruned subplans above, then we
	 * must re-sequence the subplan indexes so that ExecFindMatchingSubPlans
	 * properly returns the indexes from the subplans which will remain after
	 * execution of this function.
	 *
	 * We can safely skip this when !do_exec_prune, even though that leaves
	 * invalid data in prunestate, because that data won't be consulted again
	 * (cf initial Assert in ExecFindMatchingSubPlans).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>prunestate</name><operator>-&gt;</operator><name>do_exec_prune</name></name> <operator>&amp;&amp;</operator> <call><name>bms_num_members</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>nsubplans</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>new_subplan_indexes</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>new_other_subplans</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>newidx</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * First we must build a temporary array which maps old subplan
		 * indexes to new ones.  For convenience of initialization, we use
		 * 1-based indexes in this array and leave pruned items as 0.
		 */</comment>
		<expr_stmt><expr><name>new_subplan_indexes</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nsubplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>newidx</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;</operator> <name>nsubplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>new_subplan_indexes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>newidx</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>

		<comment type="block">/*
		 * Now we can update each PartitionedRelPruneInfo's subplan_map with
		 * new subplan indexes.  We must also recompute its present_parts
		 * bitmap.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>prunestate</name><operator>-&gt;</operator><name>num_partprunedata</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PartitionPruningData</name> <modifier>*</modifier></type><name>prunedata</name> <init>= <expr><name><name>prunestate</name><operator>-&gt;</operator><name>partprunedata</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Within each hierarchy, we perform this loop in back-to-front
			 * order so that we determine present_parts for the lowest-level
			 * partitioned tables first.  This way we can tell whether a
			 * sub-partitioned table's partitions were entirely pruned so we
			 * can exclude it from the current level's present_parts.
			 */</comment>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name><name>prunedata</name><operator>-&gt;</operator><name>num_partrelprunedata</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PartitionedRelPruningData</name> <modifier>*</modifier></type><name>pprune</name> <init>= <expr><operator>&amp;</operator><name><name>prunedata</name><operator>-&gt;</operator><name>partrelprunedata</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>nparts</name> <init>= <expr><name><name>pprune</name><operator>-&gt;</operator><name>nparts</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>k</name></decl>;</decl_stmt>

				<comment type="block">/* We just rebuild present_parts from scratch */</comment>
				<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>pprune</name><operator>-&gt;</operator><name>present_parts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pprune</name><operator>-&gt;</operator><name>present_parts</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>nparts</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>oldidx</name> <init>= <expr><name><name>pprune</name><operator>-&gt;</operator><name>subplan_map</name><index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>subidx</name></decl>;</decl_stmt>

					<comment type="block">/*
					 * If this partition existed as a subplan then change the
					 * old subplan index to the new subplan index.  The new
					 * index may become -1 if the partition was pruned above,
					 * or it may just come earlier in the subplan list due to
					 * some subplans being removed earlier in the list.  If
					 * it's a subpartition, add it to present_parts unless
					 * it's entirely pruned.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>oldidx</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>oldidx</name> <operator>&lt;</operator> <name>nsubplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>pprune</name><operator>-&gt;</operator><name>subplan_map</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name><name>new_subplan_indexes</name><index>[<expr><name>oldidx</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><name><name>new_subplan_indexes</name><index>[<expr><name>oldidx</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>pprune</name><operator>-&gt;</operator><name>present_parts</name></name> <operator>=</operator>
								<call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>pprune</name><operator>-&gt;</operator><name>present_parts</name></name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><operator>(</operator><name>subidx</name> <operator>=</operator> <name><name>pprune</name><operator>-&gt;</operator><name>subpart_map</name><index>[<expr><name>k</name></expr>]</index></name><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>PartitionedRelPruningData</name> <modifier>*</modifier></type><name>subprune</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>subprune</name> <operator>=</operator> <operator>&amp;</operator><name><name>prunedata</name><operator>-&gt;</operator><name>partrelprunedata</name><index>[<expr><name>subidx</name></expr>]</index></name></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>subprune</name><operator>-&gt;</operator><name>present_parts</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>pprune</name><operator>-&gt;</operator><name>present_parts</name></name> <operator>=</operator>
								<call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>pprune</name><operator>-&gt;</operator><name>present_parts</name></name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
			</block_content>}</block></for>
		</block_content>}</block></for>

		<comment type="block">/*
		 * We must also recompute the other_subplans set, since indexes in it
		 * may change.
		 */</comment>
		<expr_stmt><expr><name>new_other_subplans</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name><name>prunestate</name><operator>-&gt;</operator><name>other_subplans</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>new_other_subplans</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>new_other_subplans</name></expr></argument>,
												<argument><expr><name><name>new_subplan_indexes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>prunestate</name><operator>-&gt;</operator><name>other_subplans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prunestate</name><operator>-&gt;</operator><name>other_subplans</name></name> <operator>=</operator> <name>new_other_subplans</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_subplan_indexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecFindMatchingSubPlans
 *		Determine which subplans match the pruning steps detailed in
 *		'prunestate' for the current comparison expression values.
 *
 * Here we assume we may evaluate PARAM_EXEC Params.
 */</comment>
<function><type><name>Bitmapset</name> <modifier>*</modifier></type>
<name>ExecFindMatchingSubPlans</name><parameter_list>(<parameter><decl><type><name>PartitionPruneState</name> <modifier>*</modifier></type><name>prunestate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If !do_exec_prune, we've got problems because
	 * ExecFindInitialMatchingSubPlans will not have bothered to update
	 * prunestate for whatever pruning it did.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>prunestate</name><operator>-&gt;</operator><name>do_exec_prune</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Switch to a temp context to avoid leaking memory in the executor's
	 * query-lifespan memory context.
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>prunestate</name><operator>-&gt;</operator><name>prune_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For each hierarchy, do the pruning tests, and add nondeletable
	 * subplans' indexes to "result".
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>prunestate</name><operator>-&gt;</operator><name>num_partprunedata</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionPruningData</name> <modifier>*</modifier></type><name>prunedata</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PartitionedRelPruningData</name> <modifier>*</modifier></type><name>pprune</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>prunedata</name> <operator>=</operator> <name><name>prunestate</name><operator>-&gt;</operator><name>partprunedata</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pprune</name> <operator>=</operator> <operator>&amp;</operator><name><name>prunedata</name><operator>-&gt;</operator><name>partrelprunedata</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>find_matching_subplans_recurse</name><argument_list>(<argument><expr><name>prunedata</name></expr></argument>, <argument><expr><name>pprune</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Expression eval may have used space in node's ps_ExprContext too */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pprune</name><operator>-&gt;</operator><name>exec_pruning_steps</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name><name>pprune</name><operator>-&gt;</operator><name>exec_context</name><operator>.</operator><name>planstate</name><operator>-&gt;</operator><name>ps_ExprContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Add in any subplans that partition pruning didn't account for */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>prunestate</name><operator>-&gt;</operator><name>other_subplans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Copy result out of the temp context before we reset it */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>prunestate</name><operator>-&gt;</operator><name>prune_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * find_matching_subplans_recurse
 *		Recursive worker function for ExecFindMatchingSubPlans and
 *		ExecFindInitialMatchingSubPlans
 *
 * Adds valid (non-prunable) subplan IDs to *validsubplans
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>find_matching_subplans_recurse</name><parameter_list>(<parameter><decl><type><name>PartitionPruningData</name> <modifier>*</modifier></type><name>prunedata</name></decl></parameter>,
							   <parameter><decl><type><name>PartitionedRelPruningData</name> <modifier>*</modifier></type><name>pprune</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name></type> <name>initial_prune</name></decl></parameter>,
							   <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier><modifier>*</modifier></type><name>validsubplans</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>partset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Guard against stack overflow due to overly deep partition hierarchy. */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Only prune if pruning would be useful at this level. */</comment>
	<if_stmt><if>if <condition>(<expr><name>initial_prune</name> <operator>&amp;&amp;</operator> <name><name>pprune</name><operator>-&gt;</operator><name>initial_pruning_steps</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>partset</name> <operator>=</operator> <call><name>get_matching_partitions</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pprune</name><operator>-&gt;</operator><name>initial_context</name></name></expr></argument>,
										  <argument><expr><name><name>pprune</name><operator>-&gt;</operator><name>initial_pruning_steps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name>initial_prune</name> <operator>&amp;&amp;</operator> <name><name>pprune</name><operator>-&gt;</operator><name>exec_pruning_steps</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>partset</name> <operator>=</operator> <call><name>get_matching_partitions</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pprune</name><operator>-&gt;</operator><name>exec_context</name></name></expr></argument>,
										  <argument><expr><name><name>pprune</name><operator>-&gt;</operator><name>exec_pruning_steps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If no pruning is to be done, just include all partitions at this
		 * level.
		 */</comment>
		<expr_stmt><expr><name>partset</name> <operator>=</operator> <name><name>pprune</name><operator>-&gt;</operator><name>present_parts</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Translate partset into subplan indexes */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>partset</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>pprune</name><operator>-&gt;</operator><name>subplan_map</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>validsubplans</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><operator>*</operator><name>validsubplans</name></expr></argument>,
											<argument><expr><name><name>pprune</name><operator>-&gt;</operator><name>subplan_map</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>partidx</name> <init>= <expr><name><name>pprune</name><operator>-&gt;</operator><name>subpart_map</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>partidx</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>find_matching_subplans_recurse</name><argument_list>(<argument><expr><name>prunedata</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name><name>prunedata</name><operator>-&gt;</operator><name>partrelprunedata</name><index>[<expr><name>partidx</name></expr>]</index></name></expr></argument>,
											   <argument><expr><name>initial_prune</name></expr></argument>, <argument><expr><name>validsubplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * We get here if the planner already pruned all the sub-
				 * partitions for this partition.  Silently ignore this
				 * partition in this case.  The end result is the same: we
				 * would have pruned all partitions just the same, but we
				 * don't have any pruning steps to execute to verify this.
				 */</comment>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>
</unit>
