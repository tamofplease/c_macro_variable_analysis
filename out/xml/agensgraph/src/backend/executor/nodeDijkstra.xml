<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/executor/nodeDijkstra.c"><comment type="block">/*
 * nodeDijkstra.c
 *	  routines to support finding the shortest path between two nodes in
 *	  weighted directed graph
 *
 * Portions Copyright (c) 2017, Bitnine Inc.
 * Portions Copyright (c) 1996-2016, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/executor/nodeDijkstra.c
 */</comment>

<comment type="block">/*
 *	 INTERFACE ROUTINES
 *		ExecDijkstra	 	- execute dijkstra's algorithm
 *		ExecInitDijkstra 	- initialize
 *		ExecEndDijkstra 	- shut down
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/ag_vertex_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeDijkstra.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/tuptable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/pairingheap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/execnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/memnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>

<typedef>typedef <type><struct>struct <name>vnode</name>
<block>{
	<decl_stmt><decl><type><name>Graphid</name></type>		<name>id</name></decl>;</decl_stmt>					<comment type="block">/* hash key */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>weight</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>incoming_enodes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>out_edge</name></decl>;</decl_stmt>
}</block></struct></type> <name>vnode</name>;</typedef>

<typedef>typedef <type><struct>struct <name>enode</name>
<block>{
	<decl_stmt><decl><type><name>Graphid</name></type>		<name>id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>vnode</name>	   <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>
}</block></struct></type> <name>enode</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>HeapTuple</name></type> <name>replace_vertexRow_graphid</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>,
										   <parameter><decl><type><name>HeapTuple</name></type> <name>vertexRow</name></decl></parameter>,
										   <parameter><decl><type><name>Datum</name></type> <name>graphid</name></decl></parameter>)</parameter_list>;</function_decl>
<function><type><specifier>static</specifier> <name>enode</name> <modifier>*</modifier></type>
<name>new_enode</name><parameter_list>(<parameter><decl><type><name>Graphid</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>vnode</name> <modifier>*</modifier></type><name>prev</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>enode</name> <modifier>*</modifier></type><name>edge</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>enode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>edge</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>edge</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>
	<return>return <expr><name>edge</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>vnode_add_enode</name><parameter_list>(<parameter><decl><type><name>vnode</name> <modifier>*</modifier></type><name>vertex</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>weight</name></decl></parameter>, <parameter><decl><type><name>Graphid</name></type> <name>eid</name></decl></parameter>, <parameter><decl><type><name>vnode</name> <modifier>*</modifier></type><name>prev</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>enode</name> <modifier>*</modifier></type><name>edge</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>vertex</name><operator>-&gt;</operator><name>weight</name></name> <operator>=</operator> <name>weight</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>edge</name> <operator>=</operator> <call><name>new_enode</name><argument_list>(<argument><expr><name>eid</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vertex</name><operator>-&gt;</operator><name>incoming_enodes</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>vertex</name><operator>-&gt;</operator><name>incoming_enodes</name></name></expr></argument>, <argument><expr><name>edge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vertex</name><operator>-&gt;</operator><name>out_edge</name></name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>vertex</name><operator>-&gt;</operator><name>incoming_enodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>vnode_update_enode</name><parameter_list>(<parameter><decl><type><name>vnode</name> <modifier>*</modifier></type><name>vertex</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>weight</name></decl></parameter>, <parameter><decl><type><name>Graphid</name></type> <name>eid</name></decl></parameter>, <parameter><decl><type><name>vnode</name> <modifier>*</modifier></type><name>prev</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>vertex</name><operator>-&gt;</operator><name>incoming_enodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vertex</name><operator>-&gt;</operator><name>incoming_enodes</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>vnode_add_enode</name><argument_list>(<argument><expr><name>vertex</name></expr></argument>, <argument><expr><name>weight</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vertex</name><operator>-&gt;</operator><name>out_edge</name></name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>vertex</name><operator>-&gt;</operator><name>incoming_enodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>enode</name> <modifier>*</modifier></type>
<name>vnode_get_curr_enode</name><parameter_list>(<parameter><decl><type><name>vnode</name> <modifier>*</modifier></type><name>vertex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><ternary><condition><expr><name><name>vertex</name><operator>-&gt;</operator><name>out_edge</name></name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><call><name>lfirst</name><argument_list>(<argument><expr><name><name>vertex</name><operator>-&gt;</operator><name>out_edge</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>vnode_next_enode</name><parameter_list>(<parameter><decl><type><name>vnode</name> <modifier>*</modifier></type><name>vertex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>vertex</name><operator>-&gt;</operator><name>out_edge</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>vertex</name><operator>-&gt;</operator><name>out_edge</name></name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>vertex</name><operator>-&gt;</operator><name>incoming_enodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>vertex</name><operator>-&gt;</operator><name>out_edge</name></name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name><name>vertex</name><operator>-&gt;</operator><name>incoming_enodes</name></name></expr></argument>, <argument><expr><name><name>vertex</name><operator>-&gt;</operator><name>out_edge</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* returns true if out_edge is reset to the first incoming edge */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>vnode_next_path</name><parameter_list>(<parameter><decl><type><name>vnode</name> <modifier>*</modifier></type><name>vertex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>enode</name>	   <modifier>*</modifier></type><name>edge</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>last</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>vertex</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>edge</name> <operator>=</operator> <call><name>vnode_get_curr_enode</name><argument_list>(<argument><expr><name>vertex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>last</name> <operator>=</operator> <call><name>vnode_next_path</name><argument_list>(<argument><expr><name><name>edge</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>last</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>vnode_next_enode</name><argument_list>(<argument><expr><name>vertex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>edge</name> <operator>=</operator> <call><name>vnode_get_curr_enode</name><argument_list>(<argument><expr><name>vertex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>edge</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>vnode_next_enode</name><argument_list>(<argument><expr><name>vertex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>dijkstra_pq_entry</name>
<block>{
	<decl_stmt><decl><type><name>pairingheap_node</name></type> <name>ph_node</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Graphid</name></type>		<name>to</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>weight</name></decl>;</decl_stmt>
}</block></struct></type> <name>dijkstra_pq_entry</name>;</typedef>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pq_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>pairingheap_node</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>pairingheap_node</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dijkstra_pq_entry</name> <modifier>*</modifier></type><name>x</name> <init>= <expr><operator>(</operator><name>dijkstra_pq_entry</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dijkstra_pq_entry</name> <modifier>*</modifier></type><name>y</name> <init>= <expr><operator>(</operator><name>dijkstra_pq_entry</name> <operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>y</name><operator>-&gt;</operator><name>weight</name></name> <operator>==</operator> <name><name>x</name><operator>-&gt;</operator><name>weight</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>y</name><operator>-&gt;</operator><name>weight</name></name> <operator>&gt;</operator> <name><name>x</name><operator>-&gt;</operator><name>weight</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>dijkstra_pq_entry</name> <modifier>*</modifier></type>
<name>pq_add</name><parameter_list>(<parameter><decl><type><name>pairingheap</name> <modifier>*</modifier></type><name>pq</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>pq_mcxt</name></decl></parameter>, <parameter><decl><type><name>Graphid</name></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>weight</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dijkstra_pq_entry</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>pq_mcxt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>dijkstra_pq_entry</name> <operator>*</operator><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>pq_mcxt</name></expr></argument>,
												 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dijkstra_pq_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>to</name></name> <operator>=</operator> <name>to</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>weight</name></name> <operator>=</operator> <name>weight</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pairingheap_add</name><argument_list>(<argument><expr><name>pq</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>ph_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>eval_array</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>elems</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> 		<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>dims</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>lbs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>element_typeid</name></decl>;</decl_stmt> <comment type="block">/* common type of array elements */</comment>
	<decl_stmt><decl><type><name>int16</name></type>		<name>elemlength</name></decl>;</decl_stmt>		<comment type="block">/* typlen of the array element type */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>elembyval</name></decl>;</decl_stmt>		<comment type="block">/* is the element type pass-by-value? */</comment>
	<decl_stmt><decl><type><name>char</name></type>		<name>elemalign</name></decl>;</decl_stmt>		<comment type="block">/* typalign of the element type */</comment>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>elems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>element_typeid</name> <operator>=</operator> <name>GRAPHIDOID</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>construct_empty_array</name><argument_list>(<argument><expr><name>element_typeid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>values</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nulls</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>elems</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Graphid</name> <modifier>*</modifier></type><name>id</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>UInt64GetDatum</name><argument_list>(<argument><expr><operator>*</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>dims</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lbs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><name>element_typeid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elemlength</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elembyval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elemalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>construct_md_array</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>dims</name></expr></argument>, <argument><expr><name>lbs</name></expr></argument>, <argument><expr><name>element_typeid</name></expr></argument>,
								<argument><expr><name>elemlength</name></expr></argument>, <argument><expr><name>elembyval</name></expr></argument>, <argument><expr><name>elemalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>proj_path</name><parameter_list>(<parameter><decl><type><name>DijkstraState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Dijkstra</name>   <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ProjectionInfo</name> <modifier>*</modifier></type><name>projInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>vnode</name>	   <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>vnode</name>	   <modifier>*</modifier></type><name>vertex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>enode</name>	   <modifier>*</modifier></type><name>edge</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>weight</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>vertexes</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>edges</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>null_edge</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>tts_values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>tts_isnull</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Dijkstra</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>vertex</name> <operator>=</operator> <name>end</name> <operator>=</operator> <operator>(</operator><name>vnode</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>visited_nodes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>target_id</name></name></expr></argument>,
										 <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>weight</name> <operator>=</operator> <name><name>vertex</name><operator>-&gt;</operator><name>weight</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>vertex</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>vertexes</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vertex</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><name>vertexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>edge</name> <operator>=</operator> <call><name>vnode_get_curr_enode</name><argument_list>(<argument><expr><name>vertex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>edges</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>edge</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><name>edges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>vertex</name> <operator>=</operator> <name><name>edge</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>n</name></name><operator>++</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>vnode_next_path</name><argument_list>(<argument><expr><operator>(</operator><name>end</name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>max_n</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* no more path */</comment>

	<expr_stmt><expr><name>null_edge</name> <operator>=</operator> <call><name>list_nth_cell</name><argument_list>(<argument><expr><name>edges</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>edges</name> <operator>=</operator> <call><name>list_delete_cell</name><argument_list>(<argument><expr><name>edges</name></expr></argument>, <argument><expr><name>null_edge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>projInfo</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ProjInfo</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>projInfo</name><operator>-&gt;</operator><name>pi_state</name><operator>.</operator><name>resultslot</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>projInfo</name><operator>-&gt;</operator><name>pi_exprContext</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tts_values</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tts_isnull</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>tts_values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>eval_array</name><argument_list>(<argument><expr><name>vertexes</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tts_isnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tts_values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>eval_array</name><argument_list>(<argument><expr><name>edges</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tts_isnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>weight_out</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>tts_values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <call><name>Float8GetDatum</name><argument_list>(<argument><expr><name>weight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tts_isnull</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>tts_values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tts_isnull</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><call><name>ExecStoreVirtualTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>compute_limit</name><parameter_list>(<parameter><decl><type><name>DijkstraState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>limit</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>val</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>is_null</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>ExecEvalExprSwitchContext</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>limit</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>max_n</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>max_n</name></name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>max_n</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_ROW_COUNT_IN_LIMIT_CLAUSE</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"LIMIT must be larger than 0"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>max_n</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to replace the graphid portion of a vertex
 * row. It requires the vertex row and tuple descriptor be non NULL and
 * the attbyval attribute be set. It returns a pointer to the updated
 * vertex row as a HeapTuple on conclusion.
 */</comment>
<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>replace_vertexRow_graphid</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>vertexRow</name></decl></parameter>,
						  <parameter><decl><type><name>Datum</name></type> <name>graphid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type>	<name>vheader</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attribute</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>			<modifier>*</modifier></type><name>vgdata</name></decl>;</decl_stmt>

	<comment type="block">/* Verify input constraints */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tupleDesc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>vertexRow</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>attribute</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>Anum_ag_vertex_id</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* This function only works for element 1, graphid, by value */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>attbyval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>vheader</name> <operator>=</operator> <name><name>vertexRow</name><operator>-&gt;</operator><name>t_data</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>vgdata</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>vheader</name> <operator>+</operator> <name><name>vheader</name><operator>-&gt;</operator><name>t_hoff</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>vgdata</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>vgdata</name></expr></argument>, <argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>store_att_byval</name><argument_list>(<argument><expr><name>vgdata</name></expr></argument>, <argument><expr><name>graphid</name></expr></argument>, <argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>vertexRow</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecDijkstra</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DijkstraState</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>DijkstraState</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Dijkstra</name>   <modifier>*</modifier></type><name>dijkstra</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>outerPlan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>outerTupleSlot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_null</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>start_vid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dijkstra_pq_entry</name> <modifier>*</modifier></type><name>start_node</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>end_vid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>vnode</name>	   <modifier>*</modifier></type><name>vertex</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dijkstra</name> <operator>=</operator> <operator>(</operator><name>Dijkstra</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>outerPlan</name> <operator>=</operator> <call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Reset per-tuple memory context to free any expression evaluation
	 * storage allocated in the previous tuple cycle.
	 */</comment>
	<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>is_executed</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>n</name></name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>max_n</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>proj_path</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>is_executed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>compute_limit</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>start_vid</name> <operator>=</operator> <call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>source</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>start_node</name> <operator>=</operator> <call><name>pq_add</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>pq</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>pq_mcxt</name></name></expr></argument>, <argument><expr><call><name>DatumGetGraphid</name><argument_list>(<argument><expr><name>start_vid</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>end_vid</name> <operator>=</operator> <call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>target_id</name></name> <operator>=</operator> <call><name>DatumGetGraphid</name><argument_list>(<argument><expr><name>end_vid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>vertex</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>visited_nodes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>start_node</name><operator>-&gt;</operator><name>to</name></name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>,
						 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vertex</name><operator>-&gt;</operator><name>incoming_enodes</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>vnode_add_enode</name><argument_list>(<argument><expr><name>vertex</name></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>!</operator><call><name>pairingheap_is_empty</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>pq</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>dijkstra_pq_entry</name> <modifier>*</modifier></type><name>min_pq_entry</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>vnode</name>	   <modifier>*</modifier></type><name>frontier</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>paramno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>orig_param</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ParamExecData</name> <modifier>*</modifier></type><name>prm</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>min_pq_entry</name> <operator>=</operator> <operator>(</operator><name>dijkstra_pq_entry</name> <operator>*</operator><operator>)</operator> <call><name>pairingheap_remove_first</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>pq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>min_pq_entry</name><operator>-&gt;</operator><name>to</name></name> <operator>==</operator> <name><name>node</name><operator>-&gt;</operator><name>target_id</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>proj_path</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>frontier</name> <operator>=</operator> <operator>(</operator><name>vnode</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>visited_nodes</name></name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name><name>min_pq_entry</name><operator>-&gt;</operator><name>to</name></name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>source</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>FieldSelect</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>paramno</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>FieldSelect</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>source</name><operator>-&gt;</operator><name>expr</name></name><operator>)</operator><operator>-&gt;</operator><name>arg</name><operator>)</operator><operator>-&gt;</operator><name>paramid</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>paramno</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>source</name><operator>-&gt;</operator><name>expr</name></name><operator>)</operator><operator>-&gt;</operator><name>paramid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>prm</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_param_exec_vals</name><index>[<expr><name>paramno</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>orig_param</name> <operator>=</operator> <name><name>prm</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>source</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>FieldSelect</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HeapTuple</name></type> <name>vertexRow</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>vertexRow</name> <operator>=</operator> <call><name>replace_vertexRow_graphid</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>tupleDesc</name></name></expr></argument>,
												  <argument><expr><name><name>node</name><operator>-&gt;</operator><name>vertexRow</name></name></expr></argument>,
												  <argument><expr><name><name>min_pq_entry</name><operator>-&gt;</operator><name>to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>vertexRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>UInt64GetDatum</name><argument_list>(<argument><expr><name><name>min_pq_entry</name><operator>-&gt;</operator><name>to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name><name>outerPlan</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>outerPlan</name><operator>-&gt;</operator><name>chgParam</name></name></expr></argument>, <argument><expr><name>paramno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecReScan</name><argument_list>(<argument><expr><name>outerPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>min_pq_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>to</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>eid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>weight</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Graphid</name></type>		<name>to_val</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Graphid</name></type>		<name>eid_val</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type>		<name>weight_val</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type>		<name>new_weight</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>vnode</name>	   <modifier>*</modifier></type><name>neighbor</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>outerTupleSlot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>outerPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>outerTupleSlot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>to</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>outerTupleSlot</name></expr></argument>, <argument><expr><name><name>dijkstra</name><operator>-&gt;</operator><name>end_id</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>to_val</name> <operator>=</operator> <call><name>DatumGetGraphid</name><argument_list>(<argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>eid</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>outerTupleSlot</name></expr></argument>, <argument><expr><name><name>dijkstra</name><operator>-&gt;</operator><name>edge_id</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>eid_val</name> <operator>=</operator> <call><name>DatumGetGraphid</name><argument_list>(<argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>weight</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>outerTupleSlot</name></expr></argument>, <argument><expr><name><name>dijkstra</name><operator>-&gt;</operator><name>weight</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>weight_val</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><name>weight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>weight_val</name> <operator>&lt;</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"WEIGHT must be larger than 0"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>new_weight</name> <operator>=</operator> <name><name>frontier</name><operator>-&gt;</operator><name>weight</name></name> <operator>+</operator> <name>weight_val</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>neighbor</name> <operator>=</operator> <operator>(</operator><name>vnode</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>visited_nodes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>to_val</name></expr></argument>,
											 <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pq_add</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>pq</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>pq_mcxt</name></name></expr></argument>, <argument><expr><name>to_val</name></expr></argument>, <argument><expr><name>new_weight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>neighbor</name><operator>-&gt;</operator><name>incoming_enodes</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>vnode_add_enode</name><argument_list>(<argument><expr><name>neighbor</name></expr></argument>, <argument><expr><name>new_weight</name></expr></argument>, <argument><expr><name>eid_val</name></expr></argument>, <argument><expr><name>frontier</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>new_weight</name> <operator>&lt;</operator> <name><name>neighbor</name><operator>-&gt;</operator><name>weight</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pq_add</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>pq</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>pq_mcxt</name></name></expr></argument>, <argument><expr><name>to_val</name></expr></argument>, <argument><expr><name>new_weight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>vnode_update_enode</name><argument_list>(<argument><expr><name>neighbor</name></expr></argument>, <argument><expr><name>new_weight</name></expr></argument>, <argument><expr><name>eid_val</name></expr></argument>, <argument><expr><name>frontier</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>max_n</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>new_weight</name> <operator>==</operator> <name><name>neighbor</name><operator>-&gt;</operator><name>weight</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* add a same weight edge */</comment>
				<expr_stmt><expr><call><name>vnode_add_enode</name><argument_list>(<argument><expr><name>neighbor</name></expr></argument>, <argument><expr><name>new_weight</name></expr></argument>, <argument><expr><name>eid_val</name></expr></argument>, <argument><expr><name>frontier</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Parameter is also used in the parent plan, so it must be restored.
		 */</comment>
		<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>orig_param</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>max_n</name></name></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>DijkstraState</name> <modifier>*</modifier></type>
<name>ExecInitDijkstra</name><parameter_list>(<parameter><decl><type><name>Dijkstra</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DijkstraState</name> <modifier>*</modifier></type><name>dstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>hash_ctl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>outerPlan</name></decl>;</decl_stmt>

	<comment type="block">/* check for unsupported flags */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <operator>(</operator><name>EXEC_FLAG_BACKWARD</name> <operator>|</operator> <name>EXEC_FLAG_MARK</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * create state structure
	 */</comment>
	<expr_stmt><expr><name>dstate</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>DijkstraState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ExecProcNode</name></name> <operator>=</operator> <name>ExecDijkstra</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Miscellaneous initialization
	 *
	 * create expression context for node
	 */</comment>
	<expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dstate</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dstate</name><operator>-&gt;</operator><name>is_executed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dstate</name><operator>-&gt;</operator><name>pq</name></name> <operator>=</operator> <call><name>pairingheap_allocate</name><argument_list>(<argument><expr><name>pq_cmp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dstate</name><operator>-&gt;</operator><name>pq_mcxt</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
											<argument><expr><literal type="string">"dijkstra's priority queue"</literal></expr></argument>,
											<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Graphid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>vnode</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dstate</name><operator>-&gt;</operator><name>visited_nodes</name></name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"dijkstra's visited nodes"</literal></expr></argument>,
										<argument><expr><literal type="number">1024</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
										<argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>dstate</name><operator>-&gt;</operator><name>source</name></name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>source</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>dstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dstate</name><operator>-&gt;</operator><name>target</name></name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>dstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dstate</name><operator>-&gt;</operator><name>limit</name></name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>limit</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>dstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * initialize child nodes
	 */</comment>
	<expr_stmt><expr><name>outerPlan</name> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><call><name>outerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>dstate</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>outerPlan</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * tuple table initialization
	 */</comment>
    <expr_stmt><expr><call><name>ExecInitResultTupleSlotTL</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dstate</name><operator>-&gt;</operator><name>selfTupleSlot</name></name> <operator>=</operator> <call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>dstate</name><operator>-&gt;</operator><name>tupleDesc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * ExecDijkstra was originally written without expectations that the
	 * source node might reside in a FieldSelect expression. This code
	 * is to address that deficit. Additionally, it is added here to
	 * help with memory conservation by providing a vertex row and the
	 * tuple descriptor for that vertex row for reuse.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>source</name></name></expr></argument>, <argument><expr><name>FieldSelect</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>       <name><name>values</name><index>[<expr><name>Natts_ag_vertex</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>        <name><name>isnull</name><index>[<expr><name>Natts_ag_vertex</name></expr>]</index></name> <init>= <expr><block>{<expr><name>false</name></expr>, <expr><name>true</name></expr>, <expr><name>true</name></expr>}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupleDesc</name> <init>= <expr><call><name>lookup_rowtype_tupdesc</name><argument_list>(<argument><expr><name>VERTEXOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>==</operator> <name>Natts_ag_vertex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>dstate</name><operator>-&gt;</operator><name>tupleDesc</name></name> <operator>=</operator> <name>tupleDesc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dstate</name><operator>-&gt;</operator><name>vertexRow</name></name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>dstate</name><operator>-&gt;</operator><name>tupleDesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dstate</name><operator>-&gt;</operator><name>vertexRow</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * initialize tuple type and projection info
	 */</comment>
	<expr_stmt><expr><call><name>ExecAssignProjectionInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecSetSlotDescriptor</name><argument_list>(<argument><expr><name><name>dstate</name><operator>-&gt;</operator><name>selfTupleSlot</name></name></expr></argument>, <argument><expr><call><name>ExecGetResultType</name><argument_list>(<argument><expr><name>outerPlan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>dstate</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecEndDijkstra</name><parameter_list>(<parameter><decl><type><name>DijkstraState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Release the tuple descriptor in the DijkstraState node */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>tupleDesc</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>tupleDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Release the vertexRow container in the DijkstraState node */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>vertexRow</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>vertexRow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Free the exprcontext
	 */</comment>
	<expr_stmt><expr><call><name>ExecFreeExprContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * clean out the tuple table
	 */</comment>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>selfTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * close down subplans
	 */</comment>
	<expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecReScanDijkstra</name><parameter_list>(<parameter><decl><type><name>DijkstraState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>outerPlan</name> <init>= <expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>hash_ctl</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>compute_limit</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If outerPlan-&gt;chgParam is not null then plan will be automatically
	 * re-scanned by first ExecProcNode.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>outerPlan</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecReScan</name><argument_list>(<argument><expr><name>outerPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>is_executed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* reset hash table and priority queue */</comment>
	<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>visited_nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Graphid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>vnode</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>visited_nodes</name></name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"dijkstra's visited nodes"</literal></expr></argument>,
									  <argument><expr><literal type="number">1024</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
									  <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>pq_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pairingheap_reset</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>pq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>selfTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
