<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/executor/execSRF.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * execSRF.c
 *	  Routines implementing the API for set-returning functions
 *
 * This file serves nodeFunctionscan.c and nodeProjectSet.c, providing
 * common code for calling set-returning functions according to the
 * ReturnSetInfo API.
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/executor/execSRF.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/objectaccess.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execdebug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>


<comment type="block">/* static function decls */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>init_sexpr</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>foid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>input_collation</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
					   <parameter><decl><type><name>SetExprState</name> <modifier>*</modifier></type><name>sexpr</name></decl></parameter>, <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>,
					   <parameter><decl><type><name>MemoryContext</name></type> <name>sexprCxt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>allowSRF</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>needDescForSRF</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ShutdownSetExpr</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecEvalFuncArgs</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>,
							 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>argList</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecPrepareTuplestoreResult</name><parameter_list>(<parameter><decl><type><name>SetExprState</name> <modifier>*</modifier></type><name>sexpr</name></decl></parameter>,
										<parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>,
										<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>resultStore</name></decl></parameter>,
										<parameter><decl><type><name>TupleDesc</name></type> <name>resultDesc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>tupledesc_match</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>dst_tupdesc</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>src_tupdesc</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Prepare function call in FROM (ROWS FROM) for execution.
 *
 * This is used by nodeFunctionscan.c.
 */</comment>
<function><type><name>SetExprState</name> <modifier>*</modifier></type>
<name>ExecInitTableFunctionResult</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
							<parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>, <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SetExprState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>SetExprState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>funcReturnsSet</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>expr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>func</name><operator>.</operator><name>fn_oid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Normally the passed expression tree will be a FuncExpr, since the
	 * grammar only allows a function call at the top level of a table
	 * function reference.  However, if the function doesn't return set then
	 * the planner might have replaced the function call via constant-folding
	 * or inlining.  So if we see any other kind of expression node, execute
	 * it via the general ExecEvalExpr() code.  That code path will not
	 * support set-returning functions buried in the expression, though.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>func</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>funcReturnsSet</name></name> <operator>=</operator> <name><name>func</name><operator>-&gt;</operator><name>funcretset</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>ExecInitExprList</name><argument_list>(<argument><expr><name><name>func</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>init_sexpr</name><argument_list>(<argument><expr><name><name>func</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>, <argument><expr><name><name>func</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>,
				   <argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr></argument>, <argument><expr><name><name>func</name><operator>-&gt;</operator><name>funcretset</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>elidedFuncState</name></name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		ExecMakeTableFunctionResult
 *
 * Evaluate a table function, producing a materialized result in a Tuplestore
 * object.
 *
 * This is used by nodeFunctionscan.c.
 */</comment>
<function><type><name>Tuplestorestate</name> <modifier>*</modifier></type>
<name>ExecMakeTableFunctionResult</name><parameter_list>(<parameter><decl><type><name>SetExprState</name> <modifier>*</modifier></type><name>setexpr</name></decl></parameter>,
							<parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>,
							<parameter><decl><type><name>MemoryContext</name></type> <name>argContext</name></decl></parameter>,
							<parameter><decl><type><name>TupleDesc</name></type> <name>expectedDesc</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>randomAccess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupstore</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>funcrettype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>returnsTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>returnsSet</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PgStat_FunctionCallUsage</name></type> <name>fcusage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReturnSetInfo</name></type> <name>rsinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>tmptup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>callerContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>first_time</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Execute per-tablefunc actions in appropriate context.
	 *
	 * The FunctionCallInfo needs to live across all the calls to a
	 * ValuePerCall function, so it can't be allocated in the per-tuple
	 * context. Similarly, the function arguments need to be evaluated in a
	 * context that is longer lived than the per-tuple context: The argument
	 * values would otherwise disappear when we reset that context in the
	 * inner loop.  As the caller's CurrentMemoryContext is typically a
	 * query-lifespan context, we don't want to leak memory there.  We require
	 * the caller to pass a separate memory context that can be used for this,
	 * and can be reset each time through to avoid bloat.
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>argContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>callerContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>argContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>funcrettype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>setexpr</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>returnsTuple</name> <operator>=</operator> <call><name>type_is_rowtype</name><argument_list>(<argument><expr><name>funcrettype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Prepare a resultinfo node for communication.  We always do this even if
	 * not expecting a set result, so that we can pass expectedDesc.  In the
	 * generic-expression case, the expression doesn't actually get to see the
	 * resultinfo, but set it up anyway because we use some of the fields as
	 * our own state variables.
	 */</comment>
	<expr_stmt><expr><name><name>rsinfo</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_ReturnSetInfo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>.</operator><name>econtext</name></name> <operator>=</operator> <name>econtext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>.</operator><name>expectedDesc</name></name> <operator>=</operator> <name>expectedDesc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>.</operator><name>allowedModes</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>SFRM_ValuePerCall</name> <operator>|</operator> <name>SFRM_Materialize</name> <operator>|</operator> <name>SFRM_Materialize_Preferred</name><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>randomAccess</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>rsinfo</name><operator>.</operator><name>allowedModes</name></name> <operator>|=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>SFRM_Materialize_Random</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>.</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_ValuePerCall</name></expr>;</expr_stmt>
	<comment type="block">/* isDone is filled below */</comment>
	<expr_stmt><expr><name><name>rsinfo</name><operator>.</operator><name>setResult</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>.</operator><name>setDesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>fcinfo</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>SizeForFunctionCallInfo</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>setexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Normally the passed expression tree will be a SetExprState, since the
	 * grammar only allows a function call at the top level of a table
	 * function reference.  However, if the function doesn't return set then
	 * the planner might have replaced the function call via constant-folding
	 * or inlining.  So if we see any other kind of expression node, execute
	 * it via the general ExecEvalExpr() code; the only difference is that we
	 * don't get a chance to pass a special ReturnSetInfo to any functions
	 * buried in the expression.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>setexpr</name><operator>-&gt;</operator><name>elidedFuncState</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * This path is similar to ExecMakeFunctionResultSet.
		 */</comment>
		<expr_stmt><expr><name>returnsSet</name> <operator>=</operator> <name><name>setexpr</name><operator>-&gt;</operator><name>funcReturnsSet</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>setexpr</name><operator>-&gt;</operator><name>func</name></name><operator>)</operator></expr></argument>,
								 <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>setexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name><name>setexpr</name><operator>-&gt;</operator><name>fcinfo</name><operator>-&gt;</operator><name>fncollation</name></name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>rsinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* evaluate the function's argument list */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name> <operator>==</operator> <name>argContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecEvalFuncArgs</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name><name>setexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If function is strict, and there are any NULL arguments, skip
		 * calling the function and act like it returned NULL (or an empty
		 * set, in the returns-set case).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>setexpr</name><operator>-&gt;</operator><name>func</name><operator>.</operator><name>fn_strict</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>nargs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
					<goto>goto <name>no_function_result</name>;</goto></block_content></block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Treat setexpr as a generic expression */</comment>
		<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Switch to short-lived context for calling the function or expression.
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Loop to handle the ValuePerCall protocol (which is also the same
	 * behavior needed in the generic ExecEvalExpr path).
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Reset per-tuple memory context before each call of the function or
		 * expression. This cleans up any local memory the function may leak
		 * when called.
		 */</comment>
		<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Call the function or expression one time */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>setexpr</name><operator>-&gt;</operator><name>elidedFuncState</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pgstat_init_function_usage</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fcusage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rsinfo</name><operator>.</operator><name>isDone</name></name> <operator>=</operator> <name>ExprSingleResult</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>pgstat_end_function_usage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fcusage</name></expr></argument>,
									  <argument><expr><name><name>rsinfo</name><operator>.</operator><name>isDone</name></name> <operator>!=</operator> <name>ExprMultipleResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator>
				<call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name><name>setexpr</name><operator>-&gt;</operator><name>elidedFuncState</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rsinfo</name><operator>.</operator><name>isDone</name></name> <operator>=</operator> <name>ExprSingleResult</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Which protocol does function want to use? */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rsinfo</name><operator>.</operator><name>returnMode</name></name> <operator>==</operator> <name>SFRM_ValuePerCall</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Check for end of result set.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rsinfo</name><operator>.</operator><name>isDone</name></name> <operator>==</operator> <name>ExprEndResult</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * If first time through, build tuplestore for result.  For a
			 * scalar function result type, also make a suitable tupdesc.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>first_time</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>=
				<expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>tupstore</name> <operator>=</operator> <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>randomAccess</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rsinfo</name><operator>.</operator><name>setResult</name></name> <operator>=</operator> <name>tupstore</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>returnsTuple</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>,
									   <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>,
									   <argument><expr><literal type="string">"column"</literal></expr></argument>,
									   <argument><expr><name>funcrettype</name></expr></argument>,
									   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
									   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>rsinfo</name><operator>.</operator><name>setDesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Store current resultset item.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>returnsTuple</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>td</name> <init>= <expr><call><name>DatumGetHeapTupleHeader</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>tupdesc</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>=
						<expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<comment type="block">/*
						 * This is the first non-NULL result from the
						 * function.  Use the type info embedded in the
						 * rowtype Datum to look up the needed tupdesc.  Make
						 * a copy for the query.
						 */</comment>
						<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc_copy</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetTypeId</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr></argument>,
															  <argument><expr><call><name>HeapTupleHeaderGetTypMod</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>rsinfo</name><operator>.</operator><name>setDesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/*
						 * Verify all later returned rows have same subtype;
						 * necessary in case the type is RECORD.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>HeapTupleHeaderGetTypeId</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypeid</name></name> <operator>||</operator>
							<call><name>HeapTupleHeaderGetTypMod</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"rows returned by function are not all of the same row type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></else></if_stmt>

					<comment type="block">/*
					 * tuplestore_puttuple needs a HeapTuple not a bare
					 * HeapTupleHeader, but it doesn't need all the fields.
					 */</comment>
					<expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetDatumLength</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <name>td</name></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>tuplestore_puttuple</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmptup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * NULL result from a tuple-returning function; expand it
					 * to a row of all nulls.  We rely on the expectedDesc to
					 * form such rows.  (Note: this would be problematic if
					 * tuplestore_putvalues saved the tdtypeid/tdtypmod from
					 * the provided descriptor, since that might not match
					 * what we get from the function itself.  But it doesn't.)
					 */</comment>
					<decl_stmt><decl><type><name>int</name></type>			<name>natts</name> <init>= <expr><name><name>expectedDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nullflags</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>nullflags</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nullflags</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>expectedDesc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>nullflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Scalar-type case: just store the function result */</comment>
				<expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/*
			 * Are we done?
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rsinfo</name><operator>.</operator><name>isDone</name></name> <operator>!=</operator> <name>ExprMultipleResult</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rsinfo</name><operator>.</operator><name>returnMode</name></name> <operator>==</operator> <name>SFRM_Materialize</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* check we're on the same page as the function author */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first_time</name> <operator>||</operator> <name><name>rsinfo</name><operator>.</operator><name>isDone</name></name> <operator>!=</operator> <name>ExprSingleResult</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_E_R_I_E_SRF_PROTOCOL_VIOLATED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table-function protocol for materialize mode was not followed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* Done evaluating the set result */</comment>
			<break>break;</break>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_E_R_I_E_SRF_PROTOCOL_VIOLATED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized table-function returnMode: %d"</literal></expr></argument>,
							<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>rsinfo</name><operator>.</operator><name>returnMode</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>first_time</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></for>

<label><name>no_function_result</name>:</label>

	<comment type="block">/*
	 * If we got nothing from the function (ie, an empty-set or NULL result),
	 * we have to create the tuplestore to return, and if it's a
	 * non-set-returning function then insert a single all-nulls row.  As
	 * above, we depend on the expectedDesc to manufacture the dummy row.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rsinfo</name><operator>.</operator><name>setResult</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>=
		<expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>tupstore</name> <operator>=</operator> <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>randomAccess</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rsinfo</name><operator>.</operator><name>setResult</name></name> <operator>=</operator> <name>tupstore</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>returnsSet</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>natts</name> <init>= <expr><name><name>expectedDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nullflags</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>nullflags</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nullflags</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>expectedDesc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>nullflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If function provided a tupdesc, cross-check it.  We only really need to
	 * do this for functions returning RECORD, but might as well do it always.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rsinfo</name><operator>.</operator><name>setDesc</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>tupledesc_match</name><argument_list>(<argument><expr><name>expectedDesc</name></expr></argument>, <argument><expr><name><name>rsinfo</name><operator>.</operator><name>setDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If it is a dynamically-allocated TupleDesc, free it: it is
		 * typically allocated in a per-query context, so we must avoid
		 * leaking it across multiple usages.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rsinfo</name><operator>.</operator><name>setDesc</name><operator>-&gt;</operator><name>tdrefcount</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>FreeTupleDesc</name><argument_list>(<argument><expr><name><name>rsinfo</name><operator>.</operator><name>setDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>callerContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* All done, pass back the tuplestore */</comment>
	<return>return <expr><name><name>rsinfo</name><operator>.</operator><name>setResult</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Prepare targetlist SRF function call for execution.
 *
 * This is used by nodeProjectSet.c.
 */</comment>
<function><type><name>SetExprState</name> <modifier>*</modifier></type>
<name>ExecInitFunctionResultSet</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
						  <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>, <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SetExprState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>SetExprState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>funcReturnsSet</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>expr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>func</name><operator>.</operator><name>fn_oid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize metadata.  The expression node could be either a FuncExpr or
	 * an OpExpr.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>func</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>ExecInitExprList</name><argument_list>(<argument><expr><name><name>func</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>init_sexpr</name><argument_list>(<argument><expr><name><name>func</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>, <argument><expr><name><name>func</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>,
				   <argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>op</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>ExecInitExprList</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>init_sexpr</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>opfuncid</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>,
				   <argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* shouldn't get here unless the selected function returns set */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>func</name><operator>.</operator><name>fn_retset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		ExecMakeFunctionResultSet
 *
 * Evaluate the arguments to a set-returning function and then call the
 * function itself.  The argument expressions may not contain set-returning
 * functions (the planner is supposed to have separated evaluation for those).
 *
 * This should be called in a short-lived (per-tuple) context, argContext
 * needs to live until all rows have been returned (i.e. *isDone set to
 * ExprEndResult or ExprSingleResult).
 *
 * This is used by nodeProjectSet.c.
 */</comment>
<function><type><name>Datum</name></type>
<name>ExecMakeFunctionResultSet</name><parameter_list>(<parameter><decl><type><name>SetExprState</name> <modifier>*</modifier></type><name>fcache</name></decl></parameter>,
						  <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>,
						  <parameter><decl><type><name>MemoryContext</name></type> <name>argContext</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>,
						  <parameter><decl><type><name>ExprDoneCond</name> <modifier>*</modifier></type><name>isDone</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>arguments</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PgStat_FunctionCallUsage</name></type> <name>fcusage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReturnSetInfo</name></type> <name>rsinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>callit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

<label><name>restart</name>:</label>

	<comment type="block">/* Guard against stack overflow due to overly complex expressions */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If a previous call of the function returned a set result in the form of
	 * a tuplestore, continue reading rows from the tuplestore until it's
	 * empty.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcache</name><operator>-&gt;</operator><name>funcResultStore</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>fcache</name><operator>-&gt;</operator><name>funcResultSlot</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>foundTup</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Have to make sure tuple in slot lives long enough, otherwise
		 * clearing the slot could end up trying to free something already
		 * freed.
		 */</comment>
		<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>foundTup</name> <operator>=</operator> <call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>funcResultStore</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										   <argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>funcResultSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>foundTup</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>isDone</name> <operator>=</operator> <name>ExprMultipleResult</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>fcache</name><operator>-&gt;</operator><name>funcReturnsTuple</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* We must return the whole tuple as a Datum. */</comment>
				<expr_stmt><expr><operator>*</operator><name>isNull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<return>return <expr><call><name>ExecFetchSlotHeapTupleDatum</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>funcResultSlot</name></name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Extract the first column and return it as a scalar. */</comment>
				<return>return <expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>funcResultSlot</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>isNull</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Exhausted the tuplestore, so clean up */</comment>
		<expr_stmt><expr><call><name>tuplestore_end</name><argument_list>(<argument><expr><name><name>fcache</name><operator>-&gt;</operator><name>funcResultStore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>funcResultStore</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>isDone</name> <operator>=</operator> <name>ExprEndResult</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>isNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * arguments is a list of expressions to evaluate before passing to the
	 * function manager.  We skip the evaluation if it was already done in the
	 * previous call (ie, we are continuing the evaluation of a set-valued
	 * function).  Otherwise, collect the current argument values into fcinfo.
	 *
	 * The arguments have to live in a context that lives at least until all
	 * rows from this SRF have been returned, otherwise ValuePerCall SRFs
	 * would reference freed memory after the first returned row.
	 */</comment>
	<expr_stmt><expr><name>fcinfo</name> <operator>=</operator> <name><name>fcache</name><operator>-&gt;</operator><name>fcinfo</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>arguments</name> <operator>=</operator> <name><name>fcache</name><operator>-&gt;</operator><name>args</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fcache</name><operator>-&gt;</operator><name>setArgsValid</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>argContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ExecEvalFuncArgs</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>arguments</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Reset flag (we may set it again below) */</comment>
		<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>setArgsValid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Now call the function, passing the evaluated parameter values.
	 */</comment>

	<comment type="block">/* Prepare a resultinfo node for communication. */</comment>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>rsinfo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_ReturnSetInfo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>.</operator><name>econtext</name></name> <operator>=</operator> <name>econtext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>.</operator><name>expectedDesc</name></name> <operator>=</operator> <name><name>fcache</name><operator>-&gt;</operator><name>funcResultDesc</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>.</operator><name>allowedModes</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>SFRM_ValuePerCall</name> <operator>|</operator> <name>SFRM_Materialize</name><operator>)</operator></expr>;</expr_stmt>
	<comment type="block">/* note we do not set SFRM_Materialize_Random or _Preferred */</comment>
	<expr_stmt><expr><name><name>rsinfo</name><operator>.</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_ValuePerCall</name></expr>;</expr_stmt>
	<comment type="block">/* isDone is filled below */</comment>
	<expr_stmt><expr><name><name>rsinfo</name><operator>.</operator><name>setResult</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>.</operator><name>setDesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If function is strict, and there are any NULL arguments, skip calling
	 * the function.
	 */</comment>
	<expr_stmt><expr><name>callit</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>fcache</name><operator>-&gt;</operator><name>func</name><operator>.</operator><name>fn_strict</name></name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>nargs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>callit</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>callit</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pgstat_init_function_usage</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fcusage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rsinfo</name><operator>.</operator><name>isDone</name></name> <operator>=</operator> <name>ExprSingleResult</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>isNull</name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>isDone</name> <operator>=</operator> <name><name>rsinfo</name><operator>.</operator><name>isDone</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pgstat_end_function_usage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fcusage</name></expr></argument>,
								  <argument><expr><name><name>rsinfo</name><operator>.</operator><name>isDone</name></name> <operator>!=</operator> <name>ExprMultipleResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* for a strict SRF, result for NULL is an empty set */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>isNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>isDone</name> <operator>=</operator> <name>ExprEndResult</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Which protocol does function want to use? */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rsinfo</name><operator>.</operator><name>returnMode</name></name> <operator>==</operator> <name>SFRM_ValuePerCall</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>isDone</name> <operator>!=</operator> <name>ExprEndResult</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Save the current argument values to re-use on the next call.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>isDone</name> <operator>==</operator> <name>ExprMultipleResult</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>setArgsValid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<comment type="block">/* Register cleanup callback if we didn't already */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fcache</name><operator>-&gt;</operator><name>shutdown_reg</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>RegisterExprContextCallback</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>,
												<argument><expr><name>ShutdownSetExpr</name></expr></argument>,
												<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>fcache</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>fcache</name><operator>-&gt;</operator><name>shutdown_reg</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>rsinfo</name><operator>.</operator><name>returnMode</name></name> <operator>==</operator> <name>SFRM_Materialize</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* check we're on the same page as the function author */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rsinfo</name><operator>.</operator><name>isDone</name></name> <operator>!=</operator> <name>ExprSingleResult</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_E_R_I_E_SRF_PROTOCOL_VIOLATED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table-function protocol for materialize mode was not followed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>rsinfo</name><operator>.</operator><name>setResult</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* prepare to return values from the tuplestore */</comment>
			<expr_stmt><expr><call><name>ExecPrepareTuplestoreResult</name><argument_list>(<argument><expr><name>fcache</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>,
										<argument><expr><name><name>rsinfo</name><operator>.</operator><name>setResult</name></name></expr></argument>,
										<argument><expr><name><name>rsinfo</name><operator>.</operator><name>setDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* loop back to top to start returning from tuplestore */</comment>
			<goto>goto <name>restart</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* if setResult was left null, treat it as empty set */</comment>
		<expr_stmt><expr><operator>*</operator><name>isDone</name> <operator>=</operator> <name>ExprEndResult</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>isNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_E_R_I_E_SRF_PROTOCOL_VIOLATED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized table-function returnMode: %d"</literal></expr></argument>,
						<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>rsinfo</name><operator>.</operator><name>returnMode</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * init_sexpr - initialize a SetExprState node during first use
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_sexpr</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>foid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>input_collation</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
		   <parameter><decl><type><name>SetExprState</name> <modifier>*</modifier></type><name>sexpr</name></decl></parameter>, <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>,
		   <parameter><decl><type><name>MemoryContext</name></type> <name>sexprCxt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>allowSRF</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>needDescForSRF</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>numargs</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>sexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Check permission to call function */</comment>
	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_proc_aclcheck</name><argument_list>(<argument><expr><name>foid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_FUNCTION</name></expr></argument>, <argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name>foid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>InvokeFunctionExecuteHook</name><argument_list>(<argument><expr><name>foid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Safety check on nargs.  Under normal circumstances this should never
	 * fail, as parser should check sooner.  But possibly it might fail if
	 * server has been compiled with FUNC_MAX_ARGS smaller than some functions
	 * declared in pg_proc?
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>sexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>FUNC_MAX_ARGS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_ARGUMENTS</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg_plural</name><argument_list>(<argument><expr><literal type="string">"cannot pass more than %d argument to a function"</literal></expr></argument>,
							   <argument><expr><literal type="string">"cannot pass more than %d arguments to a function"</literal></expr></argument>,
							   <argument><expr><name>FUNC_MAX_ARGS</name></expr></argument>,
							   <argument><expr><name>FUNC_MAX_ARGS</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Set up the primary fmgr lookup information */</comment>
	<expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><name>foid</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>sexpr</name><operator>-&gt;</operator><name>func</name></name><operator>)</operator></expr></argument>, <argument><expr><name>sexprCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fmgr_info_set_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>sexpr</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>sexpr</name><operator>-&gt;</operator><name>func</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize the function call parameter struct as well */</comment>
	<expr_stmt><expr><name><name>sexpr</name><operator>-&gt;</operator><name>fcinfo</name></name> <operator>=</operator>
		<operator>(</operator><name>FunctionCallInfo</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>SizeForFunctionCallInfo</name><argument_list>(<argument><expr><name>numargs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name><name>sexpr</name><operator>-&gt;</operator><name>fcinfo</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>sexpr</name><operator>-&gt;</operator><name>func</name></name><operator>)</operator></expr></argument>,
							 <argument><expr><name>numargs</name></expr></argument>,
							 <argument><expr><name>input_collation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If function returns set, check if that's allowed by caller */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>sexpr</name><operator>-&gt;</operator><name>func</name><operator>.</operator><name>fn_retset</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>allowSRF</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <ternary><condition><expr><name>parent</name></expr> ?</condition><then> <expr><call><name>executor_errposition</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>state</name></name></expr></argument>,
											   <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Otherwise, caller should have marked the sexpr correctly */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sexpr</name><operator>-&gt;</operator><name>func</name><operator>.</operator><name>fn_retset</name></name> <operator>==</operator> <name><name>sexpr</name><operator>-&gt;</operator><name>funcReturnsSet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If function returns set, prepare expected tuple descriptor */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>sexpr</name><operator>-&gt;</operator><name>func</name><operator>.</operator><name>fn_retset</name></name> <operator>&amp;&amp;</operator> <name>needDescForSRF</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TypeFuncClass</name></type> <name>functypclass</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>funcrettype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>functypclass</name> <operator>=</operator> <call><name>get_expr_result_type</name><argument_list>(<argument><expr><name><name>sexpr</name><operator>-&gt;</operator><name>func</name><operator>.</operator><name>fn_expr</name></name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>funcrettype</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Must save tupdesc in sexpr's context */</comment>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>sexprCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>functypclass</name> <operator>==</operator> <name>TYPEFUNC_COMPOSITE</name> <operator>||</operator>
			<name>functypclass</name> <operator>==</operator> <name>TYPEFUNC_COMPOSITE_DOMAIN</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Composite data type, e.g. a table's row type */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Must copy it out of typcache for safety */</comment>
			<expr_stmt><expr><name><name>sexpr</name><operator>-&gt;</operator><name>funcResultDesc</name></name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sexpr</name><operator>-&gt;</operator><name>funcReturnsTuple</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>functypclass</name> <operator>==</operator> <name>TYPEFUNC_SCALAR</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Base data type, i.e. scalar */</comment>
			<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>,
							   <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><name>funcrettype</name></expr></argument>,
							   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
							   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sexpr</name><operator>-&gt;</operator><name>funcResultDesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sexpr</name><operator>-&gt;</operator><name>funcReturnsTuple</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>functypclass</name> <operator>==</operator> <name>TYPEFUNC_RECORD</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* This will work if function doesn't need an expectedDesc */</comment>
			<expr_stmt><expr><name><name>sexpr</name><operator>-&gt;</operator><name>funcResultDesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sexpr</name><operator>-&gt;</operator><name>funcReturnsTuple</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Else, we will fail if function needs an expectedDesc */</comment>
			<expr_stmt><expr><name><name>sexpr</name><operator>-&gt;</operator><name>funcResultDesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>sexpr</name><operator>-&gt;</operator><name>funcResultDesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Initialize additional state */</comment>
	<expr_stmt><expr><name><name>sexpr</name><operator>-&gt;</operator><name>funcResultStore</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sexpr</name><operator>-&gt;</operator><name>funcResultSlot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sexpr</name><operator>-&gt;</operator><name>shutdown_reg</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * callback function in case a SetExprState needs to be shut down before it
 * has been run to completion
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ShutdownSetExpr</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SetExprState</name> <modifier>*</modifier></type><name>sexpr</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>SetExprState</name></expr></argument>, <argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* If we have a slot, make sure it's let go of any tuplestore pointer */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>sexpr</name><operator>-&gt;</operator><name>funcResultSlot</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>sexpr</name><operator>-&gt;</operator><name>funcResultSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Release any open tuplestore */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>sexpr</name><operator>-&gt;</operator><name>funcResultStore</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tuplestore_end</name><argument_list>(<argument><expr><name><name>sexpr</name><operator>-&gt;</operator><name>funcResultStore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>sexpr</name><operator>-&gt;</operator><name>funcResultStore</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Clear any active set-argument state */</comment>
	<expr_stmt><expr><name><name>sexpr</name><operator>-&gt;</operator><name>setArgsValid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* execUtils will deregister the callback... */</comment>
	<expr_stmt><expr><name><name>sexpr</name><operator>-&gt;</operator><name>shutdown_reg</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Evaluate arguments for a function.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecEvalFuncArgs</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>,
				 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>argList</name></decl></parameter>,
				 <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>arg</argument>, <argument>argList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>argstate</name> <init>= <expr><operator>(</operator><name>ExprState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name>argstate</name></expr></argument>,
											 <argument><expr><name>econtext</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>==</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>nargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		ExecPrepareTuplestoreResult
 *
 * Subroutine for ExecMakeFunctionResultSet: prepare to extract rows from a
 * tuplestore function result.  We must set up a funcResultSlot (unless
 * already done in a previous call cycle) and verify that the function
 * returned the expected tuple descriptor.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecPrepareTuplestoreResult</name><parameter_list>(<parameter><decl><type><name>SetExprState</name> <modifier>*</modifier></type><name>sexpr</name></decl></parameter>,
							<parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>,
							<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>resultStore</name></decl></parameter>,
							<parameter><decl><type><name>TupleDesc</name></type> <name>resultDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>sexpr</name><operator>-&gt;</operator><name>funcResultStore</name></name> <operator>=</operator> <name>resultStore</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>sexpr</name><operator>-&gt;</operator><name>funcResultSlot</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Create a slot so we can read data out of the tuplestore */</comment>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>slotDesc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>sexpr</name><operator>-&gt;</operator><name>func</name><operator>.</operator><name>fn_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we were not able to determine the result rowtype from context,
		 * and the function didn't return a tupdesc, we have to fail.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>sexpr</name><operator>-&gt;</operator><name>funcResultDesc</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>slotDesc</name> <operator>=</operator> <name><name>sexpr</name><operator>-&gt;</operator><name>funcResultDesc</name></name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>resultDesc</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* don't assume resultDesc is long-lived */</comment>
			<expr_stmt><expr><name>slotDesc</name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name>resultDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function returning setof record called in "</literal>
							<literal type="string">"context that cannot accept type record"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>slotDesc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>sexpr</name><operator>-&gt;</operator><name>funcResultSlot</name></name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>slotDesc</name></expr></argument>,
														 <argument><expr><operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If function provided a tupdesc, cross-check it.  We only really need to
	 * do this for functions returning RECORD, but might as well do it always.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>resultDesc</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>sexpr</name><operator>-&gt;</operator><name>funcResultDesc</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>tupledesc_match</name><argument_list>(<argument><expr><name><name>sexpr</name><operator>-&gt;</operator><name>funcResultDesc</name></name></expr></argument>, <argument><expr><name>resultDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If it is a dynamically-allocated TupleDesc, free it: it is
		 * typically allocated in a per-query context, so we must avoid
		 * leaking it across multiple usages.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>resultDesc</name><operator>-&gt;</operator><name>tdrefcount</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>FreeTupleDesc</name><argument_list>(<argument><expr><name>resultDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Register cleanup callback if we didn't already */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sexpr</name><operator>-&gt;</operator><name>shutdown_reg</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RegisterExprContextCallback</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>,
									<argument><expr><name>ShutdownSetExpr</name></expr></argument>,
									<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>sexpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sexpr</name><operator>-&gt;</operator><name>shutdown_reg</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check that function result tuple type (src_tupdesc) matches or can
 * be considered to match what the query expects (dst_tupdesc). If
 * they don't match, ereport.
 *
 * We really only care about number of attributes and data type.
 * Also, we can ignore type mismatch on columns that are dropped in the
 * destination type, so long as the physical storage matches.  This is
 * helpful in some cases involving out-of-date cached plans.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>tupledesc_match</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>dst_tupdesc</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>src_tupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dst_tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>!=</operator> <name><name>src_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function return row and query-specified return row do not match"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail_plural</name><argument_list>(<argument><expr><literal type="string">"Returned row contains %d attribute, but query expects %d."</literal></expr></argument>,
								  <argument><expr><literal type="string">"Returned row contains %d attributes, but query expects %d."</literal></expr></argument>,
								  <argument><expr><name><name>src_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>,
								  <argument><expr><name><name>src_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>, <argument><expr><name><name>dst_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>dst_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>dattr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>dst_tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>sattr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>src_tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsBinaryCoercible</name><argument_list>(<argument><expr><name><name>sattr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><name><name>dattr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* no worries */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dattr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function return row and query-specified return row do not match"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Returned type %s at ordinal position %d, but query expects %s."</literal></expr></argument>,
							   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>sattr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
							   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>dattr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>dattr</name><operator>-&gt;</operator><name>attlen</name></name> <operator>!=</operator> <name><name>sattr</name><operator>-&gt;</operator><name>attlen</name></name> <operator>||</operator>
			<name><name>dattr</name><operator>-&gt;</operator><name>attalign</name></name> <operator>!=</operator> <name><name>sattr</name><operator>-&gt;</operator><name>attalign</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function return row and query-specified return row do not match"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Physical storage mismatch on dropped attribute at ordinal position %d."</literal></expr></argument>,
							   <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>
</unit>
