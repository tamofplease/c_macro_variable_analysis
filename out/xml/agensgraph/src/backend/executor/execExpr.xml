<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/executor/execExpr.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * execExpr.c
 *	  Expression evaluation infrastructure.
 *
 *	During executor startup, we compile each expression tree (which has
 *	previously been processed by the parser and planner) into an ExprState,
 *	using ExecInitExpr() et al.  This converts the tree into a flat array
 *	of ExprEvalSteps, which may be thought of as instructions in a program.
 *	At runtime, we'll execute steps, starting with the first, until we reach
 *	an EEOP_DONE opcode.
 *
 *	This file contains the "compilation" logic.  It is independent of the
 *	specific execution technology we use (switch statement, computed goto,
 *	JIT compilation, etc).
 *
 *	See src/backend/executor/README for some background, specifically the
 *	"Expression Trees and ExprState nodes", "Expression Initialization",
 *	and "Expression Evaluation" sections.
 *
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/executor/execExpr.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/objectaccess.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execExpr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSubplan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jit/jit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>


<typedef>typedef <type><struct>struct <name>LastAttnumInfo</name>
<block>{
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>last_inner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>last_outer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>last_scan</name></decl>;</decl_stmt>
}</block></struct></type> <name>LastAttnumInfo</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecReadyExpr</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecInitExprRec</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
							<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>resv</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>resnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecInitFunc</name><parameter_list>(<parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>scratch</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>inputcollid</name></decl></parameter>,
						 <parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecInitExprSlots</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecPushExprSlots</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>LastAttnumInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>get_last_attnums_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>LastAttnumInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ExecComputeSlotInfo</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecInitWholeRowVar</name><parameter_list>(<parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>scratch</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>variable</name></decl></parameter>,
								<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecInitSubscriptingRef</name><parameter_list>(<parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>scratch</name></decl></parameter>,
									<parameter><decl><type><name>SubscriptingRef</name> <modifier>*</modifier></type><name>sbsref</name></decl></parameter>,
									<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
									<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>resv</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>resnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>isAssignmentIndirectionExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecInitCoerceToDomain</name><parameter_list>(<parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>scratch</name></decl></parameter>, <parameter><decl><type><name>CoerceToDomain</name> <modifier>*</modifier></type><name>ctest</name></decl></parameter>,
								   <parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
								   <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>resv</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>resnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecBuildAggTransCall</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>,
								  <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>scratch</name></decl></parameter>,
								  <parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name></decl></parameter>,
								  <parameter><decl><type><name>int</name></type> <name>transno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>setno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>setoff</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ishash</name></decl></parameter>,
								  <parameter><decl><type><name>bool</name></type> <name>nullcheck</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecInitCypherTypeCast</name><parameter_list>(<parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>scratch</name></decl></parameter>, <parameter><decl><type><name>CypherTypeCast</name> <modifier>*</modifier></type><name>tc</name></decl></parameter>,
								   <parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecInitCypherMap</name><parameter_list>(<parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>scratch</name></decl></parameter>, <parameter><decl><type><name>CypherMapExpr</name> <modifier>*</modifier></type><name>mapexpr</name></decl></parameter>,
							  <parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecInitCypherList</name><parameter_list>(<parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>scratch</name></decl></parameter>, <parameter><decl><type><name>CypherListExpr</name> <modifier>*</modifier></type><name>listexpr</name></decl></parameter>,
							   <parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecInitCypherListComp</name><parameter_list>(<parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>scratch</name></decl></parameter>,
								   <parameter><decl><type><name>CypherListCompExpr</name> <modifier>*</modifier></type><name>listcompexpr</name></decl></parameter>,
								   <parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>isIdentity</name><parameter_list>(<parameter><decl><type><name>CypherListCompExpr</name> <modifier>*</modifier></type><name>listcompexpr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>initExprSaveIter</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>next_step</name></decl></parameter>,
							 <parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>resv</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>resnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecInitCypherAccess</name><parameter_list>(<parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>scratch</name></decl></parameter>,
								 <parameter><decl><type><name>CypherAccessExpr</name> <modifier>*</modifier></type><name>accessexpr</name></decl></parameter>,
								 <parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>initCypherIndex</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>CypherIndexResult</name> <modifier>*</modifier></type><name>cidxres</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * ExecInitExpr: prepare an expression tree for execution
 *
 * This function builds and returns an ExprState implementing the given
 * Expr node tree.  The return ExprState can then be handed to ExecEvalExpr
 * for execution.  Because the Expr tree itself is read-only as far as
 * ExecInitExpr and ExecEvalExpr are concerned, several different executions
 * of the same plan tree can occur concurrently.  (But note that an ExprState
 * does mutate at runtime, so it can't be re-used concurrently.)
 *
 * This must be called in a memory context that will last as long as repeated
 * executions of the expression are needed.  Typically the context will be
 * the same as the per-query context of the associated ExprContext.
 *
 * Any Aggref, WindowFunc, or SubPlan nodes found in the tree are added to
 * the lists of such nodes held by the parent PlanState (or more accurately,
 * the AggrefExprState etc. nodes created for them are added).
 *
 * Note: there is no ExecEndExpr function; we assume that any resource
 * cleanup needed will be handled by just releasing the memory context
 * in which the state tree is built.  Functions that require additional
 * cleanup work can register a shutdown callback in the ExprContext.
 *
 *	'node' is the root of the expression tree to compile.
 *	'parent' is the PlanState node that owns the expression.
 *
 * 'parent' may be NULL if we are preparing an expression that is not
 * associated with a plan tree.  (If so, it can't have aggs or subplans.)
 * Such cases should usually come through ExecPrepareExpr, not directly here.
 *
 * Also, if 'node' is NULL, we just return NULL.  This is convenient for some
 * callers that may or may not have an expression that needs to be compiled.
 * Note that a NULL ExprState pointer *cannot* be handed to ExecEvalExpr,
 * although ExecQual and ExecCheck will accept one (and treat it as "true").
 */</comment>
<function><type><name>ExprState</name> <modifier>*</modifier></type>
<name>ExecInitExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprEvalStep</name></type> <name>scratch</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Special case: NULL expression produces a NULL ExprState pointer */</comment>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Initialize ExprState with empty step list */</comment>
	<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ExprState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>parent</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ext_params</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Insert EEOP_*_FETCHSOME steps as needed */</comment>
	<expr_stmt><expr><call><name>ExecInitExprSlots</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Compile the expression proper */</comment>
	<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>resvalue</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>resnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Finally, append a DONE step */</comment>
	<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_DONE</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecReadyExpr</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecInitExprWithParams: prepare a standalone expression tree for execution
 *
 * This is the same as ExecInitExpr, except that there is no parent PlanState,
 * and instead we may have a ParamListInfo describing PARAM_EXTERN Params.
 */</comment>
<function><type><name>ExprState</name> <modifier>*</modifier></type>
<name>ExecInitExprWithParams</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>ext_params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprEvalStep</name></type> <name>scratch</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Special case: NULL expression produces a NULL ExprState pointer */</comment>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Initialize ExprState with empty step list */</comment>
	<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ExprState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ext_params</name></name> <operator>=</operator> <name>ext_params</name></expr>;</expr_stmt>

	<comment type="block">/* Insert EEOP_*_FETCHSOME steps as needed */</comment>
	<expr_stmt><expr><call><name>ExecInitExprSlots</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Compile the expression proper */</comment>
	<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>resvalue</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>resnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Finally, append a DONE step */</comment>
	<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_DONE</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecReadyExpr</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecInitQual: prepare a qual for execution by ExecQual
 *
 * Prepares for the evaluation of a conjunctive boolean expression (qual list
 * with implicit AND semantics) that returns true if none of the
 * subexpressions are false.
 *
 * We must return true if the list is empty.  Since that's a very common case,
 * we optimize it a bit further by translating to a NULL ExprState pointer
 * rather than setting up an ExprState that computes constant TRUE.  (Some
 * especially hot-spot callers of ExecQual detect this and avoid calling
 * ExecQual at all.)
 *
 * If any of the subexpressions yield NULL, then the result of the conjunction
 * is false.  This makes ExecQual primarily useful for evaluating WHERE
 * clauses, since SQL specifies that tuples with null WHERE results do not
 * get selected.
 */</comment>
<function><type><name>ExprState</name> <modifier>*</modifier></type>
<name>ExecInitQual</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>, <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprEvalStep</name></type> <name>scratch</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>adjust_jumps</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* short-circuit (here and in ExecQual) for empty restriction list */</comment>
	<if_stmt><if>if <condition>(<expr><name>qual</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ExprState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>qual</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>parent</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ext_params</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* mark expression as to be used with ExecQual() */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>EEO_FLAG_IS_QUAL</name></expr>;</expr_stmt>

	<comment type="block">/* Insert EEOP_*_FETCHSOME steps as needed */</comment>
	<expr_stmt><expr><call><name>ExecInitExprSlots</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * ExecQual() needs to return false for an expression returning NULL. That
	 * allows us to short-circuit the evaluation the first time a NULL is
	 * encountered.  As qual evaluation is a hot-path this warrants using a
	 * special opcode for qual evaluation that's simpler than BOOL_AND (which
	 * has more complex NULL handling).
	 */</comment>
	<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_QUAL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We can use ExprState's resvalue/resnull as target for each qual expr.
	 */</comment>
	<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>resvalue</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>resvalue</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>resnull</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>resnull</name></name></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>qual</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* first evaluate expression */</comment>
		<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>resvalue</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>resnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* then emit EEOP_QUAL to detect if it's false (or null) */</comment>
		<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>qualexpr</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>adjust_jumps</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>adjust_jumps</name></expr></argument>,
								   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* adjust jump targets */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>adjust_jumps</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>as</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>steps</name><index>[<expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>opcode</name></name> <operator>==</operator> <name>EEOP_QUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>qualexpr</name><operator>.</operator><name>jumpdone</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>qualexpr</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * At the end, we don't need to do anything more.  The last qual expr must
	 * have yielded TRUE, and since its result is stored in the desired output
	 * location, we're done.
	 */</comment>
	<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_DONE</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecReadyExpr</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecInitCheck: prepare a check constraint for execution by ExecCheck
 *
 * This is much like ExecInitQual/ExecQual, except that a null result from
 * the conjunction is treated as TRUE.  This behavior is appropriate for
 * evaluating CHECK constraints, since SQL specifies that NULL constraint
 * conditions are not failures.
 *
 * Note that like ExecInitQual, this expects input in implicit-AND format.
 * Users of ExecCheck that have expressions in normal explicit-AND format
 * can just apply ExecInitExpr to produce suitable input for ExecCheck.
 */</comment>
<function><type><name>ExprState</name> <modifier>*</modifier></type>
<name>ExecInitCheck</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>, <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* short-circuit (here and in ExecCheck) for empty restriction list */</comment>
	<if_stmt><if>if <condition>(<expr><name>qual</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Just convert the implicit-AND list to an explicit AND (if there's more
	 * than one entry), and compile normally.  Unlike ExecQual, we can't
	 * short-circuit on NULL results, so the regular AND behavior is needed.
	 */</comment>
	<return>return <expr><call><name>ExecInitExpr</name><argument_list>(<argument><expr><call><name>make_ands_explicit</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Call ExecInitExpr() on a list of expressions, return a list of ExprStates.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>ExecInitExprList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>nodes</name></decl></parameter>, <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>nodes</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>ExecInitExpr</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		ExecBuildProjectionInfo
 *
 * Build a ProjectionInfo node for evaluating the given tlist in the given
 * econtext, and storing the result into the tuple slot.  (Caller must have
 * ensured that tuple slot has a descriptor matching the tlist!)
 *
 * inputDesc can be NULL, but if it is not, we check to see whether simple
 * Vars in the tlist match the descriptor.  It is important to provide
 * inputDesc for relation-scan plan nodes, as a cross check that the relation
 * hasn't been changed since the plan was made.  At higher levels of a plan,
 * there is no need to recheck.
 *
 * This is implemented by internally building an ExprState that performs the
 * whole projection in one go.
 *
 * Caution: before PG v10, the targetList was a list of ExprStates; now it
 * should be the planner-created targetlist, since we do the compilation here.
 */</comment>
<function><type><name>ProjectionInfo</name> <modifier>*</modifier></type>
<name>ExecBuildProjectionInfo</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>,
						<parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>,
						<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
						<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>,
						<parameter><decl><type><name>TupleDesc</name></type> <name>inputDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ExecBuildProjectionInfoExt</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>,
									  <argument><expr><name>econtext</name></expr></argument>,
									  <argument><expr><name>slot</name></expr></argument>,
									  <argument><expr><name>true</name></expr></argument>,
									  <argument><expr><name>parent</name></expr></argument>,
									  <argument><expr><name>inputDesc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		ExecBuildProjectionInfoExt
 *
 * As above, with one additional option.
 *
 * If assignJunkEntries is true (the usual case), resjunk entries in the tlist
 * are not handled specially: they are evaluated and assigned to the proper
 * column of the result slot.  If assignJunkEntries is false, resjunk entries
 * are evaluated, but their result is discarded without assignment.
 */</comment>
<function><type><name>ProjectionInfo</name> <modifier>*</modifier></type>
<name>ExecBuildProjectionInfoExt</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>,
						   <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>,
						   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>assignJunkEntries</name></decl></parameter>,
						   <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>,
						   <parameter><decl><type><name>TupleDesc</name></type> <name>inputDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ProjectionInfo</name> <modifier>*</modifier></type><name>projInfo</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ProjectionInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprEvalStep</name></type> <name>scratch</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>projInfo</name><operator>-&gt;</operator><name>pi_exprContext</name></name> <operator>=</operator> <name>econtext</name></expr>;</expr_stmt>
	<comment type="block">/* We embed ExprState into ProjectionInfo instead of doing extra palloc */</comment>
	<expr_stmt><expr><name><name>projInfo</name><operator>-&gt;</operator><name>pi_state</name><operator>.</operator><name>tag</name></name> <operator>=</operator> <name>T_ExprState</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>&amp;</operator><name><name>projInfo</name><operator>-&gt;</operator><name>pi_state</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>targetList</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>parent</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ext_params</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>resultslot</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>

	<comment type="block">/* Insert EEOP_*_FETCHSOME steps as needed */</comment>
	<expr_stmt><expr><call><name>ExecInitExprSlots</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>targetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now compile each tlist column */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>variable</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isSafeVar</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If tlist expression is a safe non-system Var, use the fast-path
		 * ASSIGN_*_VAR opcodes.  "Safe" means that we don't need to apply
		 * CheckVarSlotCompatibility() during plan startup.  If a source slot
		 * was provided, we make the equivalent tests here; if a slot was not
		 * provided, we assume that no check is needed because we're dealing
		 * with a non-relation-scan-level expression.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name><operator>)</operator><operator>-&gt;</operator><name>varattno</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>assignJunkEntries</name> <operator>||</operator> <operator>!</operator><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Non-system Var, but how safe is it? */</comment>
			<expr_stmt><expr><name>variable</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>variable</name><operator>-&gt;</operator><name>varattno</name></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>inputDesc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>isSafeVar</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* can't check, just assume OK */</comment>
			<if type="elseif">else if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <name><name>inputDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>inputDesc</name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * If user attribute is dropped or has a type mismatch, don't
				 * use ASSIGN_*_VAR.  Instead let the normal expression
				 * machinery handle it (which'll possibly error out).
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name> <operator>&amp;&amp;</operator> <name><name>variable</name><operator>-&gt;</operator><name>vartype</name></name> <operator>==</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>isSafeVar</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>isSafeVar</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Fast-path: just generate an EEOP_ASSIGN_*_VAR step */</comment>
			<switch>switch <condition>(<expr><name><name>variable</name><operator>-&gt;</operator><name>varno</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>INNER_VAR</name></expr>:</case>
					<comment type="block">/* get the tuple from the inner node */</comment>
					<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_ASSIGN_INNER_VAR</name></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><name>OUTER_VAR</name></expr>:</case>
					<comment type="block">/* get the tuple from the outer node */</comment>
					<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_ASSIGN_OUTER_VAR</name></expr>;</expr_stmt>
					<break>break;</break>

					<comment type="block">/* INDEX_VAR is handled by default case */</comment>

				<default>default:</default>
					<comment type="block">/* get the tuple from the relation being scanned */</comment>
					<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_ASSIGN_SCAN_VAR</name></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>

			<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>assign_var</name><operator>.</operator><name>attnum</name></name> <operator>=</operator> <name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>assign_var</name><operator>.</operator><name>resultnum</name></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Otherwise, compile the column expression normally.
			 *
			 * We can't tell the expression to evaluate directly into the
			 * result slot, as the result slot (and the exprstate for that
			 * matter) can change between executions.  We instead evaluate
			 * into the ExprState's resvalue/resnull and then move.
			 */</comment>
			<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>resvalue</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>resnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* This makes it easy to discard resjunk results when told to. */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>assignJunkEntries</name> <operator>&amp;&amp;</operator> <name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Column might be referenced multiple times in upper nodes, so
			 * force value to R/O - but only if it could be an expanded datum.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>get_typlen</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_ASSIGN_TMP_MAKE_RO</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_ASSIGN_TMP</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>assign_tmp</name><operator>.</operator><name>resultnum</name></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_DONE</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecReadyExpr</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>projInfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecPrepareExpr --- initialize for expression execution outside a normal
 * Plan tree context.
 *
 * This differs from ExecInitExpr in that we don't assume the caller is
 * already running in the EState's per-query context.  Also, we run the
 * passed expression tree through expression_planner() to prepare it for
 * execution.  (In ordinary Plan trees the regular planning process will have
 * made the appropriate transformations on expressions, but for standalone
 * expressions this won't have happened.)
 */</comment>
<function><type><name>ExprState</name> <modifier>*</modifier></type>
<name>ExecPrepareExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>expression_planner</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecPrepareQual --- initialize for qual execution outside a normal
 * Plan tree context.
 *
 * This differs from ExecInitQual in that we don't assume the caller is
 * already running in the EState's per-query context.  Also, we run the
 * passed expression tree through expression_planner() to prepare it for
 * execution.  (In ordinary Plan trees the regular planning process will have
 * made the appropriate transformations on expressions, but for standalone
 * expressions this won't have happened.)
 */</comment>
<function><type><name>ExprState</name> <modifier>*</modifier></type>
<name>ExecPrepareQual</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qual</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>expression_planner</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecInitQual</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecPrepareCheck -- initialize check constraint for execution outside a
 * normal Plan tree context.
 *
 * See ExecPrepareExpr() and ExecInitCheck() for details.
 */</comment>
<function><type><name>ExprState</name> <modifier>*</modifier></type>
<name>ExecPrepareCheck</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qual</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>expression_planner</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecInitCheck</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Call ExecPrepareExpr() on each member of a list of Exprs, and return
 * a list of ExprStates.
 *
 * See ExecPrepareExpr() for details.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>ExecPrepareExprList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>nodes</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Ensure that the list cell nodes are in the right context too */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>nodes</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>ExecPrepareExpr</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecCheck - evaluate a check constraint
 *
 * For check constraints, a null result is taken as TRUE, ie the constraint
 * passes.
 *
 * The check constraint may have been prepared with ExecInitCheck
 * (possibly via ExecPrepareCheck) if the caller had it in implicit-AND
 * format, but a regular boolean expression prepared with ExecInitExpr or
 * ExecPrepareExpr works too.
 */</comment>
<function><type><name>bool</name></type>
<name>ExecCheck</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

	<comment type="block">/* short-circuit (here and in ExecInitCheck) for empty restriction list */</comment>
	<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* verify that expression was not compiled using ExecInitQual */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EEO_FLAG_IS_QUAL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ExecEvalExprSwitchContext</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Prepare a compiled expression for execution.  This has to be called for
 * every ExprState before it can be executed.
 *
 * NB: While this currently only calls ExecReadyInterpretedExpr(),
 * this will likely get extended to further expression evaluation methods.
 * Therefore this should be used instead of directly calling
 * ExecReadyInterpretedExpr().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecReadyExpr</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>jit_compile_expr</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ExecReadyInterpretedExpr</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Append the steps necessary for the evaluation of node to ExprState-&gt;steps,
 * possibly recursing into sub-expressions of node.
 *
 * node - expression to evaluate
 * state - ExprState to whose -&gt;steps to append the necessary operations
 * resv / resnull - where to store the result of the node into
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecInitExprRec</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
				<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>resv</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>resnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprEvalStep</name></type> <name>scratch</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Guard against stack overflow due to overly complex expressions */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Step's output location is always what the caller gave us */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>resv</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>resnull</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>resvalue</name></name> <operator>=</operator> <name>resv</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>resnull</name></name> <operator>=</operator> <name>resnull</name></expr>;</expr_stmt>

	<comment type="block">/* cases should be ordered as they are in enum NodeTag */</comment>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Var</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>variable</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>variable</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* whole-row Var */</comment>
					<expr_stmt><expr><call><name>ExecInitWholeRowVar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>, <argument><expr><name>variable</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>variable</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* system column */</comment>
					<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>var</name><operator>.</operator><name>attnum</name></name> <operator>=</operator> <name><name>variable</name><operator>-&gt;</operator><name>varattno</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>var</name><operator>.</operator><name>vartype</name></name> <operator>=</operator> <name><name>variable</name><operator>-&gt;</operator><name>vartype</name></name></expr>;</expr_stmt>
					<switch>switch <condition>(<expr><name><name>variable</name><operator>-&gt;</operator><name>varno</name></name></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><name>INNER_VAR</name></expr>:</case>
							<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_INNER_SYSVAR</name></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>OUTER_VAR</name></expr>:</case>
							<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_OUTER_SYSVAR</name></expr>;</expr_stmt>
							<break>break;</break>

							<comment type="block">/* INDEX_VAR is handled by default case */</comment>

						<default>default:</default>
							<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_SCAN_SYSVAR</name></expr>;</expr_stmt>
							<break>break;</break>
					</block_content>}</block></switch>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* regular user column */</comment>
					<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>var</name><operator>.</operator><name>attnum</name></name> <operator>=</operator> <name><name>variable</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>var</name><operator>.</operator><name>vartype</name></name> <operator>=</operator> <name><name>variable</name><operator>-&gt;</operator><name>vartype</name></name></expr>;</expr_stmt>
					<switch>switch <condition>(<expr><name><name>variable</name><operator>-&gt;</operator><name>varno</name></name></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><name>INNER_VAR</name></expr>:</case>
							<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_INNER_VAR</name></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>OUTER_VAR</name></expr>:</case>
							<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_OUTER_VAR</name></expr>;</expr_stmt>
							<break>break;</break>

							<comment type="block">/* INDEX_VAR is handled by default case */</comment>

						<default>default:</default>
							<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_SCAN_VAR</name></expr>;</expr_stmt>
							<break>break;</break>
					</block_content>}</block></switch>
				</block_content>}</block></else></if_stmt>

				<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_Const</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>con</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_CONST</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>constval</name><operator>.</operator><name>value</name></name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>constvalue</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>constval</name><operator>.</operator><name>isnull</name></name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>constisnull</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_Param</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Param</name>	   <modifier>*</modifier></type><name>param</name> <init>= <expr><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>params</name></decl>;</decl_stmt>

				<switch>switch <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>paramkind</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>PARAM_EXEC</name></expr>:</case>
						<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_PARAM_EXEC</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>param</name><operator>.</operator><name>paramid</name></name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>paramid</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>param</name><operator>.</operator><name>paramtype</name></name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>paramtype</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>PARAM_EXTERN</name></expr>:</case>

						<comment type="block">/*
						 * If we have a relevant ParamCompileHook, use it;
						 * otherwise compile a standard EEOP_PARAM_EXTERN
						 * step.  ext_params, if supplied, takes precedence
						 * over info from the parent node's EState (if any).
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>ext_params</name></name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>params</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>ext_params</name></name></expr>;</expr_stmt></block_content></block></if>
						<if type="elseif">else if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>parent</name></name> <operator>&amp;&amp;</operator>
								 <name><name>state</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>params</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>es_param_list_info</name></name></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><name>params</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
						<if_stmt><if>if <condition>(<expr><name>params</name> <operator>&amp;&amp;</operator> <name><name>params</name><operator>-&gt;</operator><name>paramCompile</name></name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name><name>params</name><operator>-&gt;</operator><name>paramCompile</name></name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>param</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
												 <argument><expr><name>resv</name></expr></argument>, <argument><expr><name>resnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if>
						<else>else
						<block>{<block_content>
							<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_PARAM_EXTERN</name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>param</name><operator>.</operator><name>paramid</name></name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>paramid</name></name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>param</name><operator>.</operator><name>paramtype</name></name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>paramtype</name></name></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></else></if_stmt>
						<break>break;</break>
					<default>default:</default>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized paramkind: %d"</literal></expr></argument>,
							 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>param</name><operator>-&gt;</operator><name>paramkind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_Aggref</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Aggref</name>	   <modifier>*</modifier></type><name>aggref</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>AggrefExprState</name> <modifier>*</modifier></type><name>astate</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AggrefExprState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_AGGREF</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>aggref</name><operator>.</operator><name>astate</name></name> <operator>=</operator> <name>astate</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>aggref</name></name> <operator>=</operator> <name>aggref</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>parent</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>, <argument><expr><name>AggState</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>AggState</name>   <modifier>*</modifier></type><name>aggstate</name> <init>= <expr><operator>(</operator><name>AggState</name> <operator>*</operator><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggs</name></name></expr></argument>, <argument><expr><name>astate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>numaggs</name></name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* planner messed up */</comment>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Aggref found in non-Agg plan node"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_GroupingFunc</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>GroupingFunc</name> <modifier>*</modifier></type><name>grp_node</name> <init>= <expr><operator>(</operator><name>GroupingFunc</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Agg</name>		   <modifier>*</modifier></type><name>agg</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>parent</name></name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>, <argument><expr><name>AggState</name></expr></argument>)</argument_list></call> <operator>||</operator>
					<operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><name>Agg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"GroupingFunc found in non-Agg plan node"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_GROUPING_FUNC</name></expr>;</expr_stmt>

				<expr_stmt><expr><name>agg</name> <operator>=</operator> <operator>(</operator><name>Agg</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>plan</name></name><operator>)</operator></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>grouping_func</name><operator>.</operator><name>clauses</name></name> <operator>=</operator> <name><name>grp_node</name><operator>-&gt;</operator><name>cols</name></name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>grouping_func</name><operator>.</operator><name>clauses</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_WindowFunc</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>WindowFunc</name> <modifier>*</modifier></type><name>wfunc</name> <init>= <expr><operator>(</operator><name>WindowFunc</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>WindowFuncExprState</name> <modifier>*</modifier></type><name>wfstate</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>WindowFuncExprState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>wfstate</name><operator>-&gt;</operator><name>wfunc</name></name> <operator>=</operator> <name>wfunc</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>parent</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>, <argument><expr><name>WindowAggState</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>winstate</name> <init>= <expr><operator>(</operator><name>WindowAggState</name> <operator>*</operator><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>nfuncs</name></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>funcs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>funcs</name></name></expr></argument>, <argument><expr><name>wfstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>nfuncs</name> <operator>=</operator> <operator>++</operator><name><name>winstate</name><operator>-&gt;</operator><name>numfuncs</name></name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>wfunc</name><operator>-&gt;</operator><name>winagg</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>numaggs</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/* for now initialize agg using old style expressions */</comment>
					<expr_stmt><expr><name><name>wfstate</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>ExecInitExprList</name><argument_list>(<argument><expr><name><name>wfunc</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
													 <argument><expr><name><name>state</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>wfstate</name><operator>-&gt;</operator><name>aggfilter</name></name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><name><name>wfunc</name><operator>-&gt;</operator><name>aggfilter</name></name></expr></argument>,
													  <argument><expr><name><name>state</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * Complain if the windowfunc's arguments contain any
					 * windowfuncs; nested window functions are semantically
					 * nonsensical.  (This should have been caught earlier,
					 * but we defend against it here anyway.)
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>nfuncs</name> <operator>!=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>numfuncs</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WINDOWING_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"window function calls cannot be nested"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* planner messed up */</comment>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"WindowFunc found in non-WindowAgg plan node"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_WINDOW_FUNC</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>window_func</name><operator>.</operator><name>wfstate</name></name> <operator>=</operator> <name>wfstate</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_SubscriptingRef</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SubscriptingRef</name> <modifier>*</modifier></type><name>sbsref</name> <init>= <expr><operator>(</operator><name>SubscriptingRef</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>ExecInitSubscriptingRef</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>, <argument><expr><name>sbsref</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>resv</name></expr></argument>, <argument><expr><name>resnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_FuncExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>func</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>ExecInitFunc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
							 <argument><expr><name><name>func</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>func</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>, <argument><expr><name><name>func</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>,
							 <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_OpExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>op</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>ExecInitFunc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
							 <argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>opfuncid</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>,
							 <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_DistinctExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>DistinctExpr</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><operator>(</operator><name>DistinctExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>ExecInitFunc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
							 <argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>opfuncid</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>,
							 <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Change opcode of call instruction to EEOP_DISTINCT.
				 *
				 * XXX: historically we've not called the function usage
				 * pgstat infrastructure - that seems inconsistent given that
				 * we do so for normal function *and* operator evaluation.  If
				 * we decided to do that here, we'd probably want separate
				 * opcodes for FUSAGE or not.
				 */</comment>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_DISTINCT</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_NullIfExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NullIfExpr</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><operator>(</operator><name>NullIfExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>ExecInitFunc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
							 <argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>opfuncid</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>,
							 <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Change opcode of call instruction to EEOP_NULLIF.
				 *
				 * XXX: historically we've not called the function usage
				 * pgstat infrastructure - that seems inconsistent given that
				 * we do so for normal function *and* operator evaluation.  If
				 * we decided to do that here, we'd probably want separate
				 * opcodes for FUSAGE or not.
				 */</comment>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_NULLIF</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_ScalarArrayOpExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>opexpr</name> <init>= <expr><operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>scalararg</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>arrayarg</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>finfo</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>scalararg</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>arrayarg</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Check permission to call function */</comment>
				<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_proc_aclcheck</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>opfuncid</name></name></expr></argument>,
											 <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
											 <argument><expr><name>ACL_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_FUNCTION</name></expr></argument>,
								   <argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>opfuncid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>InvokeFunctionExecuteHook</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>opfuncid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Set up the primary fmgr lookup information */</comment>
				<expr_stmt><expr><name>finfo</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>fcinfo</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><call><name>SizeForFunctionCallInfo</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>opfuncid</name></name></expr></argument>, <argument><expr><name>finfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>fmgr_info_set_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>finfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><name>finfo</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
										 <argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Evaluate scalar directly into left function argument */</comment>
				<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name>scalararg</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Evaluate array argument into our return value.  There's no
				 * danger in that, because the return value is guaranteed to
				 * be overwritten by EEOP_SCALARARRAYOP, and will not be
				 * passed to any other expression.
				 */</comment>
				<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name>arrayarg</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>resv</name></expr></argument>, <argument><expr><name>resnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* And perform the operation */</comment>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_SCALARARRAYOP</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>scalararrayop</name><operator>.</operator><name>element_type</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>scalararrayop</name><operator>.</operator><name>useOr</name></name> <operator>=</operator> <name><name>opexpr</name><operator>-&gt;</operator><name>useOr</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>scalararrayop</name><operator>.</operator><name>finfo</name></name> <operator>=</operator> <name>finfo</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>scalararrayop</name><operator>.</operator><name>fcinfo_data</name></name> <operator>=</operator> <name>fcinfo</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>scalararrayop</name><operator>.</operator><name>fn_addr</name></name> <operator>=</operator> <name><name>finfo</name><operator>-&gt;</operator><name>fn_addr</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_BoolExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BoolExpr</name>   <modifier>*</modifier></type><name>boolexpr</name> <init>= <expr><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>boolexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>adjust_jumps</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>off</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

				<comment type="block">/* allocate scratch memory used by all steps of AND/OR */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>boolexpr</name><operator>-&gt;</operator><name>boolop</name></name> <operator>!=</operator> <name>NOT_EXPR</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>boolexpr</name><operator>.</operator><name>anynull</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * For each argument evaluate the argument itself, then
				 * perform the bool operation's appropriate handling.
				 *
				 * We can evaluate each argument into our result area, since
				 * the short-circuiting logic means we only need to remember
				 * previous NULL values.
				 *
				 * AND/OR is split into separate STEP_FIRST (one) / STEP (zero
				 * or more) / STEP_LAST (one) steps, as each of those has to
				 * perform different work.  The FIRST/LAST split is valid
				 * because AND/OR have at least two arguments.
				 */</comment>
				<expr_stmt><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>boolexpr-&gt;args</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<comment type="block">/* Evaluate argument into our output variable */</comment>
					<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>resv</name></expr></argument>, <argument><expr><name>resnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* Perform the appropriate step type */</comment>
					<switch>switch <condition>(<expr><name><name>boolexpr</name><operator>-&gt;</operator><name>boolop</name></name></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><name>AND_EXPR</name></expr>:</case>
							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<if_stmt><if>if <condition>(<expr><name>off</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_BOOL_AND_STEP_FIRST</name></expr>;</expr_stmt></block_content></block></if>
							<if type="elseif">else if <condition>(<expr><name>off</name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <name>nargs</name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_BOOL_AND_STEP_LAST</name></expr>;</expr_stmt></block_content></block></if>
							<else>else<block type="pseudo"><block_content>
								<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_BOOL_AND_STEP</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
							<break>break;</break>
						<case>case <expr><name>OR_EXPR</name></expr>:</case>
							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<if_stmt><if>if <condition>(<expr><name>off</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_BOOL_OR_STEP_FIRST</name></expr>;</expr_stmt></block_content></block></if>
							<if type="elseif">else if <condition>(<expr><name>off</name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <name>nargs</name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_BOOL_OR_STEP_LAST</name></expr>;</expr_stmt></block_content></block></if>
							<else>else<block type="pseudo"><block_content>
								<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_BOOL_OR_STEP</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
							<break>break;</break>
						<case>case <expr><name>NOT_EXPR</name></expr>:</case>
							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_BOOL_NOT_STEP</name></expr>;</expr_stmt>
							<break>break;</break>
						<default>default:</default>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized boolop: %d"</literal></expr></argument>,
								 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>boolexpr</name><operator>-&gt;</operator><name>boolop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
					</block_content>}</block></switch>

					<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>boolexpr</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>adjust_jumps</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>adjust_jumps</name></expr></argument>,
											   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>off</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block>

				<comment type="block">/* adjust jump targets */</comment>
				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>adjust_jumps</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>as</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>steps</name><index>[<expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>boolexpr</name><operator>.</operator><name>jumpdone</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>boolexpr</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name></expr>;</expr_stmt>
				</block_content>}</block>

				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_SubPlan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><name>SubPlan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>SubPlanState</name> <modifier>*</modifier></type><name>sstate</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>parent</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SubPlan found with no parent plan"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>sstate</name> <operator>=</operator> <call><name>ExecInitSubPlan</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* add SubPlanState nodes to state-&gt;parent-&gt;subPlan */</comment>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>subPlan</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>subPlan</name></name></expr></argument>,
												 <argument><expr><name>sstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_SUBPLAN</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>subplan</name><operator>.</operator><name>sstate</name></name> <operator>=</operator> <name>sstate</name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_AlternativeSubPlan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AlternativeSubPlan</name> <modifier>*</modifier></type><name>asplan</name> <init>= <expr><operator>(</operator><name>AlternativeSubPlan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>AlternativeSubPlanState</name> <modifier>*</modifier></type><name>asstate</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>parent</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"AlternativeSubPlan found with no parent plan"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>asstate</name> <operator>=</operator> <call><name>ExecInitAlternativeSubPlan</name><argument_list>(<argument><expr><name>asplan</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_ALTERNATIVE_SUBPLAN</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>alternative_subplan</name><operator>.</operator><name>asstate</name></name> <operator>=</operator> <name>asstate</name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_FieldSelect</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FieldSelect</name> <modifier>*</modifier></type><name>fselect</name> <init>= <expr><operator>(</operator><name>FieldSelect</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* evaluate row/record argument into result area */</comment>
				<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>fselect</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>resv</name></expr></argument>, <argument><expr><name>resnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* and extract field */</comment>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_FIELDSELECT</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fieldselect</name><operator>.</operator><name>fieldnum</name></name> <operator>=</operator> <name><name>fselect</name><operator>-&gt;</operator><name>fieldnum</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fieldselect</name><operator>.</operator><name>resulttype</name></name> <operator>=</operator> <name><name>fselect</name><operator>-&gt;</operator><name>resulttype</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fieldselect</name><operator>.</operator><name>rowcache</name><operator>.</operator><name>cacheptr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_FieldStore</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FieldStore</name> <modifier>*</modifier></type><name>fstore</name> <init>= <expr><operator>(</operator><name>FieldStore</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ExprEvalRowtypeCache</name> <modifier>*</modifier></type><name>rowcachep</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>ncolumns</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l1</name></decl>,
						   <decl><type ref="prev"><modifier>*</modifier></type><name>l2</name></decl>;</decl_stmt>

				<comment type="block">/* find out the number of columns in the composite type */</comment>
				<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc</name><argument_list>(<argument><expr><name><name>fstore</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ncolumns</name> <operator>=</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>DecrTupleDescRefCount</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* create workspace for column values */</comment>
				<expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ncolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>nulls</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ncolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* create shared composite-type-lookup cache struct */</comment>
				<expr_stmt><expr><name>rowcachep</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExprEvalRowtypeCache</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rowcachep</name><operator>-&gt;</operator><name>cacheptr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/* emit code to evaluate the composite input value */</comment>
				<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>fstore</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>resv</name></expr></argument>, <argument><expr><name>resnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* next, deform the input tuple into our workspace */</comment>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_FIELDSTORE_DEFORM</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fieldstore</name><operator>.</operator><name>fstore</name></name> <operator>=</operator> <name>fstore</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fieldstore</name><operator>.</operator><name>rowcache</name></name> <operator>=</operator> <name>rowcachep</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fieldstore</name><operator>.</operator><name>values</name></name> <operator>=</operator> <name>values</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fieldstore</name><operator>.</operator><name>nulls</name></name> <operator>=</operator> <name>nulls</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fieldstore</name><operator>.</operator><name>ncolumns</name></name> <operator>=</operator> <name>ncolumns</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* evaluate new field values, store in workspace columns */</comment>
				<macro><name>forboth</name><argument_list>(<argument>l1</argument>, <argument>fstore-&gt;newvals</argument>, <argument>l2</argument>, <argument>fstore-&gt;fieldnums</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>fieldnum</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>save_innermost_caseval</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>save_innermost_casenull</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>fieldnum</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>fieldnum</name> <operator>&gt;</operator> <name>ncolumns</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"field number %d is out of range in FieldStore"</literal></expr></argument>,
							 <argument><expr><name>fieldnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/*
					 * Use the CaseTestExpr mechanism to pass down the old
					 * value of the field being replaced; this is needed in
					 * case the newval is itself a FieldStore or
					 * SubscriptingRef that has to obtain and modify the old
					 * value.  It's safe to reuse the CASE mechanism because
					 * there cannot be a CASE between here and where the value
					 * would be needed, and a field assignment can't be within
					 * a CASE either.  (So saving and restoring
					 * innermost_caseval is just paranoia, but let's do it
					 * anyway.)
					 *
					 * Another non-obvious point is that it's safe to use the
					 * field's values[]/nulls[] entries as both the caseval
					 * source and the result address for this subexpression.
					 * That's okay only because (1) both FieldStore and
					 * SubscriptingRef evaluate their arg or refexpr inputs
					 * first, and (2) any such CaseTestExpr is directly the
					 * arg or refexpr input.  So any read of the caseval will
					 * occur before there's a chance to overwrite it.  Also,
					 * if multiple entries in the newvals/fieldnums lists
					 * target the same field, they'll effectively be applied
					 * left-to-right which is what we want.
					 */</comment>
					<expr_stmt><expr><name>save_innermost_caseval</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>innermost_caseval</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>save_innermost_casenull</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>innermost_casenull</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>innermost_caseval</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>values</name><index>[<expr><name>fieldnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>innermost_casenull</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>nulls</name><index>[<expr><name>fieldnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>values</name><index>[<expr><name>fieldnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>nulls</name><index>[<expr><name>fieldnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>innermost_caseval</name></name> <operator>=</operator> <name>save_innermost_caseval</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>innermost_casenull</name></name> <operator>=</operator> <name>save_innermost_casenull</name></expr>;</expr_stmt>
				</block_content>}</block>

				<comment type="block">/* finally, form result tuple */</comment>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_FIELDSTORE_FORM</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fieldstore</name><operator>.</operator><name>fstore</name></name> <operator>=</operator> <name>fstore</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fieldstore</name><operator>.</operator><name>rowcache</name></name> <operator>=</operator> <name>rowcachep</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fieldstore</name><operator>.</operator><name>values</name></name> <operator>=</operator> <name>values</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fieldstore</name><operator>.</operator><name>nulls</name></name> <operator>=</operator> <name>nulls</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fieldstore</name><operator>.</operator><name>ncolumns</name></name> <operator>=</operator> <name>ncolumns</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_RelabelType</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/* relabel doesn't need to do anything at runtime */</comment>
				<decl_stmt><decl><type><name>RelabelType</name> <modifier>*</modifier></type><name>relabel</name> <init>= <expr><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>relabel</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>resv</name></expr></argument>, <argument><expr><name>resnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_CoerceViaIO</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CoerceViaIO</name> <modifier>*</modifier></type><name>iocoerce</name> <init>= <expr><operator>(</operator><name>CoerceViaIO</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>iofunc</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>typisvarlena</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>typioparam</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo_in</name></decl>;</decl_stmt>

				<comment type="block">/* evaluate argument into step's result area */</comment>
				<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>iocoerce</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>resv</name></expr></argument>, <argument><expr><name>resnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Prepare both output and input function calls, to be
				 * evaluated inside a single evaluation step for speed - this
				 * can be a very common operation.
				 *
				 * We don't check permissions here as a type's input/output
				 * function are assumed to be executable by everyone.
				 */</comment>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_IOCOERCE</name></expr>;</expr_stmt>

				<comment type="block">/* lookup the source type's output function */</comment>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>iocoerce</name><operator>.</operator><name>finfo_out</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>iocoerce</name><operator>.</operator><name>fcinfo_data_out</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><call><name>SizeForFunctionCallInfo</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>iocoerce</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>iofunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typisvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>iofunc</name></expr></argument>, <argument><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>iocoerce</name><operator>.</operator><name>finfo_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>fmgr_info_set_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>iocoerce</name><operator>.</operator><name>finfo_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>iocoerce</name><operator>.</operator><name>fcinfo_data_out</name></name></expr></argument>,
										 <argument><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>iocoerce</name><operator>.</operator><name>finfo_out</name></name></expr></argument>,
										 <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* lookup the result type's input function */</comment>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>iocoerce</name><operator>.</operator><name>finfo_in</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>iocoerce</name><operator>.</operator><name>fcinfo_data_in</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><call><name>SizeForFunctionCallInfo</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>getTypeInputInfo</name><argument_list>(<argument><expr><name><name>iocoerce</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>iofunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typioparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>iofunc</name></expr></argument>, <argument><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>iocoerce</name><operator>.</operator><name>finfo_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>fmgr_info_set_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>iocoerce</name><operator>.</operator><name>finfo_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>iocoerce</name><operator>.</operator><name>fcinfo_data_in</name></name></expr></argument>,
										 <argument><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>iocoerce</name><operator>.</operator><name>finfo_in</name></name></expr></argument>,
										 <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * We can preload the second and third arguments for the input
				 * function, since they're constants.
				 */</comment>
				<expr_stmt><expr><name>fcinfo_in</name> <operator>=</operator> <name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>iocoerce</name><operator>.</operator><name>fcinfo_data_in</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>fcinfo_in</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typioparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>fcinfo_in</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>fcinfo_in</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>fcinfo_in</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_ArrayCoerceExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ArrayCoerceExpr</name> <modifier>*</modifier></type><name>acoerce</name> <init>= <expr><operator>(</operator><name>ArrayCoerceExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>resultelemtype</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>elemstate</name></decl>;</decl_stmt>

				<comment type="block">/* evaluate argument into step's result area */</comment>
				<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>acoerce</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>resv</name></expr></argument>, <argument><expr><name>resnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>resultelemtype</name> <operator>=</operator> <call><name>get_element_type</name><argument_list>(<argument><expr><name><name>acoerce</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>resultelemtype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"target type is not an array"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Construct a sub-expression for the per-element expression;
				 * but don't ready it until after we check it for triviality.
				 * We assume it hasn't any Var references, but does have a
				 * CaseTestExpr representing the source array element values.
				 */</comment>
				<expr_stmt><expr><name>elemstate</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ExprState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>elemstate</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name><name>acoerce</name><operator>-&gt;</operator><name>elemexpr</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>elemstate</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>elemstate</name><operator>-&gt;</operator><name>ext_params</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>ext_params</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>elemstate</name><operator>-&gt;</operator><name>innermost_caseval</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>elemstate</name><operator>-&gt;</operator><name>innermost_casenull</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>acoerce</name><operator>-&gt;</operator><name>elemexpr</name></name></expr></argument>, <argument><expr><name>elemstate</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name><name>elemstate</name><operator>-&gt;</operator><name>resvalue</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>elemstate</name><operator>-&gt;</operator><name>resnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>elemstate</name><operator>-&gt;</operator><name>steps_len</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
					<name><name>elemstate</name><operator>-&gt;</operator><name>steps</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>opcode</name> <operator>==</operator> <name>EEOP_CASE_TESTVAL</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Trivial, so we need no per-element work at runtime */</comment>
					<expr_stmt><expr><name>elemstate</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* Not trivial, so append a DONE step */</comment>
					<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_DONE</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>elemstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* and ready the subexpression */</comment>
					<expr_stmt><expr><call><name>ExecReadyExpr</name><argument_list>(<argument><expr><name>elemstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_ARRAYCOERCE</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>arraycoerce</name><operator>.</operator><name>elemexprstate</name></name> <operator>=</operator> <name>elemstate</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>arraycoerce</name><operator>.</operator><name>resultelemtype</name></name> <operator>=</operator> <name>resultelemtype</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>elemstate</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Set up workspace for array_map */</comment>
					<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>arraycoerce</name><operator>.</operator><name>amstate</name></name> <operator>=</operator>
						<operator>(</operator><name>ArrayMapState</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ArrayMapState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* Don't need workspace if there's no subexpression */</comment>
					<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>arraycoerce</name><operator>.</operator><name>amstate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_ConvertRowtypeExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ConvertRowtypeExpr</name> <modifier>*</modifier></type><name>convert</name> <init>= <expr><operator>(</operator><name>ConvertRowtypeExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ExprEvalRowtypeCache</name> <modifier>*</modifier></type><name>rowcachep</name></decl>;</decl_stmt>

				<comment type="block">/* cache structs must be out-of-line for space reasons */</comment>
				<expr_stmt><expr><name>rowcachep</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ExprEvalRowtypeCache</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rowcachep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>cacheptr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rowcachep</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>cacheptr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/* evaluate argument into step's result area */</comment>
				<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>convert</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>resv</name></expr></argument>, <argument><expr><name>resnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* and push conversion step */</comment>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_CONVERT_ROWTYPE</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>convert_rowtype</name><operator>.</operator><name>inputtype</name></name> <operator>=</operator>
					<call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>convert</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>convert_rowtype</name><operator>.</operator><name>outputtype</name></name> <operator>=</operator> <name><name>convert</name><operator>-&gt;</operator><name>resulttype</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>convert_rowtype</name><operator>.</operator><name>incache</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>rowcachep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>convert_rowtype</name><operator>.</operator><name>outcache</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>rowcachep</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>convert_rowtype</name><operator>.</operator><name>map</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

			<comment type="block">/* note that CaseWhen expressions are handled within this block */</comment>
		<case>case <expr><name>T_CaseExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CaseExpr</name>   <modifier>*</modifier></type><name>caseExpr</name> <init>= <expr><operator>(</operator><name>CaseExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>adjust_jumps</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>caseval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>casenull</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * If there's a test expression, we have to evaluate it and
				 * save the value where the CaseTestExpr placeholders can find
				 * it.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>caseExpr</name><operator>-&gt;</operator><name>arg</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Evaluate testexpr into caseval/casenull workspace */</comment>
					<expr_stmt><expr><name>caseval</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>casenull</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>caseExpr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
									<argument><expr><name>caseval</name></expr></argument>, <argument><expr><name>casenull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * Since value might be read multiple times, force to R/O
					 * - but only if it could be an expanded datum.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>get_typlen</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>caseExpr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* change caseval in-place */</comment>
						<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_MAKE_READONLY</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>resvalue</name></name> <operator>=</operator> <name>caseval</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>resnull</name></name> <operator>=</operator> <name>casenull</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>make_readonly</name><operator>.</operator><name>value</name></name> <operator>=</operator> <name>caseval</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>make_readonly</name><operator>.</operator><name>isnull</name></name> <operator>=</operator> <name>casenull</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<comment type="block">/* restore normal settings of scratch fields */</comment>
						<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>resvalue</name></name> <operator>=</operator> <name>resv</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>resnull</name></name> <operator>=</operator> <name>resnull</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Prepare to evaluate each of the WHEN clauses in turn; as
				 * soon as one is true we return the value of the
				 * corresponding THEN clause.  If none are true then we return
				 * the value of the ELSE clause, or NULL if there is none.
				 */</comment>
				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>caseExpr-&gt;args</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>CaseWhen</name>   <modifier>*</modifier></type><name>when</name> <init>= <expr><operator>(</operator><name>CaseWhen</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>save_innermost_caseval</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>save_innermost_casenull</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>whenstep</name></decl>;</decl_stmt>

					<comment type="block">/*
					 * Make testexpr result available to CaseTestExpr nodes
					 * within the condition.  We must save and restore prior
					 * setting of innermost_caseval fields, in case this node
					 * is itself within a larger CASE.
					 *
					 * If there's no test expression, we don't actually need
					 * to save and restore these fields; but it's less code to
					 * just do so unconditionally.
					 */</comment>
					<expr_stmt><expr><name>save_innermost_caseval</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>innermost_caseval</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>save_innermost_casenull</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>innermost_casenull</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>innermost_caseval</name></name> <operator>=</operator> <name>caseval</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>innermost_casenull</name></name> <operator>=</operator> <name>casenull</name></expr>;</expr_stmt>

					<comment type="block">/* evaluate condition into CASE's result variables */</comment>
					<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>when</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>resv</name></expr></argument>, <argument><expr><name>resnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>innermost_caseval</name></name> <operator>=</operator> <name>save_innermost_caseval</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>innermost_casenull</name></name> <operator>=</operator> <name>save_innermost_casenull</name></expr>;</expr_stmt>

					<comment type="block">/* If WHEN result isn't true, jump to next CASE arm */</comment>
					<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_JUMP_IF_NOT_TRUE</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>jump</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* computed later */</comment>
					<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>whenstep</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

					<comment type="block">/*
					 * If WHEN result is true, evaluate THEN result, storing
					 * it into the CASE's result variables.
					 */</comment>
					<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>when</name><operator>-&gt;</operator><name>result</name></name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>resv</name></expr></argument>, <argument><expr><name>resnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* Emit JUMP step to jump to end of CASE's code */</comment>
					<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_JUMP</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>jump</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* computed later */</comment>
					<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * Don't know address for that jump yet, compute once the
					 * whole CASE expression is built.
					 */</comment>
					<expr_stmt><expr><name>adjust_jumps</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>adjust_jumps</name></expr></argument>,
											   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * But we can set WHEN test's jump target now, to make it
					 * jump to the next WHEN subexpression or the ELSE.
					 */</comment>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>steps</name><index>[<expr><name>whenstep</name></expr>]</index></name><operator>.</operator><name><name>d</name><operator>.</operator><name>jump</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name></expr>;</expr_stmt>
				</block_content>}</block>

				<comment type="block">/* transformCaseExpr always adds a default */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>caseExpr</name><operator>-&gt;</operator><name>defresult</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* evaluate ELSE expr into CASE's result variables */</comment>
				<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>caseExpr</name><operator>-&gt;</operator><name>defresult</name></name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
								<argument><expr><name>resv</name></expr></argument>, <argument><expr><name>resnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* adjust jump targets */</comment>
				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>adjust_jumps</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>as</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>steps</name><index>[<expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>opcode</name></name> <operator>==</operator> <name>EEOP_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>jump</name><operator>.</operator><name>jumpdone</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>jump</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name></expr>;</expr_stmt>
				</block_content>}</block>

				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_CaseTestExpr</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * Read from location identified by innermost_caseval.  Note
				 * that innermost_caseval could be NULL, if this node isn't
				 * actually within a CaseExpr, ArrayCoerceExpr, etc structure.
				 * That can happen because some parts of the system abuse
				 * CaseTestExpr to cause a read of a value externally supplied
				 * in econtext-&gt;caseValue_datum.  We'll take care of that
				 * scenario at runtime.
				 */</comment>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_CASE_TESTVAL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>casetest</name><operator>.</operator><name>value</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>innermost_caseval</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>casetest</name><operator>.</operator><name>isnull</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>innermost_casenull</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_ArrayExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ArrayExpr</name>  <modifier>*</modifier></type><name>arrayexpr</name> <init>= <expr><operator>(</operator><name>ArrayExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>nelems</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>arrayexpr</name><operator>-&gt;</operator><name>elements</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>elemoff</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * Evaluate by computing each element, and then forming the
				 * array.  Elements are computed into scratch arrays
				 * associated with the ARRAYEXPR step.
				 */</comment>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_ARRAYEXPR</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>arrayexpr</name><operator>.</operator><name>elemvalues</name></name> <operator>=</operator>
					<operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nelems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>arrayexpr</name><operator>.</operator><name>elemnulls</name></name> <operator>=</operator>
					<operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nelems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>arrayexpr</name><operator>.</operator><name>nelems</name></name> <operator>=</operator> <name>nelems</name></expr>;</expr_stmt>

				<comment type="block">/* fill remaining fields of step */</comment>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>arrayexpr</name><operator>.</operator><name>multidims</name></name> <operator>=</operator> <name><name>arrayexpr</name><operator>-&gt;</operator><name>multidims</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>arrayexpr</name><operator>.</operator><name>elemtype</name></name> <operator>=</operator> <name><name>arrayexpr</name><operator>-&gt;</operator><name>element_typeid</name></name></expr>;</expr_stmt>

				<comment type="block">/* do one-time catalog lookup for type info */</comment>
				<expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><name><name>arrayexpr</name><operator>-&gt;</operator><name>element_typeid</name></name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>arrayexpr</name><operator>.</operator><name>elemlength</name></name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>arrayexpr</name><operator>.</operator><name>elembyval</name></name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>arrayexpr</name><operator>.</operator><name>elemalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* prepare to evaluate all arguments */</comment>
				<expr_stmt><expr><name>elemoff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>arrayexpr-&gt;elements</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>arrayexpr</name><operator>.</operator><name>elemvalues</name><index>[<expr><name>elemoff</name></expr>]</index></name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>arrayexpr</name><operator>.</operator><name>elemnulls</name><index>[<expr><name>elemoff</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>elemoff</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block>

				<comment type="block">/* and then collect all into an array */</comment>
				<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_RowExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RowExpr</name>    <modifier>*</modifier></type><name>rowexpr</name> <init>= <expr><operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>nelems</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

				<comment type="block">/* Build tupdesc to describe result tuples */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>rowexpr</name><operator>-&gt;</operator><name>row_typeid</name></name> <operator>==</operator> <name>RECORDOID</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* generic record, use types of given expressions */</comment>
					<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>ExecTypeFromExprList</name><argument_list>(<argument><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* ... but adopt RowExpr's column aliases */</comment>
					<expr_stmt><expr><call><name>ExecTypeSetColNames</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* Bless the tupdesc so it can be looked up later */</comment>
					<expr_stmt><expr><call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* it's been cast to a named type, use that */</comment>
					<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc_copy</name><argument_list>(<argument><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>row_typeid</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<comment type="block">/*
				 * In the named-type case, the tupdesc could have more columns
				 * than are in the args list, since the type might have had
				 * columns added since the ROW() was parsed.  We want those
				 * extra columns to go to nulls, so we make sure that the
				 * workspace arrays are large enough and then initialize any
				 * extra columns to read as NULLs.
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nelems</name> <operator>&lt;=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>nelems</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>nelems</name></expr></argument>, <argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Evaluate by first building datums for each field, and then
				 * a final step forming the composite datum.
				 */</comment>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_ROW</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>row</name><operator>.</operator><name>tupdesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>

				<comment type="block">/* space for the individual field datums */</comment>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>row</name><operator>.</operator><name>elemvalues</name></name> <operator>=</operator>
					<operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nelems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>row</name><operator>.</operator><name>elemnulls</name></name> <operator>=</operator>
					<operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nelems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* as explained above, make sure any extra columns are null */</comment>
				<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>row</name><operator>.</operator><name>elemnulls</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nelems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Set up evaluation, skipping any deleted columns */</comment>
				<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>rowexpr-&gt;args</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * Guard against ALTER COLUMN TYPE on rowtype since
						 * the RowExpr was created.  XXX should we check
						 * typmod too?	Not sure we can be sure it'll be the
						 * same.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>e</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ROW() column has type %s instead of type %s"</literal></expr></argument>,
											<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/*
						 * Ignore original expression and insert a NULL. We
						 * don't really care what type of NULL it is, so
						 * always make an int4 NULL.
						 */</comment>
						<expr_stmt><expr><name>e</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeNullConst</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>

					<comment type="block">/* Evaluate column expr into appropriate workspace slot */</comment>
					<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>row</name><operator>.</operator><name>elemvalues</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>row</name><operator>.</operator><name>elemnulls</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block>

				<comment type="block">/* And finally build the row value */</comment>
				<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_RowCompareExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RowCompareExpr</name> <modifier>*</modifier></type><name>rcexpr</name> <init>= <expr><operator>(</operator><name>RowCompareExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>nopers</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rcexpr</name><operator>-&gt;</operator><name>opnos</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>adjust_jumps</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l_left_expr</name></decl>,
						   <decl><type ref="prev"><modifier>*</modifier></type><name>l_right_expr</name></decl>,
						   <decl><type ref="prev"><modifier>*</modifier></type><name>l_opno</name></decl>,
						   <decl><type ref="prev"><modifier>*</modifier></type><name>l_opfamily</name></decl>,
						   <decl><type ref="prev"><modifier>*</modifier></type><name>l_inputcollid</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * Iterate over each field, prepare comparisons.  To handle
				 * NULL results, prepare jumps to after the expression.  If a
				 * comparison yields a != 0 result, jump to the final step.
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rcexpr</name><operator>-&gt;</operator><name>largs</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>nopers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rcexpr</name><operator>-&gt;</operator><name>rargs</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>nopers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rcexpr</name><operator>-&gt;</operator><name>opfamilies</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>nopers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rcexpr</name><operator>-&gt;</operator><name>inputcollids</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>nopers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<macro><name>forfive</name><argument_list>(<argument>l_left_expr</argument>, <argument>rcexpr-&gt;largs</argument>,
						<argument>l_right_expr</argument>, <argument>rcexpr-&gt;rargs</argument>,
						<argument>l_opno</argument>, <argument>rcexpr-&gt;opnos</argument>,
						<argument>l_opfamily</argument>, <argument>rcexpr-&gt;opfamilies</argument>,
						<argument>l_inputcollid</argument>, <argument>rcexpr-&gt;inputcollids</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>left_expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l_left_expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>right_expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l_right_expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>opno</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l_opno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>opfamily</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l_opfamily</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>inputcollid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l_inputcollid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>strategy</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>lefttype</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>righttype</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>proc</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>finfo</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>get_op_opfamily_properties</name><argument_list>(<argument><expr><name>opno</name></expr></argument>, <argument><expr><name>opfamily</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>strategy</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>lefttype</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>righttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>proc</name> <operator>=</operator> <call><name>get_opfamily_proc</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>,
											 <argument><expr><name>lefttype</name></expr></argument>,
											 <argument><expr><name>righttype</name></expr></argument>,
											 <argument><expr><name>BTORDER_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing support function %d(%u,%u) in opfamily %u"</literal></expr></argument>,
							 <argument><expr><name>BTORDER_PROC</name></expr></argument>, <argument><expr><name>lefttype</name></expr></argument>, <argument><expr><name>righttype</name></expr></argument>, <argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/* Set up the primary fmgr lookup information */</comment>
					<expr_stmt><expr><name>finfo</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>fcinfo</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><call><name>SizeForFunctionCallInfo</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>finfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>fmgr_info_set_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>finfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><name>finfo</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
											 <argument><expr><name>inputcollid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * If we enforced permissions checks on index support
					 * functions, we'd need to make a check here.  But the
					 * index support machinery doesn't do that, and thus
					 * neither does this code.
					 */</comment>

					<comment type="block">/* evaluate left and right args directly into fcinfo */</comment>
					<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name>left_expr</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name>right_expr</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_ROWCOMPARE_STEP</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>rowcompare_step</name><operator>.</operator><name>finfo</name></name> <operator>=</operator> <name>finfo</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>rowcompare_step</name><operator>.</operator><name>fcinfo_data</name></name> <operator>=</operator> <name>fcinfo</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>rowcompare_step</name><operator>.</operator><name>fn_addr</name></name> <operator>=</operator> <name><name>finfo</name><operator>-&gt;</operator><name>fn_addr</name></name></expr>;</expr_stmt>
					<comment type="block">/* jump targets filled below */</comment>
					<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>rowcompare_step</name><operator>.</operator><name>jumpnull</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>rowcompare_step</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>adjust_jumps</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>adjust_jumps</name></expr></argument>,
											   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>

				<comment type="block">/*
				 * We could have a zero-column rowtype, in which case the rows
				 * necessarily compare equal.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>nopers</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_CONST</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>constval</name><operator>.</operator><name>value</name></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>constval</name><operator>.</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Finally, examine the last comparison result */</comment>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_ROWCOMPARE_FINAL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>rowcompare_final</name><operator>.</operator><name>rctype</name></name> <operator>=</operator> <name><name>rcexpr</name><operator>-&gt;</operator><name>rctype</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* adjust jump targets */</comment>
				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>adjust_jumps</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>as</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>steps</name><index>[<expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>opcode</name></name> <operator>==</operator> <name>EEOP_ROWCOMPARE_STEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>rowcompare_step</name><operator>.</operator><name>jumpdone</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>rowcompare_step</name><operator>.</operator><name>jumpnull</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* jump to comparison evaluation */</comment>
					<expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>rowcompare_step</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					<comment type="block">/* jump to the following expression */</comment>
					<expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>rowcompare_step</name><operator>.</operator><name>jumpnull</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name></expr>;</expr_stmt>
				</block_content>}</block>

				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_CoalesceExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CoalesceExpr</name> <modifier>*</modifier></type><name>coalesce</name> <init>= <expr><operator>(</operator><name>CoalesceExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>adjust_jumps</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

				<comment type="block">/* We assume there's at least one arg */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>coalesce</name><operator>-&gt;</operator><name>args</name></name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Prepare evaluation of all coalesced arguments, after each
				 * one push a step that short-circuits if not null.
				 */</comment>
				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>coalesce-&gt;args</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<comment type="block">/* evaluate argument, directly into result datum */</comment>
					<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>resv</name></expr></argument>, <argument><expr><name>resnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* if it's not null, skip to end of COALESCE expr */</comment>
					<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_JUMP_IF_NOT_NULL</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>jump</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* adjust later */</comment>
					<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>adjust_jumps</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>adjust_jumps</name></expr></argument>,
											   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>

				<comment type="block">/*
				 * No need to add a constant NULL return - we only can get to
				 * the end of the expression if a NULL already is being
				 * returned.
				 */</comment>

				<comment type="block">/* adjust jump targets */</comment>
				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>adjust_jumps</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>as</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>steps</name><index>[<expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>opcode</name></name> <operator>==</operator> <name>EEOP_JUMP_IF_NOT_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>jump</name><operator>.</operator><name>jumpdone</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>jump</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name></expr>;</expr_stmt>
				</block_content>}</block>

				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_MinMaxExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>MinMaxExpr</name> <modifier>*</modifier></type><name>minmaxexpr</name> <init>= <expr><operator>(</operator><name>MinMaxExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>nelems</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>minmaxexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>finfo</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>off</name></decl>;</decl_stmt>

				<comment type="block">/* Look up the btree comparison function for the datatype */</comment>
				<expr_stmt><expr><name>typentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name><name>minmaxexpr</name><operator>-&gt;</operator><name>minmaxtype</name></name></expr></argument>,
											 <argument><expr><name>TYPECACHE_CMP_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>cmp_proc</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not identify a comparison function for type %s"</literal></expr></argument>,
									<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>minmaxexpr</name><operator>-&gt;</operator><name>minmaxtype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * If we enforced permissions checks on index support
				 * functions, we'd need to make a check here.  But the index
				 * support machinery doesn't do that, and thus neither does
				 * this code.
				 */</comment>

				<comment type="block">/* Perform function lookup */</comment>
				<expr_stmt><expr><name>finfo</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>fcinfo</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><call><name>SizeForFunctionCallInfo</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>cmp_proc</name></name></expr></argument>, <argument><expr><name>finfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>fmgr_info_set_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>finfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><name>finfo</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
										 <argument><expr><name><name>minmaxexpr</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_MINMAX</name></expr>;</expr_stmt>
				<comment type="block">/* allocate space to store arguments */</comment>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>minmax</name><operator>.</operator><name>values</name></name> <operator>=</operator>
					<operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nelems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>minmax</name><operator>.</operator><name>nulls</name></name> <operator>=</operator>
					<operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nelems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>minmax</name><operator>.</operator><name>nelems</name></name> <operator>=</operator> <name>nelems</name></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>minmax</name><operator>.</operator><name>op</name></name> <operator>=</operator> <name><name>minmaxexpr</name><operator>-&gt;</operator><name>op</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>minmax</name><operator>.</operator><name>finfo</name></name> <operator>=</operator> <name>finfo</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>minmax</name><operator>.</operator><name>fcinfo_data</name></name> <operator>=</operator> <name>fcinfo</name></expr>;</expr_stmt>

				<comment type="block">/* evaluate expressions into minmax-&gt;values/nulls */</comment>
				<expr_stmt><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>minmaxexpr-&gt;args</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>minmax</name><operator>.</operator><name>values</name><index>[<expr><name>off</name></expr>]</index></name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>minmax</name><operator>.</operator><name>nulls</name><index>[<expr><name>off</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>off</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block>

				<comment type="block">/* and push the final comparison */</comment>
				<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_SQLValueFunction</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SQLValueFunction</name> <modifier>*</modifier></type><name>svf</name> <init>= <expr><operator>(</operator><name>SQLValueFunction</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_SQLVALUEFUNCTION</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>sqlvaluefunction</name><operator>.</operator><name>svf</name></name> <operator>=</operator> <name>svf</name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_XmlExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>XmlExpr</name>    <modifier>*</modifier></type><name>xexpr</name> <init>= <expr><operator>(</operator><name>XmlExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>nnamed</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>named_args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>off</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_XMLEXPR</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>xexpr</name></name> <operator>=</operator> <name>xexpr</name></expr>;</expr_stmt>

				<comment type="block">/* allocate space for storing all the arguments */</comment>
				<if_stmt><if>if <condition>(<expr><name>nnamed</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>named_argvalue</name></name> <operator>=</operator>
						<operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nnamed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>named_argnull</name></name> <operator>=</operator>
						<operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nnamed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>named_argvalue</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>named_argnull</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>nargs</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>argvalue</name></name> <operator>=</operator>
						<operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>argnull</name></name> <operator>=</operator>
						<operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>argvalue</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>argnull</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<comment type="block">/* prepare argument execution */</comment>
				<expr_stmt><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>arg</argument>, <argument>xexpr-&gt;named_args</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>named_argvalue</name><index>[<expr><name>off</name></expr>]</index></name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>named_argnull</name><index>[<expr><name>off</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>off</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block>

				<expr_stmt><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>arg</argument>, <argument>xexpr-&gt;args</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>argvalue</name><index>[<expr><name>off</name></expr>]</index></name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>argnull</name><index>[<expr><name>off</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>off</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block>

				<comment type="block">/* and evaluate the actual XML expression */</comment>
				<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_NullTest</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>ntest</name> <init>= <expr><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>ntest</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>==</operator> <name>IS_NULL</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>ntest</name><operator>-&gt;</operator><name>argisrow</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_NULLTEST_ROWISNULL</name></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_NULLTEST_ISNULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>ntest</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>==</operator> <name>IS_NOT_NULL</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>ntest</name><operator>-&gt;</operator><name>argisrow</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_NULLTEST_ROWISNOTNULL</name></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_NULLTEST_ISNOTNULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized nulltesttype: %d"</literal></expr></argument>,
						 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>ntest</name><operator>-&gt;</operator><name>nulltesttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<comment type="block">/* initialize cache in case it's a row test */</comment>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>nulltest_row</name><operator>.</operator><name>rowcache</name><operator>.</operator><name>cacheptr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/* first evaluate argument into result variable */</comment>
				<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>ntest</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
								<argument><expr><name>resv</name></expr></argument>, <argument><expr><name>resnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* then push the test of that argument */</comment>
				<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_BooleanTest</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BooleanTest</name> <modifier>*</modifier></type><name>btest</name> <init>= <expr><operator>(</operator><name>BooleanTest</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * Evaluate argument, directly into result datum.  That's ok,
				 * because resv/resnull is definitely not used anywhere else,
				 * and will get overwritten by the below EEOP_BOOLTEST_IS_*
				 * step.
				 */</comment>
				<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>btest</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>resv</name></expr></argument>, <argument><expr><name>resnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<switch>switch <condition>(<expr><name><name>btest</name><operator>-&gt;</operator><name>booltesttype</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>IS_TRUE</name></expr>:</case>
						<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_BOOLTEST_IS_TRUE</name></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>IS_NOT_TRUE</name></expr>:</case>
						<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_BOOLTEST_IS_NOT_TRUE</name></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>IS_FALSE</name></expr>:</case>
						<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_BOOLTEST_IS_FALSE</name></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>IS_NOT_FALSE</name></expr>:</case>
						<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_BOOLTEST_IS_NOT_FALSE</name></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>IS_UNKNOWN</name></expr>:</case>
						<comment type="block">/* Same as scalar IS NULL test */</comment>
						<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_NULLTEST_ISNULL</name></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>IS_NOT_UNKNOWN</name></expr>:</case>
						<comment type="block">/* Same as scalar IS NOT NULL test */</comment>
						<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_NULLTEST_ISNOTNULL</name></expr>;</expr_stmt>
						<break>break;</break>
					<default>default:</default>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized booltesttype: %d"</literal></expr></argument>,
							 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>btest</name><operator>-&gt;</operator><name>booltesttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></switch>

				<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_CoerceToDomain</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CoerceToDomain</name> <modifier>*</modifier></type><name>ctest</name> <init>= <expr><operator>(</operator><name>CoerceToDomain</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>ExecInitCoerceToDomain</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>, <argument><expr><name>ctest</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
									   <argument><expr><name>resv</name></expr></argument>, <argument><expr><name>resnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_CoerceToDomainValue</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * Read from location identified by innermost_domainval.  Note
				 * that innermost_domainval could be NULL, if we're compiling
				 * a standalone domain check rather than one embedded in a
				 * larger expression.  In that case we must read from
				 * econtext-&gt;domainValue_datum.  We'll take care of that
				 * scenario at runtime.
				 */</comment>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_DOMAIN_TESTVAL</name></expr>;</expr_stmt>
				<comment type="block">/* we share instruction union variant with case testval */</comment>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>casetest</name><operator>.</operator><name>value</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>innermost_domainval</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>casetest</name><operator>.</operator><name>isnull</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>innermost_domainnull</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_CurrentOfExpr</name></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_CURRENTOFEXPR</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_NextValueExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NextValueExpr</name> <modifier>*</modifier></type><name>nve</name> <init>= <expr><operator>(</operator><name>NextValueExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_NEXTVALUEEXPR</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>nextvalueexpr</name><operator>.</operator><name>seqid</name></name> <operator>=</operator> <name><name>nve</name><operator>-&gt;</operator><name>seqid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>nextvalueexpr</name><operator>.</operator><name>seqtypid</name></name> <operator>=</operator> <name><name>nve</name><operator>-&gt;</operator><name>typeId</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_CypherTypeCast</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CypherTypeCast</name> <modifier>*</modifier></type><name>tc</name> <init>= <expr><operator>(</operator><name>CypherTypeCast</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>ExecInitCypherTypeCast</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_CypherMapExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CypherMapExpr</name> <modifier>*</modifier></type><name>mapexpr</name> <init>= <expr><operator>(</operator><name>CypherMapExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>ExecInitCypherMap</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>, <argument><expr><name>mapexpr</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_CypherListExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CypherListExpr</name> <modifier>*</modifier></type><name>listexpr</name> <init>= <expr><operator>(</operator><name>CypherListExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>ExecInitCypherList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>, <argument><expr><name>listexpr</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_CypherListCompExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CypherListCompExpr</name> <modifier>*</modifier></type><name>listcompexpr</name> <init>= <expr><operator>(</operator><name>CypherListCompExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>ExecInitCypherListComp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>, <argument><expr><name>listcompexpr</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_CypherListCompVar</name></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_CYPHERLISTCOMP_VAR</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>cypherlistcomp_var</name><operator>.</operator><name>elemvalue</name></name> <operator>=</operator>
					<name><name>state</name><operator>-&gt;</operator><name>innermost_cypherlistcomp_iterval</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>cypherlistcomp_var</name><operator>.</operator><name>elemnull</name></name> <operator>=</operator>
					<name><name>state</name><operator>-&gt;</operator><name>innermost_cypherlistcomp_iternull</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_CypherAccessExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CypherAccessExpr</name> <modifier>*</modifier></type><name>accessexpr</name> <init>= <expr><operator>(</operator><name>CypherAccessExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>ExecInitCypherAccess</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>, <argument><expr><name>accessexpr</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Add another expression evaluation step to ExprState-&gt;steps.
 *
 * Note that this potentially re-allocates es-&gt;steps, therefore no pointer
 * into that array may be used while the expression is still being built.
 */</comment>
<function><type><name>void</name></type>
<name>ExprEvalPushStep</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ExprEvalStep</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>steps_alloc</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>steps_alloc</name></name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>steps</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExprEvalStep</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>es</name><operator>-&gt;</operator><name>steps_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>steps_alloc</name></name> <operator>==</operator> <name><name>es</name><operator>-&gt;</operator><name>steps_len</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>steps_alloc</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>steps</name></name> <operator>=</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>steps</name></name></expr></argument>,
							 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExprEvalStep</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>es</name><operator>-&gt;</operator><name>steps_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>es</name><operator>-&gt;</operator><name>steps</name><index>[<expr><name><name>es</name><operator>-&gt;</operator><name>steps_len</name></name><operator>++</operator></expr>]</index></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExprEvalStep</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Perform setup necessary for the evaluation of a function-like expression,
 * appending argument evaluation steps to the steps list in *state, and
 * setting up *scratch so it is ready to be pushed.
 *
 * *scratch is not pushed here, so that callers may override the opcode,
 * which is useful for function-like cases like DISTINCT.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecInitFunc</name><parameter_list>(<parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>scratch</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>,
			 <parameter><decl><type><name>Oid</name></type> <name>inputcollid</name></decl></parameter>, <parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>flinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>argno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Check permission to call function */</comment>
	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_proc_aclcheck</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_FUNCTION</name></expr></argument>, <argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>InvokeFunctionExecuteHook</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Safety check on nargs.  Under normal circumstances this should never
	 * fail, as parser should check sooner.  But possibly it might fail if
	 * server has been compiled with FUNC_MAX_ARGS smaller than some functions
	 * declared in pg_proc?
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&gt;</operator> <name>FUNC_MAX_ARGS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_ARGUMENTS</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg_plural</name><argument_list>(<argument><expr><literal type="string">"cannot pass more than %d argument to a function"</literal></expr></argument>,
							   <argument><expr><literal type="string">"cannot pass more than %d arguments to a function"</literal></expr></argument>,
							   <argument><expr><name>FUNC_MAX_ARGS</name></expr></argument>,
							   <argument><expr><name>FUNC_MAX_ARGS</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Allocate function lookup data and parameter workspace for this call */</comment>
	<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>func</name><operator>.</operator><name>finfo</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>func</name><operator>.</operator><name>fcinfo_data</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><call><name>SizeForFunctionCallInfo</name><argument_list>(<argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>flinfo</name> <operator>=</operator> <name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>func</name><operator>.</operator><name>finfo</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>fcinfo</name> <operator>=</operator> <name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>func</name><operator>.</operator><name>fcinfo_data</name></name></expr>;</expr_stmt>

	<comment type="block">/* Set up the primary fmgr lookup information */</comment>
	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>, <argument><expr><name>flinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fmgr_info_set_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>flinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize function call parameter structure too */</comment>
	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><name>flinfo</name></expr></argument>,
							 <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>inputcollid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Keep extra copies of this info to save an indirection at runtime */</comment>
	<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>func</name><operator>.</operator><name>fn_addr</name></name> <operator>=</operator> <name><name>flinfo</name><operator>-&gt;</operator><name>fn_addr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>func</name><operator>.</operator><name>nargs</name></name> <operator>=</operator> <name>nargs</name></expr>;</expr_stmt>

	<comment type="block">/* We only support non-set functions here */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>flinfo</name><operator>-&gt;</operator><name>fn_retset</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <ternary><condition><expr><name><name>state</name><operator>-&gt;</operator><name>parent</name></name></expr> ?</condition><then>
				 <expr><call><name>executor_errposition</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>state</name></name></expr></argument>,
									  <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Build code to evaluate arguments directly into the fcinfo struct */</comment>
	<expr_stmt><expr><name>argno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>args</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Don't evaluate const arguments every round; especially
			 * interesting for constants in comparisons.
			 */</comment>
			<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>con</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>argno</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>constvalue</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>argno</name></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>constisnull</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>argno</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>argno</name></expr>]</index></name><operator>.</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>argno</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Insert appropriate opcode depending on strictness and stats level */</comment>
	<if_stmt><if>if <condition>(<expr><name>pgstat_track_functions</name> <operator>&lt;=</operator> <name><name>flinfo</name><operator>-&gt;</operator><name>fn_stats</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>flinfo</name><operator>-&gt;</operator><name>fn_strict</name></name> <operator>&amp;&amp;</operator> <name>nargs</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_FUNCEXPR_STRICT</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_FUNCEXPR</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>flinfo</name><operator>-&gt;</operator><name>fn_strict</name></name> <operator>&amp;&amp;</operator> <name>nargs</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_FUNCEXPR_STRICT_FUSAGE</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_FUNCEXPR_FUSAGE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add expression steps deforming the ExprState's inner/outer/scan slots
 * as much as required by the expression.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecInitExprSlots</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LastAttnumInfo</name></type> <name>info</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Figure out which attributes we're going to need.
	 */</comment>
	<expr_stmt><expr><call><name>get_last_attnums_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecPushExprSlots</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add steps deforming the ExprState's inner/out/scan slots as much as
 * indicated by info. This is useful when building an ExprState covering more
 * than one expression.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecPushExprSlots</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>LastAttnumInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprEvalStep</name></type> <name>scratch</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>resvalue</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>resnull</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Emit steps as needed */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>last_inner</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_INNER_FETCHSOME</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fetch</name><operator>.</operator><name>last_var</name></name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>last_inner</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fetch</name><operator>.</operator><name>fixed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fetch</name><operator>.</operator><name>kind</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fetch</name><operator>.</operator><name>known_desc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>ExecComputeSlotInfo</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>last_outer</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_OUTER_FETCHSOME</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fetch</name><operator>.</operator><name>last_var</name></name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>last_outer</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fetch</name><operator>.</operator><name>fixed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fetch</name><operator>.</operator><name>kind</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fetch</name><operator>.</operator><name>known_desc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>ExecComputeSlotInfo</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>last_scan</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_SCAN_FETCHSOME</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fetch</name><operator>.</operator><name>last_var</name></name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>last_scan</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fetch</name><operator>.</operator><name>fixed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fetch</name><operator>.</operator><name>kind</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fetch</name><operator>.</operator><name>known_desc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>ExecComputeSlotInfo</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_last_attnums_walker: expression walker for ExecInitExprSlots
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>get_last_attnums_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>LastAttnumInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>variable</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name> <init>= <expr><name><name>variable</name><operator>-&gt;</operator><name>varattno</name></name></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>variable</name><operator>-&gt;</operator><name>varno</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>INNER_VAR</name></expr>:</case>
				<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>last_inner</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>last_inner</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>OUTER_VAR</name></expr>:</case>
				<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>last_outer</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>last_outer</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/* INDEX_VAR is handled by default case */</comment>

			<default>default:</default>
				<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>last_scan</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>last_scan</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Don't examine the arguments or filters of Aggrefs or WindowFuncs,
	 * because those do not represent expressions to be evaluated within the
	 * calling expression's econtext.  GroupingFunc arguments are never
	 * evaluated at all.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>WindowFunc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>GroupingFunc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>get_last_attnums_walker</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>info</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Compute additional information for EEOP_*_FETCHSOME ops.
 *
 * The goal is to determine whether a slot is 'fixed', that is, every
 * evaluation of the expression will have the same type of slot, with an
 * equivalent descriptor.
 *
 * Returns true if the deforming step is required, false otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExecComputeSlotInfo</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>parent</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>desc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>TupleTableSlotOps</name> <modifier>*</modifier></type><name>tts_ops</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isfixed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprEvalOp</name></type>	<name>opcode</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>opcode</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>opcode</name> <operator>==</operator> <name>EEOP_INNER_FETCHSOME</name> <operator>||</operator>
		   <name>opcode</name> <operator>==</operator> <name>EEOP_OUTER_FETCHSOME</name> <operator>||</operator>
		   <name>opcode</name> <operator>==</operator> <name>EEOP_SCAN_FETCHSOME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>fetch</name><operator>.</operator><name>known_desc</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>desc</name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>fetch</name><operator>.</operator><name>known_desc</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>tts_ops</name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>fetch</name><operator>.</operator><name>kind</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>isfixed</name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>fetch</name><operator>.</operator><name>kind</name></name> <operator>!=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name>parent</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>isfixed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>EEOP_INNER_FETCHSOME</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>is</name> <init>= <expr><call><name>innerPlanState</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>parent</name><operator>-&gt;</operator><name>inneropsset</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>parent</name><operator>-&gt;</operator><name>inneropsfixed</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>isfixed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>parent</name><operator>-&gt;</operator><name>inneropsset</name></name> <operator>&amp;&amp;</operator> <name><name>parent</name><operator>-&gt;</operator><name>innerops</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>isfixed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>tts_ops</name> <operator>=</operator> <name><name>parent</name><operator>-&gt;</operator><name>innerops</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>ExecGetResultType</name><argument_list>(<argument><expr><name>is</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>is</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>tts_ops</name> <operator>=</operator> <call><name>ExecGetResultSlotOps</name><argument_list>(<argument><expr><name>is</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isfixed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>ExecGetResultType</name><argument_list>(<argument><expr><name>is</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>EEOP_OUTER_FETCHSOME</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>os</name> <init>= <expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>parent</name><operator>-&gt;</operator><name>outeropsset</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>parent</name><operator>-&gt;</operator><name>outeropsfixed</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>isfixed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>parent</name><operator>-&gt;</operator><name>outeropsset</name></name> <operator>&amp;&amp;</operator> <name><name>parent</name><operator>-&gt;</operator><name>outerops</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>isfixed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>tts_ops</name> <operator>=</operator> <name><name>parent</name><operator>-&gt;</operator><name>outerops</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>ExecGetResultType</name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>os</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>tts_ops</name> <operator>=</operator> <call><name>ExecGetResultSlotOps</name><argument_list>(<argument><expr><name>os</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isfixed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>ExecGetResultType</name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>EEOP_SCAN_FETCHSOME</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>desc</name> <operator>=</operator> <name><name>parent</name><operator>-&gt;</operator><name>scandesc</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>parent</name><operator>-&gt;</operator><name>scanops</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>tts_ops</name> <operator>=</operator> <name><name>parent</name><operator>-&gt;</operator><name>scanops</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>parent</name><operator>-&gt;</operator><name>scanopsset</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>isfixed</name> <operator>=</operator> <name><name>parent</name><operator>-&gt;</operator><name>scanopsfixed</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>isfixed</name> <operator>&amp;&amp;</operator> <name>desc</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>tts_ops</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>fetch</name><operator>.</operator><name>fixed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>fetch</name><operator>.</operator><name>kind</name></name> <operator>=</operator> <name>tts_ops</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>fetch</name><operator>.</operator><name>known_desc</name></name> <operator>=</operator> <name>desc</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>fetch</name><operator>.</operator><name>fixed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>fetch</name><operator>.</operator><name>kind</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>fetch</name><operator>.</operator><name>known_desc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* if the slot is known to always virtual we never need to deform */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>fetch</name><operator>.</operator><name>fixed</name></name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>fetch</name><operator>.</operator><name>kind</name></name> <operator>==</operator> <operator>&amp;</operator><name>TTSOpsVirtual</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Prepare step for the evaluation of a whole-row variable.
 * The caller still has to push the step.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecInitWholeRowVar</name><parameter_list>(<parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>scratch</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>variable</name></decl></parameter>, <parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>parent</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* fill in all but the target */</comment>
	<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_WHOLEROW</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>wholerow</name><operator>.</operator><name>var</name></name> <operator>=</operator> <name>variable</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>wholerow</name><operator>.</operator><name>first</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>wholerow</name><operator>.</operator><name>slow</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>wholerow</name><operator>.</operator><name>tupdesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* filled at runtime */</comment>
	<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>wholerow</name><operator>.</operator><name>junkFilter</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the input tuple came from a subquery, it might contain "resjunk"
	 * columns (such as GROUP BY or ORDER BY columns), which we don't want to
	 * keep in the whole-row result.  We can get rid of such columns by
	 * passing the tuple through a JunkFilter --- but to make one, we have to
	 * lay our hands on the subquery's targetlist.  Fortunately, there are not
	 * very many cases where this can happen, and we can identify all of them
	 * by examining our parent PlanState.  We assume this is not an issue in
	 * standalone expressions that don't have parent plans.  (Whole-row Vars
	 * can occur in such expressions, but they will always be referencing
	 * table rows.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>parent</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>subplan</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>T_SubqueryScanState</name></expr>:</case>
				<expr_stmt><expr><name>subplan</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SubqueryScanState</name> <operator>*</operator><operator>)</operator> <name>parent</name><operator>)</operator><operator>-&gt;</operator><name>subplan</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CteScanState</name></expr>:</case>
				<expr_stmt><expr><name>subplan</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>CteScanState</name> <operator>*</operator><operator>)</operator> <name>parent</name><operator>)</operator><operator>-&gt;</operator><name>cteplanstate</name></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<break>break;</break>
		</block_content>}</block></switch>

		<if_stmt><if>if <condition>(<expr><name>subplan</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>junk_filter_needed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>

			<comment type="block">/* Detect whether subplan tlist actually has any junk columns */</comment>
			<macro><name>foreach</name><argument_list>(<argument>tlist</argument>, <argument>subplan-&gt;plan-&gt;targetlist</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>junk_filter_needed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>

			<comment type="block">/* If so, build the junkfilter now */</comment>
			<if_stmt><if>if <condition>(<expr><name>junk_filter_needed</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>wholerow</name><operator>.</operator><name>junkFilter</name></name> <operator>=</operator>
					<call><name>ExecInitJunkFilter</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>,
									   <argument><expr><call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
															  <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Prepare evaluation of a SubscriptingRef expression.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecInitSubscriptingRef</name><parameter_list>(<parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>scratch</name></decl></parameter>, <parameter><decl><type><name>SubscriptingRef</name> <modifier>*</modifier></type><name>sbsref</name></decl></parameter>,
						<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>resv</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>resnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isAssignment</name> <init>= <expr><operator>(</operator><name><name>sbsref</name><operator>-&gt;</operator><name>refassgnexpr</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SubscriptingRefState</name> <modifier>*</modifier></type><name>sbsrefstate</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SubscriptingRefState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>adjust_jumps</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Fill constant fields of SubscriptingRefState */</comment>
	<expr_stmt><expr><name><name>sbsrefstate</name><operator>-&gt;</operator><name>isassignment</name></name> <operator>=</operator> <name>isAssignment</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sbsrefstate</name><operator>-&gt;</operator><name>refelemtype</name></name> <operator>=</operator> <name><name>sbsref</name><operator>-&gt;</operator><name>refelemtype</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sbsrefstate</name><operator>-&gt;</operator><name>refattrlength</name></name> <operator>=</operator> <call><name>get_typlen</name><argument_list>(<argument><expr><name><name>sbsref</name><operator>-&gt;</operator><name>refcontainertype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><name><name>sbsref</name><operator>-&gt;</operator><name>refelemtype</name></name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>sbsrefstate</name><operator>-&gt;</operator><name>refelemlength</name></name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>sbsrefstate</name><operator>-&gt;</operator><name>refelembyval</name></name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>sbsrefstate</name><operator>-&gt;</operator><name>refelemalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Evaluate array input.  It's safe to do so into resv/resnull, because we
	 * won't use that as target for any of the other subexpressions, and it'll
	 * be overwritten by the final EEOP_SBSREF_FETCH/ASSIGN step, which is
	 * pushed last.
	 */</comment>
	<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>sbsref</name><operator>-&gt;</operator><name>refexpr</name></name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>resv</name></expr></argument>, <argument><expr><name>resnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If refexpr yields NULL, and it's a fetch, then result is NULL.  We can
	 * implement this with just JUMP_IF_NULL, since we evaluated the array
	 * into the desired target location.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isAssignment</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_JUMP_IF_NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>jump</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* adjust later */</comment>
		<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>adjust_jumps</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>adjust_jumps</name></expr></argument>,
								   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Verify subscript list lengths are within limit */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>sbsref</name><operator>-&gt;</operator><name>refupperindexpr</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>MAXDIM</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of array dimensions (%d) exceeds the maximum allowed (%d)"</literal></expr></argument>,
						<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>sbsref</name><operator>-&gt;</operator><name>refupperindexpr</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MAXDIM</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>sbsref</name><operator>-&gt;</operator><name>reflowerindexpr</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>MAXDIM</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of array dimensions (%d) exceeds the maximum allowed (%d)"</literal></expr></argument>,
						<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>sbsref</name><operator>-&gt;</operator><name>reflowerindexpr</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MAXDIM</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Evaluate upper subscripts */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>sbsref-&gt;refupperindexpr</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* When slicing, individual subscript bounds can be omitted */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>e</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>sbsrefstate</name><operator>-&gt;</operator><name>upperprovided</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>sbsrefstate</name><operator>-&gt;</operator><name>upperprovided</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/* Each subscript is evaluated into subscriptvalue/subscriptnull */</comment>
		<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name><name>sbsrefstate</name><operator>-&gt;</operator><name>subscriptvalue</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sbsrefstate</name><operator>-&gt;</operator><name>subscriptnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* ... and then SBSREF_SUBSCRIPT saves it into step's workspace */</comment>
		<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_SBSREF_SUBSCRIPT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>sbsref_subscript</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>sbsrefstate</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>sbsref_subscript</name><operator>.</operator><name>off</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>sbsref_subscript</name><operator>.</operator><name>isupper</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>sbsref_subscript</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* adjust later */</comment>
		<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>adjust_jumps</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>adjust_jumps</name></expr></argument>,
								   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name><name>sbsrefstate</name><operator>-&gt;</operator><name>numupper</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

	<comment type="block">/* Evaluate lower subscripts similarly */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>sbsref-&gt;reflowerindexpr</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* When slicing, individual subscript bounds can be omitted */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>e</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>sbsrefstate</name><operator>-&gt;</operator><name>lowerprovided</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>sbsrefstate</name><operator>-&gt;</operator><name>lowerprovided</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/* Each subscript is evaluated into subscriptvalue/subscriptnull */</comment>
		<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name><name>sbsrefstate</name><operator>-&gt;</operator><name>subscriptvalue</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sbsrefstate</name><operator>-&gt;</operator><name>subscriptnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* ... and then SBSREF_SUBSCRIPT saves it into step's workspace */</comment>
		<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_SBSREF_SUBSCRIPT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>sbsref_subscript</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>sbsrefstate</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>sbsref_subscript</name><operator>.</operator><name>off</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>sbsref_subscript</name><operator>.</operator><name>isupper</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>sbsref_subscript</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* adjust later */</comment>
		<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>adjust_jumps</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>adjust_jumps</name></expr></argument>,
								   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name><name>sbsrefstate</name><operator>-&gt;</operator><name>numlower</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

	<comment type="block">/* Should be impossible if parser is sane, but check anyway: */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>sbsrefstate</name><operator>-&gt;</operator><name>numlower</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name><name>sbsrefstate</name><operator>-&gt;</operator><name>numupper</name></name> <operator>!=</operator> <name><name>sbsrefstate</name><operator>-&gt;</operator><name>numlower</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"upper and lower index lists are not same length"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>isAssignment</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>save_innermost_caseval</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>save_innermost_casenull</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We might have a nested-assignment situation, in which the
		 * refassgnexpr is itself a FieldStore or SubscriptingRef that needs
		 * to obtain and modify the previous value of the array element or
		 * slice being replaced.  If so, we have to extract that value from
		 * the array and pass it down via the CaseTestExpr mechanism.  It's
		 * safe to reuse the CASE mechanism because there cannot be a CASE
		 * between here and where the value would be needed, and an array
		 * assignment can't be within a CASE either.  (So saving and restoring
		 * innermost_caseval is just paranoia, but let's do it anyway.)
		 *
		 * Since fetching the old element might be a nontrivial expense, do it
		 * only if the argument actually needs it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>isAssignmentIndirectionExpr</name><argument_list>(<argument><expr><name><name>sbsref</name><operator>-&gt;</operator><name>refassgnexpr</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_SBSREF_OLD</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>sbsref</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>sbsrefstate</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* SBSREF_OLD puts extracted value into prevvalue/prevnull */</comment>
		<expr_stmt><expr><name>save_innermost_caseval</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>innermost_caseval</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>save_innermost_casenull</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>innermost_casenull</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>innermost_caseval</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>sbsrefstate</name><operator>-&gt;</operator><name>prevvalue</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>innermost_casenull</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>sbsrefstate</name><operator>-&gt;</operator><name>prevnull</name></name></expr>;</expr_stmt>

		<comment type="block">/* evaluate replacement value into replacevalue/replacenull */</comment>
		<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>sbsref</name><operator>-&gt;</operator><name>refassgnexpr</name></name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name><name>sbsrefstate</name><operator>-&gt;</operator><name>replacevalue</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sbsrefstate</name><operator>-&gt;</operator><name>replacenull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>innermost_caseval</name></name> <operator>=</operator> <name>save_innermost_caseval</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>innermost_casenull</name></name> <operator>=</operator> <name>save_innermost_casenull</name></expr>;</expr_stmt>

		<comment type="block">/* and perform the assignment */</comment>
		<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_SBSREF_ASSIGN</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>sbsref</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>sbsrefstate</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* array fetch is much simpler */</comment>
		<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_SBSREF_FETCH</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>sbsref</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>sbsrefstate</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	</block_content>}</block></else></if_stmt>

	<comment type="block">/* adjust jump targets */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>adjust_jumps</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>as</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>steps</name><index>[<expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>as</name><operator>-&gt;</operator><name>opcode</name></name> <operator>==</operator> <name>EEOP_SBSREF_SUBSCRIPT</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>sbsref_subscript</name><operator>.</operator><name>jumpdone</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>sbsref_subscript</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>opcode</name></name> <operator>==</operator> <name>EEOP_JUMP_IF_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>jump</name><operator>.</operator><name>jumpdone</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>jump</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Helper for preparing SubscriptingRef expressions for evaluation: is expr
 * a nested FieldStore or SubscriptingRef that needs the old element value
 * passed down?
 *
 * (We could use this in FieldStore too, but in that case passing the old
 * value is so cheap there's no need.)
 *
 * Note: it might seem that this needs to recurse, but in most cases it does
 * not; the CaseTestExpr, if any, will be directly the arg or refexpr of the
 * top-level node.  Nested-assignment situations give rise to expression
 * trees in which each level of assignment has its own CaseTestExpr, and the
 * recursive structure appears within the newvals or refassgnexpr field.
 * There is an exception, though: if the array is an array-of-domain, we will
 * have a CoerceToDomain as the refassgnexpr, and we need to be able to look
 * through that.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>isAssignmentIndirectionExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>expr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* just paranoia */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>FieldStore</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FieldStore</name> <modifier>*</modifier></type><name>fstore</name> <init>= <expr><operator>(</operator><name>FieldStore</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>fstore</name><operator>-&gt;</operator><name>arg</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>fstore</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>CaseTestExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>SubscriptingRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SubscriptingRef</name> <modifier>*</modifier></type><name>sbsRef</name> <init>= <expr><operator>(</operator><name>SubscriptingRef</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>sbsRef</name><operator>-&gt;</operator><name>refexpr</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>sbsRef</name><operator>-&gt;</operator><name>refexpr</name></name></expr></argument>, <argument><expr><name>CaseTestExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>CoerceToDomain</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CoerceToDomain</name> <modifier>*</modifier></type><name>cd</name> <init>= <expr><operator>(</operator><name>CoerceToDomain</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

		<return>return <expr><call><name>isAssignmentIndirectionExpr</name><argument_list>(<argument><expr><name><name>cd</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Prepare evaluation of a CoerceToDomain expression.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecInitCoerceToDomain</name><parameter_list>(<parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>scratch</name></decl></parameter>, <parameter><decl><type><name>CoerceToDomain</name> <modifier>*</modifier></type><name>ctest</name></decl></parameter>,
					   <parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>resv</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>resnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DomainConstraintRef</name> <modifier>*</modifier></type><name>constraint_ref</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>domainval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>domainnull</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>domaincheck</name><operator>.</operator><name>resulttype</name></name> <operator>=</operator> <name><name>ctest</name><operator>-&gt;</operator><name>resulttype</name></name></expr>;</expr_stmt>
	<comment type="block">/* we'll allocate workspace only if needed */</comment>
	<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>domaincheck</name><operator>.</operator><name>checkvalue</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>domaincheck</name><operator>.</operator><name>checknull</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Evaluate argument - it's fine to directly store it into resv/resnull,
	 * if there's constraint failures there'll be errors, otherwise it's what
	 * needs to be returned.
	 */</comment>
	<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>ctest</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>resv</name></expr></argument>, <argument><expr><name>resnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note: if the argument is of varlena type, it could be a R/W expanded
	 * object.  We want to return the R/W pointer as the final result, but we
	 * have to pass a R/O pointer as the value to be tested by any functions
	 * in check expressions.  We don't bother to emit a MAKE_READONLY step
	 * unless there's actually at least one check expression, though.  Until
	 * we've tested that, domainval/domainnull are NULL.
	 */</comment>

	<comment type="block">/*
	 * Collect the constraints associated with the domain.
	 *
	 * Note: before PG v10 we'd recheck the set of constraints during each
	 * evaluation of the expression.  Now we bake them into the ExprState
	 * during executor initialization.  That means we don't need typcache.c to
	 * provide compiled exprs.
	 */</comment>
	<expr_stmt><expr><name>constraint_ref</name> <operator>=</operator> <operator>(</operator><name>DomainConstraintRef</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DomainConstraintRef</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InitDomainConstraintRef</name><argument_list>(<argument><expr><name><name>ctest</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>,
							<argument><expr><name>constraint_ref</name></expr></argument>,
							<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
							<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compile code to check each domain constraint.  NOTNULL constraints can
	 * just be applied on the resv/resnull value, but for CHECK constraints we
	 * need more pushups.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>constraint_ref-&gt;constraints</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DomainConstraintState</name> <modifier>*</modifier></type><name>con</name> <init>= <expr><operator>(</operator><name>DomainConstraintState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>save_innermost_domainval</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>save_innermost_domainnull</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>domaincheck</name><operator>.</operator><name>constraintname</name></name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>constrainttype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>DOM_CONSTRAINT_NOTNULL</name></expr>:</case>
				<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_DOMAIN_NOTNULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DOM_CONSTRAINT_CHECK</name></expr>:</case>
				<comment type="block">/* Allocate workspace for CHECK output if we didn't yet */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>domaincheck</name><operator>.</operator><name>checkvalue</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>domaincheck</name><operator>.</operator><name>checkvalue</name></name> <operator>=</operator>
						<operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>domaincheck</name><operator>.</operator><name>checknull</name></name> <operator>=</operator>
						<operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * If first time through, determine where CoerceToDomainValue
				 * nodes should read from.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>domainval</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Since value might be read multiple times, force to R/O
					 * - but only if it could be an expanded datum.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>get_typlen</name><argument_list>(<argument><expr><name><name>ctest</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>ExprEvalStep</name></type> <name>scratch2</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

						<comment type="block">/* Yes, so make output workspace for MAKE_READONLY */</comment>
						<expr_stmt><expr><name>domainval</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>domainnull</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/* Emit MAKE_READONLY */</comment>
						<expr_stmt><expr><name><name>scratch2</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_MAKE_READONLY</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>scratch2</name><operator>.</operator><name>resvalue</name></name> <operator>=</operator> <name>domainval</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>scratch2</name><operator>.</operator><name>resnull</name></name> <operator>=</operator> <name>domainnull</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>scratch2</name><operator>.</operator><name>d</name><operator>.</operator><name>make_readonly</name><operator>.</operator><name>value</name></name> <operator>=</operator> <name>resv</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>scratch2</name><operator>.</operator><name>d</name><operator>.</operator><name>make_readonly</name><operator>.</operator><name>isnull</name></name> <operator>=</operator> <name>resnull</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* No, so it's fine to read from resv/resnull */</comment>
						<expr_stmt><expr><name>domainval</name> <operator>=</operator> <name>resv</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>domainnull</name> <operator>=</operator> <name>resnull</name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Set up value to be returned by CoerceToDomainValue nodes.
				 * We must save and restore innermost_domainval/null fields,
				 * in case this node is itself within a check expression for
				 * another domain.
				 */</comment>
				<expr_stmt><expr><name>save_innermost_domainval</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>innermost_domainval</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>save_innermost_domainnull</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>innermost_domainnull</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>innermost_domainval</name></name> <operator>=</operator> <name>domainval</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>innermost_domainnull</name></name> <operator>=</operator> <name>domainnull</name></expr>;</expr_stmt>

				<comment type="block">/* evaluate check expression value */</comment>
				<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>check_expr</name></name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
								<argument><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>domaincheck</name><operator>.</operator><name>checkvalue</name></name></expr></argument>,
								<argument><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>domaincheck</name><operator>.</operator><name>checknull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>innermost_domainval</name></name> <operator>=</operator> <name>save_innermost_domainval</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>innermost_domainnull</name></name> <operator>=</operator> <name>save_innermost_domainnull</name></expr>;</expr_stmt>

				<comment type="block">/* now test result */</comment>
				<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_DOMAIN_CHECK</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized constraint type: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>con</name><operator>-&gt;</operator><name>constrainttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Build transition/combine function invocations for all aggregate transition
 * / combination function invocations in a grouping sets phase. This has to
 * invoke all sort based transitions in a phase (if doSort is true), all hash
 * based transitions (if doHash is true), or both (both true).
 *
 * The resulting expression will, for each set of transition values, first
 * check for filters, evaluate aggregate input, check that that input is not
 * NULL for a strict transition function, and then finally invoke the
 * transition for each of the concurrently computed grouping sets.
 *
 * If nullcheck is true, the generated code will check for a NULL pointer to
 * the array of AggStatePerGroup, and skip evaluation if so.
 */</comment>
<function><type><name>ExprState</name> <modifier>*</modifier></type>
<name>ExecBuildAggTrans</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>, <parameter><decl><type><name>AggStatePerPhase</name></type> <name>phase</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>doSort</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>doHash</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nullcheck</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>state</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ExprState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>parent</name> <init>= <expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprEvalStep</name></type> <name>scratch</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isCombine</name> <init>= <expr><call><name>DO_AGGSPLIT_COMBINE</name><argument_list>(<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggsplit</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LastAttnumInfo</name></type> <name>deform</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>aggstate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>parent</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>resvalue</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>resvalue</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>resnull</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>resnull</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * First figure out which slots, and how many columns from each, we're
	 * going to need.
	 */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>transno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>transno</name> <operator>&lt;</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>numtrans</name></name></expr>;</condition> <incr><expr><name>transno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name> <init>= <expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>pertrans</name><index>[<expr><name>transno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>get_last_attnums_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>pertrans</name><operator>-&gt;</operator><name>aggref</name><operator>-&gt;</operator><name>aggdirectargs</name></name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>deform</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_last_attnums_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>pertrans</name><operator>-&gt;</operator><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>deform</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_last_attnums_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>pertrans</name><operator>-&gt;</operator><name>aggref</name><operator>-&gt;</operator><name>aggorder</name></name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>deform</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_last_attnums_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>pertrans</name><operator>-&gt;</operator><name>aggref</name><operator>-&gt;</operator><name>aggdistinct</name></name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>deform</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_last_attnums_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>pertrans</name><operator>-&gt;</operator><name>aggref</name><operator>-&gt;</operator><name>aggfilter</name></name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>deform</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>ExecPushExprSlots</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>deform</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Emit instructions for each transition value / grouping set combination.
	 */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>transno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>transno</name> <operator>&lt;</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>numtrans</name></name></expr>;</condition> <incr><expr><name>transno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name> <init>= <expr><operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>pertrans</name><index>[<expr><name>transno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>trans_fcinfo</name> <init>= <expr><name><name>pertrans</name><operator>-&gt;</operator><name>transfn_fcinfo</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>adjust_bailout</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>NullableDatum</name> <modifier>*</modifier></type><name>strictargs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>strictnulls</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>argno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>bail</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * If filter present, emit. Do so before evaluating the input, to
		 * avoid potentially unneeded computations, or even worse, unintended
		 * side-effects.  When combining, all the necessary filtering has
		 * already been done.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>aggref</name><operator>-&gt;</operator><name>aggfilter</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isCombine</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* evaluate filter expression */</comment>
			<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>aggref</name><operator>-&gt;</operator><name>aggfilter</name></name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>resvalue</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>resnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* and jump out if false */</comment>
			<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_JUMP_IF_NOT_TRUE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>jump</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* adjust later */</comment>
			<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>adjust_bailout</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>adjust_bailout</name></expr></argument>,
										 <argument><expr><name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Evaluate arguments to aggregate/combine function.
		 */</comment>
		<expr_stmt><expr><name>argno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isCombine</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Combining two aggregate transition values. Instead of directly
			 * coming from a tuple the input is a, potentially deserialized,
			 * transition value.
			 */</comment>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>source_tle</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>numSortCols</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>strictargs</name> <operator>=</operator> <name><name>trans_fcinfo</name><operator>-&gt;</operator><name>args</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>source_tle</name> <operator>=</operator> <operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * deserialfn_oid will be set if we must deserialize the input
			 * state before calling the combine function.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>deserialfn_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Start from 1, since the 0th arg will be the transition
				 * value
				 */</comment>
				<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>source_tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name><name>trans_fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>argno</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name><name>trans_fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>argno</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>ds_fcinfo</name> <init>= <expr><name><name>pertrans</name><operator>-&gt;</operator><name>deserialfn_fcinfo</name></name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* evaluate argument */</comment>
				<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>source_tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name><name>ds_fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name><name>ds_fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Dummy second argument for type-safety reasons */</comment>
				<expr_stmt><expr><name><name>ds_fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>ds_fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Don't call a strict deserialization function with NULL
				 * input
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>deserialfn</name><operator>.</operator><name>fn_strict</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_AGG_STRICT_DESERIALIZE</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_AGG_DESERIALIZE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>agg_deserialize</name><operator>.</operator><name>fcinfo_data</name></name> <operator>=</operator> <name>ds_fcinfo</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>agg_deserialize</name><operator>.</operator><name>jumpnull</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* adjust later */</comment>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>resvalue</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>trans_fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>argno</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>value</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>resnull</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>trans_fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>argno</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>isnull</name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* don't add an adjustment unless the function is strict */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>deserialfn</name><operator>.</operator><name>fn_strict</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>adjust_bailout</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>adjust_bailout</name></expr></argument>,
												 <argument><expr><name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* restore normal settings of scratch fields */</comment>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>resvalue</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>resvalue</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>resnull</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>resnull</name></name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><name>argno</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>numSortCols</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Normal transition function without ORDER BY / DISTINCT.
			 */</comment>
			<expr_stmt><expr><name>strictargs</name> <operator>=</operator> <name><name>trans_fcinfo</name><operator>-&gt;</operator><name>args</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

			<macro><name>foreach</name><argument_list>(<argument>arg</argument>, <argument>pertrans-&gt;aggref-&gt;args</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>source_tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * Start from 1, since the 0th arg will be the transition
				 * value
				 */</comment>
				<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>source_tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name><name>trans_fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>argno</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name><name>trans_fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>argno</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>argno</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>numInputs</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * DISTINCT and/or ORDER BY case, with a single column sorted on.
			 */</comment>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>source_tle</name> <init>=
			<expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>source_tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>resvalue</name></name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>resnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>strictnulls</name> <operator>=</operator> <operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>resnull</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>argno</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * DISTINCT and/or ORDER BY case, with multiple columns sorted on.
			 */</comment>
			<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>values</name> <init>= <expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortslot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nulls</name> <init>= <expr><name><name>pertrans</name><operator>-&gt;</operator><name>sortslot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>strictnulls</name> <operator>=</operator> <name>nulls</name></expr>;</expr_stmt>

			<macro><name>foreach</name><argument_list>(<argument>arg</argument>, <argument>pertrans-&gt;aggref-&gt;args</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>source_tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>source_tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name><name>values</name><index>[<expr><name>argno</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nulls</name><index>[<expr><name>argno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>argno</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pertrans</name><operator>-&gt;</operator><name>numInputs</name></name> <operator>==</operator> <name>argno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * For a strict transfn, nothing happens when there's a NULL input; we
		 * just keep the prior transValue. This is true for both plain and
		 * sorted/distinct aggregates.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>trans_fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_strict</name></name> <operator>&amp;&amp;</operator> <name><name>pertrans</name><operator>-&gt;</operator><name>numTransInputs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>strictnulls</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_AGG_STRICT_INPUT_CHECK_NULLS</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_AGG_STRICT_INPUT_CHECK_ARGS</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>agg_strict_input_check</name><operator>.</operator><name>nulls</name></name> <operator>=</operator> <name>strictnulls</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>agg_strict_input_check</name><operator>.</operator><name>args</name></name> <operator>=</operator> <name>strictargs</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>agg_strict_input_check</name><operator>.</operator><name>jumpnull</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* adjust later */</comment>
			<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>agg_strict_input_check</name><operator>.</operator><name>nargs</name></name> <operator>=</operator> <name><name>pertrans</name><operator>-&gt;</operator><name>numTransInputs</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>adjust_bailout</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>adjust_bailout</name></expr></argument>,
										 <argument><expr><name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Call transition function (once for each concurrently evaluated
		 * grouping set). Do so for both sort and hash based computations, as
		 * applicable.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>doSort</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>processGroupingSets</name> <init>= <expr><call><name>Max</name><argument_list>(<argument><expr><name><name>phase</name><operator>-&gt;</operator><name>numsets</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>setoff</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

			<for>for <control>(<init><decl><type><name>int</name></type> <name>setno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>setno</name> <operator>&lt;</operator> <name>processGroupingSets</name></expr>;</condition> <incr><expr><name>setno</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ExecBuildAggTransCall</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>aggstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>, <argument><expr><name>trans_fcinfo</name></expr></argument>,
									  <argument><expr><name>pertrans</name></expr></argument>, <argument><expr><name>transno</name></expr></argument>, <argument><expr><name>setno</name></expr></argument>, <argument><expr><name>setoff</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									  <argument><expr><name>nullcheck</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>setoff</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>doHash</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>numHashes</name> <init>= <expr><name><name>aggstate</name><operator>-&gt;</operator><name>num_hashes</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>setoff</name></decl>;</decl_stmt>

			<comment type="block">/* in MIXED mode, there'll be preceding transition values */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>!=</operator> <name>AGG_HASHED</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>setoff</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>maxsets</name></name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>setoff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<for>for <control>(<init><decl><type><name>int</name></type> <name>setno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>setno</name> <operator>&lt;</operator> <name>numHashes</name></expr>;</condition> <incr><expr><name>setno</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ExecBuildAggTransCall</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>aggstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>, <argument><expr><name>trans_fcinfo</name></expr></argument>,
									  <argument><expr><name>pertrans</name></expr></argument>, <argument><expr><name>transno</name></expr></argument>, <argument><expr><name>setno</name></expr></argument>, <argument><expr><name>setoff</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
									  <argument><expr><name>nullcheck</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>setoff</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* adjust early bail out jump target(s) */</comment>
		<macro><name>foreach</name><argument_list>(<argument>bail</argument>, <argument>adjust_bailout</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>as</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>steps</name><index>[<expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>bail</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>as</name><operator>-&gt;</operator><name>opcode</name></name> <operator>==</operator> <name>EEOP_JUMP_IF_NOT_TRUE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>jump</name><operator>.</operator><name>jumpdone</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>jump</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>as</name><operator>-&gt;</operator><name>opcode</name></name> <operator>==</operator> <name>EEOP_AGG_STRICT_INPUT_CHECK_ARGS</name> <operator>||</operator>
					 <name><name>as</name><operator>-&gt;</operator><name>opcode</name></name> <operator>==</operator> <name>EEOP_AGG_STRICT_INPUT_CHECK_NULLS</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_strict_input_check</name><operator>.</operator><name>jumpnull</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_strict_input_check</name><operator>.</operator><name>jumpnull</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>as</name><operator>-&gt;</operator><name>opcode</name></name> <operator>==</operator> <name>EEOP_AGG_STRICT_DESERIALIZE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_deserialize</name><operator>.</operator><name>jumpnull</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_deserialize</name><operator>.</operator><name>jumpnull</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>resvalue</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>resnull</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_DONE</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecReadyExpr</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Build transition/combine function invocation for a single transition
 * value. This is separated from ExecBuildAggTrans() because there are
 * multiple callsites (hash and sort in some grouping set cases).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecBuildAggTransCall</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>,
					  <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>scratch</name></decl></parameter>,
					  <parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>AggStatePerTrans</name></type> <name>pertrans</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>transno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>setno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>setoff</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ishash</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>nullcheck</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>aggcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>adjust_jumpnull</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>ishash</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>aggcontext</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>hashcontext</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>aggcontext</name> <operator>=</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>aggcontexts</name><index>[<expr><name>setno</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* add check for NULL pointer? */</comment>
	<if_stmt><if>if <condition>(<expr><name>nullcheck</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_AGG_PLAIN_PERGROUP_NULLCHECK</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_plain_pergroup_nullcheck</name><operator>.</operator><name>setoff</name></name> <operator>=</operator> <name>setoff</name></expr>;</expr_stmt>
		<comment type="block">/* adjust later */</comment>
		<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_plain_pergroup_nullcheck</name><operator>.</operator><name>jumpnull</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>adjust_jumpnull</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Determine appropriate transition implementation.
	 *
	 * For non-ordered aggregates:
	 *
	 * If the initial value for the transition state doesn't exist in the
	 * pg_aggregate table then we will let the first non-NULL value returned
	 * from the outer procNode become the initial value. (This is useful for
	 * aggregates like max() and min().) The noTransValue flag signals that we
	 * need to do so. If true, generate a
	 * EEOP_AGG_INIT_STRICT_PLAIN_TRANS{,_BYVAL} step. This step also needs to
	 * do the work described next:
	 *
	 * If the function is strict, but does have an initial value, choose
	 * EEOP_AGG_STRICT_PLAIN_TRANS{,_BYVAL}, which skips the transition
	 * function if the transition value has become NULL (because a previous
	 * transition function returned NULL). This step also needs to do the work
	 * described next:
	 *
	 * Otherwise we call EEOP_AGG_PLAIN_TRANS{,_BYVAL}, which does not have to
	 * perform either of the above checks.
	 *
	 * Having steps with overlapping responsibilities is not nice, but
	 * aggregations are very performance sensitive, making this worthwhile.
	 *
	 * For ordered aggregates:
	 *
	 * Only need to choose between the faster path for a single orderred
	 * column, and the one between multiple columns. Checking strictness etc
	 * is done when finalizing the aggregate. See
	 * process_ordered_aggregate_{single, multi} and
	 * advance_transition_function.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>numSortCols</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>transtypeByVal</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_strict</name></name> <operator>&amp;&amp;</operator>
				<name><name>pertrans</name><operator>-&gt;</operator><name>initValueIsNull</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_AGG_PLAIN_TRANS_INIT_STRICT_BYVAL</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_strict</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_AGG_PLAIN_TRANS_STRICT_BYVAL</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_AGG_PLAIN_TRANS_BYVAL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_strict</name></name> <operator>&amp;&amp;</operator>
				<name><name>pertrans</name><operator>-&gt;</operator><name>initValueIsNull</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_AGG_PLAIN_TRANS_INIT_STRICT_BYREF</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_strict</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_AGG_PLAIN_TRANS_STRICT_BYREF</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_AGG_PLAIN_TRANS_BYREF</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>pertrans</name><operator>-&gt;</operator><name>numInputs</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_AGG_ORDERED_TRANS_DATUM</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_AGG_ORDERED_TRANS_TUPLE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_trans</name><operator>.</operator><name>pertrans</name></name> <operator>=</operator> <name>pertrans</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_trans</name><operator>.</operator><name>setno</name></name> <operator>=</operator> <name>setno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_trans</name><operator>.</operator><name>setoff</name></name> <operator>=</operator> <name>setoff</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_trans</name><operator>.</operator><name>transno</name></name> <operator>=</operator> <name>transno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_trans</name><operator>.</operator><name>aggcontext</name></name> <operator>=</operator> <name>aggcontext</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* fix up jumpnull */</comment>
	<if_stmt><if>if <condition>(<expr><name>adjust_jumpnull</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>as</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>steps</name><index>[<expr><name>adjust_jumpnull</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>opcode</name></name> <operator>==</operator> <name>EEOP_AGG_PLAIN_PERGROUP_NULLCHECK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_plain_pergroup_nullcheck</name><operator>.</operator><name>jumpnull</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>agg_plain_pergroup_nullcheck</name><operator>.</operator><name>jumpnull</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Build equality expression that can be evaluated using ExecQual(), returning
 * true if the expression context's inner/outer tuple are NOT DISTINCT. I.e
 * two nulls match, a null and a not-null don't match.
 *
 * desc: tuple descriptor of the to-be-compared tuples
 * numCols: the number of attributes to be examined
 * keyColIdx: array of attribute column numbers
 * eqFunctions: array of function oids of the equality functions to use
 * parent: parent executor node
 */</comment>
<function><type><name>ExprState</name> <modifier>*</modifier></type>
<name>ExecBuildGroupingEqual</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>ldesc</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>rdesc</name></decl></parameter>,
					   <parameter><decl><type><specifier>const</specifier> <name>TupleTableSlotOps</name> <modifier>*</modifier></type><name>lops</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TupleTableSlotOps</name> <modifier>*</modifier></type><name>rops</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>numCols</name></decl></parameter>,
					   <parameter><decl><type><specifier>const</specifier> <name>AttrNumber</name> <modifier>*</modifier></type><name>keyColIdx</name></decl></parameter>,
					   <parameter><decl><type><specifier>const</specifier> <name>Oid</name> <modifier>*</modifier></type><name>eqfunctions</name></decl></parameter>,
					   <parameter><decl><type><specifier>const</specifier> <name>Oid</name> <modifier>*</modifier></type><name>collations</name></decl></parameter>,
					   <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>state</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ExprState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprEvalStep</name></type> <name>scratch</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxatt</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>adjust_jumps</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * When no columns are actually compared, the result's always true. See
	 * special case in ExecQual().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>numCols</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>EEO_FLAG_IS_QUAL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>parent</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>resvalue</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>resvalue</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>resnull</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>resnull</name></name></expr>;</expr_stmt>

	<comment type="block">/* compute max needed attribute */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>natt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>natt</name> <operator>&lt;</operator> <name>numCols</name></expr>;</condition> <incr><expr><name>natt</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>attno</name> <init>= <expr><name><name>keyColIdx</name><index>[<expr><name>natt</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>attno</name> <operator>&gt;</operator> <name>maxatt</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>maxatt</name> <operator>=</operator> <name>attno</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>maxatt</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* push deform steps */</comment>
	<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_INNER_FETCHSOME</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fetch</name><operator>.</operator><name>last_var</name></name> <operator>=</operator> <name>maxatt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fetch</name><operator>.</operator><name>fixed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fetch</name><operator>.</operator><name>known_desc</name></name> <operator>=</operator> <name>ldesc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fetch</name><operator>.</operator><name>kind</name></name> <operator>=</operator> <name>lops</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>ExecComputeSlotInfo</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_OUTER_FETCHSOME</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fetch</name><operator>.</operator><name>last_var</name></name> <operator>=</operator> <name>maxatt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fetch</name><operator>.</operator><name>fixed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fetch</name><operator>.</operator><name>known_desc</name></name> <operator>=</operator> <name>rdesc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fetch</name><operator>.</operator><name>kind</name></name> <operator>=</operator> <name>rops</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>ExecComputeSlotInfo</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Start comparing at the last field (least significant sort key). That's
	 * the most likely to be different if we are dealing with sorted input.
	 */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>natt</name> <init>= <expr><name>numCols</name></expr></init></decl>;</init> <condition><expr><operator>--</operator><name>natt</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>attno</name> <init>= <expr><name><name>keyColIdx</name><index>[<expr><name>natt</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>latt</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>ldesc</name></expr></argument>, <argument><expr><name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>ratt</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>rdesc</name></expr></argument>, <argument><expr><name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>foid</name> <init>= <expr><name><name>eqfunctions</name><index>[<expr><name>natt</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>collid</name> <init>= <expr><name><name>collations</name><index>[<expr><name>natt</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>finfo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>

		<comment type="block">/* Check permission to call function */</comment>
		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_proc_aclcheck</name><argument_list>(<argument><expr><name>foid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_FUNCTION</name></expr></argument>, <argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name>foid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>InvokeFunctionExecuteHook</name><argument_list>(<argument><expr><name>foid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Set up the primary fmgr lookup information */</comment>
		<expr_stmt><expr><name>finfo</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>fcinfo</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><call><name>SizeForFunctionCallInfo</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>foid</name></expr></argument>, <argument><expr><name>finfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fmgr_info_set_expr</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>finfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><name>finfo</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
								 <argument><expr><name>collid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* left arg */</comment>
		<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_INNER_VAR</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>var</name><operator>.</operator><name>attnum</name></name> <operator>=</operator> <name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>var</name><operator>.</operator><name>vartype</name></name> <operator>=</operator> <name><name>latt</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>resvalue</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>resnull</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>isnull</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* right arg */</comment>
		<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_OUTER_VAR</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>var</name><operator>.</operator><name>attnum</name></name> <operator>=</operator> <name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>var</name><operator>.</operator><name>vartype</name></name> <operator>=</operator> <name><name>ratt</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>resvalue</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>value</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>resnull</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>isnull</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* evaluate distinctness */</comment>
		<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_NOT_DISTINCT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>func</name><operator>.</operator><name>finfo</name></name> <operator>=</operator> <name>finfo</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>func</name><operator>.</operator><name>fcinfo_data</name></name> <operator>=</operator> <name>fcinfo</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>func</name><operator>.</operator><name>fn_addr</name></name> <operator>=</operator> <name><name>finfo</name><operator>-&gt;</operator><name>fn_addr</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>func</name><operator>.</operator><name>nargs</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>resvalue</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>resvalue</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>resnull</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>resnull</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* then emit EEOP_QUAL to detect if result is false (or null) */</comment>
		<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_QUAL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>qualexpr</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>resvalue</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>resvalue</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>resnull</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>resnull</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>adjust_jumps</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>adjust_jumps</name></expr></argument>,
								   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* adjust jump targets */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>adjust_jumps</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>as</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>steps</name><index>[<expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>opcode</name></name> <operator>==</operator> <name>EEOP_QUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>qualexpr</name><operator>.</operator><name>jumpdone</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>qualexpr</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>resvalue</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>resnull</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_DONE</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecReadyExpr</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecInitCypherTypeCast</name><parameter_list>(<parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>scratch</name></decl></parameter>, <parameter><decl><type><name>CypherTypeCast</name> <modifier>*</modifier></type><name>tc</name></decl></parameter>,
					   <parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>finfo_in</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo_data_in</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>infunc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typinparam</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tc</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>JSONBOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>tc</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
					<argument><expr><name><name>scratch</name><operator>-&gt;</operator><name>resvalue</name></name></expr></argument>, <argument><expr><name><name>scratch</name><operator>-&gt;</operator><name>resnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>finfo_in</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fcinfo_data_in</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><call><name>SizeForFunctionCallInfo</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>getTypeInputInfo</name><argument_list>(<argument><expr><name><name>tc</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>infunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typinparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>infunc</name></expr></argument>, <argument><expr><name>finfo_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fmgr_info_set_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>tc</name></expr></argument>, <argument><expr><name>finfo_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo_data_in</name></expr></argument>, <argument><expr><name>finfo_in</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The datum for the first argument will be filled every time when this
	 * expression is executed by calling ExecEvalCypherTypeCast().
	 */</comment>
	<expr_stmt><expr><name><name>fcinfo_data_in</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typinparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo_data_in</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo_data_in</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo_data_in</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_CYPHERTYPECAST</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>cyphertypecast</name><operator>.</operator><name>fcinfo_data_in</name></name> <operator>=</operator> <name>fcinfo_data_in</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecInitCypherMap</name><parameter_list>(<parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>scratch</name></decl></parameter>, <parameter><decl><type><name>CypherMapExpr</name> <modifier>*</modifier></type><name>mapexpr</name></decl></parameter>,
				  <parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>npairs</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>mapexpr</name><operator>-&gt;</operator><name>keyvals</name></name></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>key_cstrings</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>val_values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>val_nulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>le</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>key_cstrings</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>npairs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>val_values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>npairs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>val_nulls</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>npairs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>le</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>mapexpr</name><operator>-&gt;</operator><name>keyvals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>le</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>key</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>lfirst_node</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name>le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>le</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name><name>mapexpr</name><operator>-&gt;</operator><name>keyvals</name></name></expr></argument>, <argument><expr><name>le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>le</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>le</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name><name>mapexpr</name><operator>-&gt;</operator><name>keyvals</name></name></expr></argument>, <argument><expr><name>le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Since all keys of jsonb objects are C strings, convert
		 * the given key constant which is text to a corresponding
		 * C string to avoid the same conversion for every
		 * evaluation of the CypherMapExpr.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>consttype</name></name> <operator>==</operator> <name>TEXTOID</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>key</name><operator>-&gt;</operator><name>constisnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>key_cstrings</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>val</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>JSONBOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>val_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>val_nulls</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_CYPHERMAPEXPR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>cyphermapexpr</name><operator>.</operator><name>key_cstrings</name></name> <operator>=</operator> <name>key_cstrings</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>cyphermapexpr</name><operator>.</operator><name>val_values</name></name> <operator>=</operator> <name>val_values</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>cyphermapexpr</name><operator>.</operator><name>val_nulls</name></name> <operator>=</operator> <name>val_nulls</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>cyphermapexpr</name><operator>.</operator><name>npairs</name></name> <operator>=</operator> <name>npairs</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecInitCypherList</name><parameter_list>(<parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>scratch</name></decl></parameter>, <parameter><decl><type><name>CypherListExpr</name> <modifier>*</modifier></type><name>listexpr</name></decl></parameter>,
				   <parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nelems</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>listexpr</name><operator>-&gt;</operator><name>elems</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>elemvalues</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>elemnulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>le</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>elemvalues</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nelems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>elemnulls</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nelems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>le</argument>, <argument>listexpr-&gt;elems</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>elemvalues</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name><name>elemnulls</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_CYPHERLISTEXPR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>cypherlistexpr</name><operator>.</operator><name>elemvalues</name></name> <operator>=</operator> <name>elemvalues</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>cypherlistexpr</name><operator>.</operator><name>elemnulls</name></name> <operator>=</operator> <name>elemnulls</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>cypherlistexpr</name><operator>.</operator><name>nelems</name></name> <operator>=</operator> <name>nelems</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecInitCypherListComp</name><parameter_list>(<parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>scratch</name></decl></parameter>, <parameter><decl><type><name>CypherListCompExpr</name> <modifier>*</modifier></type><name>listcompexpr</name></decl></parameter>,
					   <parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprEvalStep</name></type> <name>null_step</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>null_stepno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprEvalStep</name></type> <name>begin_step</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprEvalStep</name></type> <name>init_step</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>elem_resvalue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>elem_resnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprEvalStep</name></type> <name>next_step</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>next_stepno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprEvalStep</name></type> <name>hasnext_step</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>hasnext_stepno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprEvalStep</name></type> <name>elem_step</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprEvalStep</name></type> <name>loop_step</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>end_stepno</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>listcompexpr</name><operator>-&gt;</operator><name>list</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>JSONBOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>listcompexpr</name><operator>-&gt;</operator><name>list</name></name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>scratch</name><operator>-&gt;</operator><name>resvalue</name></name></expr></argument>,
					<argument><expr><name><name>scratch</name><operator>-&gt;</operator><name>resnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>isIdentity</name><argument_list>(<argument><expr><name>listcompexpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>null_step</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_JUMP_IF_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>null_step</name><operator>.</operator><name>resvalue</name></name> <operator>=</operator> <name><name>scratch</name><operator>-&gt;</operator><name>resvalue</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>null_step</name><operator>.</operator><name>resnull</name></name> <operator>=</operator> <name><name>scratch</name><operator>-&gt;</operator><name>resnull</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>null_step</name><operator>.</operator><name>d</name><operator>.</operator><name>jump</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>null_step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>null_stepno</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>begin_step</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_CYPHERLISTCOMP_BEGIN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>begin_step</name><operator>.</operator><name>d</name><operator>.</operator><name>cypherlistcomp</name><operator>.</operator><name>liststate</name></name> <operator>=</operator>
		<operator>(</operator><name>JsonbParseState</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JsonbParseState</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>begin_step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>init_step</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_CYPHERLISTCOMP_ITER_INIT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>init_step</name><operator>.</operator><name>d</name><operator>.</operator><name>cypherlistcomp_iter</name><operator>.</operator><name>listvalue</name></name> <operator>=</operator> <name><name>scratch</name><operator>-&gt;</operator><name>resvalue</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>init_step</name><operator>.</operator><name>d</name><operator>.</operator><name>cypherlistcomp_iter</name><operator>.</operator><name>listnull</name></name> <operator>=</operator> <name><name>scratch</name><operator>-&gt;</operator><name>resnull</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>init_step</name><operator>.</operator><name>d</name><operator>.</operator><name>cypherlistcomp_iter</name><operator>.</operator><name>listiter</name></name> <operator>=</operator>
		<operator>(</operator><name>JsonbIterator</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JsonbIterator</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>init_step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>elem_resvalue</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>elem_resnull</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>next_step</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_CYPHERLISTCOMP_ITER_NEXT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>next_step</name><operator>.</operator><name>resvalue</name></name> <operator>=</operator> <name>elem_resvalue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>next_step</name><operator>.</operator><name>resnull</name></name> <operator>=</operator> <name>elem_resnull</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>next_step</name><operator>.</operator><name>d</name><operator>.</operator><name>cypherlistcomp_iter</name><operator>.</operator><name>listiter</name></name> <operator>=</operator>
		<name><name>init_step</name><operator>.</operator><name>d</name><operator>.</operator><name>cypherlistcomp_iter</name><operator>.</operator><name>listiter</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next_step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>next_stepno</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>hasnext_step</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_JUMP_IF_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hasnext_step</name><operator>.</operator><name>resvalue</name></name> <operator>=</operator> <name><name>next_step</name><operator>.</operator><name>resvalue</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hasnext_step</name><operator>.</operator><name>resnull</name></name> <operator>=</operator> <name><name>next_step</name><operator>.</operator><name>resnull</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hasnext_step</name><operator>.</operator><name>d</name><operator>.</operator><name>jump</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hasnext_step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hasnext_stepno</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>listcompexpr</name><operator>-&gt;</operator><name>cond</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>cond_resvalue</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>cond_resnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExprEvalStep</name></type> <name>cond_step</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>cond_resvalue</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cond_resnull</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>initExprSaveIter</name><argument_list>(<argument><expr><name><name>listcompexpr</name><operator>-&gt;</operator><name>cond</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next_step</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
						 <argument><expr><name>cond_resvalue</name></expr></argument>, <argument><expr><name>cond_resnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>cond_step</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_JUMP_IF_NOT_TRUE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cond_step</name><operator>.</operator><name>resvalue</name></name> <operator>=</operator> <name>cond_resvalue</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cond_step</name><operator>.</operator><name>resnull</name></name> <operator>=</operator> <name>cond_resnull</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cond_step</name><operator>.</operator><name>d</name><operator>.</operator><name>jump</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <name>next_stepno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cond_step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>listcompexpr</name><operator>-&gt;</operator><name>elem</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>initExprSaveIter</name><argument_list>(<argument><expr><name><name>listcompexpr</name><operator>-&gt;</operator><name>elem</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next_step</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
						 <argument><expr><name>elem_resvalue</name></expr></argument>, <argument><expr><name>elem_resnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>elem_step</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_CYPHERLISTCOMP_ELEM</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>elem_step</name><operator>.</operator><name>d</name><operator>.</operator><name>cypherlistcomp</name><operator>.</operator><name>elemvalue</name></name> <operator>=</operator> <name>elem_resvalue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>elem_step</name><operator>.</operator><name>d</name><operator>.</operator><name>cypherlistcomp</name><operator>.</operator><name>elemnull</name></name> <operator>=</operator> <name>elem_resnull</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>elem_step</name><operator>.</operator><name>d</name><operator>.</operator><name>cypherlistcomp</name><operator>.</operator><name>liststate</name></name> <operator>=</operator>
		<name><name>begin_step</name><operator>.</operator><name>d</name><operator>.</operator><name>cypherlistcomp</name><operator>.</operator><name>liststate</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elem_step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>loop_step</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_JUMP</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>loop_step</name><operator>.</operator><name>d</name><operator>.</operator><name>jump</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <name>next_stepno</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loop_step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_CYPHERLISTCOMP_END</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>cypherlistcomp</name><operator>.</operator><name>liststate</name></name> <operator>=</operator>
		<name><name>begin_step</name><operator>.</operator><name>d</name><operator>.</operator><name>cypherlistcomp</name><operator>.</operator><name>liststate</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>end_stepno</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>steps</name><index>[<expr><name>hasnext_stepno</name></expr>]</index></name><operator>.</operator><name><name>d</name><operator>.</operator><name>jump</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <name>end_stepno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>steps</name><index>[<expr><name>null_stepno</name></expr>]</index></name><operator>.</operator><name><name>d</name><operator>.</operator><name>jump</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>isIdentity</name><parameter_list>(<parameter><decl><type><name>CypherListCompExpr</name> <modifier>*</modifier></type><name>listcompexpr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>listcompexpr</name><operator>-&gt;</operator><name>cond</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>listcompexpr</name><operator>-&gt;</operator><name>elem</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>listcompexpr</name><operator>-&gt;</operator><name>elem</name></name></expr></argument>, <argument><expr><name>CypherListCompVar</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>CypherListCompVar</name> <operator>*</operator><operator>)</operator> <name><name>listcompexpr</name><operator>-&gt;</operator><name>elem</name></name><operator>)</operator><operator>-&gt;</operator><name>varname</name></expr></argument>,
					  <argument><expr><name><name>listcompexpr</name><operator>-&gt;</operator><name>varname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>initExprSaveIter</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>next_step</name></decl></parameter>,
				 <parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>resv</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>resnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>save_iterval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>save_iternull</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>save_iterval</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>innermost_cypherlistcomp_iterval</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>save_iternull</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>innermost_cypherlistcomp_iternull</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>innermost_cypherlistcomp_iterval</name></name> <operator>=</operator> <name><name>next_step</name><operator>-&gt;</operator><name>resvalue</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>innermost_cypherlistcomp_iternull</name></name> <operator>=</operator> <name><name>next_step</name><operator>-&gt;</operator><name>resnull</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>resv</name></expr></argument>, <argument><expr><name>resnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>innermost_cypherlistcomp_iterval</name></name> <operator>=</operator> <name>save_iterval</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>innermost_cypherlistcomp_iternull</name></name> <operator>=</operator> <name>save_iternull</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecInitCypherAccess</name><parameter_list>(<parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>scratch</name></decl></parameter>, <parameter><decl><type><name>CypherAccessExpr</name> <modifier>*</modifier></type><name>accessexpr</name></decl></parameter>,
					 <parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>argvalue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>argnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>pathlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CypherAccessPathElem</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>le</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>accessexpr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>JSONBOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>argvalue</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>argnull</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>accessexpr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>argvalue</name></expr></argument>, <argument><expr><name>argnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pathlen</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>accessexpr</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>CypherAccessPathElem</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CypherAccessPathElem</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>pathlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>le</argument>, <argument>accessexpr-&gt;path</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CypherIndices</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CypherIndices</name> <modifier>*</modifier></type><name>cind</name> <init>= <expr><operator>(</operator><name>CypherIndices</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>path</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>is_slice</name> <operator>=</operator> <name><name>cind</name><operator>-&gt;</operator><name>is_slice</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>initCypherIndex</name><argument_list>(<argument><expr><name><name>cind</name><operator>-&gt;</operator><name>lidx</name></name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>path</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>initCypherIndex</name><argument_list>(<argument><expr><name><name>cind</name><operator>-&gt;</operator><name>uidx</name></name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>path</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>uidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>path</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>is_slice</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MarkCypherIndexResultInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>path</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>initCypherIndex</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>path</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>uidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_CYPHERACCESSEXPR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>cypheraccessexpr</name><operator>.</operator><name>argvalue</name></name> <operator>=</operator> <name>argvalue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>cypheraccessexpr</name><operator>.</operator><name>argnull</name></name> <operator>=</operator> <name>argnull</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>cypheraccessexpr</name><operator>.</operator><name>path</name></name> <operator>=</operator> <name>path</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>cypheraccessexpr</name><operator>.</operator><name>pathlen</name></name> <operator>=</operator> <name>pathlen</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>initCypherIndex</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
				<parameter><decl><type><name>CypherIndexResult</name> <modifier>*</modifier></type><name>cidxres</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MarkCypherIndexResultInvalid</name><argument_list>(<argument><expr><name>cidxres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>cidxres</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cidxres</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cidxres</name><operator>-&gt;</operator><name>isnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
</unit>
