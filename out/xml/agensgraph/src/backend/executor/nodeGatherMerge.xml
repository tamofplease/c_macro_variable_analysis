<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/executor/nodeGatherMerge.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * nodeGatherMerge.c
 *		Scan a plan in multiple workers, and do order-preserving merge.
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/executor/nodeGatherMerge.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execdebug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execParallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeGatherMerge.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSubplan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/tqueue.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/binaryheap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>

<comment type="block">/*
 * When we read tuples from workers, it's a good idea to read several at once
 * for efficiency when possible: this minimizes context-switching overhead.
 * But reading too many at a time wastes memory without improving performance.
 * We'll read up to MAX_TUPLE_STORE tuples (in addition to the first one).
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_TUPLE_STORE</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>

<comment type="block">/*
 * Pending-tuple array for each worker.  This holds additional tuples that
 * we were able to fetch from the worker, but can't process yet.  In addition,
 * this struct holds the "done" flag indicating the worker is known to have
 * no more tuples.  (We do not use this struct for the leader; we don't keep
 * any pending tuples for the leader, and the need_to_scan_locally flag serves
 * as its "done" indicator.)
 */</comment>
<typedef>typedef <type><struct>struct <name>GMReaderTupleBuffer</name>
<block>{
	<decl_stmt><decl><type><name>HeapTuple</name>  <modifier>*</modifier></type><name>tuple</name></decl>;</decl_stmt>			<comment type="block">/* array of length MAX_TUPLE_STORE */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nTuples</name></decl>;</decl_stmt>		<comment type="block">/* number of tuples currently stored */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>readCounter</name></decl>;</decl_stmt>	<comment type="block">/* index of next tuple to extract */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>done</name></decl>;</decl_stmt>			<comment type="block">/* true if reader is known exhausted */</comment>
}</block></struct></type> <name>GMReaderTupleBuffer</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>ExecGatherMerge</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32</name></type> <name>heap_compare_slots</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>gather_merge_getnext</name><parameter_list>(<parameter><decl><type><name>GatherMergeState</name> <modifier>*</modifier></type><name>gm_state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HeapTuple</name></type> <name>gm_readnext_tuple</name><parameter_list>(<parameter><decl><type><name>GatherMergeState</name> <modifier>*</modifier></type><name>gm_state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nreader</name></decl></parameter>,
								   <parameter><decl><type><name>bool</name></type> <name>nowait</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>done</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecShutdownGatherMergeWorkers</name><parameter_list>(<parameter><decl><type><name>GatherMergeState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gather_merge_setup</name><parameter_list>(<parameter><decl><type><name>GatherMergeState</name> <modifier>*</modifier></type><name>gm_state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gather_merge_init</name><parameter_list>(<parameter><decl><type><name>GatherMergeState</name> <modifier>*</modifier></type><name>gm_state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gather_merge_clear_tuples</name><parameter_list>(<parameter><decl><type><name>GatherMergeState</name> <modifier>*</modifier></type><name>gm_state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>gather_merge_readnext</name><parameter_list>(<parameter><decl><type><name>GatherMergeState</name> <modifier>*</modifier></type><name>gm_state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reader</name></decl></parameter>,
								  <parameter><decl><type><name>bool</name></type> <name>nowait</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>load_tuple_array</name><parameter_list>(<parameter><decl><type><name>GatherMergeState</name> <modifier>*</modifier></type><name>gm_state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reader</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecInitGather
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>GatherMergeState</name> <modifier>*</modifier></type>
<name>ExecInitGatherMerge</name><parameter_list>(<parameter><decl><type><name>GatherMerge</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GatherMergeState</name> <modifier>*</modifier></type><name>gm_state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>outerNode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>

	<comment type="block">/* Gather merge node doesn't have innerPlan node. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>innerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * create state structure
	 */</comment>
	<expr_stmt><expr><name>gm_state</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>GatherMergeState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gm_state</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gm_state</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gm_state</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ExecProcNode</name></name> <operator>=</operator> <name>ExecGatherMerge</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>gm_state</name><operator>-&gt;</operator><name>initialized</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gm_state</name><operator>-&gt;</operator><name>gm_initialized</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gm_state</name><operator>-&gt;</operator><name>tuples_needed</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Miscellaneous initialization
	 *
	 * create expression context for node
	 */</comment>
	<expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gm_state</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * GatherMerge doesn't support checking a qual (it's always more efficient
	 * to do it in the child node).
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * now initialize outer plan
	 */</comment>
	<expr_stmt><expr><name>outerNode</name> <operator>=</operator> <call><name>outerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>gm_state</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><name>outerNode</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Leader may access ExecProcNode result directly (if
	 * need_to_scan_locally), or from workers via tuple queue.  So we can't
	 * trivially rely on the slot type being fixed for expressions evaluated
	 * within this node.
	 */</comment>
	<expr_stmt><expr><name><name>gm_state</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>outeropsset</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gm_state</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>outeropsfixed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Store the tuple descriptor into gather merge state, so we can use it
	 * while initializing the gather merge slots.
	 */</comment>
	<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>ExecGetResultType</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>gm_state</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gm_state</name><operator>-&gt;</operator><name>tupDesc</name></name> <operator>=</operator> <name>tupDesc</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize result type and projection.
	 */</comment>
	<expr_stmt><expr><call><name>ExecInitResultTypeTL</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gm_state</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecConditionalAssignProjectionInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gm_state</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>, <argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>OUTER_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Without projections result slot type is not trivially known, see
	 * comment above.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>gm_state</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ProjInfo</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>gm_state</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>resultopsset</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>gm_state</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>resultopsfixed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * initialize sort-key information
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>gm_state</name><operator>-&gt;</operator><name>gm_nkeys</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>gm_state</name><operator>-&gt;</operator><name>gm_sortkeys</name></name> <operator>=</operator>
			<call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SortSupportData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SortSupport</name></type> <name>sortKey</name> <init>= <expr><name><name>gm_state</name><operator>-&gt;</operator><name>gm_sortkeys</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>sortKey</name><operator>-&gt;</operator><name>ssup_cxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sortKey</name><operator>-&gt;</operator><name>ssup_collation</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>collations</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sortKey</name><operator>-&gt;</operator><name>ssup_nulls_first</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>nullsFirst</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sortKey</name><operator>-&gt;</operator><name>ssup_attno</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>sortColIdx</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

			<comment type="block">/*
			 * We don't perform abbreviated key conversion here, for the same
			 * reasons that it isn't used in MergeAppend
			 */</comment>
			<expr_stmt><expr><name><name>sortKey</name><operator>-&gt;</operator><name>abbreviate</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PrepareSortSupportFromOrderingOp</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>sortOperators</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>sortKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Now allocate the workspace for gather merge */</comment>
	<expr_stmt><expr><call><name>gather_merge_setup</name><argument_list>(<argument><expr><name>gm_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>gm_state</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecGatherMerge(node)
 *
 *		Scans the relation via multiple workers and returns
 *		the next qualifying tuple.
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecGatherMerge</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GatherMergeState</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>GatherMergeState</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * As with Gather, we don't launch workers until this node is actually
	 * executed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>initialized</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>GatherMerge</name> <modifier>*</modifier></type><name>gm</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>GatherMerge</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Sometimes we might have to run without parallelism; but if parallel
		 * mode is active then we can try to fire up some workers.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>gm</name><operator>-&gt;</operator><name>num_workers</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_use_parallel_mode</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl>;</decl_stmt>

			<comment type="block">/* Initialize, or re-initialize, shared state needed by workers. */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>pei</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>pei</name></name> <operator>=</operator> <call><name>ExecInitParallelPlan</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>lefttree</name></name></expr></argument>,
												 <argument><expr><name>estate</name></expr></argument>,
												 <argument><expr><name><name>gm</name><operator>-&gt;</operator><name>initParam</name></name></expr></argument>,
												 <argument><expr><name><name>gm</name><operator>-&gt;</operator><name>num_workers</name></name></expr></argument>,
												 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>tuples_needed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecParallelReinitialize</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>lefttree</name></name></expr></argument>,
										 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>pei</name></name></expr></argument>,
										 <argument><expr><name><name>gm</name><operator>-&gt;</operator><name>initParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/* Try to launch workers. */</comment>
			<expr_stmt><expr><name>pcxt</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>pei</name><operator>-&gt;</operator><name>pcxt</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LaunchParallelWorkers</name><argument_list>(<argument><expr><name>pcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* We save # workers launched for the benefit of EXPLAIN */</comment>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>nworkers_launched</name></name> <operator>=</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>nworkers_launched</name></name></expr>;</expr_stmt>

			<comment type="block">/* Set up tuple queue readers to read the results. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>pcxt</name><operator>-&gt;</operator><name>nworkers_launched</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ExecParallelCreateReaders</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>pei</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Make a working array showing the active readers */</comment>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>nreaders</name></name> <operator>=</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>nworkers_launched</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>reader</name></name> <operator>=</operator> <operator>(</operator><name>TupleQueueReader</name> <operator>*</operator><operator>*</operator><operator>)</operator>
					<call><name>palloc</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nreaders</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TupleQueueReader</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>reader</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>pei</name><operator>-&gt;</operator><name>reader</name></name></expr></argument>,
					   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nreaders</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TupleQueueReader</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* No workers?	Then never mind. */</comment>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>nreaders</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>reader</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* allow leader to participate if enabled or no choice */</comment>
		<if_stmt><if>if <condition>(<expr><name>parallel_leader_participation</name> <operator>||</operator> <name><name>node</name><operator>-&gt;</operator><name>nreaders</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>need_to_scan_locally</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>initialized</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Reset per-tuple memory context to free any expression evaluation
	 * storage allocated in the previous tuple cycle.
	 */</comment>
	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get next tuple, either from one of our workers, or by running the plan
	 * ourselves.
	 */</comment>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>gather_merge_getnext</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If no projection is required, we're done. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ProjInfo</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>slot</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Form the result tuple using ExecProject(), and return it.
	 */</comment>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
	<return>return <expr><call><name>ExecProject</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ProjInfo</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecEndGatherMerge
 *
 *		frees any storage allocated through C routines.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecEndGatherMerge</name><parameter_list>(<parameter><decl><type><name>GatherMergeState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* let children clean up first */</comment>
	<expr_stmt><expr><call><name>ExecShutdownGatherMerge</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecFreeExprContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecShutdownGatherMerge
 *
 *		Destroy the setup for parallel workers including parallel context.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecShutdownGatherMerge</name><parameter_list>(<parameter><decl><type><name>GatherMergeState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ExecShutdownGatherMergeWorkers</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now destroy the parallel context. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>pei</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecParallelCleanup</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>pei</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>pei</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecShutdownGatherMergeWorkers
 *
 *		Stop all the parallel workers.
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecShutdownGatherMergeWorkers</name><parameter_list>(<parameter><decl><type><name>GatherMergeState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>pei</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecParallelFinish</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>pei</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Flush local copy of reader array */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>reader</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>reader</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>reader</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecReScanGatherMerge
 *
 *		Prepare to re-scan the result of a GatherMerge.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecReScanGatherMerge</name><parameter_list>(<parameter><decl><type><name>GatherMergeState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GatherMerge</name> <modifier>*</modifier></type><name>gm</name> <init>= <expr><operator>(</operator><name>GatherMerge</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>outerPlan</name> <init>= <expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Make sure any existing workers are gracefully shut down */</comment>
	<expr_stmt><expr><call><name>ExecShutdownGatherMergeWorkers</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Free any unused tuples, so we don't leak memory across rescans */</comment>
	<expr_stmt><expr><call><name>gather_merge_clear_tuples</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Mark node so that shared state will be rebuilt at next call */</comment>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>initialized</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>gm_initialized</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set child node's chgParam to tell it that the next scan might deliver a
	 * different set of rows within the leader process.  (The overall rowset
	 * shouldn't change, but the leader process's subset might; hence nodes
	 * between here and the parallel table scan node mustn't optimize on the
	 * assumption of an unchanging rowset.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>gm</name><operator>-&gt;</operator><name>rescan_param</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>outerPlan</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>outerPlan</name><operator>-&gt;</operator><name>chgParam</name></name></expr></argument>,
											 <argument><expr><name><name>gm</name><operator>-&gt;</operator><name>rescan_param</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If chgParam of subnode is not null then plan will be re-scanned by
	 * first ExecProcNode.  Note: because this does nothing if we have a
	 * rescan_param, it's currently guaranteed that parallel-aware child nodes
	 * will not see a ReScan call until after they get a ReInitializeDSM call.
	 * That ordering might not be something to rely on, though.  A good rule
	 * of thumb is that ReInitializeDSM should reset only shared state, ReScan
	 * should reset only local state, and anything that depends on both of
	 * those steps being finished must wait until the first ExecProcNode call.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>outerPlan</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecReScan</name><argument_list>(<argument><expr><name>outerPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Set up the data structures that we'll need for Gather Merge.
 *
 * We allocate these once on the basis of gm-&gt;num_workers, which is an
 * upper bound for the number of workers we'll actually have.  During
 * a rescan, we reset the structures to empty.  This approach simplifies
 * not leaking memory across rescans.
 *
 * In the gm_slots[] array, index 0 is for the leader, and indexes 1 to n
 * are for workers.  The values placed into gm_heap correspond to indexes
 * in gm_slots[].  The gm_tuple_buffers[] array, however, is indexed from
 * 0 to n-1; it has no entry for the leader.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gather_merge_setup</name><parameter_list>(<parameter><decl><type><name>GatherMergeState</name> <modifier>*</modifier></type><name>gm_state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GatherMerge</name> <modifier>*</modifier></type><name>gm</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>GatherMerge</name></expr></argument>, <argument><expr><name><name>gm_state</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nreaders</name> <init>= <expr><name><name>gm</name><operator>-&gt;</operator><name>num_workers</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Allocate gm_slots for the number of workers + one more slot for leader.
	 * Slot 0 is always for the leader.  Leader always calls ExecProcNode() to
	 * read the tuple, and then stores it directly into its gm_slots entry.
	 * For other slots, code below will call ExecInitExtraTupleSlot() to
	 * create a slot for the worker's results.  Note that during any single
	 * scan, we might have fewer than num_workers available workers, in which
	 * case the extra array entries go unused.
	 */</comment>
	<expr_stmt><expr><name><name>gm_state</name><operator>-&gt;</operator><name>gm_slots</name></name> <operator>=</operator> <operator>(</operator><name>TupleTableSlot</name> <operator>*</operator><operator>*</operator><operator>)</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><operator>(</operator><name>nreaders</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TupleTableSlot</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Allocate the tuple slot and tuple array for each worker */</comment>
	<expr_stmt><expr><name><name>gm_state</name><operator>-&gt;</operator><name>gm_tuple_buffers</name></name> <operator>=</operator> <operator>(</operator><name>GMReaderTupleBuffer</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><name>nreaders</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GMReaderTupleBuffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nreaders</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* Allocate the tuple array with length MAX_TUPLE_STORE */</comment>
		<expr_stmt><expr><name><name>gm_state</name><operator>-&gt;</operator><name>gm_tuple_buffers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tuple</name> <operator>=</operator>
			<operator>(</operator><name>HeapTuple</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HeapTuple</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>MAX_TUPLE_STORE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Initialize tuple slot for worker */</comment>
		<expr_stmt><expr><name><name>gm_state</name><operator>-&gt;</operator><name>gm_slots</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
			<call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name><name>gm_state</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>, <argument><expr><name><name>gm_state</name><operator>-&gt;</operator><name>tupDesc</name></name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>TTSOpsHeapTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Allocate the resources for the merge */</comment>
	<expr_stmt><expr><name><name>gm_state</name><operator>-&gt;</operator><name>gm_heap</name></name> <operator>=</operator> <call><name>binaryheap_allocate</name><argument_list>(<argument><expr><name>nreaders</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
											<argument><expr><name>heap_compare_slots</name></expr></argument>,
											<argument><expr><name>gm_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize the Gather Merge.
 *
 * Reset data structures to ensure they're empty.  Then pull at least one
 * tuple from leader + each worker (or set its "done" indicator), and set up
 * the heap.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gather_merge_init</name><parameter_list>(<parameter><decl><type><name>GatherMergeState</name> <modifier>*</modifier></type><name>gm_state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nreaders</name> <init>= <expr><name><name>gm_state</name><operator>-&gt;</operator><name>nreaders</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>nowait</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Assert that gather_merge_setup made enough space */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nreaders</name> <operator>&lt;=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>GatherMerge</name></expr></argument>, <argument><expr><name><name>gm_state</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>num_workers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reset leader's tuple slot to empty */</comment>
	<expr_stmt><expr><name><name>gm_state</name><operator>-&gt;</operator><name>gm_slots</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Reset the tuple slot and tuple array for each worker */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nreaders</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* Reset tuple array to empty */</comment>
		<expr_stmt><expr><name><name>gm_state</name><operator>-&gt;</operator><name>gm_tuple_buffers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nTuples</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>gm_state</name><operator>-&gt;</operator><name>gm_tuple_buffers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>readCounter</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<comment type="block">/* Reset done flag to not-done */</comment>
		<expr_stmt><expr><name><name>gm_state</name><operator>-&gt;</operator><name>gm_tuple_buffers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>done</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<comment type="block">/* Ensure output slot is empty */</comment>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>gm_state</name><operator>-&gt;</operator><name>gm_slots</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Reset binary heap to empty */</comment>
	<expr_stmt><expr><call><name>binaryheap_reset</name><argument_list>(<argument><expr><name><name>gm_state</name><operator>-&gt;</operator><name>gm_heap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * First, try to read a tuple from each worker (including leader) in
	 * nowait mode.  After this, if not all workers were able to produce a
	 * tuple (or a "done" indication), then re-read from remaining workers,
	 * this time using wait mode.  Add all live readers (those producing at
	 * least one tuple) to the heap.
	 */</comment>
<label><name>reread</name>:</label>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>nreaders</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* skip this source if already known done */</comment>
		<if_stmt><if>if <condition>(<expr><ternary><condition><expr><operator>(</operator><name>i</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>gm_state</name><operator>-&gt;</operator><name>need_to_scan_locally</name></name></expr> </then><else>:
			<expr><operator>!</operator><name><name>gm_state</name><operator>-&gt;</operator><name>gm_tuple_buffers</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>done</name></expr></else></ternary></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name><name>gm_state</name><operator>-&gt;</operator><name>gm_slots</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Don't have a tuple yet, try to get one */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>gather_merge_readnext</name><argument_list>(<argument><expr><name>gm_state</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>nowait</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>binaryheap_add_unordered</name><argument_list>(<argument><expr><name><name>gm_state</name><operator>-&gt;</operator><name>gm_heap</name></name></expr></argument>,
											 <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * We already got at least one tuple from this worker, but
				 * might as well see if it has any more ready by now.
				 */</comment>
				<expr_stmt><expr><call><name>load_tuple_array</name><argument_list>(<argument><expr><name>gm_state</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* need not recheck leader, since nowait doesn't matter for it */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>nreaders</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>gm_state</name><operator>-&gt;</operator><name>gm_tuple_buffers</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>done</name> <operator>&amp;&amp;</operator>
			<call><name>TupIsNull</name><argument_list>(<argument><expr><name><name>gm_state</name><operator>-&gt;</operator><name>gm_slots</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>nowait</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<goto>goto <name>reread</name>;</goto>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Now heapify the heap. */</comment>
	<expr_stmt><expr><call><name>binaryheap_build</name><argument_list>(<argument><expr><name><name>gm_state</name><operator>-&gt;</operator><name>gm_heap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>gm_state</name><operator>-&gt;</operator><name>gm_initialized</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Clear out the tuple table slot, and any unused pending tuples,
 * for each gather merge input.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gather_merge_clear_tuples</name><parameter_list>(<parameter><decl><type><name>GatherMergeState</name> <modifier>*</modifier></type><name>gm_state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>gm_state</name><operator>-&gt;</operator><name>nreaders</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GMReaderTupleBuffer</name> <modifier>*</modifier></type><name>tuple_buffer</name> <init>= <expr><operator>&amp;</operator><name><name>gm_state</name><operator>-&gt;</operator><name>gm_tuple_buffers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><name><name>tuple_buffer</name><operator>-&gt;</operator><name>readCounter</name></name> <operator>&lt;</operator> <name><name>tuple_buffer</name><operator>-&gt;</operator><name>nTuples</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name><name>tuple_buffer</name><operator>-&gt;</operator><name>tuple</name><index>[<expr><name><name>tuple_buffer</name><operator>-&gt;</operator><name>readCounter</name></name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>gm_state</name><operator>-&gt;</operator><name>gm_slots</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Read the next tuple for gather merge.
 *
 * Fetch the sorted tuple out of the heap.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>gather_merge_getnext</name><parameter_list>(<parameter><decl><type><name>GatherMergeState</name> <modifier>*</modifier></type><name>gm_state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>gm_state</name><operator>-&gt;</operator><name>gm_initialized</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * First time through: pull the first tuple from each participant, and
		 * set up the heap.
		 */</comment>
		<expr_stmt><expr><call><name>gather_merge_init</name><argument_list>(<argument><expr><name>gm_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Otherwise, pull the next tuple from whichever participant we
		 * returned from last time, and reinsert that participant's index into
		 * the heap, because it might now compare differently against the
		 * other elements of the heap.
		 */</comment>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>binaryheap_first</name><argument_list>(<argument><expr><name><name>gm_state</name><operator>-&gt;</operator><name>gm_heap</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>gather_merge_readnext</name><argument_list>(<argument><expr><name>gm_state</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>binaryheap_replace_first</name><argument_list>(<argument><expr><name><name>gm_state</name><operator>-&gt;</operator><name>gm_heap</name></name></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* reader exhausted, remove it from heap */</comment>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>binaryheap_remove_first</name><argument_list>(<argument><expr><name><name>gm_state</name><operator>-&gt;</operator><name>gm_heap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>binaryheap_empty</name><argument_list>(<argument><expr><name><name>gm_state</name><operator>-&gt;</operator><name>gm_heap</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* All the queues are exhausted, and so is the heap */</comment>
		<expr_stmt><expr><call><name>gather_merge_clear_tuples</name><argument_list>(<argument><expr><name>gm_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Return next tuple from whichever participant has the leading one */</comment>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>binaryheap_first</name><argument_list>(<argument><expr><name><name>gm_state</name><operator>-&gt;</operator><name>gm_heap</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name><name>gm_state</name><operator>-&gt;</operator><name>gm_slots</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Read tuple(s) for given reader in nowait mode, and load into its tuple
 * array, until we have MAX_TUPLE_STORE of them or would have to block.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>load_tuple_array</name><parameter_list>(<parameter><decl><type><name>GatherMergeState</name> <modifier>*</modifier></type><name>gm_state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reader</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GMReaderTupleBuffer</name> <modifier>*</modifier></type><name>tuple_buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Don't do anything if this is the leader. */</comment>
	<if_stmt><if>if <condition>(<expr><name>reader</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tuple_buffer</name> <operator>=</operator> <operator>&amp;</operator><name><name>gm_state</name><operator>-&gt;</operator><name>gm_tuple_buffers</name><index>[<expr><name>reader</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* If there's nothing in the array, reset the counters to zero. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tuple_buffer</name><operator>-&gt;</operator><name>nTuples</name></name> <operator>==</operator> <name><name>tuple_buffer</name><operator>-&gt;</operator><name>readCounter</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tuple_buffer</name><operator>-&gt;</operator><name>nTuples</name></name> <operator>=</operator> <name><name>tuple_buffer</name><operator>-&gt;</operator><name>readCounter</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Try to fill additional slots in the array. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>tuple_buffer</name><operator>-&gt;</operator><name>nTuples</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAX_TUPLE_STORE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>gm_readnext_tuple</name><argument_list>(<argument><expr><name>gm_state</name></expr></argument>,
								  <argument><expr><name>reader</name></expr></argument>,
								  <argument><expr><name>true</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name><name>tuple_buffer</name><operator>-&gt;</operator><name>done</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>tuple_buffer</name><operator>-&gt;</operator><name>tuple</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>tuple</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tuple_buffer</name><operator>-&gt;</operator><name>nTuples</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Store the next tuple for a given reader into the appropriate slot.
 *
 * Returns true if successful, false if not (either reader is exhausted,
 * or we didn't want to wait for a tuple).  Sets done flag if reader
 * is found to be exhausted.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>gather_merge_readnext</name><parameter_list>(<parameter><decl><type><name>GatherMergeState</name> <modifier>*</modifier></type><name>gm_state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reader</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nowait</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GMReaderTupleBuffer</name> <modifier>*</modifier></type><name>tuple_buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If we're being asked to generate a tuple from the leader, then we just
	 * call ExecProcNode as normal to produce one.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>reader</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>gm_state</name><operator>-&gt;</operator><name>need_to_scan_locally</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>outerPlan</name> <init>= <expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>gm_state</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>outerTupleSlot</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>gm_state</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Install our DSA area while executing the plan. */</comment>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_dsa</name></name> <operator>=</operator> <ternary><condition><expr><name><name>gm_state</name><operator>-&gt;</operator><name>pei</name></name></expr> ?</condition><then> <expr><name><name>gm_state</name><operator>-&gt;</operator><name>pei</name><operator>-&gt;</operator><name>area</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><name>outerTupleSlot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>outerPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_dsa</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>outerTupleSlot</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>gm_state</name><operator>-&gt;</operator><name>gm_slots</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>outerTupleSlot</name></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* need_to_scan_locally serves as "done" flag for leader */</comment>
			<expr_stmt><expr><name><name>gm_state</name><operator>-&gt;</operator><name>need_to_scan_locally</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Otherwise, check the state of the relevant tuple buffer. */</comment>
	<expr_stmt><expr><name>tuple_buffer</name> <operator>=</operator> <operator>&amp;</operator><name><name>gm_state</name><operator>-&gt;</operator><name>gm_tuple_buffers</name><index>[<expr><name>reader</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tuple_buffer</name><operator>-&gt;</operator><name>nTuples</name></name> <operator>&gt;</operator> <name><name>tuple_buffer</name><operator>-&gt;</operator><name>readCounter</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Return any tuple previously read that is still buffered. */</comment>
		<expr_stmt><expr><name>tup</name> <operator>=</operator> <name><name>tuple_buffer</name><operator>-&gt;</operator><name>tuple</name><index>[<expr><name><name>tuple_buffer</name><operator>-&gt;</operator><name>readCounter</name></name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>tuple_buffer</name><operator>-&gt;</operator><name>done</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Reader is known to be exhausted. */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Read and buffer next tuple. */</comment>
		<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>gm_readnext_tuple</name><argument_list>(<argument><expr><name>gm_state</name></expr></argument>,
								<argument><expr><name>reader</name></expr></argument>,
								<argument><expr><name>nowait</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name><name>tuple_buffer</name><operator>-&gt;</operator><name>done</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Attempt to read more tuples in nowait mode and store them in the
		 * pending-tuple array for the reader.
		 */</comment>
		<expr_stmt><expr><call><name>load_tuple_array</name><argument_list>(<argument><expr><name>gm_state</name></expr></argument>, <argument><expr><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build the TupleTableSlot for the given tuple */</comment>
	<expr_stmt><expr><call><name>ExecStoreHeapTuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>,		<comment type="block">/* tuple to store */</comment>
					   <argument><expr><name><name>gm_state</name><operator>-&gt;</operator><name>gm_slots</name><index>[<expr><name>reader</name></expr>]</index></name></expr></argument>,	<comment type="block">/* slot in which to store
													 * the tuple */</comment>
					   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* pfree tuple when done with it */</comment>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Attempt to read a tuple from given worker.
 */</comment>
<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>gm_readnext_tuple</name><parameter_list>(<parameter><decl><type><name>GatherMergeState</name> <modifier>*</modifier></type><name>gm_state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nreader</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nowait</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>done</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleQueueReader</name> <modifier>*</modifier></type><name>reader</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>

	<comment type="block">/* Check for async events, particularly messages from workers. */</comment>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Attempt to read a tuple.
	 *
	 * Note that TupleQueueReaderNext will just return NULL for a worker which
	 * fails to initialize.  We'll treat that worker as having produced no
	 * tuples; WaitForParallelWorkersToFinish will error out when we get
	 * there.
	 */</comment>
	<expr_stmt><expr><name>reader</name> <operator>=</operator> <name><name>gm_state</name><operator>-&gt;</operator><name>reader</name><index>[<expr><name>nreader</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>TupleQueueReaderNext</name><argument_list>(<argument><expr><name>reader</name></expr></argument>, <argument><expr><name>nowait</name></expr></argument>, <argument><expr><name>done</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tup</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * We have one slot for each item in the heap array.  We use SlotNumber
 * to store slot indexes.  This doesn't actually provide any formal
 * type-safety, but it makes the code more self-documenting.
 */</comment>
<typedef>typedef <type><name>int32</name></type> <name>SlotNumber</name>;</typedef>

<comment type="block">/*
 * Compare the tuples in the two given slots.
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>heap_compare_slots</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GatherMergeState</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>GatherMergeState</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SlotNumber</name></type>	<name>slot1</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SlotNumber</name></type>	<name>slot2</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>s1</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>gm_slots</name><index>[<expr><name>slot1</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>s2</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>gm_slots</name><index>[<expr><name>slot2</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nkey</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>nkey</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>nkey</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>gm_nkeys</name></name></expr>;</condition> <incr><expr><name>nkey</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortSupport</name></type> <name>sortKey</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>gm_sortkeys</name></name> <operator>+</operator> <name>nkey</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attno</name> <init>= <expr><name><name>sortKey</name><operator>-&gt;</operator><name>ssup_attno</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>datum1</name></decl>,
					<decl><type ref="prev"/><name>datum2</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull1</name></decl>,
					<decl><type ref="prev"/><name>isNull2</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>compare</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>datum1</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>datum2</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>s2</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>compare</name> <operator>=</operator> <call><name>ApplySortComparator</name><argument_list>(<argument><expr><name>datum1</name></expr></argument>, <argument><expr><name>isNull1</name></expr></argument>,
									  <argument><expr><name>datum2</name></expr></argument>, <argument><expr><name>isNull2</name></expr></argument>,
									  <argument><expr><name>sortKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>compare</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>INVERT_COMPARE_RESULT</name><argument_list>(<argument><expr><name>compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>compare</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
</unit>
