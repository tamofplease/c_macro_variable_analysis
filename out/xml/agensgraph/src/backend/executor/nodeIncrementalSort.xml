<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/executor/nodeIncrementalSort.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * nodeIncrementalSort.c
 *	  Routines to handle incremental sorting of relations.
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/executor/nodeIncrementalSort.c
 *
 * DESCRIPTION
 *
 *	Incremental sort is an optimized variant of multikey sort for cases
 *	when the input is already sorted by a prefix of the sort keys.  For
 *	example when a sort by (key1, key2 ... keyN) is requested, and the
 *	input is already sorted by (key1, key2 ... keyM), M &lt; N, we can
 *	divide the input into groups where keys (key1, ... keyM) are equal,
 *	and only sort on the remaining columns.
 *
 *	Consider the following example.  We have input tuples consisting of
 *	two integers (X, Y) already presorted by X, while it's required to
 *	sort them by both X and Y.  Let input tuples be following.
 *
 *	(1, 5)
 *	(1, 2)
 *	(2, 9)
 *	(2, 1)
 *	(2, 5)
 *	(3, 3)
 *	(3, 7)
 *
 *	An incremental sort algorithm would split the input into the following
 *	groups, which have equal X, and then sort them by Y individually:
 *
 *		(1, 5) (1, 2)
 *		(2, 9) (2, 1) (2, 5)
 *		(3, 3) (3, 7)
 *
 *	After sorting these groups and putting them altogether, we would get
 *	the following result which is sorted by X and Y, as requested:
 *
 *	(1, 2)
 *	(1, 5)
 *	(2, 1)
 *	(2, 5)
 *	(2, 9)
 *	(3, 3)
 *	(3, 7)
 *
 *	Incremental sort may be more efficient than plain sort, particularly
 *	on large datasets, as it reduces the amount of data to sort at once,
 *	making it more likely it fits into work_mem (eliminating the need to
 *	spill to disk).  But the main advantage of incremental sort is that
 *	it can start producing rows early, before sorting the whole dataset,
 *	which is a significant benefit especially for queries with LIMIT.
 *
 *	The algorithm we've implemented here is modified from the theoretical
 *	base described above by operating in two different modes:
 *	  - Fetching a minimum number of tuples without checking prefix key
 *	    group membership and sorting on all columns when safe.
 *	  - Fetching all tuples for a single prefix key group and sorting on
 *	    solely the unsorted columns.
 *	We always begin in the first mode, and employ a heuristic to switch
 *	into the second mode if we believe it's beneficial.
 *
 *	Sorting incrementally can potentially use less memory, avoid fetching
 *	and sorting all tuples in the dataset, and begin returning tuples before
 *	the entire result set is available.
 *
 *	The hybrid mode approach allows us to optimize for both very small
 *	groups (where the overhead of a new tuplesort is high) and very	large
 *	groups (where we can lower cost by not having to sort on already sorted
 *	columns), albeit at some extra cost while switching between modes.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execdebug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeIncrementalSort.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tuplesort.h"</cpp:file></cpp:include>

<comment type="block">/*
 * We need to store the instrumentation information in either local node's sort
 * info or, for a parallel worker process, in the shared info (this avoids
 * having to additionally memcpy the info from local memory to shared memory
 * at each instrumentation call). This macro expands to choose the proper sort
 * state and group info.
 *
 * Arguments:
 * - node: type IncrementalSortState *
 * - groupName: the token fullsort or prefixsort
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INSTRUMENT_SORT_GROUP</name><parameter_list>(<parameter><type><name>node</name></type></parameter>, <parameter><type><name>groupName</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		if ((node)-&gt;ss.ps.instrument != NULL) \
		{ \
			if ((node)-&gt;shared_info &amp;&amp; (node)-&gt;am_worker) \
			{ \
				Assert(IsParallelWorker()); \
				Assert(ParallelWorkerNumber &lt;= (node)-&gt;shared_info-&gt;num_workers); \
				instrumentSortedGroup(&amp;(node)-&gt;shared_info-&gt;sinfo[ParallelWorkerNumber].groupName##GroupInfo, \
									  (node)-&gt;groupName##_state); \
			} \
			else \
			{ \
				instrumentSortedGroup(&amp;(node)-&gt;incsort_info.groupName##GroupInfo, \
									  (node)-&gt;groupName##_state); \
			} \
		} \
	} while (0)</cpp:value></cpp:define>


<comment type="block">/* ----------------------------------------------------------------
 * instrumentSortedGroup
 *
 * Because incremental sort processes (potentially many) sort batches, we need
 * to capture tuplesort stats each time we finalize a sort state. This summary
 * data is later used for EXPLAIN ANALYZE output.
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>instrumentSortedGroup</name><parameter_list>(<parameter><decl><type><name>IncrementalSortGroupInfo</name> <modifier>*</modifier></type><name>groupInfo</name></decl></parameter>,
					  <parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>sortState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TuplesortInstrumentation</name></type> <name>sort_instr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>groupInfo</name><operator>-&gt;</operator><name>groupCount</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>tuplesort_get_stats</name><argument_list>(<argument><expr><name>sortState</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sort_instr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Calculate total and maximum memory and disk space used. */</comment>
	<switch>switch <condition>(<expr><name><name>sort_instr</name><operator>.</operator><name>spaceType</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>SORT_SPACE_TYPE_DISK</name></expr>:</case>
			<expr_stmt><expr><name><name>groupInfo</name><operator>-&gt;</operator><name>totalDiskSpaceUsed</name></name> <operator>+=</operator> <name><name>sort_instr</name><operator>.</operator><name>spaceUsed</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>sort_instr</name><operator>.</operator><name>spaceUsed</name></name> <operator>&gt;</operator> <name><name>groupInfo</name><operator>-&gt;</operator><name>maxDiskSpaceUsed</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>groupInfo</name><operator>-&gt;</operator><name>maxDiskSpaceUsed</name></name> <operator>=</operator> <name><name>sort_instr</name><operator>.</operator><name>spaceUsed</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<break>break;</break>
		<case>case <expr><name>SORT_SPACE_TYPE_MEMORY</name></expr>:</case>
			<expr_stmt><expr><name><name>groupInfo</name><operator>-&gt;</operator><name>totalMemorySpaceUsed</name></name> <operator>+=</operator> <name><name>sort_instr</name><operator>.</operator><name>spaceUsed</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>sort_instr</name><operator>.</operator><name>spaceUsed</name></name> <operator>&gt;</operator> <name><name>groupInfo</name><operator>-&gt;</operator><name>maxMemorySpaceUsed</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>groupInfo</name><operator>-&gt;</operator><name>maxMemorySpaceUsed</name></name> <operator>=</operator> <name><name>sort_instr</name><operator>.</operator><name>spaceUsed</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Track each sort method we've used. */</comment>
	<expr_stmt><expr><name><name>groupInfo</name><operator>-&gt;</operator><name>sortMethods</name></name> <operator>|=</operator> <name><name>sort_instr</name><operator>.</operator><name>sortMethod</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 * preparePresortedCols
 *
 * Prepare information for presorted_keys comparisons.
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>preparePresortedCols</name><parameter_list>(<parameter><decl><type><name>IncrementalSortState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IncrementalSort</name> <modifier>*</modifier></type><name>plannode</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>IncrementalSort</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>presorted_keys</name></name> <operator>=</operator>
		<operator>(</operator><name>PresortedKeyData</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>plannode</name><operator>-&gt;</operator><name>nPresortedCols</name></name> <operator>*</operator>
									<sizeof>sizeof<argument_list>(<argument><expr><name>PresortedKeyData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Pre-cache comparison functions for each pre-sorted key. */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>plannode</name><operator>-&gt;</operator><name>nPresortedCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>equalityOp</name></decl>,
					<decl><type ref="prev"/><name>equalityFunc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PresortedKeyData</name> <modifier>*</modifier></type><name>key</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>key</name> <operator>=</operator> <operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>presorted_keys</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>attno</name></name> <operator>=</operator> <name><name>plannode</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>sortColIdx</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>equalityOp</name> <operator>=</operator> <call><name>get_equality_op_for_ordering_op</name><argument_list>(<argument><expr><name><name>plannode</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>sortOperators</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
													 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>equalityOp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing equality operator for ordering operator %u"</literal></expr></argument>,
				 <argument><expr><name><name>plannode</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>sortOperators</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>equalityFunc</name> <operator>=</operator> <call><name>get_opcode</name><argument_list>(<argument><expr><name>equalityOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>equalityFunc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing function for operator %u"</literal></expr></argument>, <argument><expr><name>equalityOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Lookup the comparison function */</comment>
		<expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><name>equalityFunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* We can initialize the callinfo just once and re-use it */</comment>
		<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>fcinfo</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><call><name>SizeForFunctionCallInfo</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name><name>key</name><operator>-&gt;</operator><name>fcinfo</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
								 <argument><expr><name><name>plannode</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>collations</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 * isCurrentGroup
 *
 * Check whether a given tuple belongs to the current sort group by comparing
 * the presorted column values to the pivot tuple of the current group.
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>isCurrentGroup</name><parameter_list>(<parameter><decl><type><name>IncrementalSortState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>pivot</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nPresortedCols</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>nPresortedCols</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>IncrementalSort</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>nPresortedCols</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * That the input is sorted by keys * (0, ... n) implies that the tail
	 * keys are more likely to change. Therefore we do our comparison starting
	 * from the last pre-sorted column to optimize for early detection of
	 * inequality and minimizing the number of function calls..
	 */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>nPresortedCols</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>datumA</name></decl>,
					<decl><type ref="prev"/><name>datumB</name></decl>,
					<decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnullA</name></decl>,
					<decl><type ref="prev"/><name>isnullB</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attno</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>presorted_keys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>attno</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PresortedKeyData</name> <modifier>*</modifier></type><name>key</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>datumA</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>pivot</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnullA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>datumB</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnullB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Special case for NULL-vs-NULL, else use standard comparison */</comment>
		<if_stmt><if>if <condition>(<expr><name>isnullA</name> <operator>||</operator> <name>isnullB</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>isnullA</name> <operator>==</operator> <name>isnullB</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>key</name> <operator>=</operator> <operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>presorted_keys</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>datumA</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>datumB</name></expr>;</expr_stmt>

		<comment type="block">/* just for paranoia's sake, we reset isnull each time */</comment>
		<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>fcinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Check for null result, since caller is clearly not expecting one */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function %u returned NULL"</literal></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>flinfo</name><operator>.</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 * switchToPresortedPrefixMode
 *
 * When we determine that we've likely encountered a large batch of tuples all
 * having the same presorted prefix values, we want to optimize tuplesort by
 * only sorting on unsorted suffix keys.
 *
 * The problem is that we've already accumulated several tuples in another
 * tuplesort configured to sort by all columns (assuming that there may be
 * more than one prefix key group). So to switch to presorted prefix mode we
 * have to go back and look at all the tuples we've already accumulated to
 * verify they're all part of the same prefix key group before sorting them
 * solely by unsorted suffix keys.
 *
 * While it's likely that all tuples already fetched are all part of a single
 * prefix group, we also have to handle the possibility that there is at least
 * one different prefix key group before the large prefix key group.
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>switchToPresortedPrefixMode</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IncrementalSortState</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>IncrementalSortState</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanDirection</name></type> <name>dir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>nTuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>outerNode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IncrementalSort</name> <modifier>*</modifier></type><name>plannode</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>IncrementalSort</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>dir</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>es_direction</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>outerNode</name> <operator>=</operator> <call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>ExecGetResultType</name><argument_list>(<argument><expr><name>outerNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Configure the prefix sort state the first time around. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>prefixsort_state</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>prefixsort_state</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nPresortedCols</name> <init>= <expr><name><name>plannode</name><operator>-&gt;</operator><name>nPresortedCols</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Optimize the sort by assuming the prefix columns are all equal and
		 * thus we only need to sort by any remaining columns.
		 */</comment>
		<expr_stmt><expr><name>prefixsort_state</name> <operator>=</operator> <call><name>tuplesort_begin_heap</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>,
												<argument><expr><name><name>plannode</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>numCols</name></name> <operator>-</operator> <name>nPresortedCols</name></expr></argument>,
												<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>plannode</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>sortColIdx</name><index>[<expr><name>nPresortedCols</name></expr>]</index></name><operator>)</operator></expr></argument>,
												<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>plannode</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>sortOperators</name><index>[<expr><name>nPresortedCols</name></expr>]</index></name><operator>)</operator></expr></argument>,
												<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>plannode</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>collations</name><index>[<expr><name>nPresortedCols</name></expr>]</index></name><operator>)</operator></expr></argument>,
												<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>plannode</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>nullsFirst</name><index>[<expr><name>nPresortedCols</name></expr>]</index></name><operator>)</operator></expr></argument>,
												<argument><expr><name>work_mem</name></expr></argument>,
												<argument><expr><name>NULL</name></expr></argument>,
												<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>prefixsort_state</name></name> <operator>=</operator> <name>prefixsort_state</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Next group of presorted data */</comment>
		<expr_stmt><expr><call><name>tuplesort_reset</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>prefixsort_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * If the current node has a bound, then it's reasonably likely that a
	 * large prefix key group will benefit from bounded sort, so configure the
	 * tuplesort to allow for that optimization.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>bounded</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SO1_printf</name><argument_list>(<argument><expr><literal type="string">"Setting bound on presorted prefix tuplesort to: "</literal> <name>INT64_FORMAT</name> <literal type="string">"\n"</literal></expr></argument>,
				   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>bound</name></name> <operator>-</operator> <name><name>node</name><operator>-&gt;</operator><name>bound_Done</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>tuplesort_set_bound</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>prefixsort_state</name></name></expr></argument>,
							<argument><expr><name><name>node</name><operator>-&gt;</operator><name>bound</name></name> <operator>-</operator> <name><name>node</name><operator>-&gt;</operator><name>bound_Done</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Copy as many tuples as we can (i.e., in the same prefix key group) from
	 * the full sort state to the prefix sort state.
	 */</comment>
	<for>for <control>(<init><expr><name>nTuples</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>nTuples</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>n_fullsort_remaining</name></name></expr>;</condition> <incr><expr><name>nTuples</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * When we encounter multiple prefix key groups inside the full sort
		 * tuplesort we have to carry over the last read tuple into the next
		 * batch.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>nTuples</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>transfer_tuple</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>tuplesort_puttupleslot</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>prefixsort_state</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>transfer_tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* The carried over tuple is our new group pivot tuple. */</comment>
			<expr_stmt><expr><call><name>ExecCopySlot</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>group_pivot</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>transfer_tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>tuplesort_gettupleslot</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>fullsort_state</name></name></expr></argument>,
								   <argument><expr><call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>transfer_tuple</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If this is our first time through the loop, then we need to
			 * save the first tuple we get as our new group pivot.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>group_pivot</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecCopySlot</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>group_pivot</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>transfer_tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>isCurrentGroup</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>group_pivot</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>transfer_tuple</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>tuplesort_puttupleslot</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>prefixsort_state</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>transfer_tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * The tuple isn't part of the current batch so we need to
				 * carry it over into the next batch of tuples we transfer out
				 * of the full sort tuplesort into the presorted prefix
				 * tuplesort. We don't actually have to do anything special to
				 * save the tuple since we've already loaded it into the
				 * node-&gt;transfer_tuple slot, and, even though that slot
				 * points to memory inside the full sort tuplesort, we can't
				 * reset that tuplesort anyway until we've fully transferred
				 * out its tuples, so this reference is safe. We do need to
				 * reset the group pivot tuple though since we've finished the
				 * current prefix key group.
				 */</comment>
				<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>group_pivot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Break out of for-loop early */</comment>
				<break>break;</break>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Track how many tuples remain in the full sort batch so that we know if
	 * we need to sort multiple prefix key groups before processing tuples
	 * remaining in the large single prefix key group we think we've
	 * encountered.
	 */</comment>
	<expr_stmt><expr><call><name>SO1_printf</name><argument_list>(<argument><expr><literal type="string">"Moving "</literal> <name>INT64_FORMAT</name> <literal type="string">" tuples to presorted prefix tuplesort\n"</literal></expr></argument>, <argument><expr><name>nTuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>n_fullsort_remaining</name></name> <operator>-=</operator> <name>nTuples</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SO1_printf</name><argument_list>(<argument><expr><literal type="string">"Setting n_fullsort_remaining to "</literal> <name>INT64_FORMAT</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>n_fullsort_remaining</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>n_fullsort_remaining</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We've found that all tuples remaining in the full sort batch are in
		 * the same prefix key group and moved all of those tuples into the
		 * presorted prefix tuplesort.  We don't know that we've yet found the
		 * last tuple in the current prefix key group, so save our pivot
		 * comparison tuple and continue fetching tuples from the outer
		 * execution node to load into the presorted prefix tuplesort.
		 */</comment>
		<expr_stmt><expr><call><name>ExecCopySlot</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>group_pivot</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>transfer_tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SO_printf</name><argument_list>(<argument><expr><literal type="string">"Setting execution_status to INCSORT_LOADPREFIXSORT (switchToPresortedPrefixMode)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>execution_status</name></name> <operator>=</operator> <name>INCSORT_LOADPREFIXSORT</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Make sure we clear the transfer tuple slot so that next time we
		 * encounter a large prefix key group we don't incorrectly assume we
		 * have a tuple carried over from the previous group.
		 */</comment>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>transfer_tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * We finished a group but didn't consume all of the tuples from the
		 * full sort state, so we'll sort this batch, let the outer node read
		 * out all of those tuples, and then come back around to find another
		 * batch.
		 */</comment>
		<expr_stmt><expr><call><name>SO1_printf</name><argument_list>(<argument><expr><literal type="string">"Sorting presorted prefix tuplesort with "</literal> <name>INT64_FORMAT</name> <literal type="string">" tuples\n"</literal></expr></argument>, <argument><expr><name>nTuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>tuplesort_performsort</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>prefixsort_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>INSTRUMENT_SORT_GROUP</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>prefixsort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>bounded</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If the current node has a bound and we've already sorted n
			 * tuples, then the functional bound remaining is (original bound
			 * - n), so store the current number of processed tuples for use
			 * in configuring sorting bound.
			 */</comment>
			<expr_stmt><expr><call><name>SO2_printf</name><argument_list>(<argument><expr><literal type="string">"Changing bound_Done from "</literal> <name>INT64_FORMAT</name> <literal type="string">" to "</literal> <name>INT64_FORMAT</name> <literal type="string">"\n"</literal></expr></argument>,
					   <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>bound</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>bound_Done</name></name> <operator>+</operator> <name>nTuples</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>bound_Done</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>bound_Done</name></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>bound</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>bound_Done</name></name> <operator>+</operator> <name>nTuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>SO_printf</name><argument_list>(<argument><expr><literal type="string">"Setting execution_status to INCSORT_READPREFIXSORT  (switchToPresortedPrefixMode)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>execution_status</name></name> <operator>=</operator> <name>INCSORT_READPREFIXSORT</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Sorting many small groups with tuplesort is inefficient. In order to
 * cope with this problem we don't start a new group until the current one
 * contains at least DEFAULT_MIN_GROUP_SIZE tuples (unfortunately this also
 * means we can't assume small groups of tuples all have the same prefix keys.)
 * When we have a bound that's less than DEFAULT_MIN_GROUP_SIZE we start looking
 * for the new group as soon as we've met our bound to avoid fetching more
 * tuples than we absolutely have to fetch.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_MIN_GROUP_SIZE</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>

<comment type="block">/*
 * While we've optimized for small prefix key groups by not starting our prefix
 * key comparisons until we've reached a minimum number of tuples, we don't want
 * that optimization to cause us to lose out on the benefits of being able to
 * assume a large group of tuples is fully presorted by its prefix keys.
 * Therefore we use the DEFAULT_MAX_FULL_SORT_GROUP_SIZE cutoff as a heuristic
 * for determining when we believe we've encountered a large group, and, if we
 * get to that point without finding a new prefix key group we transition to
 * presorted prefix key mode.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_MAX_FULL_SORT_GROUP_SIZE</name></cpp:macro> <cpp:value>(2 * DEFAULT_MIN_GROUP_SIZE)</cpp:value></cpp:define>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecIncrementalSort
 *
 *		Assuming that outer subtree returns tuple presorted by some prefix
 *		of target sort columns, performs incremental sort.
 *
 *		Conditions:
 *		  -- none.
 *
 *		Initial States:
 *		  -- the outer child is prepared to return the first tuple.
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecIncrementalSort</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IncrementalSortState</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>IncrementalSortState</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanDirection</name></type> <name>dir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>read_sortstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>fullsort_state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IncrementalSort</name> <modifier>*</modifier></type><name>plannode</name> <init>= <expr><operator>(</operator><name>IncrementalSort</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>outerNode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>nTuples</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>minGroupSize</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>estate</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>dir</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_direction</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>fullsort_state</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>fullsort_state</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If a previous iteration has sorted a batch, then we need to check to
	 * see if there are any remaining tuples in that batch that we can return
	 * before moving on to other execution states.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>execution_status</name></name> <operator>==</operator> <name>INCSORT_READFULLSORT</name>
		<operator>||</operator> <name><name>node</name><operator>-&gt;</operator><name>execution_status</name></name> <operator>==</operator> <name>INCSORT_READPREFIXSORT</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Return next tuple from the current sorted group set if available.
		 */</comment>
		<expr_stmt><expr><name>read_sortstate</name> <operator>=</operator> <ternary><condition><expr><name><name>node</name><operator>-&gt;</operator><name>execution_status</name></name> <operator>==</operator> <name>INCSORT_READFULLSORT</name></expr> ?</condition><then>
			<expr><name>fullsort_state</name></expr> </then><else>: <expr><name><name>node</name><operator>-&gt;</operator><name>prefixsort_state</name></name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * We have to populate the slot from the tuplesort before checking
		 * outerNodeDone because it will set the slot to NULL if no more
		 * tuples remain. If the tuplesort is empty, but we don't have any
		 * more tuples available for sort from the outer node, then
		 * outerNodeDone will have been set so we'll return that now-empty
		 * slot to the caller.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>tuplesort_gettupleslot</name><argument_list>(<argument><expr><name>read_sortstate</name></expr></argument>, <argument><expr><call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>false</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>node</name><operator>-&gt;</operator><name>outerNodeDone</name></name></expr>)</condition><block type="pseudo"><block_content>

			<comment type="block">/*
			 * Note: there isn't a good test case for the node-&gt;outerNodeDone
			 * check directly, but we need it for any plan where the outer
			 * node will fail when trying to fetch too many tuples.
			 */</comment>
			<return>return <expr><name>slot</name></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>n_fullsort_remaining</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * When we transition to presorted prefix mode, we might have
			 * accumulated at least one additional prefix key group in the
			 * full sort tuplesort. The first call to
			 * switchToPresortedPrefixMode() will have pulled the first one of
			 * those groups out, and we've returned those tuples to the parent
			 * node, but if at this point we still have tuples remaining in
			 * the full sort state (i.e., n_fullsort_remaining &gt; 0), then we
			 * need to re-execute the prefix mode transition function to pull
			 * out the next prefix key group.
			 */</comment>
			<expr_stmt><expr><call><name>SO1_printf</name><argument_list>(<argument><expr><literal type="string">"Re-calling switchToPresortedPrefixMode() because n_fullsort_remaining is &gt; 0 ("</literal> <name>INT64_FORMAT</name> <literal type="string">")\n"</literal></expr></argument>,
					   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>n_fullsort_remaining</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>switchToPresortedPrefixMode</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * If we don't have any sorted tuples to read and we're not
			 * currently transitioning into presorted prefix sort mode, then
			 * it's time to start the process all over again by building a new
			 * group in the full sort state.
			 */</comment>
			<expr_stmt><expr><call><name>SO_printf</name><argument_list>(<argument><expr><literal type="string">"Setting execution_status to INCSORT_LOADFULLSORT (n_fullsort_remaining &gt; 0)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>execution_status</name></name> <operator>=</operator> <name>INCSORT_LOADFULLSORT</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Scan the subplan in the forward direction while creating the sorted
	 * data.
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_direction</name></name> <operator>=</operator> <name>ForwardScanDirection</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>outerNode</name> <operator>=</operator> <call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>ExecGetResultType</name><argument_list>(<argument><expr><name>outerNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Load tuples into the full sort state. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>execution_status</name></name> <operator>==</operator> <name>INCSORT_LOADFULLSORT</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Initialize sorting structures.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>fullsort_state</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Initialize presorted column support structures for
			 * isCurrentGroup(). It's correct to do this along with the
			 * initial initialization for the full sort state (and not for the
			 * prefix sort state) since we always load the full sort state
			 * first.
			 */</comment>
			<expr_stmt><expr><call><name>preparePresortedCols</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Since we optimize small prefix key groups by accumulating a
			 * minimum number of tuples before sorting, we can't assume that a
			 * group of tuples all have the same prefix key values. Hence we
			 * setup the full sort tuplesort to sort by all requested sort
			 * keys.
			 */</comment>
			<expr_stmt><expr><name>fullsort_state</name> <operator>=</operator> <call><name>tuplesort_begin_heap</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>,
												  <argument><expr><name><name>plannode</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>numCols</name></name></expr></argument>,
												  <argument><expr><name><name>plannode</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>sortColIdx</name></name></expr></argument>,
												  <argument><expr><name><name>plannode</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>sortOperators</name></name></expr></argument>,
												  <argument><expr><name><name>plannode</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>collations</name></name></expr></argument>,
												  <argument><expr><name><name>plannode</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>nullsFirst</name></name></expr></argument>,
												  <argument><expr><name>work_mem</name></expr></argument>,
												  <argument><expr><name>NULL</name></expr></argument>,
												  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>fullsort_state</name></name> <operator>=</operator> <name>fullsort_state</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Reset sort for the next batch. */</comment>
			<expr_stmt><expr><call><name>tuplesort_reset</name><argument_list>(<argument><expr><name>fullsort_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Calculate the remaining tuples left if bounded and configure both
		 * bounded sort and the minimum group size accordingly.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>bounded</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int64</name></type>		<name>currentBound</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>bound</name></name> <operator>-</operator> <name><name>node</name><operator>-&gt;</operator><name>bound_Done</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Bounded sort isn't likely to be a useful optimization for full
			 * sort mode since we limit full sort mode to a relatively small
			 * number of tuples and tuplesort doesn't switch over to top-n
			 * heap sort anyway unless it hits (2 * bound) tuples.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>currentBound</name> <operator>&lt;</operator> <name>DEFAULT_MIN_GROUP_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>tuplesort_set_bound</name><argument_list>(<argument><expr><name>fullsort_state</name></expr></argument>, <argument><expr><name>currentBound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>minGroupSize</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>DEFAULT_MIN_GROUP_SIZE</name></expr></argument>, <argument><expr><name>currentBound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>minGroupSize</name> <operator>=</operator> <name>DEFAULT_MIN_GROUP_SIZE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * Because we have to read the next tuple to find out that we've
		 * encountered a new prefix key group, on subsequent groups we have to
		 * carry over that extra tuple and add it to the new group's sort here
		 * before we read any new tuples from the outer node.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>group_pivot</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>tuplesort_puttupleslot</name><argument_list>(<argument><expr><name>fullsort_state</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>group_pivot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>nTuples</name><operator>++</operator></expr>;</expr_stmt>

			<comment type="block">/*
			 * We're in full sort mode accumulating a minimum number of tuples
			 * and not checking for prefix key equality yet, so we can't
			 * assume the group pivot tuple will reamin the same -- unless
			 * we're using a minimum group size of 1, in which case the pivot
			 * is obviously still the pviot.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>nTuples</name> <operator>!=</operator> <name>minGroupSize</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>group_pivot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>


		<comment type="block">/*
		 * Pull as many tuples from the outer node as possible given our
		 * current operating mode.
		 */</comment>
		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>outerNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If the outer node can't provide us any more tuples, then we can
			 * sort the current group and return those tuples.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * We need to know later if the outer node has completed to be
				 * able to distinguish between being done with a batch and
				 * being done with the whole node.
				 */</comment>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>outerNodeDone</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>SO1_printf</name><argument_list>(<argument><expr><literal type="string">"Sorting fullsort with "</literal> <name>INT64_FORMAT</name> <literal type="string">" tuples\n"</literal></expr></argument>, <argument><expr><name>nTuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>tuplesort_performsort</name><argument_list>(<argument><expr><name>fullsort_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>INSTRUMENT_SORT_GROUP</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>fullsort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>SO_printf</name><argument_list>(<argument><expr><literal type="string">"Setting execution_status to INCSORT_READFULLSORT (final tuple)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>execution_status</name></name> <operator>=</operator> <name>INCSORT_READFULLSORT</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Accumulate the next group of presorted tuples. */</comment>
			<if_stmt><if>if <condition>(<expr><name>nTuples</name> <operator>&lt;</operator> <name>minGroupSize</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * If we haven't yet hit our target minimum group size, then
				 * we don't need to bother checking for inclusion in the
				 * current prefix group since at this point we'll assume that
				 * we'll full sort this batch to avoid a large number of very
				 * tiny (and thus inefficient) sorts.
				 */</comment>
				<expr_stmt><expr><call><name>tuplesort_puttupleslot</name><argument_list>(<argument><expr><name>fullsort_state</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>nTuples</name><operator>++</operator></expr>;</expr_stmt>

				<comment type="block">/*
				 * If we've reached our minimum group size, then we need to
				 * store the most recent tuple as a pivot.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>nTuples</name> <operator>==</operator> <name>minGroupSize</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ExecCopySlot</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>group_pivot</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * If we've already accumulated enough tuples to reach our
				 * minimum group size, then we need to compare any additional
				 * tuples to our pivot tuple to see if we reach the end of
				 * that prefix key group. Only after we find changed prefix
				 * keys can we guarantee sort stability of the tuples we've
				 * already accumulated.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>isCurrentGroup</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>group_pivot</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * As long as the prefix keys match the pivot tuple then
					 * load the tuple into the tuplesort.
					 */</comment>
					<expr_stmt><expr><call><name>tuplesort_puttupleslot</name><argument_list>(<argument><expr><name>fullsort_state</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>nTuples</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * Since the tuple we fetched isn't part of the current
					 * prefix key group we don't want to sort it as part of
					 * the current batch. Instead we use the group_pivot slot
					 * to carry it over to the next batch (even though we
					 * won't actually treat it as a group pivot).
					 */</comment>
					<expr_stmt><expr><call><name>ExecCopySlot</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>group_pivot</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>bounded</name></name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * If the current node has a bound, and we've already
						 * sorted n tuples, then the functional bound
						 * remaining is (original bound - n), so store the
						 * current number of processed tuples for later use
						 * configuring the sort state's bound.
						 */</comment>
						<expr_stmt><expr><call><name>SO2_printf</name><argument_list>(<argument><expr><literal type="string">"Changing bound_Done from "</literal> <name>INT64_FORMAT</name> <literal type="string">" to "</literal> <name>INT64_FORMAT</name> <literal type="string">"\n"</literal></expr></argument>,
								   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>bound_Done</name></name></expr></argument>,
								   <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>bound</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>bound_Done</name></name> <operator>+</operator> <name>nTuples</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>bound_Done</name></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>bound</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>bound_Done</name></name> <operator>+</operator> <name>nTuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * Once we find changed prefix keys we can complete the
					 * sort and transition modes to reading out the sorted
					 * tuples.
					 */</comment>
					<expr_stmt><expr><call><name>SO1_printf</name><argument_list>(<argument><expr><literal type="string">"Sorting fullsort tuplesort with "</literal> <name>INT64_FORMAT</name> <literal type="string">" tuples\n"</literal></expr></argument>,
							   <argument><expr><name>nTuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>tuplesort_performsort</name><argument_list>(<argument><expr><name>fullsort_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>INSTRUMENT_SORT_GROUP</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>fullsort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>SO_printf</name><argument_list>(<argument><expr><literal type="string">"Setting execution_status to INCSORT_READFULLSORT (found end of group)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>execution_status</name></name> <operator>=</operator> <name>INCSORT_READFULLSORT</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/*
			 * Unless we've already transitioned modes to reading from the
			 * full sort state, then we assume that having read at least
			 * DEFAULT_MAX_FULL_SORT_GROUP_SIZE tuples means it's likely we're
			 * processing a large group of tuples all having equal prefix keys
			 * (but haven't yet found the final tuple in that prefix key
			 * group), so we need to transition into presorted prefix mode.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>nTuples</name> <operator>&gt;</operator> <name>DEFAULT_MAX_FULL_SORT_GROUP_SIZE</name> <operator>&amp;&amp;</operator>
				<name><name>node</name><operator>-&gt;</operator><name>execution_status</name></name> <operator>!=</operator> <name>INCSORT_READFULLSORT</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * The group pivot we have stored has already been put into
				 * the tuplesort; we don't want to carry it over. Since we
				 * haven't yet found the end of the prefix key group, it might
				 * seem like we should keep this, but we don't actually know
				 * how many prefix key groups might be represented in the full
				 * sort state, so we'll let the mode transition function
				 * manage this state for us.
				 */</comment>
				<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>group_pivot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Unfortunately the tuplesort API doesn't include a way to
				 * retrieve tuples unless a sort has been performed, so we
				 * perform the sort even though we could just as easily rely
				 * on FIFO retrieval semantics when transferring them to the
				 * presorted prefix tuplesort.
				 */</comment>
				<expr_stmt><expr><call><name>SO1_printf</name><argument_list>(<argument><expr><literal type="string">"Sorting fullsort tuplesort with "</literal> <name>INT64_FORMAT</name> <literal type="string">" tuples\n"</literal></expr></argument>, <argument><expr><name>nTuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>tuplesort_performsort</name><argument_list>(<argument><expr><name>fullsort_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>INSTRUMENT_SORT_GROUP</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>fullsort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If the full sort tuplesort happened to switch into top-n
				 * heapsort mode then we will only be able to retrieve
				 * currentBound tuples (since the tuplesort will have only
				 * retained the top-n tuples). This is safe even though we
				 * haven't yet completed fetching the current prefix key group
				 * because the tuples we've "lost" already sorted "below" the
				 * retained ones, and we're already contractually guaranteed
				 * to not need any more than the currentBound tuples.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>tuplesort_used_bound</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>fullsort_state</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int64</name></type>		<name>currentBound</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>bound</name></name> <operator>-</operator> <name><name>node</name><operator>-&gt;</operator><name>bound_Done</name></name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>SO2_printf</name><argument_list>(<argument><expr><literal type="string">"Read "</literal> <name>INT64_FORMAT</name> <literal type="string">" tuples, but setting to "</literal> <name>INT64_FORMAT</name> <literal type="string">" because we used bounded sort\n"</literal></expr></argument>,
							   <argument><expr><name>nTuples</name></expr></argument>, <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>currentBound</name></expr></argument>, <argument><expr><name>nTuples</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>nTuples</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>currentBound</name></expr></argument>, <argument><expr><name>nTuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>SO1_printf</name><argument_list>(<argument><expr><literal type="string">"Setting n_fullsort_remaining to "</literal> <name>INT64_FORMAT</name> <literal type="string">" and calling switchToPresortedPrefixMode()\n"</literal></expr></argument>,
						   <argument><expr><name>nTuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * We might have multiple prefix key groups in the full sort
				 * state, so the mode transition function needs to know that
				 * it needs to move from the fullsort to presorted prefix
				 * sort.
				 */</comment>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>n_fullsort_remaining</name></name> <operator>=</operator> <name>nTuples</name></expr>;</expr_stmt>

				<comment type="block">/* Transition the tuples to the presorted prefix tuplesort. */</comment>
				<expr_stmt><expr><call><name>switchToPresortedPrefixMode</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Since we know we had tuples to move to the presorted prefix
				 * tuplesort, we know that unless that transition has verified
				 * that all tuples belonged to the same prefix key group (in
				 * which case we can go straight to continuing to load tuples
				 * into that tuplesort), we should have a tuple to return
				 * here.
				 *
				 * Either way, the appropriate execution status should have
				 * been set by switchToPresortedPrefixMode(), so we can drop
				 * out of the loop here and let the appropriate path kick in.
				 */</comment>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>execution_status</name></name> <operator>==</operator> <name>INCSORT_LOADPREFIXSORT</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We only enter this state after the mode transition function has
		 * confirmed all remaining tuples from the full sort state have the
		 * same prefix and moved those tuples to the prefix sort state. That
		 * function has also set a group pivot tuple (which doesn't need to be
		 * carried over; it's already been put into the prefix sort state).
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>group_pivot</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Read tuples from the outer node and load them into the prefix sort
		 * state until we encounter a tuple whose prefix keys don't match the
		 * current group_pivot tuple, since we can't guarantee sort stability
		 * until we have all tuples matching those prefix keys.
		 */</comment>
		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>outerNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If we've exhausted tuples from the outer node we're done
			 * loading the prefix sort state.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * We need to know later if the outer node has completed to be
				 * able to distinguish between being done with a batch and
				 * being done with the whole node.
				 */</comment>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>outerNodeDone</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * If the tuple's prefix keys match our pivot tuple, we're not
			 * done yet and can load it into the prefix sort state. If not, we
			 * don't want to sort it as part of the current batch. Instead we
			 * use the group_pivot slot to carry it over to the next batch
			 * (even though we won't actually treat it as a group pivot).
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>isCurrentGroup</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>group_pivot</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>tuplesort_puttupleslot</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>prefixsort_state</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>nTuples</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>ExecCopySlot</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>group_pivot</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Perform the sort and begin returning the tuples to the parent plan
		 * node.
		 */</comment>
		<expr_stmt><expr><call><name>SO1_printf</name><argument_list>(<argument><expr><literal type="string">"Sorting presorted prefix tuplesort with "</literal> <name>INT64_FORMAT</name> <literal type="string">" tuples\n"</literal></expr></argument>, <argument><expr><name>nTuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>tuplesort_performsort</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>prefixsort_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>INSTRUMENT_SORT_GROUP</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>prefixsort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SO_printf</name><argument_list>(<argument><expr><literal type="string">"Setting execution_status to INCSORT_READPREFIXSORT (found end of group)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>execution_status</name></name> <operator>=</operator> <name>INCSORT_READPREFIXSORT</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>bounded</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If the current node has a bound, and we've already sorted n
			 * tuples, then the functional bound remaining is (original bound
			 * - n), so store the current number of processed tuples for use
			 * in configuring sorting bound.
			 */</comment>
			<expr_stmt><expr><call><name>SO2_printf</name><argument_list>(<argument><expr><literal type="string">"Changing bound_Done from "</literal> <name>INT64_FORMAT</name> <literal type="string">" to "</literal> <name>INT64_FORMAT</name> <literal type="string">"\n"</literal></expr></argument>,
					   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>bound_Done</name></name></expr></argument>,
					   <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>bound</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>bound_Done</name></name> <operator>+</operator> <name>nTuples</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>bound_Done</name></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>bound</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>bound_Done</name></name> <operator>+</operator> <name>nTuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Restore to user specified direction. */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_direction</name></name> <operator>=</operator> <name>dir</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get the first or next tuple from tuplesort. Returns NULL if no more
	 * tuples.
	 */</comment>
	<expr_stmt><expr><name>read_sortstate</name> <operator>=</operator> <ternary><condition><expr><name><name>node</name><operator>-&gt;</operator><name>execution_status</name></name> <operator>==</operator> <name>INCSORT_READFULLSORT</name></expr> ?</condition><then>
		<expr><name>fullsort_state</name></expr> </then><else>: <expr><name><name>node</name><operator>-&gt;</operator><name>prefixsort_state</name></name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>tuplesort_gettupleslot</name><argument_list>(<argument><expr><name>read_sortstate</name></expr></argument>, <argument><expr><call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecInitIncrementalSort
 *
 *		Creates the run-time state information for the sort node
 *		produced by the planner and initializes its outer subtree.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>IncrementalSortState</name> <modifier>*</modifier></type>
<name>ExecInitIncrementalSort</name><parameter_list>(<parameter><decl><type><name>IncrementalSort</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IncrementalSortState</name> <modifier>*</modifier></type><name>incrsortstate</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SO_printf</name><argument_list>(<argument><expr><literal type="string">"ExecInitIncrementalSort: initializing sort node\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Incremental sort can't be used with EXEC_FLAG_BACKWARD or
	 * EXEC_FLAG_MARK, because the current sort state contains only one sort
	 * batch rather than the full result set.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <operator>(</operator><name>EXEC_FLAG_BACKWARD</name> <operator>|</operator> <name>EXEC_FLAG_MARK</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize state structure. */</comment>
	<expr_stmt><expr><name>incrsortstate</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>IncrementalSortState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>incrsortstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>incrsortstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>incrsortstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ExecProcNode</name></name> <operator>=</operator> <name>ExecIncrementalSort</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>incrsortstate</name><operator>-&gt;</operator><name>execution_status</name></name> <operator>=</operator> <name>INCSORT_LOADFULLSORT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>incrsortstate</name><operator>-&gt;</operator><name>bounded</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>incrsortstate</name><operator>-&gt;</operator><name>outerNodeDone</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>incrsortstate</name><operator>-&gt;</operator><name>bound_Done</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>incrsortstate</name><operator>-&gt;</operator><name>fullsort_state</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>incrsortstate</name><operator>-&gt;</operator><name>prefixsort_state</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>incrsortstate</name><operator>-&gt;</operator><name>group_pivot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>incrsortstate</name><operator>-&gt;</operator><name>transfer_tuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>incrsortstate</name><operator>-&gt;</operator><name>n_fullsort_remaining</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>incrsortstate</name><operator>-&gt;</operator><name>presorted_keys</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>incrsortstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>instrument</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IncrementalSortGroupInfo</name> <modifier>*</modifier></type><name>fullsortGroupInfo</name> <init>=
		<expr><operator>&amp;</operator><name><name>incrsortstate</name><operator>-&gt;</operator><name>incsort_info</name><operator>.</operator><name>fullsortGroupInfo</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IncrementalSortGroupInfo</name> <modifier>*</modifier></type><name>prefixsortGroupInfo</name> <init>=
		<expr><operator>&amp;</operator><name><name>incrsortstate</name><operator>-&gt;</operator><name>incsort_info</name><operator>.</operator><name>prefixsortGroupInfo</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>fullsortGroupInfo</name><operator>-&gt;</operator><name>groupCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fullsortGroupInfo</name><operator>-&gt;</operator><name>maxDiskSpaceUsed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fullsortGroupInfo</name><operator>-&gt;</operator><name>totalDiskSpaceUsed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fullsortGroupInfo</name><operator>-&gt;</operator><name>maxMemorySpaceUsed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fullsortGroupInfo</name><operator>-&gt;</operator><name>totalMemorySpaceUsed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fullsortGroupInfo</name><operator>-&gt;</operator><name>sortMethods</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prefixsortGroupInfo</name><operator>-&gt;</operator><name>groupCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prefixsortGroupInfo</name><operator>-&gt;</operator><name>maxDiskSpaceUsed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prefixsortGroupInfo</name><operator>-&gt;</operator><name>totalDiskSpaceUsed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prefixsortGroupInfo</name><operator>-&gt;</operator><name>maxMemorySpaceUsed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prefixsortGroupInfo</name><operator>-&gt;</operator><name>totalMemorySpaceUsed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prefixsortGroupInfo</name><operator>-&gt;</operator><name>sortMethods</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Miscellaneous initialization
	 *
	 * Sort nodes don't initialize their ExprContexts because they never call
	 * ExecQual or ExecProject.
	 */</comment>

	<comment type="block">/*
	 * Initialize child nodes.
	 *
	 * Incremental sort does not support backwards scans and mark/restore, so
	 * we don't bother removing the flags from eflags here. We allow passing a
	 * REWIND flag, because although incremental sort can't use it, the child
	 * nodes may be able to do something more useful.
	 */</comment>
	<expr_stmt><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>incrsortstate</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><call><name>outerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize scan slot and type.
	 */</comment>
	<expr_stmt><expr><call><name>ExecCreateScanSlotFromOuterPlan</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>incrsortstate</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize return slot and type. No need to initialize projection info
	 * because we don't do any projections.
	 */</comment>
	<expr_stmt><expr><call><name>ExecInitResultTupleSlotTL</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>incrsortstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>incrsortstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ProjInfo</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize standalone slots to store a tuple for pivot prefix keys and
	 * for carrying over a tuple from one batch to the next.
	 */</comment>
	<expr_stmt><expr><name><name>incrsortstate</name><operator>-&gt;</operator><name>group_pivot</name></name> <operator>=</operator>
		<call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><call><name>ExecGetResultType</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>incrsortstate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>incrsortstate</name><operator>-&gt;</operator><name>transfer_tuple</name></name> <operator>=</operator>
		<call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><call><name>ExecGetResultType</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>incrsortstate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SO_printf</name><argument_list>(<argument><expr><literal type="string">"ExecInitIncrementalSort: sort node initialized\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>incrsortstate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecEndIncrementalSort(node)
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecEndIncrementalSort</name><parameter_list>(<parameter><decl><type><name>IncrementalSortState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>SO_printf</name><argument_list>(<argument><expr><literal type="string">"ExecEndIncrementalSort: shutting down sort node\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* clean out the scan tuple */</comment>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* must drop pointer to sort result tuple */</comment>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* must drop standalone tuple slots from outer node */</comment>
	<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>group_pivot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>transfer_tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Release tuplesort resources.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>fullsort_state</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>tuplesort_end</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>fullsort_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>fullsort_state</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>prefixsort_state</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>tuplesort_end</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>prefixsort_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>prefixsort_state</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Shut down the subplan.
	 */</comment>
	<expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SO_printf</name><argument_list>(<argument><expr><literal type="string">"ExecEndIncrementalSort: sort node shutdown\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecReScanIncrementalSort</name><parameter_list>(<parameter><decl><type><name>IncrementalSortState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>outerPlan</name> <init>= <expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Incremental sort doesn't support efficient rescan even when parameters
	 * haven't changed (e.g., rewind) because unlike regular sort we don't
	 * store all tuples at once for the full sort.
	 *
	 * So even if EXEC_FLAG_REWIND is set we just reset all of our state and
	 * re-execute the sort along with the child node. Incremental sort itself
	 * can't do anything smarter, but maybe the child nodes can.
	 *
	 * In theory if we've only filled the full sort with one batch (and
	 * haven't reset it for a new batch yet) then we could efficiently rewind,
	 * but that seems a narrow enough case that it's not worth handling
	 * specially at this time.
	 */</comment>

	<comment type="block">/* must drop pointer to sort result tuple */</comment>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>group_pivot</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>group_pivot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>transfer_tuple</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>transfer_tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>outerNodeDone</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>n_fullsort_remaining</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>bound_Done</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>presorted_keys</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>execution_status</name></name> <operator>=</operator> <name>INCSORT_LOADFULLSORT</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we've set up either of the sort states yet, we need to reset them.
	 * We could end them and null out the pointers, but there's no reason to
	 * repay the setup cost, and because ExecIncrementalSort guards presorted
	 * column functions by checking to see if the full sort state has been
	 * initialized yet, setting the sort states to null here might actually
	 * cause a leak.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>fullsort_state</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>tuplesort_reset</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>fullsort_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>fullsort_state</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>prefixsort_state</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>tuplesort_reset</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>prefixsort_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>prefixsort_state</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If chgParam of subnode is not null, theni the plan will be re-scanned
	 * by the first ExecProcNode.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>outerPlan</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecReScan</name><argument_list>(<argument><expr><name>outerPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *						Parallel Query Support
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecSortEstimate
 *
 *		Estimate space required to propagate sort statistics.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecIncrementalSortEstimate</name><parameter_list>(<parameter><decl><type><name>IncrementalSortState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>

	<comment type="block">/* don't need this if not instrumenting or no workers */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>instrument</name></name> <operator>||</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>mul_size</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IncrementalSortInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>SharedIncrementalSortInfo</name></expr></argument>, <argument><expr><name>sinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecSortInitializeDSM
 *
 *		Initialize DSM space for sort statistics.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecIncrementalSortInitializeDSM</name><parameter_list>(<parameter><decl><type><name>IncrementalSortState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>

	<comment type="block">/* don't need this if not instrumenting or no workers */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>instrument</name></name> <operator>||</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>SharedIncrementalSortInfo</name></expr></argument>, <argument><expr><name>sinfo</name></expr></argument>)</argument_list></call>
		<operator>+</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IncrementalSortInfo</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>shared_info</name></name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* ensure any unfilled slots will contain zeroes */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>shared_info</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>shared_info</name><operator>-&gt;</operator><name>num_workers</name></name> <operator>=</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>plan_node_id</name></name></expr></argument>,
				   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>shared_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecSortInitializeWorker
 *
 *		Attach worker to DSM space for sort statistics.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecIncrementalSortInitializeWorker</name><parameter_list>(<parameter><decl><type><name>IncrementalSortState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ParallelWorkerContext</name> <modifier>*</modifier></type><name>pwcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>shared_info</name></name> <operator>=</operator>
		<call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name><name>pwcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>plan_node_id</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>am_worker</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecSortRetrieveInstrumentation
 *
 *		Transfer sort statistics from DSM to private memory.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecIncrementalSortRetrieveInstrumentation</name><parameter_list>(<parameter><decl><type><name>IncrementalSortState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SharedIncrementalSortInfo</name> <modifier>*</modifier></type><name>si</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>shared_info</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>SharedIncrementalSortInfo</name></expr></argument>, <argument><expr><name>sinfo</name></expr></argument>)</argument_list></call>
		<operator>+</operator> <name><name>node</name><operator>-&gt;</operator><name>shared_info</name><operator>-&gt;</operator><name>num_workers</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IncrementalSortInfo</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>si</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>si</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>shared_info</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>shared_info</name></name> <operator>=</operator> <name>si</name></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
