<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/executor/nodeAppend.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * nodeAppend.c
 *	  routines to handle append nodes.
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/executor/nodeAppend.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<comment type="block">/* INTERFACE ROUTINES
 *		ExecInitAppend	- initialize the append node
 *		ExecAppend		- retrieve the next tuple from the node
 *		ExecEndAppend	- shut down the append node
 *		ExecReScanAppend - rescan the append node
 *
 *	 NOTES
 *		Each append node contains a list of one or more subplans which
 *		must be iteratively processed (forwards or backwards).
 *		Tuples are retrieved by executing the 'whichplan'th subplan
 *		until the subplan stops returning tuples, at which point that
 *		plan is shut down and the next started up.
 *
 *		Append nodes don't make use of their left and right
 *		subtrees, rather they maintain a list of subplans so
 *		a typical append node looks like this in the plan tree:
 *
 *				   ...
 *				   /
 *				Append -------+------+------+--- nil
 *				/	\		  |		 |		|
 *			  nil	nil		 ...    ...    ...
 *								 subplans
 *
 *		Append nodes are currently used for unions, and to support
 *		inheritance queries, where several relations need to be scanned.
 *		For example, in our standard person/student/employee/student-emp
 *		example, where student and employee inherit from person
 *		and student-emp inherits from student and employee, the
 *		query:
 *
 *				select name from person
 *
 *		generates the plan:
 *
 *				  |
 *				Append -------+-------+--------+--------+
 *				/	\		  |		  |		   |		|
 *			  nil	nil		 Scan	 Scan	  Scan	   Scan
 *							  |		  |		   |		|
 *							person employee student student-emp
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execdebug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execPartition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeAppend.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/ilist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<typedef>typedef <type><struct>struct <name>AppendContext</name>
<block>{
	<decl_stmt><decl><type><name>dlist_node</name></type>	<name>list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>whichplan</name></decl>;</decl_stmt>
}</block></struct></type> <name>AppendContext</name>;</typedef>


<comment type="block">/* Shared state for parallel-aware Append. */</comment>
<struct>struct <name>ParallelAppendState</name>
<block>{
	<decl_stmt><decl><type><name>LWLock</name></type>		<name>pa_lock</name></decl>;</decl_stmt>		<comment type="block">/* mutual exclusion to choose next subplan */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>pa_next_plan</name></decl>;</decl_stmt>	<comment type="block">/* next plan to choose by any worker */</comment>

	<comment type="block">/*
	 * pa_finished[i] should be true if no more workers should select subplan
	 * i.  for a non-partial plan, this should be set to true as soon as a
	 * worker selects the plan; for a partial plan, it remains false until
	 * some worker executes the plan to completion.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>pa_finished</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALID_SUBPLAN_INDEX</name></cpp:macro>		<cpp:value>-1</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>ExecAppend</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>choose_next_subplan_locally</name><parameter_list>(<parameter><decl><type><name>AppendState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>choose_next_subplan_for_leader</name><parameter_list>(<parameter><decl><type><name>AppendState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>choose_next_subplan_for_worker</name><parameter_list>(<parameter><decl><type><name>AppendState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>mark_invalid_subplans_as_finished</name><parameter_list>(<parameter><decl><type><name>AppendState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecInitAppend
 *
 *		Begin all of the subscans of the append node.
 *
 *	   (This is potentially wasteful, since the entire result of the
 *		append node may not be scanned, but this way all of the
 *		structures get allocated in the executor's top level memory
 *		block instead of that of the call to ExecAppend.)
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>AppendState</name> <modifier>*</modifier></type>
<name>ExecInitAppend</name><parameter_list>(<parameter><decl><type><name>Append</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendState</name> <modifier>*</modifier></type><name>appendstate</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AppendState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name> <modifier>*</modifier><modifier>*</modifier></type><name>appendplanstates</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>validsubplans</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nplans</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>firstvalid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

	<comment type="block">/* check for unsupported flags */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <name>EXEC_FLAG_MARK</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * create new AppendState for our append node
	 */</comment>
	<expr_stmt><expr><name><name>appendstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>appendstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>appendstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ExecProcNode</name></name> <operator>=</operator> <name>ExecAppend</name></expr>;</expr_stmt>

	<comment type="block">/* Let choose_next_subplan_* function handle setting the first subplan */</comment>
	<expr_stmt><expr><name><name>appendstate</name><operator>-&gt;</operator><name>as_whichplan</name></name> <operator>=</operator> <name>INVALID_SUBPLAN_INDEX</name></expr>;</expr_stmt>

	<comment type="block">/* If run-time partition pruning is enabled, then set that up now */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>part_prune_info</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionPruneState</name> <modifier>*</modifier></type><name>prunestate</name></decl>;</decl_stmt>

		<comment type="block">/* We may need an expression context to evaluate partition exprs */</comment>
		<expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>appendstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Create the working data structure for pruning. */</comment>
		<expr_stmt><expr><name>prunestate</name> <operator>=</operator> <call><name>ExecCreatePartitionPruneState</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>appendstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>,
												   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>part_prune_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>appendstate</name><operator>-&gt;</operator><name>as_prune_state</name></name> <operator>=</operator> <name>prunestate</name></expr>;</expr_stmt>

		<comment type="block">/* Perform an initial partition prune, if required. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>prunestate</name><operator>-&gt;</operator><name>do_initial_prune</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Determine which subplans survive initial pruning */</comment>
			<expr_stmt><expr><name>validsubplans</name> <operator>=</operator> <call><name>ExecFindInitialMatchingSubPlans</name><argument_list>(<argument><expr><name>prunestate</name></expr></argument>,
															<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>appendplans</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>nplans</name> <operator>=</operator> <call><name>bms_num_members</name><argument_list>(<argument><expr><name>validsubplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* We'll need to initialize all subplans */</comment>
			<expr_stmt><expr><name>nplans</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>appendplans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nplans</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>validsubplans</name> <operator>=</operator> <call><name>bms_add_range</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nplans</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * When no run-time pruning is required and there's at least one
		 * subplan, we can fill as_valid_subplans immediately, preventing
		 * later calls to ExecFindMatchingSubPlans.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>prunestate</name><operator>-&gt;</operator><name>do_exec_prune</name></name> <operator>&amp;&amp;</operator> <name>nplans</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>appendstate</name><operator>-&gt;</operator><name>as_valid_subplans</name></name> <operator>=</operator> <call><name>bms_add_range</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nplans</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>nplans</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>appendplans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * When run-time partition pruning is not enabled we can just mark all
		 * subplans as valid; they must also all be initialized.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nplans</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>appendstate</name><operator>-&gt;</operator><name>as_valid_subplans</name></name> <operator>=</operator> <name>validsubplans</name> <operator>=</operator>
			<call><name>bms_add_range</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nplans</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>appendstate</name><operator>-&gt;</operator><name>as_prune_state</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Initialize result tuple type and slot.
	 */</comment>
	<expr_stmt><expr><call><name>ExecInitResultTupleSlotTL</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>appendstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* node returns slots from each of its subnodes, therefore not fixed */</comment>
	<expr_stmt><expr><name><name>appendstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>resultopsset</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>appendstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>resultopsfixed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>appendplanstates</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nplans</name> <operator>*</operator>
											 <sizeof>sizeof<argument_list>(<argument><expr><name>PlanState</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * call ExecInitNode on each of the valid plans to be executed and save
	 * the results into the appendplanstates array.
	 *
	 * While at it, find out the first valid partial plan.
	 */</comment>
	<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>firstvalid</name> <operator>=</operator> <name>nplans</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>validsubplans</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>initNode</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>appendplans</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Record the lowest appendplans index which is a valid partial plan.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name><name>node</name><operator>-&gt;</operator><name>first_partial_plan</name></name> <operator>&amp;&amp;</operator> <name>j</name> <operator>&lt;</operator> <name>firstvalid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>firstvalid</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>appendplanstates</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><name>initNode</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><name><name>appendstate</name><operator>-&gt;</operator><name>as_first_partial_plan</name></name> <operator>=</operator> <name>firstvalid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>appendstate</name><operator>-&gt;</operator><name>appendplans</name></name> <operator>=</operator> <name>appendplanstates</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>appendstate</name><operator>-&gt;</operator><name>as_nplans</name></name> <operator>=</operator> <name>nplans</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Miscellaneous initialization
	 */</comment>

	<expr_stmt><expr><name><name>appendstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ProjInfo</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* For parallel query, this will be overridden later. */</comment>
	<expr_stmt><expr><name><name>appendstate</name><operator>-&gt;</operator><name>choose_next_subplan</name></name> <operator>=</operator> <name>choose_next_subplan_locally</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>dlist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>appendstate</name><operator>-&gt;</operator><name>ctxs_head</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>appendstate</name><operator>-&gt;</operator><name>prev_ctx_node</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>appendstate</name><operator>-&gt;</operator><name>ctxs_head</name><operator>.</operator><name>head</name></name></expr>;</expr_stmt>

	<return>return <expr><name>appendstate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *	   ExecAppend
 *
 *		Handles iteration over multiple subplans.
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecAppend</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendState</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AppendState</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>as_whichplan</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Nothing to do if there are no subplans */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>as_nplans</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If no subplan has been chosen, we must choose one before
		 * proceeding.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>as_whichplan</name></name> <operator>==</operator> <name>INVALID_SUBPLAN_INDEX</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name><name>node</name><operator>-&gt;</operator><name>choose_next_subplan</name></name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>subnode</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * figure out which subplan we are currently processing
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>as_whichplan</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>as_whichplan</name></name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>as_nplans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>subnode</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>appendplans</name><index>[<expr><name><name>node</name><operator>-&gt;</operator><name>as_whichplan</name></name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * get a tuple from the subplan
		 */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>subnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If the subplan gave us something then return it as-is. We do
			 * NOT make use of the result slot that was set up in
			 * ExecInitAppend; there's no need for it.
			 */</comment>
			<return>return <expr><name>result</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* choose new subplan; if none, we're done */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>node</name><operator>-&gt;</operator><name>choose_next_subplan</name></name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecEndAppend
 *
 *		Shuts down the subscans of the append node.
 *
 *		Returns nothing of interest.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecEndAppend</name><parameter_list>(<parameter><decl><type><name>AppendState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlanState</name> <modifier>*</modifier><modifier>*</modifier></type><name>appendplans</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nplans</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_mutable_iter</name></type> <name>iter</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * get information from the node
	 */</comment>
	<expr_stmt><expr><name>appendplans</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>appendplans</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nplans</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>as_nplans</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * shut down each of the subscans
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nplans</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><name><name>appendplans</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<macro><name>dlist_foreach_modify</name><argument_list>(<argument>iter</argument>, <argument>&amp;node-&gt;ctxs_head</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AppendContext</name> <modifier>*</modifier></type><name>ctx</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ctx</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>AppendContext</name></expr></argument>, <argument><expr><name>list</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>prev_ctx_node</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ctxs_head</name><operator>.</operator><name>head</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecReScanAppend</name><parameter_list>(<parameter><decl><type><name>AppendState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If any PARAM_EXEC Params used in pruning expressions have changed, then
	 * we'd better unset the valid subplans so that they are reselected for
	 * the new parameter values.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>as_prune_state</name></name> <operator>&amp;&amp;</operator>
		<call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>chgParam</name></name></expr></argument>,
					<argument><expr><name><name>node</name><operator>-&gt;</operator><name>as_prune_state</name><operator>-&gt;</operator><name>execparamids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>as_valid_subplans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>as_valid_subplans</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>as_nplans</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>subnode</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>appendplans</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * ExecReScan doesn't know about my subplans, so I have to do
		 * changed-parameter signaling myself.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>chgParam</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>UpdateChangedParamSet</name><argument_list>(<argument><expr><name>subnode</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>chgParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If chgParam of subnode is not null then plan will be re-scanned by
		 * first ExecProcNode.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>subnode</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecReScan</name><argument_list>(<argument><expr><name>subnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Let choose_next_subplan_* function handle setting the first subplan */</comment>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>as_whichplan</name></name> <operator>=</operator> <name>INVALID_SUBPLAN_INDEX</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *						Parallel Append Support
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecAppendEstimate
 *
 *		Compute the amount of space we'll need in the parallel
 *		query DSM, and inform pcxt-&gt;estimator about our needs.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecAppendEstimate</name><parameter_list>(<parameter><decl><type><name>AppendState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
				   <parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>pstate_len</name></name> <operator>=</operator>
		<call><name>add_size</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ParallelAppendState</name></expr></argument>, <argument><expr><name>pa_finished</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>node</name><operator>-&gt;</operator><name>as_nplans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>pstate_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------
 *		ExecAppendInitializeDSM
 *
 *		Set up shared state for Parallel Append.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecAppendInitializeDSM</name><parameter_list>(<parameter><decl><type><name>AppendState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
						<parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParallelAppendState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>pstate_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>pstate_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>pa_lock</name></name></expr></argument>, <argument><expr><name>LWTRANCHE_PARALLEL_APPEND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>plan_node_id</name></name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>as_pstate</name></name> <operator>=</operator> <name>pstate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>choose_next_subplan</name></name> <operator>=</operator> <name>choose_next_subplan_for_leader</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecAppendReInitializeDSM
 *
 *		Reset shared state before beginning a fresh scan.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecAppendReInitializeDSM</name><parameter_list>(<parameter><decl><type><name>AppendState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParallelAppendState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>as_pstate</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>pa_next_plan</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>pa_finished</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>node</name><operator>-&gt;</operator><name>as_nplans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecAppendInitializeWorker
 *
 *		Copy relevant information from TOC into planstate, and initialize
 *		whatever is required to choose and execute the optimal subplan.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecAppendInitializeWorker</name><parameter_list>(<parameter><decl><type><name>AppendState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ParallelWorkerContext</name> <modifier>*</modifier></type><name>pwcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>as_pstate</name></name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name><name>pwcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>plan_node_id</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>choose_next_subplan</name></name> <operator>=</operator> <name>choose_next_subplan_for_worker</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		choose_next_subplan_locally
 *
 *		Choose next subplan for a non-parallel-aware Append,
 *		returning false if there are no more.
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>choose_next_subplan_locally</name><parameter_list>(<parameter><decl><type><name>AppendState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>whichplan</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>as_whichplan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nextplan</name></decl>;</decl_stmt>

	<comment type="block">/* We should never be called when there are no subplans */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>as_nplans</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If first call then have the bms member function choose the first valid
	 * subplan by initializing whichplan to -1.  If there happen to be no
	 * valid subplans then the bms member function will handle that by
	 * returning a negative number which will allow us to exit returning a
	 * false value.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>whichplan</name> <operator>==</operator> <name>INVALID_SUBPLAN_INDEX</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>as_valid_subplans</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>as_valid_subplans</name></name> <operator>=</operator>
				<call><name>ExecFindMatchingSubPlans</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>as_prune_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>whichplan</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Ensure whichplan is within the expected range */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>whichplan</name> <operator>&gt;=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>whichplan</name> <operator>&lt;=</operator> <name><name>node</name><operator>-&gt;</operator><name>as_nplans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>es_direction</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nextplan</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>as_valid_subplans</name></name></expr></argument>, <argument><expr><name>whichplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>nextplan</name> <operator>=</operator> <call><name>bms_prev_member</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>as_valid_subplans</name></name></expr></argument>, <argument><expr><name>whichplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>nextplan</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>as_whichplan</name></name> <operator>=</operator> <name>nextplan</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		choose_next_subplan_for_leader
 *
 *      Try to pick a plan which doesn't commit us to doing much
 *      work locally, so that as much work as possible is done in
 *      the workers.  Cheapest subplans are at the end.
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>choose_next_subplan_for_leader</name><parameter_list>(<parameter><decl><type><name>AppendState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParallelAppendState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>as_pstate</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Backward scan is not supported by parallel-aware plans */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>es_direction</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We should never be called when there are no subplans */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>as_nplans</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>pa_lock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>as_whichplan</name></name> <operator>!=</operator> <name>INVALID_SUBPLAN_INDEX</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Mark just-completed subplan as finished. */</comment>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>as_pstate</name><operator>-&gt;</operator><name>pa_finished</name><index>[<expr><name><name>node</name><operator>-&gt;</operator><name>as_whichplan</name></name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Start with last subplan. */</comment>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>as_whichplan</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>as_nplans</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we've yet to determine the valid subplans then do so now.  If
		 * run-time pruning is disabled then the valid subplans will always be
		 * set to all subplans.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>as_valid_subplans</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>as_valid_subplans</name></name> <operator>=</operator>
				<call><name>ExecFindMatchingSubPlans</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>as_prune_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Mark each invalid plan as finished to allow the loop below to
			 * select the first valid subplan.
			 */</comment>
			<expr_stmt><expr><call><name>mark_invalid_subplans_as_finished</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Loop until we find a subplan to execute. */</comment>
	<while>while <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>pa_finished</name><index>[<expr><name><name>node</name><operator>-&gt;</operator><name>as_whichplan</name></name></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>as_whichplan</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>pa_next_plan</name></name> <operator>=</operator> <name>INVALID_SUBPLAN_INDEX</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>as_whichplan</name></name> <operator>=</operator> <name>INVALID_SUBPLAN_INDEX</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>pa_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We needn't pay attention to as_valid_subplans here as all invalid
		 * plans have been marked as finished.
		 */</comment>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>as_whichplan</name></name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* If non-partial, immediately mark as finished. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>as_whichplan</name></name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>as_first_partial_plan</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>as_pstate</name><operator>-&gt;</operator><name>pa_finished</name><index>[<expr><name><name>node</name><operator>-&gt;</operator><name>as_whichplan</name></name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>pa_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		choose_next_subplan_for_worker
 *
 *		Choose next subplan for a parallel-aware Append, returning
 *		false if there are no more.
 *
 *		We start from the first plan and advance through the list;
 *		when we get back to the end, we loop back to the first
 *		partial plan.  This assigns the non-partial plans first in
 *		order of descending cost and then spreads out the workers
 *		as evenly as possible across the remaining partial plans.
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>choose_next_subplan_for_worker</name><parameter_list>(<parameter><decl><type><name>AppendState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParallelAppendState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>as_pstate</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Backward scan is not supported by parallel-aware plans */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>es_direction</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We should never be called when there are no subplans */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>as_nplans</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>pa_lock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Mark just-completed subplan as finished. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>as_whichplan</name></name> <operator>!=</operator> <name>INVALID_SUBPLAN_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>as_pstate</name><operator>-&gt;</operator><name>pa_finished</name><index>[<expr><name><name>node</name><operator>-&gt;</operator><name>as_whichplan</name></name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>

	<comment type="block">/*
	 * If we've yet to determine the valid subplans then do so now.  If
	 * run-time pruning is disabled then the valid subplans will always be set
	 * to all subplans.
	 */</comment>
	<if type="elseif">else if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>as_valid_subplans</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>as_valid_subplans</name></name> <operator>=</operator>
			<call><name>ExecFindMatchingSubPlans</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>as_prune_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>mark_invalid_subplans_as_finished</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If all the plans are already done, we have nothing to do */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>pa_next_plan</name></name> <operator>==</operator> <name>INVALID_SUBPLAN_INDEX</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>pa_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Save the plan from which we are starting the search. */</comment>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>as_whichplan</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>pa_next_plan</name></name></expr>;</expr_stmt>

	<comment type="block">/* Loop until we find a valid subplan to execute. */</comment>
	<while>while <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>pa_finished</name><index>[<expr><name><name>pstate</name><operator>-&gt;</operator><name>pa_next_plan</name></name></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>nextplan</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>nextplan</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>as_valid_subplans</name></name></expr></argument>,
								   <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>pa_next_plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>nextplan</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Advance to the next valid plan. */</comment>
			<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>pa_next_plan</name></name> <operator>=</operator> <name>nextplan</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>as_whichplan</name></name> <operator>&gt;</operator> <name><name>node</name><operator>-&gt;</operator><name>as_first_partial_plan</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Try looping back to the first valid partial plan, if there is
			 * one.  If there isn't, arrange to bail out below.
			 */</comment>
			<expr_stmt><expr><name>nextplan</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>as_valid_subplans</name></name></expr></argument>,
									   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>as_first_partial_plan</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>pa_next_plan</name></name> <operator>=</operator>
				<ternary><condition><expr><name>nextplan</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>node</name><operator>-&gt;</operator><name>as_whichplan</name></name></expr> </then><else>: <expr><name>nextplan</name></expr></else></ternary></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * At last plan, and either there are no partial plans or we've
			 * tried them all.  Arrange to bail out.
			 */</comment>
			<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>pa_next_plan</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>as_whichplan</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>pa_next_plan</name></name> <operator>==</operator> <name><name>node</name><operator>-&gt;</operator><name>as_whichplan</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* We've tried everything! */</comment>
			<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>pa_next_plan</name></name> <operator>=</operator> <name>INVALID_SUBPLAN_INDEX</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>pa_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Pick the plan we found, and advance pa_next_plan one more time. */</comment>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>as_whichplan</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>pa_next_plan</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>pa_next_plan</name></name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>as_valid_subplans</name></name></expr></argument>,
										   <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>pa_next_plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there are no more valid plans then try setting the next plan to the
	 * first valid partial plan.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>pa_next_plan</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>nextplan</name> <init>= <expr><call><name>bms_next_member</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>as_valid_subplans</name></name></expr></argument>,
											   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>as_first_partial_plan</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>nextplan</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>pa_next_plan</name></name> <operator>=</operator> <name>nextplan</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * There are no valid partial plans, and we already chose the last
			 * non-partial plan; so flag that there's nothing more for our
			 * fellow workers to do.
			 */</comment>
			<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>pa_next_plan</name></name> <operator>=</operator> <name>INVALID_SUBPLAN_INDEX</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If non-partial, immediately mark as finished. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>as_whichplan</name></name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>as_first_partial_plan</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>as_pstate</name><operator>-&gt;</operator><name>pa_finished</name><index>[<expr><name><name>node</name><operator>-&gt;</operator><name>as_whichplan</name></name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>pa_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * mark_invalid_subplans_as_finished
 *		Marks the ParallelAppendState's pa_finished as true for each invalid
 *		subplan.
 *
 * This function should only be called for parallel Append with run-time
 * pruning enabled.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>mark_invalid_subplans_as_finished</name><parameter_list>(<parameter><decl><type><name>AppendState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Only valid to call this while in parallel Append mode */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>as_pstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Shouldn't have been called when run-time pruning is not enabled */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>as_prune_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Nothing to do if all plans are valid */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>bms_num_members</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>as_valid_subplans</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>node</name><operator>-&gt;</operator><name>as_nplans</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Mark all non-valid plans as finished */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>as_nplans</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>as_valid_subplans</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>as_pstate</name><operator>-&gt;</operator><name>pa_finished</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecNextAppendContext</name><parameter_list>(<parameter><decl><type><name>AppendState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dlist_node</name> <modifier>*</modifier></type><name>ctx_node</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AppendContext</name> <modifier>*</modifier></type><name>ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* get the current context */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>dlist_has_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ctxs_head</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>prev_ctx_node</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ctx_node</name> <operator>=</operator> <call><name>dlist_next_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ctxs_head</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>prev_ctx_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ctx</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>AppendContext</name></expr></argument>, <argument><expr><name>list</name></expr></argument>, <argument><expr><name>ctx_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>ctx</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ctx_node</name> <operator>=</operator> <operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>list</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ctxs_head</name></name></expr></argument>, <argument><expr><name>ctx_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>whichplan</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>as_whichplan</name></name></expr>;</expr_stmt>

	<comment type="block">/* make the current context previous context */</comment>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>prev_ctx_node</name></name> <operator>=</operator> <name>ctx_node</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We don't have to restore the current as_whichplan because it is an
	 * integer value and will be initialized when the current Append is
	 * re-scanned next time.
	 */</comment>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>as_nplans</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecNextContext</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>appendplans</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecPrevAppendContext</name><parameter_list>(<parameter><decl><type><name>AppendState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dlist_node</name> <modifier>*</modifier></type><name>ctx_node</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AppendContext</name> <modifier>*</modifier></type><name>ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We don't have to store the current as_whichplan because of the same
	 * reason above.
	 */</comment>

	<comment type="block">/* if chgParam is not NULL, free it now */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>chgParam</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>chgParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>chgParam</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* make the previous context current context */</comment>
	<expr_stmt><expr><name>ctx_node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>prev_ctx_node</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ctx_node</name> <operator>!=</operator> <operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ctxs_head</name><operator>.</operator><name>head</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>dlist_has_prev</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ctxs_head</name></name></expr></argument>, <argument><expr><name>ctx_node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>prev_ctx_node</name></name> <operator>=</operator> <call><name>dlist_prev_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ctxs_head</name></name></expr></argument>, <argument><expr><name>ctx_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>prev_ctx_node</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ctxs_head</name><operator>.</operator><name>head</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>ctx</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>AppendContext</name></expr></argument>, <argument><expr><name>list</name></expr></argument>, <argument><expr><name>ctx_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>as_whichplan</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>whichplan</name></name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>as_nplans</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecPrevContext</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>appendplans</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>
</unit>
