<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/executor/nodeModifyGraph.c"><comment type="block">/*
 * nodeModifyGraph.c
 *	  routines to handle ModifyGraph nodes.
 *
 * Copyright (c) 2016 by Bitnine Global, Inc.
 *
 * IDENTIFICATION
 *	  src/backend/executor/nodeModifyGraph.c
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/ag_graph_fn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeModifyGraph.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/graphnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/arrayaccess.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/graph.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/jsonb.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tuplestore.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>bool</name></type>		<name>enable_multiple_update</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>auto_gather_graphmeta</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* hash entry */</comment>
<typedef>typedef <type><struct>struct <name>ModifiedElemEntry</name>
<block>{
	<decl_stmt><decl><type><name>Graphid</name></type>		<name>key</name></decl>;</decl_stmt>
	<union>union
	<block>{
		<decl_stmt><decl><type><name>Datum</name></type>			<name>elem</name></decl>;</decl_stmt>	<comment type="block">/* modified graph element */</comment>
		<decl_stmt><decl><type><name>ItemPointerData</name></type>	<name>tid</name></decl>;</decl_stmt>	<comment type="block">/* use to find tuple in delete plan */</comment>
	}</block> <decl><name>data</name></decl>;</union>
}</block></struct></type> <name>ModifiedElemEntry</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>ExecModifyGraph</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>initGraphWRStats</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>, <parameter><decl><type><name>GraphWriteOp</name></type> <name>op</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>ExecInitGraphPattern</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>ExecInitGraphSets</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sets</name></decl></parameter>, <parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>ExecInitGraphDelExprs</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprs</name></decl></parameter>, <parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* CREATE */</comment>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>ExecCreateGraph</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>,
									   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>createPath</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>, <parameter><decl><type><name>GraphPath</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
								  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>createVertex</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>, <parameter><decl><type><name>GraphVertex</name> <modifier>*</modifier></type><name>gvertex</name></decl></parameter>,
						  <parameter><decl><type><name>Graphid</name> <modifier>*</modifier></type><name>vid</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inPath</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>createEdge</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>, <parameter><decl><type><name>GraphEdge</name> <modifier>*</modifier></type><name>gedge</name></decl></parameter>,
						<parameter><decl><type><name>Graphid</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>Graphid</name></type> <name>end</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>inPath</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* DELETE */</comment>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>ExecDeleteGraph</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>,
									   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>isDetachRequired</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>isEdgeArrayOfPath</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprs</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>variable</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deleteElem</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>gid</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>,
					   <parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* SET */</comment>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>ExecSetGraph</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>, <parameter><decl><type><name>GSPKind</name></type> <name>kind</name></decl></parameter>,
									<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>copyVirtualTupleTableSlot</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>dstslot</name></decl></parameter>,
												 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>srcslot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>findAndReflectNewestValue</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>,
									  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
									  <parameter><decl><type><name>bool</name></type> <name>free_slot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ItemPointer</name></type> <name>updateElemProp</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>elemtype</name></decl></parameter>,
								  <parameter><decl><type><name>Datum</name></type> <name>gid</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>elem_datum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>makeModifiedElem</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>elem</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>elemtype</name></decl></parameter>,
							  <parameter><decl><type><name>Datum</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>prop_map</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>tid</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* MERGE */</comment>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>ExecMergeGraph</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>,
									  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>isMatchedMergePattern</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>createMergePath</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>,
									   <parameter><decl><type><name>GraphPath</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>createMergeVertex</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>,
							   <parameter><decl><type><name>GraphVertex</name> <modifier>*</modifier></type><name>gvertex</name></decl></parameter>,
							   <parameter><decl><type><name>Graphid</name> <modifier>*</modifier></type><name>vid</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>createMergeEdge</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>, <parameter><decl><type><name>GraphEdge</name> <modifier>*</modifier></type><name>gedge</name></decl></parameter>,
							 <parameter><decl><type><name>Graphid</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>Graphid</name></type> <name>end</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* eager */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>enterSetPropTable</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>gid</name></decl></parameter>,
							  <parameter><decl><type><name>Datum</name></type> <name>newelem</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>enterDelPropTable</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>elem</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>getVertexFinal</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>origin</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>getEdgeFinal</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>origin</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>getPathFinal</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>origin</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>reflectModifiedProp</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* common */</comment>
<function_decl><type><specifier>static</specifier> <name>ResultRelInfo</name> <modifier>*</modifier></type><name>getResultRelInfo</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>findVertex</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>GraphVertex</name> <modifier>*</modifier></type><name>gvertex</name></decl></parameter>, <parameter><decl><type><name>Graphid</name> <modifier>*</modifier></type><name>vid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>findEdge</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>GraphEdge</name> <modifier>*</modifier></type><name>gedge</name></decl></parameter>, <parameter><decl><type><name>Graphid</name> <modifier>*</modifier></type><name>eid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>AttrNumber</name></type> <name>findAttrInSlotByName</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setSlotValueByName</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setSlotValueByAttnum</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name> <modifier>*</modifier></type><name>makeDatumArray</name><parameter_list>(<parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>fitEStateRangeTable</name><parameter_list>(<parameter><decl><type><name>EState</name><modifier>*</modifier></type> <name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>fitEStateRelations</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>newsize</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* global variable - see postgres.c */</comment>
<decl_stmt><decl><type><specifier>extern</specifier> <name>GraphWriteStats</name></type> <name>graphWriteStats</name></decl>;</decl_stmt>

<function><type><name>ModifyGraphState</name> <modifier>*</modifier></type>
<name>ExecInitModifyGraph</name><parameter_list>(<parameter><decl><type><name>ModifyGraph</name> <modifier>*</modifier></type><name>mgplan</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommandId</name></type>	<name>svCid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <operator>(</operator><name>EXEC_FLAG_BACKWARD</name> <operator>|</operator> <name>EXEC_FLAG_MARK</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>mgstate</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ModifyGraphState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mgstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>mgplan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mgstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mgstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ExecProcNode</name></name> <operator>=</operator> <name>ExecModifyGraph</name></expr>;</expr_stmt>

	<comment type="block">/* Tuple desc for result is the same as the subplan. */</comment>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecAllocTableSlot</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>estate</name><operator>-&gt;</operator><name>es_tupleTable</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mgstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We don't use ExecInitResultTypeTL because we need to get the
	 * information of the subplan, not the current plan.
	 */</comment>
	<expr_stmt><expr><name><name>mgstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleDesc</name></name> <operator>=</operator> <call><name>ExecTypeFromTL</name><argument_list>(<argument><expr><name><name>mgplan</name><operator>-&gt;</operator><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecSetSlotDescriptor</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>mgstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mgstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>mgstate</name><operator>-&gt;</operator><name>done</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mgstate</name><operator>-&gt;</operator><name>child_done</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mgstate</name><operator>-&gt;</operator><name>eagerness</name></name> <operator>=</operator> <name><name>mgplan</name><operator>-&gt;</operator><name>eagerness</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mgstate</name><operator>-&gt;</operator><name>modify_cid</name></name> <operator>=</operator> <call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>+</operator>
						  <operator>(</operator><name><name>mgplan</name><operator>-&gt;</operator><name>nr_modify</name></name> <operator>*</operator> <name>MODIFY_CID_MAX</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Pass the lower limit of the CID of the current clause to the previous
	 * clause as a default CID of it.
	 */</comment>
	<expr_stmt><expr><name>svCid</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name><operator>-&gt;</operator><name>curcid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name><operator>-&gt;</operator><name>curcid</name></name> <operator>=</operator> <name><name>mgstate</name><operator>-&gt;</operator><name>modify_cid</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>mgstate</name><operator>-&gt;</operator><name>subplan</name></name> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><name><name>mgplan</name><operator>-&gt;</operator><name>subplan</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name><name>mgplan</name><operator>-&gt;</operator><name>operation</name></name> <operator>!=</operator> <name>GWROP_MERGE</name> <operator>||</operator>
			  <call><name>IsA</name><argument_list>(<argument><expr><name><name>mgstate</name><operator>-&gt;</operator><name>subplan</name></name></expr></argument>, <argument><expr><name>NestLoopState</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name><operator>-&gt;</operator><name>curcid</name></name> <operator>=</operator> <name>svCid</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>mgstate</name><operator>-&gt;</operator><name>elemTupleSlot</name></name> <operator>=</operator> <call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>mgstate</name><operator>-&gt;</operator><name>graphid</name></name> <operator>=</operator> <call><name>get_graph_path_oid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>mgstate</name><operator>-&gt;</operator><name>pattern</name></name> <operator>=</operator> <call><name>ExecInitGraphPattern</name><argument_list>(<argument><expr><name><name>mgplan</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>, <argument><expr><name>mgstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check to see if we have RTEs to add to the es_range_table. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>mgplan</name><operator>-&gt;</operator><name>targets</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If the ert_base_index is equal to es_range_table_size then we need
		 * to add our RTEs to the end of the es_range_table. Otherwise, we just
		 * need to link the resultRels to their RTEs. In the later case we
		 * don't need to search the es_range_table for our RTEs because we
		 * already know the order and the base offset.
		 */</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>build_new_range_table</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfos</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>targets_length</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>mgplan</name><operator>-&gt;</operator><name>targets</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>rtindex</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * RTEs need to be added to the es_range_table using the
		 * proper memory context due to cached plans. So, we need to
		 * retrieve the context of the ModifyGraph plan and use that
		 * for adding RTEs.
		 */</comment>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>rtemctx</name> <init>= <expr><call><name>GetMemoryChunkContext</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>mgplan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Allocate our stuff in the Executor memory context. */</comment>
		<expr_stmt><expr><name>resultRelInfos</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>targets_length</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ResultRelInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we added RTEs to the es_range_table, but not all of them,
		 * free and truncate the es_range_table from this point. This will
		 * not effect parent plans, as they would not have added RTEs yet.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>mgplan</name><operator>-&gt;</operator><name>ert_rtes_added</name></name> <operator>!=</operator> <name>targets_length</name> <operator>&amp;&amp;</operator>
			<name><name>mgplan</name><operator>-&gt;</operator><name>ert_rtes_added</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
			<name><name>mgplan</name><operator>-&gt;</operator><name>ert_base_index</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fitEStateRangeTable</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>mgplan</name><operator>-&gt;</operator><name>ert_base_index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* save the es_range_table index where we start adding our RTEs */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>mgplan</name><operator>-&gt;</operator><name>ert_base_index</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>mgplan</name><operator>-&gt;</operator><name>ert_base_index</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_range_table_size</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>build_new_range_table</name> <operator>=</operator>
				<operator>(</operator><name><name>mgplan</name><operator>-&gt;</operator><name>ert_base_index</name></name> <operator>==</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_range_table_size</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <name>targets_length</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>build_new_range_table</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fitEStateRelations</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_range_table_size</name></name> <operator>+</operator>
									   <name>targets_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>rtindex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<comment type="block">/* Process each new RTE to add. */</comment>
		<macro><name>foreach</name><argument_list>(<argument>lt</argument>, <argument>mgplan-&gt;targets</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<comment type="block">/* open relation in Executor context */</comment>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<comment type="block">/* Switch to the memory context for building RTEs */</comment>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldmctx</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>rtemctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * If the ert_base_index is equal to numOldRtable then we need
			 * to add our RTEs to the end of the es_range_table. Otherwise,
			 * we just need to link the resultRels to their RTEs. In the later
			 * case we don't need to search the es_range_table for our RTEs
			 * because we already know the order and the base offset.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>build_new_range_table</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>our_nsitem</name> <init>= <expr><call><name>addRangeTableEntryForRelation</name>
						<argument_list>(<argument><expr><name>pstate</name></expr></argument>,
						 <argument><expr><name>relation</name></expr></argument>,
						 <argument><expr><name>AccessShareLock</name></expr></argument>,
						 <argument><expr><name>NULL</name></expr></argument>,
						 <argument><expr><name>false</name></expr></argument>,
						 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>our_rte</name> <init>= <expr><name><name>our_nsitem</name><operator>-&gt;</operator><name>p_rte</name></name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * remove the cell containing the RTE from pstate and reset
				 * the list p_rtable to NIL
				 */</comment>
				<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>our_rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <name>ACL_INSERT</name></expr>;</expr_stmt>

				<comment type="block">/* Now add in our RTE */</comment>
				<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_range_table</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_range_table</name></name></expr></argument>, <argument><expr><name>our_rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_relations</name><index>[<expr><name><name>mgplan</name><operator>-&gt;</operator><name>ert_base_index</name></name> <operator>+</operator> <name>rtindex</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>our_rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ExecGetRangeTableRelation</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>mgplan</name><operator>-&gt;</operator><name>ert_base_index</name></name> <operator>+</operator> <name>rtindex</name> <operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* increment the number of RTEs we've added */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>mgplan</name><operator>-&gt;</operator><name>ert_rtes_added</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>mgplan</name><operator>-&gt;</operator><name>ert_rtes_added</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>mgplan</name><operator>-&gt;</operator><name>ert_rtes_added</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>our_nsitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Now switch back to the Executor context to finish building
			 * our structures. We need to do this so that our stuff gets
			 * cleaned up after an abrupt exit, at the end of the Executor
			 * context, or in ExecEndModifyGraph.
			 */</comment>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldmctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>InitResultRelInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>resultRelInfos</name><index>[<expr><name>rtindex</name></expr>]</index></name></expr></argument>,
							  <argument><expr><name>relation</name></expr></argument>,
							  <argument><expr><operator>(</operator><name><name>mgplan</name><operator>-&gt;</operator><name>ert_base_index</name></name> <operator>+</operator> <name>rtindex</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_instrument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ExecOpenIndices</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>resultRelInfos</name><index>[<expr><name>rtindex</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rtindex</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><name><name>mgstate</name><operator>-&gt;</operator><name>resultRelations</name></name> <operator>=</operator> <name>resultRelInfos</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mgstate</name><operator>-&gt;</operator><name>numResultRelations</name></name> <operator>=</operator> <name>targets_length</name></expr>;</expr_stmt>

		<comment type="block">/* es_result_relation_info is NULL except ModifyTable case */</comment>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>free_parsestate</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>mgstate</name><operator>-&gt;</operator><name>exprs</name></name> <operator>=</operator> <call><name>ExecInitGraphDelExprs</name><argument_list>(<argument><expr><name><name>mgplan</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>, <argument><expr><name>mgstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mgstate</name><operator>-&gt;</operator><name>sets</name></name> <operator>=</operator> <call><name>ExecInitGraphSets</name><argument_list>(<argument><expr><name><name>mgplan</name><operator>-&gt;</operator><name>sets</name></name></expr></argument>, <argument><expr><name>mgstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initGraphWRStats</name><argument_list>(<argument><expr><name>mgstate</name></expr></argument>, <argument><expr><name><name>mgplan</name><operator>-&gt;</operator><name>operation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>mgstate</name><operator>-&gt;</operator><name>eagerness</name></name> <operator>||</operator>
		<operator>(</operator><name><name>mgstate</name><operator>-&gt;</operator><name>sets</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name>enable_multiple_update</name><operator>)</operator> <operator>||</operator>
		<name><name>mgstate</name><operator>-&gt;</operator><name>exprs</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HASHCTL</name></type> <name>ctl</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Graphid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ModifiedElemEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>mgstate</name><operator>-&gt;</operator><name>elemTable</name></name> <operator>=</operator>
				<call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"modified object table"</literal></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>,
							<argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>mgstate</name><operator>-&gt;</operator><name>elemTable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>mgstate</name><operator>-&gt;</operator><name>tuplestorestate</name></name> <operator>=</operator> <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>eager_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>mgstate</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecModifyGraph</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>ModifyGraphState</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ModifyGraph</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>ModifyGraph</name> <operator>*</operator><operator>)</operator> <name><name>mgstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>mgstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>mgstate</name><operator>-&gt;</operator><name>done</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>mgstate</name><operator>-&gt;</operator><name>child_done</name></name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>CommandId</name></type>	<name>svCid</name></decl>;</decl_stmt>

			<comment type="block">/* ExecInsertIndexTuples() uses per-tuple context. Reset it here. */</comment>
			<expr_stmt><expr><call><name>ResetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* pass lower bound CID to subplan */</comment>
			<expr_stmt><expr><name>svCid</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name><operator>-&gt;</operator><name>curcid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name><operator>-&gt;</operator><name>curcid</name></name> <operator>=</operator>
					<name><name>mgstate</name><operator>-&gt;</operator><name>modify_cid</name></name> <operator>+</operator> <name>MODIFY_CID_LOWER_BOUND</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name><name>mgstate</name><operator>-&gt;</operator><name>subplan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name><operator>-&gt;</operator><name>curcid</name></name> <operator>=</operator> <name>svCid</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<switch>switch <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>operation</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>GWROP_CREATE</name></expr>:</case>
					<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecCreateGraph</name><argument_list>(<argument><expr><name>mgstate</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>GWROP_DELETE</name></expr>:</case>
					<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecDeleteGraph</name><argument_list>(<argument><expr><name>mgstate</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>GWROP_SET</name></expr>:</case>
					<block>{<block_content>
						<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>mgstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>

						<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecSetGraph</name><argument_list>(<argument><expr><name>mgstate</name></expr></argument>, <argument><expr><name>GSP_NORMAL</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block>
					<break>break;</break>
				<case>case <expr><name>GWROP_MERGE</name></expr>:</case>
					<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecMergeGraph</name><argument_list>(<argument><expr><name>mgstate</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown operation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>

			<if_stmt><if>if <condition>(<expr><name><name>mgstate</name><operator>-&gt;</operator><name>eagerness</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>tuplestore_puttupleslot</name><argument_list>(<argument><expr><name><name>mgstate</name><operator>-&gt;</operator><name>tuplestorestate</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><name>slot</name></expr>;</return>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>last</name></name> <operator>==</operator> <name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name><name>mgstate</name><operator>-&gt;</operator><name>child_done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>mgstate</name><operator>-&gt;</operator><name>elemTable</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>reflectModifiedProp</name><argument_list>(<argument><expr><name>mgstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>mgstate</name><operator>-&gt;</operator><name>eagerness</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>natts</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/* don't care about scan direction */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>mgstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name><name>mgstate</name><operator>-&gt;</operator><name>tuplestorestate</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>slot_getallattrs</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>mgstate</name><operator>-&gt;</operator><name>elemTable</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
			<call><name>hash_get_num_entries</name><argument_list>(<argument><expr><name><name>mgstate</name><operator>-&gt;</operator><name>elemTable</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>natts</name> <operator>=</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>type</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>elem</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>VERTEXOID</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>elem</name> <operator>=</operator> <call><name>getVertexFinal</name><argument_list>(<argument><expr><name>mgstate</name></expr></argument>, <argument><expr><name><name>result</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>EDGEOID</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>elem</name> <operator>=</operator> <call><name>getEdgeFinal</name><argument_list>(<argument><expr><name>mgstate</name></expr></argument>, <argument><expr><name><name>result</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>GRAPHPATHOID</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * When deleting the graphpath, edge array of graphpath is
				 * deleted first and vertex array is deleted in the next plan.
				 * So, the graphpath must be passed to the next plan for
				 * deleting vertex array of the graphpath.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>isEdgeArrayOfPath</name><argument_list>(<argument><expr><name><name>mgstate</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>,
									  <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>elem</name> <operator>=</operator> <call><name>getPathFinal</name><argument_list>(<argument><expr><name>mgstate</name></expr></argument>, <argument><expr><name><name>result</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>EDGEARRAYOID</name> <operator>&amp;&amp;</operator> <name><name>plan</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>GWROP_DELETE</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * The edges are used only for removal,
				 * not for result output.
				 *
				 * This assumes that there are only variable references in the
				 * target list.
				 */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>setSlotValueByAttnum</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>mgstate</name><operator>-&gt;</operator><name>done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecEndModifyGraph</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommandId</name></type>	<name>used_cid</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>mgstate</name><operator>-&gt;</operator><name>tuplestorestate</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tuplestore_end</name><argument_list>(<argument><expr><name><name>mgstate</name><operator>-&gt;</operator><name>tuplestorestate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>mgstate</name><operator>-&gt;</operator><name>tuplestorestate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>mgstate</name><operator>-&gt;</operator><name>elemTable</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name><name>mgstate</name><operator>-&gt;</operator><name>elemTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name><name>mgstate</name><operator>-&gt;</operator><name>resultRelations</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>mgstate</name><operator>-&gt;</operator><name>numResultRelations</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecCloseIndices</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>resultRelInfo</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * clean out the tuple table
	 */</comment>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>mgstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><name><name>mgstate</name><operator>-&gt;</operator><name>subplan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecFreeExprContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mgstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * ModifyGraph plan uses multi-level CommandId for supporting visibitliy
	 * between cypher Clauses. Need to raise the cid to see the modifications
	 * made by this ModifyGraph plan in the next command.
	 */</comment>
	<expr_stmt><expr><name>used_cid</name> <operator>=</operator> <name><name>mgstate</name><operator>-&gt;</operator><name>modify_cid</name></name> <operator>+</operator> <name>MODIFY_CID_MAX</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>used_cid</name> <operator>&gt;</operator> <call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>initGraphWRStats</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>, <parameter><decl><type><name>GraphWriteOp</name></type> <name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>mgstate</name><operator>-&gt;</operator><name>pattern</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>op</name> <operator>==</operator> <name>GWROP_CREATE</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>GWROP_MERGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>graphWriteStats</name><operator>.</operator><name>insertVertex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>graphWriteStats</name><operator>.</operator><name>insertEdge</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>mgstate</name><operator>-&gt;</operator><name>exprs</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>op</name> <operator>==</operator> <name>GWROP_DELETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>graphWriteStats</name><operator>.</operator><name>deleteVertex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>graphWriteStats</name><operator>.</operator><name>deleteEdge</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>mgstate</name><operator>-&gt;</operator><name>sets</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>op</name> <operator>==</operator> <name>GWROP_SET</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>GWROP_MERGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>graphWriteStats</name><operator>.</operator><name>updateProperty</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>ExecInitGraphPattern</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ModifyGraph</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>ModifyGraph</name> <operator>*</operator><operator>)</operator> <name><name>mgstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GraphPath</name>  <modifier>*</modifier></type><name>gpath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>le</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>operation</name></name> <operator>!=</operator> <name>GWROP_MERGE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>pattern</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>gpath</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>le</argument>, <argument>gpath-&gt;chain</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>elem</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>elem</name></expr></argument>, <argument><expr><name>GraphVertex</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>GraphVertex</name> <modifier>*</modifier></type><name>gvertex</name> <init>= <expr><operator>(</operator><name>GraphVertex</name> <operator>*</operator><operator>)</operator> <name>elem</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>gvertex</name><operator>-&gt;</operator><name>es_expr</name></name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name><name>gvertex</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
											<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>mgstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>GraphEdge</name> <modifier>*</modifier></type><name>gedge</name> <init>= <expr><operator>(</operator><name>GraphEdge</name> <operator>*</operator><operator>)</operator> <name>elem</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>elem</name></expr></argument>, <argument><expr><name>GraphEdge</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>gedge</name><operator>-&gt;</operator><name>es_expr</name></name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name><name>gedge</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
										  <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>mgstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>pattern</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>ExecInitGraphSets</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sets</name></decl></parameter>, <parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>ls</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>ls</argument>, <argument>sets</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GraphSetProp</name> <modifier>*</modifier></type><name>gsp</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>gsp</name><operator>-&gt;</operator><name>es_elem</name></name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name><name>gsp</name><operator>-&gt;</operator><name>elem</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>mgstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>gsp</name><operator>-&gt;</operator><name>es_expr</name></name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name><name>gsp</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>mgstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>sets</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>ExecInitGraphDelExprs</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprs</name></decl></parameter>, <parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GraphDelElem</name> <modifier>*</modifier></type><name>gde</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>gde</name><operator>-&gt;</operator><name>es_elem</name></name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name><name>gde</name><operator>-&gt;</operator><name>elem</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>mgstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>exprs</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecCreateGraph</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ModifyGraph</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>ModifyGraph</name> <operator>*</operator><operator>)</operator> <name><name>mgstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>mgstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lp</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* create a pattern, accumulated paths `slot` has */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lp</argument>, <argument>plan-&gt;pattern</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GraphPath</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>(</operator><name>GraphPath</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldmctx</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>oldmctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>createPath</name><argument_list>(<argument><expr><name>mgstate</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldmctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><operator>(</operator><ternary><condition><expr><name><name>plan</name><operator>-&gt;</operator><name>last</name></name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name>slot</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* create a path and accumulate it to the given slot */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>createPath</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>, <parameter><decl><type><name>GraphPath</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>mgstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>out</name> <init>= <expr><operator>(</operator><name><name>path</name><operator>-&gt;</operator><name>variable</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>pathlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>vertices</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>edges</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nvertices</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nedges</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>le</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Graphid</name></type>		<name>prevvid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GraphEdge</name>  <modifier>*</modifier></type><name>gedge</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>pathlen</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pathlen</name> <operator>%</operator> <literal type="number">2</literal> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>vertices</name> <operator>=</operator> <call><name>makeDatumArray</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>, <argument><expr><operator>(</operator><name>pathlen</name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>edges</name> <operator>=</operator> <call><name>makeDatumArray</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>, <argument><expr><name>pathlen</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>nvertices</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>nedges</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>le</argument>, <argument>path-&gt;chain</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>elem</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>elem</name></expr></argument>, <argument><expr><name>GraphVertex</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>GraphVertex</name> <modifier>*</modifier></type><name>gvertex</name> <init>= <expr><operator>(</operator><name>GraphVertex</name> <operator>*</operator><operator>)</operator> <name>elem</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Graphid</name></type>		<name>vid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>vertex</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>gvertex</name><operator>-&gt;</operator><name>create</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>vertex</name> <operator>=</operator> <call><name>createVertex</name><argument_list>(<argument><expr><name>mgstate</name></expr></argument>, <argument><expr><name>gvertex</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vid</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>vertex</name> <operator>=</operator> <call><name>findVertex</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>gvertex</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>vertex</name> <operator>!=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>vertices</name><index>[<expr><name>nvertices</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>vertex</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>gedge</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Datum</name></type> <name>edge</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>gedge</name><operator>-&gt;</operator><name>direction</name></name> <operator>==</operator> <name>GRAPH_EDGE_DIR_LEFT</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>edge</name> <operator>=</operator> <call><name>createEdge</name><argument_list>(<argument><expr><name>mgstate</name></expr></argument>, <argument><expr><name>gedge</name></expr></argument>, <argument><expr><name>vid</name></expr></argument>, <argument><expr><name>prevvid</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>gedge</name><operator>-&gt;</operator><name>direction</name></name> <operator>==</operator> <name>GRAPH_EDGE_DIR_RIGHT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>edge</name> <operator>=</operator> <call><name>createEdge</name><argument_list>(<argument><expr><name>mgstate</name></expr></argument>, <argument><expr><name>gedge</name></expr></argument>, <argument><expr><name>prevvid</name></expr></argument>, <argument><expr><name>vid</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>edges</name><index>[<expr><name>nedges</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>edge</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>prevvid</name> <operator>=</operator> <name>vid</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>elem</name></expr></argument>, <argument><expr><name>GraphEdge</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>gedge</name> <operator>=</operator> <operator>(</operator><name>GraphEdge</name> <operator>*</operator><operator>)</operator> <name>elem</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/* make a graphpath and set it to the slot */</comment>
	<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type> <name>graphpath</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nvertices</name> <operator>==</operator> <name>nedges</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pathlen</name> <operator>==</operator> <name>nvertices</name> <operator>+</operator> <name>nedges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>graphpath</name> <operator>=</operator> <call><name>makeGraphpathDatum</name><argument_list>(<argument><expr><name>vertices</name></expr></argument>, <argument><expr><name>nvertices</name></expr></argument>, <argument><expr><name>edges</name></expr></argument>, <argument><expr><name>nedges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>setSlotValueByName</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>graphpath</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * createVertex - creates a vertex of a given node
 *
 * NOTE: This function returns a vertex if it must be in the result(`slot`).
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>createVertex</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>, <parameter><decl><type><name>GraphVertex</name> <modifier>*</modifier></type><name>gvertex</name></decl></parameter>, <parameter><decl><type><name>Graphid</name> <modifier>*</modifier></type><name>vid</name></decl></parameter>,
			 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inPath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>mgstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>elemTupleSlot</name> <init>= <expr><name><name>mgstate</name><operator>-&gt;</operator><name>elemTupleSlot</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>savedResultRelInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>vertex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>vertexProp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <call><name>getResultRelInfo</name><argument_list>(<argument><expr><name>mgstate</name></expr></argument>, <argument><expr><name><name>gvertex</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>savedResultRelInfo</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>vertex</name> <operator>=</operator> <call><name>findVertex</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>gvertex</name></expr></argument>, <argument><expr><name>vid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>vertexProp</name> <operator>=</operator> <call><name>getVertexPropDatum</name><argument_list>(<argument><expr><name>vertex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>JB_ROOT_IS_OBJECT</name><argument_list>(<argument><expr><call><name>DatumGetJsonbP</name><argument_list>(<argument><expr><name>vertexProp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"jsonb object is expected for property map"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>elemTupleSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecSetSlotDescriptor</name><argument_list>(<argument><expr><name>elemTupleSlot</name></expr></argument>,
						  <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>elemTupleSlot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>GraphidGetDatum</name><argument_list>(<argument><expr><operator>*</operator><name>vid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>elemTupleSlot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>vertexProp</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>elemTupleSlot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
		   <argument><expr><name><name>elemTupleSlot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecStoreVirtualTuple</name><argument_list>(<argument><expr><name>elemTupleSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name>elemTupleSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Constraints might reference the tableoid column, so initialize
	 * t_tableOid before evaluating them.
	 */</comment>
	<expr_stmt><expr><name><name>elemTupleSlot</name><operator>-&gt;</operator><name>tts_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check the constraints of the tuple
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecConstraints</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>elemTupleSlot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * insert the tuple normally
	 */</comment>
	<expr_stmt><expr><call><name>table_tuple_insert</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>, <argument><expr><name>elemTupleSlot</name></expr></argument>,
					   <argument><expr><name><name>mgstate</name><operator>-&gt;</operator><name>modify_cid</name></name> <operator>+</operator> <name>MODIFY_CID_OUTPUT</name></expr></argument>,
					   <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* insert index entries for the tuple */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumIndices</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecInsertIndexTuples</name><argument_list>(<argument><expr><name>elemTupleSlot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>vertex</name> <operator>=</operator> <call><name>makeGraphVertexDatum</name><argument_list>(<argument><expr><name><name>elemTupleSlot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
								  <argument><expr><name><name>elemTupleSlot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
								  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>elemTupleSlot</name><operator>-&gt;</operator><name>tts_tid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>gvertex</name><operator>-&gt;</operator><name>resno</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>setSlotValueByAttnum</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>vertex</name></expr></argument>, <argument><expr><name><name>gvertex</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>graphWriteStats</name><operator>.</operator><name>insertVertex</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>savedResultRelInfo</name></expr>;</expr_stmt>

	<return>return <expr><name>vertex</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>createEdge</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>, <parameter><decl><type><name>GraphEdge</name> <modifier>*</modifier></type><name>gedge</name></decl></parameter>, <parameter><decl><type><name>Graphid</name></type> <name>start</name></decl></parameter>,
		   <parameter><decl><type><name>Graphid</name></type> <name>end</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inPath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>mgstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>elemTupleSlot</name> <init>= <expr><name><name>mgstate</name><operator>-&gt;</operator><name>elemTupleSlot</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>savedResultRelInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Graphid</name></type>		<name>id</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>edge</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>edgeProp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <call><name>getResultRelInfo</name><argument_list>(<argument><expr><name>mgstate</name></expr></argument>, <argument><expr><name><name>gedge</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>savedResultRelInfo</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>edge</name> <operator>=</operator> <call><name>findEdge</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>gedge</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>edge</name> <operator>!=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>edgeProp</name> <operator>=</operator> <call><name>getEdgePropDatum</name><argument_list>(<argument><expr><name>edge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>JB_ROOT_IS_OBJECT</name><argument_list>(<argument><expr><call><name>DatumGetJsonbP</name><argument_list>(<argument><expr><name>edgeProp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"jsonb object is expected for property map"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>elemTupleSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecSetSlotDescriptor</name><argument_list>(<argument><expr><name>elemTupleSlot</name></expr></argument>,
						  <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>elemTupleSlot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>GraphidGetDatum</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>elemTupleSlot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>GraphidGetDatum</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>elemTupleSlot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>GraphidGetDatum</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>elemTupleSlot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>edgeProp</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>elemTupleSlot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
		   <argument><expr><name><name>elemTupleSlot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecStoreVirtualTuple</name><argument_list>(<argument><expr><name>elemTupleSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name>elemTupleSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>elemTupleSlot</name><operator>-&gt;</operator><name>tts_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecConstraints</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>elemTupleSlot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>table_tuple_insert</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>, <argument><expr><name>elemTupleSlot</name></expr></argument>,
					   <argument><expr><name><name>mgstate</name><operator>-&gt;</operator><name>modify_cid</name></name> <operator>+</operator> <name>MODIFY_CID_OUTPUT</name></expr></argument>,
					   <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumIndices</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecInsertIndexTuples</name><argument_list>(<argument><expr><name>elemTupleSlot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>edge</name> <operator>=</operator> <call><name>makeGraphEdgeDatum</name><argument_list>(<argument><expr><name><name>elemTupleSlot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
							  <argument><expr><name><name>elemTupleSlot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
							  <argument><expr><name><name>elemTupleSlot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
							  <argument><expr><name><name>elemTupleSlot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>,
							  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>elemTupleSlot</name><operator>-&gt;</operator><name>tts_tid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>gedge</name><operator>-&gt;</operator><name>resno</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>setSlotValueByAttnum</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>edge</name></expr></argument>, <argument><expr><name><name>gedge</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>graphWriteStats</name><operator>.</operator><name>insertEdge</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>savedResultRelInfo</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>auto_gather_graphmeta</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>agstat_count_edge_create</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>edge</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecDeleteGraph</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ModifyGraph</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>ModifyGraph</name> <operator>*</operator><operator>)</operator> <name><name>mgstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>mgstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>le</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>isDetachRequired</name><argument_list>(<argument><expr><name>mgstate</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"vertices with edges can not be removed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>le</argument>, <argument>mgstate-&gt;exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GraphDelElem</name> <modifier>*</modifier></type><name>gde</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>GraphDelElem</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>type</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>elem</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attno</name> <init>= <expr><call><name>findAttrInSlotByName</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>gde</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>gde</name><operator>-&gt;</operator><name>elem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>type</name> <operator>==</operator> <name>VERTEXOID</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>EDGEOID</name> <operator>||</operator>
			  <name>type</name> <operator>==</operator> <name>VERTEXARRAYOID</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>EDGEARRAYOID</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"expected node, relationship, or path"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>elem</name> <operator>=</operator> <call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name><name>gde</name><operator>-&gt;</operator><name>es_elem</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * This assumes that there are only variable references in the
			 * target list.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>EDGEARRAYOID</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping deletion of NULL graph element"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * NOTE: After all the graph elements to be removed are collected,
		 *       they will be removed.
		 */</comment>
		<expr_stmt><expr><call><name>enterDelPropTable</name><argument_list>(<argument><expr><name>mgstate</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The graphpath must be passed to the next plan for deleting
		 * vertex array of the graphpath.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>EDGEARRAYOID</name> <operator>&amp;&amp;</operator>
			<call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name> <operator>==</operator> <name>GRAPHPATHOID</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>setSlotValueByAttnum</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><operator>(</operator><ternary><condition><expr><name><name>plan</name><operator>-&gt;</operator><name>last</name></name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name>slot</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* tricky but efficient */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>isDetachRequired</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NestLoopState</name> <modifier>*</modifier></type><name>nlstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ModifyGraph</name> <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>

	<comment type="block">/* no vertex in the target list of DELETE */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>mgstate</name><operator>-&gt;</operator><name>subplan</name></name></expr></argument>, <argument><expr><name>NestLoopState</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The join may not be the join which retrieves edges connected to the
	 * target vertices.
	 */</comment>
	<expr_stmt><expr><name>nlstate</name> <operator>=</operator> <operator>(</operator><name>NestLoopState</name> <operator>*</operator><operator>)</operator> <name><name>mgstate</name><operator>-&gt;</operator><name>subplan</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>nlstate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_CYPHER_DELETE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * All the target edges will be deleted. There may be a chance that no
	 * edge exists for the vertices in the current slot, but it doesn't
	 * matter.
	 */</comment>
	<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>ModifyGraph</name> <operator>*</operator><operator>)</operator> <name><name>mgstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>detach</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * true: At least one edge exists for the target vertices in the current
	 *       slot. (nl_MatchedOuter &amp;&amp; !nl_NeedNewOuter)
	 * false: No edge exists for the target vertices in the current slot.
	 *        (!nl_MatchedOuter &amp;&amp; nl_NeedNewOuter)
	 */</comment>
	<return>return <expr><name><name>nlstate</name><operator>-&gt;</operator><name>nl_MatchedOuter</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>deleteElem</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>gid</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>mgstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>savedResultRelInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>resultRelationDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TM_Result</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TM_FailureData</name></type> <name>hufd</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>get_labid_relid</name><argument_list>(<argument><expr><name><name>mgstate</name><operator>-&gt;</operator><name>graphid</name></name></expr></argument>,
							<argument><expr><call><name>GraphidGetLabid</name><argument_list>(<argument><expr><call><name>DatumGetGraphid</name><argument_list>(<argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <call><name>getResultRelInfo</name><argument_list>(<argument><expr><name>mgstate</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>savedResultRelInfo</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>resultRelationDesc</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr>;</expr_stmt>

	<comment type="block">/* see ExecDelete() */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>heap_delete</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>,
						 <argument><expr><name><name>mgstate</name><operator>-&gt;</operator><name>modify_cid</name></name> <operator>+</operator> <name>MODIFY_CID_OUTPUT</name></expr></argument>,
						 <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_crosscheck_snapshot</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hufd</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>result</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TM_SelfModified</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"modifying the same element more than once cannot happen"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>

		<case>case <expr><name>TM_Ok</name></expr>:</case>
			<break>break;</break>

		<case>case <expr><name>TM_Updated</name></expr>:</case>
			<comment type="block">/* TODO: A solution to concurrent update is needed. */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not serialize access due to concurrent update"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized heap_update status: %u"</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * NOTE: VACUUM will delete index tuples associated with the heap tuple
	 *       later.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>VERTEXOID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>graphWriteStats</name><operator>.</operator><name>deleteVertex</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>type</name> <operator>==</operator> <name>EDGEOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>graphWriteStats</name><operator>.</operator><name>deleteEdge</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>savedResultRelInfo</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>isEdgeArrayOfPath</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprs</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>variable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GraphDelElem</name> <modifier>*</modifier></type><name>gde</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>GraphDelElem</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><name><name>gde</name><operator>-&gt;</operator><name>elem</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>EDGEARRAYOID</name> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>gde</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>, <argument><expr><name>variable</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecSetGraph</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>, <parameter><decl><type><name>GSPKind</name></type> <name>kind</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ModifyGraph</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>ModifyGraph</name> <operator>*</operator><operator>)</operator> <name><name>mgstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>mgstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name><name>mgstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>free_slot</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * The results of previous clauses should be preserved.
	 * So, shallow copying is used.
	 */</comment>
	<expr_stmt><expr><call><name>copyVirtualTupleTableSlot</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>ls</argument>, <argument>mgstate-&gt;sets</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GraphSetProp</name> <modifier>*</modifier></type><name>gsp</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>elemtype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>elem_datum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>expr_datum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>gid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>tid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>newelem</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldmctx</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>gsp</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <name>kind</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>kind</name> <operator>!=</operator> <name>GSP_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>elemtype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>gsp</name><operator>-&gt;</operator><name>es_elem</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>elemtype</name> <operator>!=</operator> <name>VERTEXOID</name> <operator>&amp;&amp;</operator> <name>elemtype</name> <operator>!=</operator> <name>EDGEOID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"expected node or relationship"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* store intermediate results in tuple memory context */</comment>
		<expr_stmt><expr><name>oldmctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Reflect newest value all types of scantuple
		 * before evaluating expression.
		 */</comment>
		<expr_stmt><expr><call><name>findAndReflectNewestValue</name><argument_list>(<argument><expr><name>mgstate</name></expr></argument>, <argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name></expr></argument>, <argument><expr><name>free_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>findAndReflectNewestValue</name><argument_list>(<argument><expr><name>mgstate</name></expr></argument>, <argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_innertuple</name></name></expr></argument>, <argument><expr><name>free_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>findAndReflectNewestValue</name><argument_list>(<argument><expr><name>mgstate</name></expr></argument>, <argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name></expr></argument>, <argument><expr><name>free_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* get original graph element */</comment>
		<expr_stmt><expr><name>elem_datum</name> <operator>=</operator> <call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name><name>gsp</name><operator>-&gt;</operator><name>es_elem</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"updating NULL is not allowed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* evaluate SET expression */</comment>
		<if_stmt><if>if <condition>(<expr><name>elemtype</name> <operator>==</operator> <name>VERTEXOID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>gid</name> <operator>=</operator> <call><name>getVertexIdDatum</name><argument_list>(<argument><expr><name>elem_datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tid</name> <operator>=</operator> <call><name>getVertexTidDatum</name><argument_list>(<argument><expr><name>elem_datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>elemtype</name> <operator>==</operator> <name>EDGEOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>gid</name> <operator>=</operator> <call><name>getEdgeIdDatum</name><argument_list>(<argument><expr><name>elem_datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tid</name> <operator>=</operator> <call><name>getEdgeTidDatum</name><argument_list>(<argument><expr><name>elem_datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>expr_datum</name> <operator>=</operator> <call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name><name>gsp</name><operator>-&gt;</operator><name>es_expr</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"property map cannot be NULL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>newelem</name> <operator>=</operator> <call><name>makeModifiedElem</name><argument_list>(<argument><expr><name>elem_datum</name></expr></argument>, <argument><expr><name>elemtype</name></expr></argument>, <argument><expr><name>gid</name></expr></argument>, <argument><expr><name>expr_datum</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldmctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>mgstate</name><operator>-&gt;</operator><name>elemTable</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>enterSetPropTable</name><argument_list>(<argument><expr><name>mgstate</name></expr></argument>, <argument><expr><name>gid</name></expr></argument>, <argument><expr><name>newelem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>updateElemProp</name><argument_list>(<argument><expr><name>mgstate</name></expr></argument>, <argument><expr><name>elemtype</name></expr></argument>, <argument><expr><name>gid</name></expr></argument>, <argument><expr><name>newelem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>setSlotValueByName</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>newelem</name></expr></argument>, <argument><expr><name><name>gsp</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
		 * we have made it through the first iteration, it is okay to start
		 * freeing our slot copies in findAndReflectNewestValue.
		 */</comment>
		<expr_stmt><expr><name>free_slot</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><operator>(</operator><ternary><condition><expr><name><name>plan</name><operator>-&gt;</operator><name>last</name></name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name>result</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>copyVirtualTupleTableSlot</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>dstslot</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>srcslot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>natts</name> <init>= <expr><name><name>srcslot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExecSetSlotDescriptor</name><argument_list>(<argument><expr><name>dstslot</name></expr></argument>, <argument><expr><name><name>srcslot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* shallow copy */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>dstslot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>, <argument><expr><name><name>srcslot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>, <argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>dstslot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>, <argument><expr><name><name>srcslot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>, <argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecStoreVirtualTuple</name><argument_list>(<argument><expr><name>dstslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>dstslot</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>findAndReflectNewestValue</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name></type> <name>free_slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>slot</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>	<name>finalValue</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>	<name>copyValue</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator>
			<name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>attisdropped</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<switch>switch<condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>atttypid</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>VERTEXOID</name></expr>:</case>
				<expr_stmt><expr><name>finalValue</name> <operator>=</operator> <call><name>getVertexFinal</name><argument_list>(<argument><expr><name>mgstate</name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>EDGEOID</name></expr>:</case>
				<expr_stmt><expr><name>finalValue</name> <operator>=</operator> <call><name>getEdgeFinal</name><argument_list>(<argument><expr><name>mgstate</name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>GRAPHPATHOID</name></expr>:</case>
				<expr_stmt><expr><name>finalValue</name> <operator>=</operator> <call><name>getPathFinal</name><argument_list>(<argument><expr><name>mgstate</name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<continue>continue;</continue>
		</block_content>}</block></switch>

		<comment type="block">/*
		 * Make a copy of finalValue to avoid the slot's copy getting freed
		 * when the mgstate-&gt;elemTable hash table entries are indepenently
		 * freed.
		 */</comment>
		<expr_stmt><expr><name>copyValue</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name>finalValue</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
		 * Free the copy of finalValue that we've previously stored in
		 * the slot.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>free_slot</name> <operator>&amp;&amp;</operator>
			<name>enable_multiple_update</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>finalValue</name> <operator>!=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>setSlotValueByAttnum</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>copyValue</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* See ExecUpdate() */</comment>
<function><type><specifier>static</specifier> <name>ItemPointer</name></type>
<name>updateElemProp</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>elemtype</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>gid</name></decl></parameter>,
			   <parameter><decl><type><name>Datum</name></type> <name>elem_datum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>mgstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>elemTupleSlot</name> <init>= <expr><name><name>mgstate</name><operator>-&gt;</operator><name>elemTupleSlot</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointer</name></type>	<name>ctid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>savedResultRelInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>resultRelationDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LockTupleMode</name></type> <name>lockmode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TM_Result</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TM_FailureData</name></type> <name>hufd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>update_indexes</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>get_labid_relid</name><argument_list>(<argument><expr><name><name>mgstate</name><operator>-&gt;</operator><name>graphid</name></name></expr></argument>,
							<argument><expr><call><name>GraphidGetLabid</name><argument_list>(<argument><expr><call><name>DatumGetGraphid</name><argument_list>(<argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <call><name>getResultRelInfo</name><argument_list>(<argument><expr><name>mgstate</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>savedResultRelInfo</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>resultRelationDesc</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create a tuple to store. Attributes of vertex/edge label are not the
	 * same with those of vertex/edge.
	 */</comment>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>elemTupleSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecSetSlotDescriptor</name><argument_list>(<argument><expr><name>elemTupleSlot</name></expr></argument>,
						  <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>elemtype</name> <operator>==</operator> <name>VERTEXOID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>elemTupleSlot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>gid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>elemTupleSlot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>getVertexPropDatum</name><argument_list>(<argument><expr><name>elem_datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ctid</name> <operator>=</operator> <operator>(</operator><name>ItemPointer</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><call><name>getVertexTidDatum</name><argument_list>(<argument><expr><name>elem_datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>elemtype</name> <operator>==</operator> <name>EDGEOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>elemTupleSlot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>gid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>elemTupleSlot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>getEdgeStartDatum</name><argument_list>(<argument><expr><name>elem_datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>elemTupleSlot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>getEdgeEndDatum</name><argument_list>(<argument><expr><name>elem_datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>elemTupleSlot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>getEdgePropDatum</name><argument_list>(<argument><expr><name>elem_datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ctid</name> <operator>=</operator> <operator>(</operator><name>ItemPointer</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><call><name>getEdgeTidDatum</name><argument_list>(<argument><expr><name>elem_datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>elemTupleSlot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
		   <argument><expr><name><name>elemTupleSlot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecStoreVirtualTuple</name><argument_list>(<argument><expr><name>elemTupleSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>resultRelationDesc</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecConstraints</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>elemTupleSlot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>table_tuple_update</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>, <argument><expr><name>ctid</name></expr></argument>, <argument><expr><name>elemTupleSlot</name></expr></argument>,
								<argument><expr><name><name>mgstate</name><operator>-&gt;</operator><name>modify_cid</name></name> <operator>+</operator> <name>MODIFY_CID_SET</name></expr></argument>,
								<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr></argument>,
								<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_crosscheck_snapshot</name></name></expr></argument>,
								<argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hufd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lockmode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>update_indexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>result</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TM_SelfModified</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"graph element(%hu,"</literal> <name>UINT64_FORMAT</name> <literal type="string">") has been SET multiple times"</literal></expr></argument>,
							<argument><expr><call><name>GraphidGetLabid</name><argument_list>(<argument><expr><call><name>DatumGetGraphid</name><argument_list>(<argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>GraphidGetLocid</name><argument_list>(<argument><expr><call><name>DatumGetGraphid</name><argument_list>(<argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>TM_Ok</name></expr>:</case>
			<break>break;</break>
		<case>case <expr><name>TM_Updated</name></expr>:</case>
			<comment type="block">/* TODO: A solution to concurrent update is needed. */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not serialize access due to concurrent update"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized heap_update status: %u"</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumIndices</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>update_indexes</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecInsertIndexTuples</name><argument_list>(<argument><expr><name>elemTupleSlot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>graphWriteStats</name><operator>.</operator><name>updateProperty</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>savedResultRelInfo</name></expr>;</expr_stmt>

	<return>return <expr><operator>&amp;</operator><operator>(</operator><name><name>elemTupleSlot</name><operator>-&gt;</operator><name>tts_tid</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>makeModifiedElem</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>elem</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>elemtype</name></decl></parameter>,
				 <parameter><decl><type><name>Datum</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>prop_map</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>tid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>elemtype</name> <operator>==</operator> <name>VERTEXOID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeGraphVertexDatum</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>prop_map</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>start</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>end</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>getEdgeStartDatum</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>getEdgeEndDatum</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeGraphEdgeDatum</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>prop_map</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecMergeGraph</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ModifyGraph</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>ModifyGraph</name> <operator>*</operator><operator>)</operator> <name><name>mgstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>mgstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GraphPath</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>(</operator><name>GraphPath</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>mgstate</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>isMatchedMergePattern</name><argument_list>(<argument><expr><name><name>mgstate</name><operator>-&gt;</operator><name>subplan</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>mgstate</name><operator>-&gt;</operator><name>sets</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecSetGraph</name><argument_list>(<argument><expr><name>mgstate</name></expr></argument>, <argument><expr><name>GSP_ON_MATCH</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldmctx</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>oldmctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>createMergePath</name><argument_list>(<argument><expr><name>mgstate</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldmctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>mgstate</name><operator>-&gt;</operator><name>sets</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecSetGraph</name><argument_list>(<argument><expr><name>mgstate</name></expr></argument>, <argument><expr><name>GSP_ON_CREATE</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><operator>(</operator><ternary><condition><expr><name><name>plan</name><operator>-&gt;</operator><name>last</name></name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name>slot</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* tricky but efficient */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>isMatchedMergePattern</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>NestLoopState</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><operator>(</operator><name>NestLoopState</name> <operator>*</operator><operator>)</operator> <name>planstate</name><operator>)</operator><operator>-&gt;</operator><name>nl_MatchedOuter</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>createMergePath</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>, <parameter><decl><type><name>GraphPath</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
				<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>mgstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>out</name> <init>= <expr><operator>(</operator><name><name>path</name><operator>-&gt;</operator><name>variable</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>pathlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>vertices</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>edges</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nvertices</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nedges</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>le</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Graphid</name></type>		<name>prevvid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GraphEdge</name>  <modifier>*</modifier></type><name>gedge</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>pathlen</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pathlen</name> <operator>%</operator> <literal type="number">2</literal> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>vertices</name> <operator>=</operator> <call><name>makeDatumArray</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>, <argument><expr><operator>(</operator><name>pathlen</name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>edges</name> <operator>=</operator> <call><name>makeDatumArray</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>, <argument><expr><name>pathlen</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>nvertices</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>nedges</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>le</argument>, <argument>path-&gt;chain</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>elem</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>elem</name></expr></argument>, <argument><expr><name>GraphVertex</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>GraphVertex</name> <modifier>*</modifier></type><name>gvertex</name> <init>= <expr><operator>(</operator><name>GraphVertex</name> <operator>*</operator><operator>)</operator> <name>elem</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Graphid</name></type>		<name>vid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>vertex</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>vertex</name> <operator>=</operator> <call><name>findVertex</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>gvertex</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>vertex</name> <operator>==</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>vertex</name> <operator>=</operator> <call><name>createMergeVertex</name><argument_list>(<argument><expr><name>mgstate</name></expr></argument>, <argument><expr><name>gvertex</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vid</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>vertices</name><index>[<expr><name>nvertices</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>vertex</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>gedge</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Datum</name></type> <name>edge</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>edge</name> <operator>=</operator> <call><name>findEdge</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>gedge</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>edge</name> <operator>==</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>gedge</name><operator>-&gt;</operator><name>direction</name></name> <operator>==</operator> <name>GRAPH_EDGE_DIR_LEFT</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>edge</name> <operator>=</operator> <call><name>createMergeEdge</name><argument_list>(<argument><expr><name>mgstate</name></expr></argument>, <argument><expr><name>gedge</name></expr></argument>, <argument><expr><name>vid</name></expr></argument>, <argument><expr><name>prevvid</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>gedge</name><operator>-&gt;</operator><name>direction</name></name> <operator>==</operator> <name>GRAPH_EDGE_DIR_RIGHT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>edge</name> <operator>=</operator> <call><name>createMergeEdge</name><argument_list>(<argument><expr><name>mgstate</name></expr></argument>, <argument><expr><name>gedge</name></expr></argument>, <argument><expr><name>prevvid</name></expr></argument>, <argument><expr><name>vid</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>edges</name><index>[<expr><name>nedges</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>edge</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>prevvid</name> <operator>=</operator> <name>vid</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>elem</name></expr></argument>, <argument><expr><name>GraphEdge</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>gedge</name> <operator>=</operator> <operator>(</operator><name>GraphEdge</name> <operator>*</operator><operator>)</operator> <name>elem</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/* make a graphpath and set it to the slot */</comment>
	<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type> <name>graphpath</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nvertices</name> <operator>==</operator> <name>nedges</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pathlen</name> <operator>==</operator> <name>nvertices</name> <operator>+</operator> <name>nedges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>graphpath</name> <operator>=</operator> <call><name>makeGraphpathDatum</name><argument_list>(<argument><expr><name>vertices</name></expr></argument>, <argument><expr><name>nvertices</name></expr></argument>, <argument><expr><name>edges</name></expr></argument>, <argument><expr><name>nedges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>setSlotValueByName</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>graphpath</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* See ExecInsert() */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>createMergeVertex</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>, <parameter><decl><type><name>GraphVertex</name> <modifier>*</modifier></type><name>gvertex</name></decl></parameter>,
				  <parameter><decl><type><name>Graphid</name> <modifier>*</modifier></type><name>vid</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>mgstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>mgstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>savedResultRelInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>vertex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>vertexId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>vertexProp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>insertSlot</name> <init>= <expr><name><name>mgstate</name><operator>-&gt;</operator><name>elemTupleSlot</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <call><name>getResultRelInfo</name><argument_list>(<argument><expr><name>mgstate</name></expr></argument>, <argument><expr><name><name>gvertex</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>savedResultRelInfo</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>vertex</name> <operator>=</operator> <call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name><name>gvertex</name><operator>-&gt;</operator><name>es_expr</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"NULL is not allowed in MERGE"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>vertexId</name> <operator>=</operator> <call><name>getVertexIdDatum</name><argument_list>(<argument><expr><name>vertex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>vid</name> <operator>=</operator> <call><name>DatumGetGraphid</name><argument_list>(<argument><expr><name>vertexId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>vertexProp</name> <operator>=</operator> <call><name>getVertexPropDatum</name><argument_list>(<argument><expr><name>vertex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>JB_ROOT_IS_OBJECT</name><argument_list>(<argument><expr><call><name>DatumGetJsonbP</name><argument_list>(<argument><expr><name>vertexProp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"jsonb object is expected for property map"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>insertSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecSetSlotDescriptor</name><argument_list>(<argument><expr><name>insertSlot</name></expr></argument>,
						  <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>insertSlot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>vertexId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>insertSlot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>vertexProp</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>insertSlot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
		   <argument><expr><name><name>insertSlot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecStoreVirtualTuple</name><argument_list>(<argument><expr><name>insertSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name>insertSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>insertSlot</name><operator>-&gt;</operator><name>tts_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecConstraints</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>insertSlot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>table_tuple_insert</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>, <argument><expr><name>insertSlot</name></expr></argument>,
					   <argument><expr><name><name>mgstate</name><operator>-&gt;</operator><name>modify_cid</name></name> <operator>+</operator> <name>MODIFY_CID_OUTPUT</name></expr></argument>,
					   <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumIndices</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecInsertIndexTuples</name><argument_list>(<argument><expr><name>insertSlot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>vertex</name> <operator>=</operator> <call><name>makeGraphVertexDatum</name><argument_list>(<argument><expr><name><name>insertSlot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
								  <argument><expr><name><name>insertSlot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
								  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>insertSlot</name><operator>-&gt;</operator><name>tts_tid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>gvertex</name><operator>-&gt;</operator><name>resno</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>setSlotValueByAttnum</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>vertex</name></expr></argument>, <argument><expr><name><name>gvertex</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>graphWriteStats</name><operator>.</operator><name>insertVertex</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>savedResultRelInfo</name></expr>;</expr_stmt>

	<return>return <expr><name>vertex</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>createMergeEdge</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>, <parameter><decl><type><name>GraphEdge</name> <modifier>*</modifier></type><name>gedge</name></decl></parameter>, <parameter><decl><type><name>Graphid</name></type> <name>start</name></decl></parameter>,
				<parameter><decl><type><name>Graphid</name></type> <name>end</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>mgstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>mgstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>savedResultRelInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>edge</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>edgeProp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>insertSlot</name> <init>= <expr><name><name>mgstate</name><operator>-&gt;</operator><name>elemTupleSlot</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <call><name>getResultRelInfo</name><argument_list>(<argument><expr><name>mgstate</name></expr></argument>, <argument><expr><name><name>gedge</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>savedResultRelInfo</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>edge</name> <operator>=</operator> <call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name><name>gedge</name><operator>-&gt;</operator><name>es_expr</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"NULL is not allowed in MERGE"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>edgeProp</name> <operator>=</operator> <call><name>getEdgePropDatum</name><argument_list>(<argument><expr><name>edge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>JB_ROOT_IS_OBJECT</name><argument_list>(<argument><expr><call><name>DatumGetJsonbP</name><argument_list>(<argument><expr><name>edgeProp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"jsonb object is expected for property map"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>insertSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecSetSlotDescriptor</name><argument_list>(<argument><expr><name>insertSlot</name></expr></argument>,
						  <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>insertSlot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>getEdgeIdDatum</name><argument_list>(<argument><expr><name>edge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>insertSlot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>GraphidGetDatum</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>insertSlot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>GraphidGetDatum</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>insertSlot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>edgeProp</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>insertSlot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
		   <argument><expr><name><name>insertSlot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecStoreVirtualTuple</name><argument_list>(<argument><expr><name>insertSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name>insertSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>insertSlot</name><operator>-&gt;</operator><name>tts_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecConstraints</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>insertSlot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>table_tuple_insert</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>, <argument><expr><name>insertSlot</name></expr></argument>,
					   <argument><expr><name><name>mgstate</name><operator>-&gt;</operator><name>modify_cid</name></name> <operator>+</operator> <name>MODIFY_CID_OUTPUT</name></expr></argument>,
					   <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumIndices</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecInsertIndexTuples</name><argument_list>(<argument><expr><name>insertSlot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>edge</name> <operator>=</operator> <call><name>makeGraphEdgeDatum</name><argument_list>(<argument><expr><name><name>insertSlot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
							  <argument><expr><name><name>insertSlot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
							  <argument><expr><name><name>insertSlot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
							  <argument><expr><name><name>insertSlot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>,
							  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>insertSlot</name><operator>-&gt;</operator><name>tts_tid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>gedge</name><operator>-&gt;</operator><name>resno</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>setSlotValueByAttnum</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>edge</name></expr></argument>, <argument><expr><name><name>gedge</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>graphWriteStats</name><operator>.</operator><name>insertEdge</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>savedResultRelInfo</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>auto_gather_graphmeta</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>agstat_count_edge_create</name><argument_list>(<argument><expr><call><name>GraphidGetDatum</name><argument_list>(<argument><expr><call><name>getEdgeIdDatum</name><argument_list>(<argument><expr><name>edge</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>edge</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>enterSetPropTable</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>gid</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>newelem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ModifiedElemEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>mgstate</name><operator>-&gt;</operator><name>elemTable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gid</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>enable_multiple_update</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>elem</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"graph element(%hu,"</literal> <name>UINT64_FORMAT</name> <literal type="string">") has been SET multiple times"</literal></expr></argument>,
							<argument><expr><call><name>GraphidGetLabid</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>GraphidGetLocid</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>elem</name></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name>newelem</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>enterDelPropTable</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>elem</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>gid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ModifiedElemEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>VERTEXOID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>gid</name> <operator>=</operator> <call><name>getVertexIdDatum</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>mgstate</name><operator>-&gt;</operator><name>elemTable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gid</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tid</name></name> <operator>=</operator>
				<operator>*</operator><operator>(</operator><operator>(</operator><name>ItemPointer</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><call><name>getVertexTidDatum</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>EDGEOID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>gid</name> <operator>=</operator> <call><name>getEdgeIdDatum</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>mgstate</name><operator>-&gt;</operator><name>elemTable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gid</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Graphid</name></type> <name>eid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Graphid</name></type> <name>start</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Graphid</name></type> <name>end</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>eid</name> <operator>=</operator> <call><name>GraphidGetLabid</name><argument_list>(<argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>GraphidGetLabid</name><argument_list>(<argument><expr><call><name>getEdgeStartDatum</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>GraphidGetLabid</name><argument_list>(<argument><expr><call><name>getEdgeEndDatum</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>auto_gather_graphmeta</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>agstat_count_edge_delete</name><argument_list>(<argument><expr><name>eid</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tid</name></name> <operator>=</operator>
				<operator>*</operator><operator>(</operator><operator>(</operator><name>ItemPointer</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><call><name>getEdgeTidDatum</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>VERTEXARRAYOID</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AnyArrayType</name> <modifier>*</modifier></type><name>vertices</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nvertices</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int16</name></type>		<name>typlen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>typbyval</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>typalign</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>array_iter</name></type>	<name>it</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>vtx</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>vertices</name> <operator>=</operator> <call><name>DatumGetAnyArrayP</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nvertices</name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><call><name>AARR_NDIM</name><argument_list>(<argument><expr><name>vertices</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>AARR_DIMS</name><argument_list>(<argument><expr><name>vertices</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><call><name>AARR_ELEMTYPE</name><argument_list>(<argument><expr><name>vertices</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>typlen</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>typbyval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>array_iter_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><name>vertices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nvertices</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>vtx</name> <operator>=</operator> <call><name>array_iter_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>gid</name> <operator>=</operator> <call><name>getVertexIdDatum</name><argument_list>(<argument><expr><name>vtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>mgstate</name><operator>-&gt;</operator><name>elemTable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gid</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tid</name></name> <operator>=</operator>
					<operator>*</operator><operator>(</operator><operator>(</operator><name>ItemPointer</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><call><name>getVertexTidDatum</name><argument_list>(<argument><expr><name>vtx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>EDGEARRAYOID</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AnyArrayType</name> <modifier>*</modifier></type><name>edges</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nedges</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int16</name></type>		<name>typlen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>typbyval</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>typalign</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>array_iter</name></type>	<name>it</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>edge</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>edges</name> <operator>=</operator> <call><name>DatumGetAnyArrayP</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nedges</name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><call><name>AARR_NDIM</name><argument_list>(<argument><expr><name>edges</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>AARR_DIMS</name><argument_list>(<argument><expr><name>edges</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><call><name>AARR_ELEMTYPE</name><argument_list>(<argument><expr><name>edges</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>typlen</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>typbyval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>array_iter_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><name>edges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nedges</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>edge</name> <operator>=</operator> <call><name>array_iter_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>gid</name> <operator>=</operator> <call><name>getEdgeIdDatum</name><argument_list>(<argument><expr><name>edge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>mgstate</name><operator>-&gt;</operator><name>elemTable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gid</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>Graphid</name></type> <name>eid</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Graphid</name></type> <name>start</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Graphid</name></type> <name>end</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>eid</name> <operator>=</operator> <call><name>GraphidGetLabid</name><argument_list>(<argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>GraphidGetLabid</name><argument_list>(<argument><expr><call><name>getEdgeStartDatum</name><argument_list>(<argument><expr><name>edge</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>GraphidGetLabid</name><argument_list>(<argument><expr><call><name>getEdgeEndDatum</name><argument_list>(<argument><expr><name>edge</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>auto_gather_graphmeta</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>agstat_count_edge_delete</name><argument_list>(<argument><expr><name>eid</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tid</name></name> <operator>=</operator>
					<operator>*</operator><operator>(</operator><operator>(</operator><name>ItemPointer</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><call><name>getEdgeTidDatum</name><argument_list>(<argument><expr><name>edge</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected graph type %d"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>getVertexFinal</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>origin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ModifyGraph</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>ModifyGraph</name> <operator>*</operator><operator>)</operator> <name><name>mgstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ModifiedElemEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>gid</name> <init>= <expr><call><name>getVertexIdDatum</name><argument_list>(<argument><expr><name>origin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>mgstate</name><operator>-&gt;</operator><name>elemTable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gid</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* unmodified vertex */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>origin</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>GWROP_DELETE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>elem</name></name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>getEdgeFinal</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>origin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ModifyGraph</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>ModifyGraph</name> <operator>*</operator><operator>)</operator> <name><name>mgstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>gid</name> <init>= <expr><call><name>getEdgeIdDatum</name><argument_list>(<argument><expr><name>origin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ModifiedElemEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>mgstate</name><operator>-&gt;</operator><name>elemTable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gid</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* unmodified edge */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>origin</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>GWROP_DELETE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>elem</name></name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>getPathFinal</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>origin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>vertices_datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>edges_datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AnyArrayType</name> <modifier>*</modifier></type><name>arrVertices</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AnyArrayType</name> <modifier>*</modifier></type><name>arrEdges</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nvertices</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nedges</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>vertices</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>edges</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name>typlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typbyval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>typalign</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>array_iter</name></type>	<name>it</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>modified</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isdeleted</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>getGraphpathArrays</name><argument_list>(<argument><expr><name>origin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vertices_datum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>edges_datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>arrVertices</name> <operator>=</operator> <call><name>DatumGetAnyArrayP</name><argument_list>(<argument><expr><name>vertices_datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>arrEdges</name> <operator>=</operator> <call><name>DatumGetAnyArrayP</name><argument_list>(<argument><expr><name>edges_datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>nvertices</name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><call><name>AARR_NDIM</name><argument_list>(<argument><expr><name>arrVertices</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>AARR_DIMS</name><argument_list>(<argument><expr><name>arrVertices</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nedges</name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><call><name>AARR_NDIM</name><argument_list>(<argument><expr><name>arrEdges</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>AARR_DIMS</name><argument_list>(<argument><expr><name>arrEdges</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nvertices</name> <operator>==</operator> <name>nedges</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>vertices</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nvertices</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>edges</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nedges</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><call><name>AARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arrVertices</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>typlen</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name>typbyval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_iter_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><name>arrVertices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nvertices</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>vertex</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>array_iter_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>vertex</name> <operator>=</operator> <call><name>getVertexFinal</name><argument_list>(<argument><expr><name>mgstate</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>vertex</name> <operator>==</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>isdeleted</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>isdeleted</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot delete a vertex in graphpath"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>vertex</name> <operator>!=</operator> <name>value</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>modified</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>vertices</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>vertex</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><call><name>AARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arrEdges</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>typlen</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name>typbyval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>array_iter_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><name>arrEdges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nedges</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>edge</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>array_iter_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>edge</name> <operator>=</operator> <call><name>getEdgeFinal</name><argument_list>(<argument><expr><name>mgstate</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>edge</name> <operator>==</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>isdeleted</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot delete a edge in graphpath."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>edge</name> <operator>!=</operator> <name>value</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>modified</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>edges</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>edge</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>isdeleted</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>modified</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeGraphpathDatum</name><argument_list>(<argument><expr><name>vertices</name></expr></argument>, <argument><expr><name>nvertices</name></expr></argument>, <argument><expr><name>edges</name></expr></argument>, <argument><expr><name>nedges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>origin</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>vertices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>edges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>reflectModifiedProp</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ModifyGraph</name>	<modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>ModifyGraph</name> <operator>*</operator><operator>)</operator> <name><name>mgstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type>	<name>seq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ModifiedElemEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mgstate</name><operator>-&gt;</operator><name>elemTable</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seq</name></expr></argument>, <argument><expr><name><name>mgstate</name><operator>-&gt;</operator><name>elemTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seq</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>	<name>gid</name> <init>= <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>		<name>type</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>get_labid_typeoid</name><argument_list>(<argument><expr><name><name>mgstate</name><operator>-&gt;</operator><name>graphid</name></name></expr></argument>,
								 <argument><expr><call><name>GraphidGetLabid</name><argument_list>(<argument><expr><call><name>DatumGetGraphid</name><argument_list>(<argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* write the object to heap */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>GWROP_DELETE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>deleteElem</name><argument_list>(<argument><expr><name>mgstate</name></expr></argument>, <argument><expr><name>gid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tid</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>ItemPointer</name></type>	<name>ctid</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>ctid</name> <operator>=</operator> <call><name>updateElemProp</name><argument_list>(<argument><expr><name>mgstate</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>gid</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>elem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>mgstate</name><operator>-&gt;</operator><name>eagerness</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Datum</name></type>		<name>property</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Datum</name></type>		<name>newelem</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>VERTEXOID</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>property</name> <operator>=</operator> <call><name>getVertexPropDatum</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>elem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>EDGEOID</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>property</name> <operator>=</operator> <call><name>getEdgePropDatum</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>elem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected graph type %d"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><name>newelem</name> <operator>=</operator> <call><name>makeModifiedElem</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>elem</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>gid</name></expr></argument>,<argument><expr><name>property</name></expr></argument>,
										   <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>ctid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>elem</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>elem</name></name> <operator>=</operator> <name>newelem</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ResultRelInfo</name> <modifier>*</modifier></type>
<name>getResultRelInfo</name><parameter_list>(<parameter><decl><type><name>ModifyGraphState</name> <modifier>*</modifier></type><name>mgstate</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name><name>mgstate</name><operator>-&gt;</operator><name>resultRelations</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>mgstate</name><operator>-&gt;</operator><name>numResultRelations</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>relid</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>resultRelInfo</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name><name>mgstate</name><operator>-&gt;</operator><name>numResultRelations</name></name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid object ID %u for the target label"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>resultRelInfo</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>findVertex</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>GraphVertex</name> <modifier>*</modifier></type><name>gvertex</name></decl></parameter>, <parameter><decl><type><name>Graphid</name> <modifier>*</modifier></type><name>vid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>vertex</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>gvertex</name><operator>-&gt;</operator><name>resno</name></name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>vertex</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>gvertex</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>vid</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>vid</name> <operator>=</operator> <call><name>DatumGetGraphid</name><argument_list>(<argument><expr><call><name>getVertexIdDatum</name><argument_list>(<argument><expr><name>vertex</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>vertex</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>findEdge</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>GraphEdge</name> <modifier>*</modifier></type><name>gedge</name></decl></parameter>, <parameter><decl><type><name>Graphid</name> <modifier>*</modifier></type><name>eid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>edge</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>gedge</name><operator>-&gt;</operator><name>resno</name></name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>edge</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>gedge</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>eid</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>eid</name> <operator>=</operator> <call><name>DatumGetGraphid</name><argument_list>(<argument><expr><call><name>getEdgeIdDatum</name><argument_list>(<argument><expr><name>edge</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>edge</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AttrNumber</name></type>
<name>findAttrInSlotByName</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>namestrcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name><operator>)</operator></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>attr</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_NAME</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"variable \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>InvalidAttrNumber</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>setSlotValueByName</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>attno</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>slot</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>attno</name> <operator>=</operator> <call><name>findAttrInSlotByName</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>setSlotValueByAttnum</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>setSlotValueByAttnum</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>slot</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>attnum</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>attnum</name> <operator>&lt;=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>value</name> <operator>==</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Datum</name> <modifier>*</modifier></type>
<name>makeDatumArray</name><parameter_list>(<parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>palloc</name><argument_list>(<argument><expr><name>len</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Remove elements from range table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fitEStateRangeTable</name><parameter_list>(<parameter><decl><type><name>EState</name><modifier>*</modifier></type> <name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>estate-&gt;es_range_table</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>es_rte</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><call><name>foreach_current_index</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <name>n</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>foreach_delete_current</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_range_table</name></name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>es_rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_relations</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_range_table_size</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>fitEStateRelations</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>newsize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name> <modifier>*</modifier></type><name>saved_relations</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>es_relations</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_range_table_size</name></name> <operator>=</operator> <name>newsize</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_relations</name></name> <operator>=</operator> <operator>(</operator><name>Relation</name> <operator>*</operator><operator>)</operator>
			<call><name>palloc0</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_range_table_size</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Relation</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_relations</name></name></expr></argument>, <argument><expr><name>saved_relations</name></expr></argument>,
		   <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_range_table_size</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Relation</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>saved_relations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
