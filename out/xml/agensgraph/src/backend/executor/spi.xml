<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/executor/spi.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * spi.c
 *				Server Programming Interface
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/executor/spi.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/printtup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/heap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/spi_priv.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/pquery.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>


<comment type="block">/*
 * These global variables are part of the API for various SPI functions
 * (a horrible API choice, but it's too late now).  To reduce the risk of
 * interference between different SPI callers, we save and restore them
 * when entering/exiting a SPI nesting level.
 */</comment>
<decl_stmt><decl><type><name>uint64</name></type>		<name>SPI_processed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SPITupleTable</name> <modifier>*</modifier></type><name>SPI_tuptable</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>SPI_result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>_SPI_connection</name> <modifier>*</modifier></type><name>_SPI_stack</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>_SPI_connection</name> <modifier>*</modifier></type><name>_SPI_current</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>_SPI_stack_depth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* allocated size of _SPI_stack */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>_SPI_connected</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* current stack index */</comment>

<function_decl><type><specifier>static</specifier> <name>Portal</name></type> <name>SPI_cursor_open_internal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>SPIPlanPtr</name></type> <name>plan</name></decl></parameter>,
									   <parameter><decl><type><name>ParamListInfo</name></type> <name>paramLI</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>read_only</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_SPI_prepare_plan</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>SPIPlanPtr</name></type> <name>plan</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_SPI_prepare_oneshot_plan</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>SPIPlanPtr</name></type> <name>plan</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>_SPI_execute_plan</name><parameter_list>(<parameter><decl><type><name>SPIPlanPtr</name></type> <name>plan</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>paramLI</name></decl></parameter>,
							  <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>crosscheck_snapshot</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name></type> <name>read_only</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fire_triggers</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>tcount</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>ParamListInfo</name></type> <name>_SPI_convert_params</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>argtypes</name></decl></parameter>,
										 <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>Values</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>Nulls</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>_SPI_pquery</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fire_triggers</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>tcount</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_SPI_error_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_SPI_cursor_operation</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>,
								  <parameter><decl><type><name>FetchDirection</name></type> <name>direction</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>count</name></decl></parameter>,
								  <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>SPIPlanPtr</name></type> <name>_SPI_make_plan_non_temp</name><parameter_list>(<parameter><decl><type><name>SPIPlanPtr</name></type> <name>plan</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SPIPlanPtr</name></type> <name>_SPI_save_plan</name><parameter_list>(<parameter><decl><type><name>SPIPlanPtr</name></type> <name>plan</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>_SPI_begin_call</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>use_exec</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>_SPI_end_call</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>use_exec</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>_SPI_execmem</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>_SPI_procmem</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>_SPI_checktuples</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* =================== interface functions =================== */</comment>

<function><type><name>int</name></type>
<name>SPI_connect</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>SPI_connect_ext</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>SPI_connect_ext</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>newdepth</name></decl>;</decl_stmt>

	<comment type="block">/* Enlarge stack if necessary */</comment>
	<if_stmt><if>if <condition>(<expr><name>_SPI_stack</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>_SPI_connected</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name>_SPI_stack_depth</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI stack corrupted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>newdepth</name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>_SPI_stack</name> <operator>=</operator> <operator>(</operator><name>_SPI_connection</name> <operator>*</operator><operator>)</operator>
			<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
							   <argument><expr><name>newdepth</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>_SPI_connection</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>_SPI_stack_depth</name> <operator>=</operator> <name>newdepth</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>_SPI_stack_depth</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>_SPI_stack_depth</name> <operator>&lt;=</operator> <name>_SPI_connected</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI stack corrupted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>_SPI_stack_depth</name> <operator>==</operator> <name>_SPI_connected</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>newdepth</name> <operator>=</operator> <name>_SPI_stack_depth</name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>_SPI_stack</name> <operator>=</operator> <operator>(</operator><name>_SPI_connection</name> <operator>*</operator><operator>)</operator>
				<call><name>repalloc</name><argument_list>(<argument><expr><name>_SPI_stack</name></expr></argument>,
						 <argument><expr><name>newdepth</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>_SPI_connection</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>_SPI_stack_depth</name> <operator>=</operator> <name>newdepth</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Enter new stack level */</comment>
	<expr_stmt><expr><name>_SPI_connected</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>_SPI_connected</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>_SPI_connected</name> <operator>&lt;</operator> <name>_SPI_stack_depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>_SPI_current</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>_SPI_stack</name><index>[<expr><name>_SPI_connected</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>processed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>tuptable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>execSubid</name></name> <operator>=</operator> <name>InvalidSubTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>slist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>_SPI_current</name><operator>-&gt;</operator><name>tuptables</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>procCxt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* in case we fail to create 'em */</comment>
	<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>execCxt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>connectSubid</name></name> <operator>=</operator> <call><name>GetCurrentSubTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>queryEnv</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>atomic</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>options</name> <operator>&amp;</operator> <name>SPI_OPT_NONATOMIC</name></expr> ?</condition><then> <expr><name>false</name></expr> </then><else>: <expr><name>true</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>internal_xact</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>outer_processed</name></name> <operator>=</operator> <name>SPI_processed</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>outer_tuptable</name></name> <operator>=</operator> <name>SPI_tuptable</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>outer_result</name></name> <operator>=</operator> <name>SPI_result</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create memory contexts for this procedure
	 *
	 * In atomic contexts (the normal case), we use TopTransactionContext,
	 * otherwise PortalContext, so that it lives across transaction
	 * boundaries.
	 *
	 * XXX It could be better to use PortalContext as the parent context in
	 * all cases, but we may not be inside a portal (consider deferred-trigger
	 * execution).  Perhaps CurTransactionContext could be an option?  For now
	 * it doesn't matter because we clean up explicitly in AtEOSubXact_SPI();
	 * but see also AtEOXact_SPI().
	 */</comment>
	<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>procCxt</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>atomic</name></name></expr> ?</condition><then> <expr><name>TopTransactionContext</name></expr> </then><else>: <expr><name>PortalContext</name></expr></else></ternary></expr></argument>,
												  <argument><expr><literal type="string">"SPI Proc"</literal></expr></argument>,
												  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>execCxt</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>atomic</name></name></expr> ?</condition><then> <expr><name>TopTransactionContext</name></expr> </then><else>: <expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>procCxt</name></name></expr></else></ternary></expr></argument>,
												  <argument><expr><literal type="string">"SPI Exec"</literal></expr></argument>,
												  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* ... and switch to procedure's context */</comment>
	<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>savedcxt</name></name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>procCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Reset API global variables so that current caller cannot accidentally
	 * depend on state of an outer caller.
	 */</comment>
	<expr_stmt><expr><name>SPI_processed</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>SPI_tuptable</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>SPI_result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<return>return <expr><name>SPI_OK_CONNECT</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>SPI_finish</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_SPI_begin_call</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* just check we're connected */</comment>
	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Restore memory context as it was before procedure call */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>savedcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Release memory used in procedure call (including tuptables) */</comment>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>execCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>execCxt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>procCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>procCxt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Restore outer API variables, especially SPI_tuptable which is probably
	 * pointing at a just-deleted tuptable
	 */</comment>
	<expr_stmt><expr><name>SPI_processed</name> <operator>=</operator> <name><name>_SPI_current</name><operator>-&gt;</operator><name>outer_processed</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>SPI_tuptable</name> <operator>=</operator> <name><name>_SPI_current</name><operator>-&gt;</operator><name>outer_tuptable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>SPI_result</name> <operator>=</operator> <name><name>_SPI_current</name><operator>-&gt;</operator><name>outer_result</name></name></expr>;</expr_stmt>

	<comment type="block">/* Exit stack level */</comment>
	<expr_stmt><expr><name>_SPI_connected</name><operator>--</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>_SPI_connected</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>_SPI_current</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>_SPI_current</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>_SPI_stack</name><index>[<expr><name>_SPI_connected</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>SPI_OK_FINISH</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SPI_start_transaction is a no-op, kept for backwards compatibility.
 * SPI callers are *always* inside a transaction.
 */</comment>
<function><type><name>void</name></type>
<name>SPI_start_transaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_SPI_commit</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>chain</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Complain if we are in a context that doesn't permit transaction
	 * termination.  (Note: here and _SPI_rollback should be the only places
	 * that throw ERRCODE_INVALID_TRANSACTION_TERMINATION, so that callers can
	 * test for that with security that they know what happened.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>atomic</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TRANSACTION_TERMINATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid transaction termination"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * This restriction is required by PLs implemented on top of SPI.  They
	 * use subtransactions to establish exception blocks that are supposed to
	 * be rolled back together if there is an error.  Terminating the
	 * top-level transaction in such a block violates that idea.  A future PL
	 * implementation might have different ideas about this, in which case
	 * this restriction would have to be refined or the check possibly be
	 * moved out of SPI into the PLs.  Note however that the code below relies
	 * on not being within a subtransaction.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsSubTransaction</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TRANSACTION_TERMINATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot commit while a subtransaction is active"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* XXX this ain't re-entrant enough for my taste */</comment>
	<if_stmt><if>if <condition>(<expr><name>chain</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SaveTransactionCharacteristics</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Catch any error occurring during the COMMIT */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/* Protect current SPI stack entry against deletion */</comment>
		<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>internal_xact</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Hold any pinned portals that any PLs might be using.  We have to do
		 * this before changing transaction state, since this will run
		 * user-defined code that might throw an error.
		 */</comment>
		<expr_stmt><expr><call><name>HoldPinnedPortals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Release snapshots associated with portals */</comment>
		<expr_stmt><expr><call><name>ForgetPortalSnapshots</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Do the deed */</comment>
		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Immediately start a new transaction */</comment>
		<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>chain</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>RestoreTransactionCharacteristics</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>internal_xact</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name></decl>;</decl_stmt>

		<comment type="block">/* Save error info in caller's context */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>edata</name> <operator>=</operator> <call><name>CopyErrorData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Abort the failed transaction.  If this fails too, we'll just
		 * propagate the error out ... there's not that much we can do.
		 */</comment>
		<expr_stmt><expr><call><name>AbortCurrentTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* ... and start a new one */</comment>
		<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>chain</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>RestoreTransactionCharacteristics</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>internal_xact</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/* Now that we've cleaned up the transaction, re-throw the error */</comment>
		<expr_stmt><expr><call><name>ReThrowError</name><argument_list>(<argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>SPI_commit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>_SPI_commit</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>SPI_commit_and_chain</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>_SPI_commit</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_SPI_rollback</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>chain</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* see under SPI_commit() */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>atomic</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TRANSACTION_TERMINATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid transaction termination"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* see under SPI_commit() */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsSubTransaction</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TRANSACTION_TERMINATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot roll back while a subtransaction is active"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* XXX this ain't re-entrant enough for my taste */</comment>
	<if_stmt><if>if <condition>(<expr><name>chain</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SaveTransactionCharacteristics</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Catch any error occurring during the ROLLBACK */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/* Protect current SPI stack entry against deletion */</comment>
		<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>internal_xact</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Hold any pinned portals that any PLs might be using.  We have to do
		 * this before changing transaction state, since this will run
		 * user-defined code that might throw an error, and in any case
		 * couldn't be run in an already-aborted transaction.
		 */</comment>
		<expr_stmt><expr><call><name>HoldPinnedPortals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Release snapshots associated with portals */</comment>
		<expr_stmt><expr><call><name>ForgetPortalSnapshots</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Do the deed */</comment>
		<expr_stmt><expr><call><name>AbortCurrentTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Immediately start a new transaction */</comment>
		<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>chain</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>RestoreTransactionCharacteristics</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>internal_xact</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name></decl>;</decl_stmt>

		<comment type="block">/* Save error info in caller's context */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>edata</name> <operator>=</operator> <call><name>CopyErrorData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Try again to abort the failed transaction.  If this fails too,
		 * we'll just propagate the error out ... there's not that much we can
		 * do.
		 */</comment>
		<expr_stmt><expr><call><name>AbortCurrentTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* ... and start a new one */</comment>
		<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>chain</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>RestoreTransactionCharacteristics</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>internal_xact</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/* Now that we've cleaned up the transaction, re-throw the error */</comment>
		<expr_stmt><expr><call><name>ReThrowError</name><argument_list>(<argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>SPI_rollback</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>_SPI_rollback</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>SPI_rollback_and_chain</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>_SPI_rollback</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SPICleanup is a no-op, kept for backwards compatibility. We rely on
 * AtEOXact_SPI to cleanup. Extensions should not (need to) fiddle with the
 * internal SPI state directly.
 */</comment>
<function><type><name>void</name></type>
<name>SPICleanup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
</block_content>}</block></function>

<comment type="block">/*
 * Clean up SPI state at transaction commit or abort.
 */</comment>
<function><type><name>void</name></type>
<name>AtEOXact_SPI</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Pop stack entries, stopping if we find one marked internal_xact (that
	 * one belongs to the caller of SPI_commit or SPI_abort).
	 */</comment>
	<while>while <condition>(<expr><name>_SPI_connected</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>_SPI_connection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>_SPI_stack</name><index>[<expr><name>_SPI_connected</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>connection</name><operator>-&gt;</operator><name>internal_xact</name></name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * We need not release the procedure's memory contexts explicitly, as
		 * they'll go away automatically when their parent context does; see
		 * notes in SPI_connect_ext.
		 */</comment>

		<comment type="block">/*
		 * Restore outer global variables and pop the stack entry.  Unlike
		 * SPI_finish(), we don't risk switching to memory contexts that might
		 * be already gone.
		 */</comment>
		<expr_stmt><expr><name>SPI_processed</name> <operator>=</operator> <name><name>connection</name><operator>-&gt;</operator><name>outer_processed</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>SPI_tuptable</name> <operator>=</operator> <name><name>connection</name><operator>-&gt;</operator><name>outer_tuptable</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>SPI_result</name> <operator>=</operator> <name><name>connection</name><operator>-&gt;</operator><name>outer_result</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>_SPI_connected</name><operator>--</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>_SPI_connected</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>_SPI_current</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>_SPI_current</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>_SPI_stack</name><index>[<expr><name>_SPI_connected</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* We should only find entries to pop during an ABORT. */</comment>
	<if_stmt><if>if <condition>(<expr><name>found</name> <operator>&amp;&amp;</operator> <name>isCommit</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WARNING</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"transaction left non-empty SPI stack"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Check for missing \"SPI_finish\" calls."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Clean up SPI state at subtransaction commit or abort.
 *
 * During commit, there shouldn't be any unclosed entries remaining from
 * the current subtransaction; we emit a warning if any are found.
 */</comment>
<function><type><name>void</name></type>
<name>AtEOSubXact_SPI</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>, <parameter><decl><type><name>SubTransactionId</name></type> <name>mySubid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>_SPI_connected</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>_SPI_connection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>_SPI_stack</name><index>[<expr><name>_SPI_connected</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>connection</name><operator>-&gt;</operator><name>connectSubid</name></name> <operator>!=</operator> <name>mySubid</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>				<comment type="block">/* couldn't be any underneath it either */</comment>

		<if_stmt><if>if <condition>(<expr><name><name>connection</name><operator>-&gt;</operator><name>internal_xact</name></name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Release procedure memory explicitly (see note in SPI_connect)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>connection</name><operator>-&gt;</operator><name>execCxt</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>execCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>execCxt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>connection</name><operator>-&gt;</operator><name>procCxt</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>procCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>procCxt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Restore outer global variables and pop the stack entry.  Unlike
		 * SPI_finish(), we don't risk switching to memory contexts that might
		 * be already gone.
		 */</comment>
		<expr_stmt><expr><name>SPI_processed</name> <operator>=</operator> <name><name>connection</name><operator>-&gt;</operator><name>outer_processed</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>SPI_tuptable</name> <operator>=</operator> <name><name>connection</name><operator>-&gt;</operator><name>outer_tuptable</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>SPI_result</name> <operator>=</operator> <name><name>connection</name><operator>-&gt;</operator><name>outer_result</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>_SPI_connected</name><operator>--</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>_SPI_connected</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>_SPI_current</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>_SPI_current</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>_SPI_stack</name><index>[<expr><name>_SPI_connected</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>found</name> <operator>&amp;&amp;</operator> <name>isCommit</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WARNING</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"subtransaction left non-empty SPI stack"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Check for missing \"SPI_finish\" calls."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we are aborting a subtransaction and there is an open SPI context
	 * surrounding the subxact, clean up to prevent memory leakage.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>_SPI_current</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isCommit</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>slist_mutable_iter</name></type> <name>siter</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Throw away executor state if current executor operation was started
		 * within current subxact (essentially, force a _SPI_end_call(true)).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>execSubid</name></name> <operator>&gt;=</operator> <name>mySubid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>execSubid</name></name> <operator>=</operator> <name>InvalidSubTransactionId</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>execCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* throw away any tuple tables created within current subxact */</comment>
		<macro><name>slist_foreach_modify</name><argument_list>(<argument>siter</argument>, <argument>&amp;_SPI_current-&gt;tuptables</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SPITupleTable</name> <modifier>*</modifier></type><name>tuptable</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>tuptable</name> <operator>=</operator> <call><name>slist_container</name><argument_list>(<argument><expr><name>SPITupleTable</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name><name>siter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>tuptable</name><operator>-&gt;</operator><name>subid</name></name> <operator>&gt;=</operator> <name>mySubid</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * If we used SPI_freetuptable() here, its internal search of
				 * the tuptables list would make this operation O(N^2).
				 * Instead, just free the tuptable manually.  This should
				 * match what SPI_freetuptable() does.
				 */</comment>
				<expr_stmt><expr><call><name>slist_delete_current</name><argument_list>(<argument><expr><operator>&amp;</operator><name>siter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>tuptable</name> <operator>==</operator> <name><name>_SPI_current</name><operator>-&gt;</operator><name>tuptable</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>tuptable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>tuptable</name> <operator>==</operator> <name>SPI_tuptable</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>SPI_tuptable</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>tuptable</name><operator>-&gt;</operator><name>tuptabcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Are we executing inside a procedure (that is, a nonatomic SPI context)?
 */</comment>
<function><type><name>bool</name></type>
<name>SPI_inside_nonatomic_context</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>_SPI_current</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* not in any SPI context at all */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>atomic</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* it's atomic (ie function not procedure) */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Parse, plan, and execute a query string */</comment>
<function><type><name>int</name></type>
<name>SPI_execute</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>read_only</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>tcount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>_SPI_plan</name></type>	<name>plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>res</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>src</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>tcount</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>SPI_ERROR_ARGUMENT</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_SPI_begin_call</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>plan</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>_SPI_plan</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>.</operator><name>magic</name></name> <operator>=</operator> <name>_SPI_PLAN_MAGIC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>.</operator><name>cursor_options</name></name> <operator>=</operator> <name>CURSOR_OPT_PARALLEL_OK</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_SPI_prepare_oneshot_plan</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_SPI_execute_plan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>plan</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							<argument><expr><name>InvalidSnapshot</name></expr></argument>, <argument><expr><name>InvalidSnapshot</name></expr></argument>,
							<argument><expr><name>read_only</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>tcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_SPI_end_call</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Obsolete version of SPI_execute */</comment>
<function><type><name>int</name></type>
<name>SPI_exec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>tcount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>SPI_execute</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>tcount</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Execute a previously prepared plan */</comment>
<function><type><name>int</name></type>
<name>SPI_execute_plan</name><parameter_list>(<parameter><decl><type><name>SPIPlanPtr</name></type> <name>plan</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>Values</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>Nulls</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>read_only</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>tcount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>res</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>plan</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>plan</name><operator>-&gt;</operator><name>magic</name></name> <operator>!=</operator> <name>_SPI_PLAN_MAGIC</name> <operator>||</operator> <name>tcount</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>SPI_ERROR_ARGUMENT</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>nargs</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>Values</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>SPI_ERROR_PARAM</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_SPI_begin_call</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_SPI_execute_plan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>,
							<argument><expr><call><name>_SPI_convert_params</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>nargs</name></name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>argtypes</name></name></expr></argument>,
												<argument><expr><name>Values</name></expr></argument>, <argument><expr><name>Nulls</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>InvalidSnapshot</name></expr></argument>, <argument><expr><name>InvalidSnapshot</name></expr></argument>,
							<argument><expr><name>read_only</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>tcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_SPI_end_call</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Obsolete version of SPI_execute_plan */</comment>
<function><type><name>int</name></type>
<name>SPI_execp</name><parameter_list>(<parameter><decl><type><name>SPIPlanPtr</name></type> <name>plan</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>Values</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>Nulls</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>tcount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>SPI_execute_plan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>Values</name></expr></argument>, <argument><expr><name>Nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>tcount</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Execute a previously prepared plan */</comment>
<function><type><name>int</name></type>
<name>SPI_execute_plan_with_paramlist</name><parameter_list>(<parameter><decl><type><name>SPIPlanPtr</name></type> <name>plan</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>read_only</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>tcount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>res</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>plan</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>plan</name><operator>-&gt;</operator><name>magic</name></name> <operator>!=</operator> <name>_SPI_PLAN_MAGIC</name> <operator>||</operator> <name>tcount</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>SPI_ERROR_ARGUMENT</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_SPI_begin_call</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_SPI_execute_plan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>params</name></expr></argument>,
							<argument><expr><name>InvalidSnapshot</name></expr></argument>, <argument><expr><name>InvalidSnapshot</name></expr></argument>,
							<argument><expr><name>read_only</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>tcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_SPI_end_call</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SPI_execute_snapshot -- identical to SPI_execute_plan, except that we allow
 * the caller to specify exactly which snapshots to use, which will be
 * registered here.  Also, the caller may specify that AFTER triggers should be
 * queued as part of the outer query rather than being fired immediately at the
 * end of the command.
 *
 * This is currently not documented in spi.sgml because it is only intended
 * for use by RI triggers.
 *
 * Passing snapshot == InvalidSnapshot will select the normal behavior of
 * fetching a new snapshot for each query.
 */</comment>
<function><type><name>int</name></type>
<name>SPI_execute_snapshot</name><parameter_list>(<parameter><decl><type><name>SPIPlanPtr</name></type> <name>plan</name></decl></parameter>,
					 <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>Values</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>Nulls</name></decl></parameter>,
					 <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>crosscheck_snapshot</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>read_only</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fire_triggers</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>tcount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>res</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>plan</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>plan</name><operator>-&gt;</operator><name>magic</name></name> <operator>!=</operator> <name>_SPI_PLAN_MAGIC</name> <operator>||</operator> <name>tcount</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>SPI_ERROR_ARGUMENT</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>nargs</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>Values</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>SPI_ERROR_PARAM</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_SPI_begin_call</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_SPI_execute_plan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>,
							<argument><expr><call><name>_SPI_convert_params</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>nargs</name></name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>argtypes</name></name></expr></argument>,
												<argument><expr><name>Values</name></expr></argument>, <argument><expr><name>Nulls</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>crosscheck_snapshot</name></expr></argument>,
							<argument><expr><name>read_only</name></expr></argument>, <argument><expr><name>fire_triggers</name></expr></argument>, <argument><expr><name>tcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_SPI_end_call</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SPI_execute_with_args -- plan and execute a query with supplied arguments
 *
 * This is functionally equivalent to SPI_prepare followed by
 * SPI_execute_plan.
 */</comment>
<function><type><name>int</name></type>
<name>SPI_execute_with_args</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>argtypes</name></decl></parameter>,
					  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>Values</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>Nulls</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>read_only</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>tcount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>_SPI_plan</name></type>	<name>plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramLI</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>src</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>tcount</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>SPI_ERROR_ARGUMENT</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>argtypes</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>Values</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>SPI_ERROR_PARAM</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_SPI_begin_call</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>plan</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>_SPI_plan</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>.</operator><name>magic</name></name> <operator>=</operator> <name>_SPI_PLAN_MAGIC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>.</operator><name>cursor_options</name></name> <operator>=</operator> <name>CURSOR_OPT_PARALLEL_OK</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>.</operator><name>nargs</name></name> <operator>=</operator> <name>nargs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>.</operator><name>argtypes</name></name> <operator>=</operator> <name>argtypes</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>.</operator><name>parserSetup</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>.</operator><name>parserSetupArg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>paramLI</name> <operator>=</operator> <call><name>_SPI_convert_params</name><argument_list>(<argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>,
								  <argument><expr><name>Values</name></expr></argument>, <argument><expr><name>Nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_SPI_prepare_oneshot_plan</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_SPI_execute_plan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>plan</name></expr></argument>, <argument><expr><name>paramLI</name></expr></argument>,
							<argument><expr><name>InvalidSnapshot</name></expr></argument>, <argument><expr><name>InvalidSnapshot</name></expr></argument>,
							<argument><expr><name>read_only</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>tcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_SPI_end_call</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>SPIPlanPtr</name></type>
<name>SPI_prepare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>argtypes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>SPI_prepare_cursor</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>SPIPlanPtr</name></type>
<name>SPI_prepare_cursor</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>argtypes</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>cursorOptions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>_SPI_plan</name></type>	<name>plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SPIPlanPtr</name></type>	<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>src</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>nargs</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>argtypes</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>SPI_result</name> <operator>=</operator> <name>SPI_ERROR_ARGUMENT</name></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>SPI_result</name> <operator>=</operator> <call><name>_SPI_begin_call</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>SPI_result</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>plan</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>_SPI_plan</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>.</operator><name>magic</name></name> <operator>=</operator> <name>_SPI_PLAN_MAGIC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>.</operator><name>cursor_options</name></name> <operator>=</operator> <name>cursorOptions</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>.</operator><name>nargs</name></name> <operator>=</operator> <name>nargs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>.</operator><name>argtypes</name></name> <operator>=</operator> <name>argtypes</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>.</operator><name>parserSetup</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>.</operator><name>parserSetupArg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_SPI_prepare_plan</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* copy plan to procedure context */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>_SPI_make_plan_non_temp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_SPI_end_call</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>SPIPlanPtr</name></type>
<name>SPI_prepare_params</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>,
				   <parameter><decl><type><name>ParserSetupHook</name></type> <name>parserSetup</name></decl></parameter>,
				   <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>parserSetupArg</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>cursorOptions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>_SPI_plan</name></type>	<name>plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SPIPlanPtr</name></type>	<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>src</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>SPI_result</name> <operator>=</operator> <name>SPI_ERROR_ARGUMENT</name></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>SPI_result</name> <operator>=</operator> <call><name>_SPI_begin_call</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>SPI_result</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>plan</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>_SPI_plan</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>.</operator><name>magic</name></name> <operator>=</operator> <name>_SPI_PLAN_MAGIC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>.</operator><name>cursor_options</name></name> <operator>=</operator> <name>cursorOptions</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>.</operator><name>nargs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>.</operator><name>argtypes</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>.</operator><name>parserSetup</name></name> <operator>=</operator> <name>parserSetup</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>.</operator><name>parserSetupArg</name></name> <operator>=</operator> <name>parserSetupArg</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_SPI_prepare_plan</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* copy plan to procedure context */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>_SPI_make_plan_non_temp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_SPI_end_call</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>SPI_keepplan</name><parameter_list>(<parameter><decl><type><name>SPIPlanPtr</name></type> <name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>plan</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>plan</name><operator>-&gt;</operator><name>magic</name></name> <operator>!=</operator> <name>_SPI_PLAN_MAGIC</name> <operator>||</operator>
		<name><name>plan</name><operator>-&gt;</operator><name>saved</name></name> <operator>||</operator> <name><name>plan</name><operator>-&gt;</operator><name>oneshot</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>SPI_ERROR_ARGUMENT</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Mark it saved, reparent it under CacheMemoryContext, and mark all the
	 * component CachedPlanSources as saved.  This sequence cannot fail
	 * partway through, so there's no risk of long-term memory leakage.
	 */</comment>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>saved</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSetParent</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>plancxt</name></name></expr></argument>, <argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>plan-&gt;plancache_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>plansource</name> <init>= <expr><operator>(</operator><name>CachedPlanSource</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>SaveCachedPlan</name><argument_list>(<argument><expr><name>plansource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>SPIPlanPtr</name></type>
<name>SPI_saveplan</name><parameter_list>(<parameter><decl><type><name>SPIPlanPtr</name></type> <name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SPIPlanPtr</name></type>	<name>newplan</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>plan</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>plan</name><operator>-&gt;</operator><name>magic</name></name> <operator>!=</operator> <name>_SPI_PLAN_MAGIC</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>SPI_result</name> <operator>=</operator> <name>SPI_ERROR_ARGUMENT</name></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>SPI_result</name> <operator>=</operator> <call><name>_SPI_begin_call</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* don't change context */</comment>
	<if_stmt><if>if <condition>(<expr><name>SPI_result</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>newplan</name> <operator>=</operator> <call><name>_SPI_save_plan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>SPI_result</name> <operator>=</operator> <call><name>_SPI_end_call</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>newplan</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>SPI_freeplan</name><parameter_list>(<parameter><decl><type><name>SPIPlanPtr</name></type> <name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>plan</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>plan</name><operator>-&gt;</operator><name>magic</name></name> <operator>!=</operator> <name>_SPI_PLAN_MAGIC</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>SPI_ERROR_ARGUMENT</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Release the plancache entries */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>plan-&gt;plancache_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>plansource</name> <init>= <expr><operator>(</operator><name>CachedPlanSource</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>DropCachedPlan</name><argument_list>(<argument><expr><name>plansource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Now get rid of the _SPI_plan and subsidiary data in its plancxt */</comment>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>plancxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>HeapTuple</name></type>
<name>SPI_copytuple</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>ctuple</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>tuple</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>SPI_result</name> <operator>=</operator> <name>SPI_ERROR_ARGUMENT</name></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>_SPI_current</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>SPI_result</name> <operator>=</operator> <name>SPI_ERROR_UNCONNECTED</name></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>savedcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ctuple</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ctuple</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>HeapTupleHeader</name></type>
<name>SPI_returntuple</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>dtup</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>tuple</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>tupdesc</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>SPI_result</name> <operator>=</operator> <name>SPI_ERROR_ARGUMENT</name></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>_SPI_current</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>SPI_result</name> <operator>=</operator> <name>SPI_ERROR_UNCONNECTED</name></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* For RECORD results, make sure a typmod has been assigned */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypeid</name></name> <operator>==</operator> <name>RECORDOID</name> <operator>&amp;&amp;</operator>
		<name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypmod</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>assign_record_type_typmod</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>savedcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>dtup</name> <operator>=</operator> <call><name>DatumGetHeapTupleHeader</name><argument_list>(<argument><expr><call><name>heap_copy_tuple_as_datum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>dtup</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>HeapTuple</name></type>
<name>SPI_modifytuple</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>natts</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>attnum</name></decl></parameter>,
				<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>Values</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>Nulls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>mtuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numberOfAttributes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>rel</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>tuple</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>natts</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>attnum</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>Values</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>SPI_result</name> <operator>=</operator> <name>SPI_ERROR_ARGUMENT</name></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>_SPI_current</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>SPI_result</name> <operator>=</operator> <name>SPI_ERROR_UNCONNECTED</name></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>savedcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>SPI_result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>numberOfAttributes</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numberOfAttributes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numberOfAttributes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* fetch old values and nulls */</comment>
	<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* replace values and nulls */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>attnum</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>attnum</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name>numberOfAttributes</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>v</name><index>[<expr><name><name>attnum</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>Values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>n</name><index>[<expr><name><name>attnum</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>Nulls</name> <operator>&amp;&amp;</operator> <name><name>Nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'n'</literal><operator>)</operator></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>natts</name></expr>)</condition>				<comment type="block">/* no errors in *attnum */</comment>
	<block>{<block_content>
		<expr_stmt><expr><name>mtuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * copy the identification info of the old tuple: t_ctid, t_self, and
		 * OID (if any)
		 */</comment>
		<expr_stmt><expr><name><name>mtuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mtuple</name><operator>-&gt;</operator><name>t_self</name></name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mtuple</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>mtuple</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>SPI_result</name> <operator>=</operator> <name>SPI_ERROR_NOATTRIBUTE</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>mtuple</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>SPI_fnumber</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>FormData_pg_attribute</name> <modifier>*</modifier></type><name>sysatt</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>res</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>res</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>namestrcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<operator>!</operator><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>res</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>sysatt</name> <operator>=</operator> <call><name>SystemAttributeByName</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>sysatt</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>sysatt</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* SPI_ERROR_NOATTRIBUTE is different from all sys column numbers */</comment>
	<return>return <expr><name>SPI_ERROR_NOATTRIBUTE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>SPI_fname</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fnumber</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>FormData_pg_attribute</name> <modifier>*</modifier></type><name>att</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>SPI_result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fnumber</name> <operator>&gt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>||</operator> <name>fnumber</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<name>fnumber</name> <operator>&lt;=</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>SPI_result</name> <operator>=</operator> <name>SPI_ERROR_NOATTRIBUTE</name></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>fnumber</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>att</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>fnumber</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>att</name> <operator>=</operator> <call><name>SystemAttributeDefinition</name><argument_list>(<argument><expr><name>fnumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>SPI_getvalue</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fnumber</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typoid</name></decl>,
				<decl><type ref="prev"/><name>foutoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typisvarlena</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>SPI_result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fnumber</name> <operator>&gt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>||</operator> <name>fnumber</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<name>fnumber</name> <operator>&lt;=</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>SPI_result</name> <operator>=</operator> <name>SPI_ERROR_NOATTRIBUTE</name></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>fnumber</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>fnumber</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>typoid</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>fnumber</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>typoid</name> <operator>=</operator> <operator>(</operator><call><name>SystemAttributeDefinition</name><argument_list>(<argument><expr><name>fnumber</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>atttypid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name>typoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>foutoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typisvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>foutoid</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>SPI_getbinval</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fnumber</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>SPI_result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fnumber</name> <operator>&gt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>||</operator> <name>fnumber</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<name>fnumber</name> <operator>&lt;=</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>SPI_result</name> <operator>=</operator> <name>SPI_ERROR_NOATTRIBUTE</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>fnumber</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>SPI_gettype</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fnumber</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>typeTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>SPI_result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fnumber</name> <operator>&gt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>||</operator> <name>fnumber</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<name>fnumber</name> <operator>&lt;=</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>SPI_result</name> <operator>=</operator> <name>SPI_ERROR_NOATTRIBUTE</name></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>fnumber</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>typoid</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>fnumber</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>typoid</name> <operator>=</operator> <operator>(</operator><call><name>SystemAttributeDefinition</name><argument_list>(<argument><expr><name>fnumber</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>atttypid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>typeTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>SPI_result</name> <operator>=</operator> <name>SPI_ERROR_TYPUNKNOWN</name></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>typname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the data type OID for a column.
 *
 * There's nothing similar for typmod and typcollation.  The rare consumers
 * thereof should inspect the TupleDesc directly.
 */</comment>
<function><type><name>Oid</name></type>
<name>SPI_gettypeid</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fnumber</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>SPI_result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fnumber</name> <operator>&gt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>||</operator> <name>fnumber</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<name>fnumber</name> <operator>&lt;=</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>SPI_result</name> <operator>=</operator> <name>SPI_ERROR_NOATTRIBUTE</name></expr>;</expr_stmt>
		<return>return <expr><name>InvalidOid</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>fnumber</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>fnumber</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><call><name>SystemAttributeDefinition</name><argument_list>(<argument><expr><name>fnumber</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>atttypid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>SPI_getrelname</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>SPI_getnspname</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>
<name>SPI_palloc</name><parameter_list>(<parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>_SPI_current</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_palloc called while not connected to SPI"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>savedcxt</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>
<name>SPI_repalloc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pointer</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* No longer need to worry which context chunk was in... */</comment>
	<return>return <expr><call><name>repalloc</name><argument_list>(<argument><expr><name>pointer</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>SPI_pfree</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pointer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* No longer need to worry which context chunk was in... */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pointer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>SPI_datumTransfer</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>typByVal</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>typLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>_SPI_current</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_datumTransfer called while not connected to SPI"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>savedcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>datumTransfer</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>typByVal</name></expr></argument>, <argument><expr><name>typLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>SPI_freetuple</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* No longer need to worry which context tuple was in... */</comment>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>SPI_freetuptable</name><parameter_list>(<parameter><decl><type><name>SPITupleTable</name> <modifier>*</modifier></type><name>tuptable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* ignore call if NULL pointer */</comment>
	<if_stmt><if>if <condition>(<expr><name>tuptable</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Search only the topmost SPI context for a matching tuple table.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>_SPI_current</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>slist_mutable_iter</name></type> <name>siter</name></decl>;</decl_stmt>

		<comment type="block">/* find tuptable in active list, then remove it */</comment>
		<macro><name>slist_foreach_modify</name><argument_list>(<argument>siter</argument>, <argument>&amp;_SPI_current-&gt;tuptables</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SPITupleTable</name> <modifier>*</modifier></type><name>tt</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>tt</name> <operator>=</operator> <call><name>slist_container</name><argument_list>(<argument><expr><name>SPITupleTable</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name><name>siter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>tt</name> <operator>==</operator> <name>tuptable</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>slist_delete_current</name><argument_list>(<argument><expr><operator>&amp;</operator><name>siter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Refuse the deletion if we didn't find it in the topmost SPI context.
	 * This is primarily a guard against double deletion, but might prevent
	 * other errors as well.  Since the worst consequence of not deleting a
	 * tuptable would be a transient memory leak, this is just a WARNING.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"attempt to delete invalid SPITupleTable %p"</literal></expr></argument>, <argument><expr><name>tuptable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* for safety, reset global variables that might point at tuptable */</comment>
	<if_stmt><if>if <condition>(<expr><name>tuptable</name> <operator>==</operator> <name><name>_SPI_current</name><operator>-&gt;</operator><name>tuptable</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>tuptable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>tuptable</name> <operator>==</operator> <name>SPI_tuptable</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>SPI_tuptable</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* release all memory belonging to tuptable */</comment>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>tuptable</name><operator>-&gt;</operator><name>tuptabcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SPI_cursor_open()
 *
 *	Open a prepared SPI plan as a portal
 */</comment>
<function><type><name>Portal</name></type>
<name>SPI_cursor_open</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>SPIPlanPtr</name></type> <name>plan</name></decl></parameter>,
				<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>Values</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>Nulls</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>read_only</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Portal</name></type>		<name>portal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramLI</name></decl>;</decl_stmt>

	<comment type="block">/* build transient ParamListInfo in caller's context */</comment>
	<expr_stmt><expr><name>paramLI</name> <operator>=</operator> <call><name>_SPI_convert_params</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>nargs</name></name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>argtypes</name></name></expr></argument>,
								  <argument><expr><name>Values</name></expr></argument>, <argument><expr><name>Nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>SPI_cursor_open_internal</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>, <argument><expr><name>paramLI</name></expr></argument>, <argument><expr><name>read_only</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* done with the transient ParamListInfo */</comment>
	<if_stmt><if>if <condition>(<expr><name>paramLI</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>paramLI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>portal</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SPI_cursor_open_with_args()
 *
 * Parse and plan a query and open it as a portal.
 */</comment>
<function><type><name>Portal</name></type>
<name>SPI_cursor_open_with_args</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
						  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>,
						  <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>argtypes</name></decl></parameter>,
						  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>Values</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>Nulls</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name></type> <name>read_only</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cursorOptions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Portal</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>_SPI_plan</name></type>	<name>plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramLI</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>src</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_cursor_open_with_args called with invalid arguments"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>argtypes</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>Values</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_cursor_open_with_args called with missing parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>SPI_result</name> <operator>=</operator> <call><name>_SPI_begin_call</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>SPI_result</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_cursor_open_with_args called while not connected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>plan</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>_SPI_plan</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>.</operator><name>magic</name></name> <operator>=</operator> <name>_SPI_PLAN_MAGIC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>.</operator><name>cursor_options</name></name> <operator>=</operator> <name>cursorOptions</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>.</operator><name>nargs</name></name> <operator>=</operator> <name>nargs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>.</operator><name>argtypes</name></name> <operator>=</operator> <name>argtypes</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>.</operator><name>parserSetup</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>.</operator><name>parserSetupArg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* build transient ParamListInfo in executor context */</comment>
	<expr_stmt><expr><name>paramLI</name> <operator>=</operator> <call><name>_SPI_convert_params</name><argument_list>(<argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>,
								  <argument><expr><name>Values</name></expr></argument>, <argument><expr><name>Nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_SPI_prepare_plan</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We needn't copy the plan; SPI_cursor_open_internal will do so */</comment>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>SPI_cursor_open_internal</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>plan</name></expr></argument>, <argument><expr><name>paramLI</name></expr></argument>, <argument><expr><name>read_only</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* And clean up */</comment>
	<expr_stmt><expr><call><name>_SPI_end_call</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SPI_cursor_open_with_paramlist()
 *
 *	Same as SPI_cursor_open except that parameters (if any) are passed
 *	as a ParamListInfo, which supports dynamic parameter set determination
 */</comment>
<function><type><name>Portal</name></type>
<name>SPI_cursor_open_with_paramlist</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>SPIPlanPtr</name></type> <name>plan</name></decl></parameter>,
							   <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>read_only</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>SPI_cursor_open_internal</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>read_only</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SPI_cursor_open_internal()
 *
 *	Common code for SPI_cursor_open variants
 */</comment>
<function><type><specifier>static</specifier> <name>Portal</name></type>
<name>SPI_cursor_open_internal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>SPIPlanPtr</name></type> <name>plan</name></decl></parameter>,
						 <parameter><decl><type><name>ParamListInfo</name></type> <name>paramLI</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>read_only</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>plansource</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CachedPlan</name> <modifier>*</modifier></type><name>cplan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>stmt_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>query_string</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snapshot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Portal</name></type>		<name>portal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>spierrcontext</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check that the plan is something the Portal code will special-case as
	 * returning one tupleset.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SPI_is_cursor_plan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* try to give a good error message */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>plancache_list</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_CURSOR_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot open multi-query plan as cursor"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>plansource</name> <operator>=</operator> <operator>(</operator><name>CachedPlanSource</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>plancache_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_CURSOR_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/* translator: %s is name of a SQL command, eg INSERT */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot open %s query as cursor"</literal></expr></argument>,
						<argument><expr><call><name>GetCommandTagName</name><argument_list>(<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>commandTag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>plancache_list</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>plansource</name> <operator>=</operator> <operator>(</operator><name>CachedPlanSource</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>plancache_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Push the SPI stack */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>_SPI_begin_call</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_cursor_open called while not connected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Reset SPI result (note we deliberately don't touch lastoid) */</comment>
	<expr_stmt><expr><name>SPI_processed</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>SPI_tuptable</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>processed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>tuptable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Create the portal */</comment>
	<if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Use a random nonconflicting name */</comment>
		<expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>CreateNewPortal</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* In this path, error if portal of same name already exists */</comment>
		<expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>CreatePortal</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Copy the plan's query string into the portal */</comment>
	<expr_stmt><expr><name>query_string</name> <operator>=</operator> <call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>portalContext</name></name></expr></argument>,
									   <argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>query_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Setup error traceback support for ereport(), in case GetCachedPlan
	 * throws an error.
	 */</comment>
	<expr_stmt><expr><name><name>spierrcontext</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>_SPI_error_callback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>spierrcontext</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <call><name>unconstify</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>, <argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>query_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>spierrcontext</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>spierrcontext</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note: for a saved plan, we mustn't have any failure occur between
	 * GetCachedPlan and PortalDefineQuery; that would result in leaking our
	 * plancache refcount.
	 */</comment>

	<comment type="block">/* Replan if needed, and increment plan refcount for portal */</comment>
	<expr_stmt><expr><name>cplan</name> <operator>=</operator> <call><name>GetCachedPlan</name><argument_list>(<argument><expr><name>plansource</name></expr></argument>, <argument><expr><name>paramLI</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>queryEnv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>stmt_list</name> <operator>=</operator> <name><name>cplan</name><operator>-&gt;</operator><name>stmt_list</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>plan</name><operator>-&gt;</operator><name>saved</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We don't want the portal to depend on an unsaved CachedPlanSource,
		 * so must copy the plan into the portal's context.  An error here
		 * will result in leaking our refcount on the plan, but it doesn't
		 * matter because the plan is unsaved and hence transient anyway.
		 */</comment>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>portalContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>stmt_list</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>stmt_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseCachedPlan</name><argument_list>(<argument><expr><name>cplan</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cplan</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>			<comment type="block">/* portal shouldn't depend on cplan */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Set up the portal.
	 */</comment>
	<expr_stmt><expr><call><name>PortalDefineQuery</name><argument_list>(<argument><expr><name>portal</name></expr></argument>,
					  <argument><expr><name>NULL</name></expr></argument>,		<comment type="block">/* no statement name */</comment>
					  <argument><expr><name>query_string</name></expr></argument>,
					  <argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>commandTag</name></name></expr></argument>,
					  <argument><expr><name>stmt_list</name></expr></argument>,
					  <argument><expr><name>cplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up options for portal.  Default SCROLL type is chosen the same way
	 * as PerformCursorOpen does it.
	 */</comment>
	<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>cursorOptions</name></name> <operator>=</operator> <name><name>plan</name><operator>-&gt;</operator><name>cursor_options</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>portal</name><operator>-&gt;</operator><name>cursorOptions</name></name> <operator>&amp;</operator> <operator>(</operator><name>CURSOR_OPT_SCROLL</name> <operator>|</operator> <name>CURSOR_OPT_NO_SCROLL</name><operator>)</operator><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>stmt_list</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
			<call><name>linitial_node</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>, <argument><expr><name>stmt_list</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>commandType</name> <operator>!=</operator> <name>CMD_UTILITY</name> <operator>&amp;&amp;</operator>
			<call><name>linitial_node</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>, <argument><expr><name>stmt_list</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>rowMarks</name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
			<call><name>ExecSupportsBackwardScan</name><argument_list>(<argument><expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>, <argument><expr><name>stmt_list</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>planTree</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>cursorOptions</name></name> <operator>|=</operator> <name>CURSOR_OPT_SCROLL</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>cursorOptions</name></name> <operator>|=</operator> <name>CURSOR_OPT_NO_SCROLL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Disallow SCROLL with SELECT FOR UPDATE.  This is not redundant with the
	 * check in transformDeclareCursorStmt because the cursor options might
	 * not have come through there.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>cursorOptions</name></name> <operator>&amp;</operator> <name>CURSOR_OPT_SCROLL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>stmt_list</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
			<call><name>linitial_node</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>, <argument><expr><name>stmt_list</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>commandType</name> <operator>!=</operator> <name>CMD_UTILITY</name> <operator>&amp;&amp;</operator>
			<call><name>linitial_node</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>, <argument><expr><name>stmt_list</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>rowMarks</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DECLARE SCROLL CURSOR ... FOR UPDATE/SHARE is not supported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Scrollable cursors must be READ ONLY."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Make current query environment available to portal at execution time. */</comment>
	<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>queryEnv</name></name> <operator>=</operator> <name><name>_SPI_current</name><operator>-&gt;</operator><name>queryEnv</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If told to be read-only, we'd better check for read-only queries. This
	 * can't be done earlier because we need to look at the finished, planned
	 * queries.  (In particular, we don't want to do it between GetCachedPlan
	 * and PortalDefineQuery, because throwing an error between those steps
	 * would result in leaking our plancache refcount.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>read_only</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmt_list</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CommandIsReadOnly</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				<comment type="block">/* translator: %s is a SQL statement name */</comment>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is not allowed in a non-volatile function"</literal></expr></argument>,
								<argument><expr><call><name>CreateCommandName</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>pstmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Set up the snapshot to use. */</comment>
	<if_stmt><if>if <condition>(<expr><name>read_only</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * If the plan has parameters, copy them into the portal.  Note that this
	 * must be done after revalidating the plan, because in dynamic parameter
	 * cases the set of parameters could have changed during re-parsing.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>paramLI</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>portalContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>paramLI</name> <operator>=</operator> <call><name>copyParamList</name><argument_list>(<argument><expr><name>paramLI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Start portal execution.
	 */</comment>
	<expr_stmt><expr><call><name>PortalStart</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>paramLI</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>strategy</name></name> <operator>!=</operator> <name>PORTAL_MULTI_QUERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Pop the error context stack */</comment>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>spierrcontext</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>

	<comment type="block">/* Pop the SPI stack */</comment>
	<expr_stmt><expr><call><name>_SPI_end_call</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Return the created portal */</comment>
	<return>return <expr><name>portal</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SPI_cursor_find()
 *
 *	Find the portal of an existing open cursor
 */</comment>
<function><type><name>Portal</name></type>
<name>SPI_cursor_find</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>GetPortalByName</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SPI_cursor_fetch()
 *
 *	Fetch rows in a cursor
 */</comment>
<function><type><name>void</name></type>
<name>SPI_cursor_fetch</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>forward</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>_SPI_cursor_operation</name><argument_list>(<argument><expr><name>portal</name></expr></argument>,
						  <argument><expr><ternary><condition><expr><name>forward</name></expr> ?</condition><then> <expr><name>FETCH_FORWARD</name></expr> </then><else>: <expr><name>FETCH_BACKWARD</name></expr></else></ternary></expr></argument>, <argument><expr><name>count</name></expr></argument>,
						  <argument><expr><call><name>CreateDestReceiver</name><argument_list>(<argument><expr><name>DestSPI</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* we know that the DestSPI receiver doesn't need a destroy call */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * SPI_cursor_move()
 *
 *	Move in a cursor
 */</comment>
<function><type><name>void</name></type>
<name>SPI_cursor_move</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>forward</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>_SPI_cursor_operation</name><argument_list>(<argument><expr><name>portal</name></expr></argument>,
						  <argument><expr><ternary><condition><expr><name>forward</name></expr> ?</condition><then> <expr><name>FETCH_FORWARD</name></expr> </then><else>: <expr><name>FETCH_BACKWARD</name></expr></else></ternary></expr></argument>, <argument><expr><name>count</name></expr></argument>,
						  <argument><expr><name>None_Receiver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SPI_scroll_cursor_fetch()
 *
 *	Fetch rows in a scrollable cursor
 */</comment>
<function><type><name>void</name></type>
<name>SPI_scroll_cursor_fetch</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>, <parameter><decl><type><name>FetchDirection</name></type> <name>direction</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>_SPI_cursor_operation</name><argument_list>(<argument><expr><name>portal</name></expr></argument>,
						  <argument><expr><name>direction</name></expr></argument>, <argument><expr><name>count</name></expr></argument>,
						  <argument><expr><call><name>CreateDestReceiver</name><argument_list>(<argument><expr><name>DestSPI</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* we know that the DestSPI receiver doesn't need a destroy call */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * SPI_scroll_cursor_move()
 *
 *	Move in a scrollable cursor
 */</comment>
<function><type><name>void</name></type>
<name>SPI_scroll_cursor_move</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>, <parameter><decl><type><name>FetchDirection</name></type> <name>direction</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>_SPI_cursor_operation</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>None_Receiver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SPI_cursor_close()
 *
 *	Close a cursor
 */</comment>
<function><type><name>void</name></type>
<name>SPI_cursor_close</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PortalIsValid</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid portal in SPI cursor operation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PortalDrop</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Returns the Oid representing the type id for argument at argIndex. First
 * parameter is at index zero.
 */</comment>
<function><type><name>Oid</name></type>
<name>SPI_getargtypeid</name><parameter_list>(<parameter><decl><type><name>SPIPlanPtr</name></type> <name>plan</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>plan</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>plan</name><operator>-&gt;</operator><name>magic</name></name> <operator>!=</operator> <name>_SPI_PLAN_MAGIC</name> <operator>||</operator>
		<name>argIndex</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>argIndex</name> <operator>&gt;=</operator> <name><name>plan</name><operator>-&gt;</operator><name>nargs</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>SPI_result</name> <operator>=</operator> <name>SPI_ERROR_ARGUMENT</name></expr>;</expr_stmt>
		<return>return <expr><name>InvalidOid</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name><name>plan</name><operator>-&gt;</operator><name>argtypes</name><index>[<expr><name>argIndex</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns the number of arguments for the prepared plan.
 */</comment>
<function><type><name>int</name></type>
<name>SPI_getargcount</name><parameter_list>(<parameter><decl><type><name>SPIPlanPtr</name></type> <name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>plan</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>plan</name><operator>-&gt;</operator><name>magic</name></name> <operator>!=</operator> <name>_SPI_PLAN_MAGIC</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>SPI_result</name> <operator>=</operator> <name>SPI_ERROR_ARGUMENT</name></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name><name>plan</name><operator>-&gt;</operator><name>nargs</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns true if the plan contains exactly one command
 * and that command returns tuples to the caller (eg, SELECT or
 * INSERT ... RETURNING, but not SELECT ... INTO). In essence,
 * the result indicates if the command can be used with SPI_cursor_open
 *
 * Parameters
 *	  plan: A plan previously prepared using SPI_prepare
 */</comment>
<function><type><name>bool</name></type>
<name>SPI_is_cursor_plan</name><parameter_list>(<parameter><decl><type><name>SPIPlanPtr</name></type> <name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>plansource</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>plan</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>plan</name><operator>-&gt;</operator><name>magic</name></name> <operator>!=</operator> <name>_SPI_PLAN_MAGIC</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>SPI_result</name> <operator>=</operator> <name>SPI_ERROR_ARGUMENT</name></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>plancache_list</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>SPI_result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>			<comment type="block">/* not exactly 1 pre-rewrite command */</comment>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>plansource</name> <operator>=</operator> <operator>(</operator><name>CachedPlanSource</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>plancache_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We used to force revalidation of the cached plan here, but that seems
	 * unnecessary: invalidation could mean a change in the rowtype of the
	 * tuples returned by a plan, but not whether it returns tuples at all.
	 */</comment>
	<expr_stmt><expr><name>SPI_result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Does it return tuples? */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>plansource</name><operator>-&gt;</operator><name>resultDesc</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SPI_plan_is_valid --- test whether a SPI plan is currently valid
 * (that is, not marked as being in need of revalidation).
 *
 * See notes for CachedPlanIsValid before using this.
 */</comment>
<function><type><name>bool</name></type>
<name>SPI_plan_is_valid</name><parameter_list>(<parameter><decl><type><name>SPIPlanPtr</name></type> <name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <name>_SPI_PLAN_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>plan-&gt;plancache_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>plansource</name> <init>= <expr><operator>(</operator><name>CachedPlanSource</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CachedPlanIsValid</name><argument_list>(<argument><expr><name>plansource</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SPI_result_code_string --- convert any SPI return code to a string
 *
 * This is often useful in error messages.  Most callers will probably
 * only pass negative (error-case) codes, but for generality we recognize
 * the success codes too.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>SPI_result_code_string</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>code</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>SPI_ERROR_CONNECT</name></expr>:</case>
			<return>return <expr><literal type="string">"SPI_ERROR_CONNECT"</literal></expr>;</return>
		<case>case <expr><name>SPI_ERROR_COPY</name></expr>:</case>
			<return>return <expr><literal type="string">"SPI_ERROR_COPY"</literal></expr>;</return>
		<case>case <expr><name>SPI_ERROR_OPUNKNOWN</name></expr>:</case>
			<return>return <expr><literal type="string">"SPI_ERROR_OPUNKNOWN"</literal></expr>;</return>
		<case>case <expr><name>SPI_ERROR_UNCONNECTED</name></expr>:</case>
			<return>return <expr><literal type="string">"SPI_ERROR_UNCONNECTED"</literal></expr>;</return>
		<case>case <expr><name>SPI_ERROR_ARGUMENT</name></expr>:</case>
			<return>return <expr><literal type="string">"SPI_ERROR_ARGUMENT"</literal></expr>;</return>
		<case>case <expr><name>SPI_ERROR_PARAM</name></expr>:</case>
			<return>return <expr><literal type="string">"SPI_ERROR_PARAM"</literal></expr>;</return>
		<case>case <expr><name>SPI_ERROR_TRANSACTION</name></expr>:</case>
			<return>return <expr><literal type="string">"SPI_ERROR_TRANSACTION"</literal></expr>;</return>
		<case>case <expr><name>SPI_ERROR_NOATTRIBUTE</name></expr>:</case>
			<return>return <expr><literal type="string">"SPI_ERROR_NOATTRIBUTE"</literal></expr>;</return>
		<case>case <expr><name>SPI_ERROR_NOOUTFUNC</name></expr>:</case>
			<return>return <expr><literal type="string">"SPI_ERROR_NOOUTFUNC"</literal></expr>;</return>
		<case>case <expr><name>SPI_ERROR_TYPUNKNOWN</name></expr>:</case>
			<return>return <expr><literal type="string">"SPI_ERROR_TYPUNKNOWN"</literal></expr>;</return>
		<case>case <expr><name>SPI_ERROR_REL_DUPLICATE</name></expr>:</case>
			<return>return <expr><literal type="string">"SPI_ERROR_REL_DUPLICATE"</literal></expr>;</return>
		<case>case <expr><name>SPI_ERROR_REL_NOT_FOUND</name></expr>:</case>
			<return>return <expr><literal type="string">"SPI_ERROR_REL_NOT_FOUND"</literal></expr>;</return>
		<case>case <expr><name>SPI_OK_CONNECT</name></expr>:</case>
			<return>return <expr><literal type="string">"SPI_OK_CONNECT"</literal></expr>;</return>
		<case>case <expr><name>SPI_OK_FINISH</name></expr>:</case>
			<return>return <expr><literal type="string">"SPI_OK_FINISH"</literal></expr>;</return>
		<case>case <expr><name>SPI_OK_FETCH</name></expr>:</case>
			<return>return <expr><literal type="string">"SPI_OK_FETCH"</literal></expr>;</return>
		<case>case <expr><name>SPI_OK_UTILITY</name></expr>:</case>
			<return>return <expr><literal type="string">"SPI_OK_UTILITY"</literal></expr>;</return>
		<case>case <expr><name>SPI_OK_SELECT</name></expr>:</case>
			<return>return <expr><literal type="string">"SPI_OK_SELECT"</literal></expr>;</return>
		<case>case <expr><name>SPI_OK_SELINTO</name></expr>:</case>
			<return>return <expr><literal type="string">"SPI_OK_SELINTO"</literal></expr>;</return>
		<case>case <expr><name>SPI_OK_INSERT</name></expr>:</case>
			<return>return <expr><literal type="string">"SPI_OK_INSERT"</literal></expr>;</return>
		<case>case <expr><name>SPI_OK_DELETE</name></expr>:</case>
			<return>return <expr><literal type="string">"SPI_OK_DELETE"</literal></expr>;</return>
		<case>case <expr><name>SPI_OK_UPDATE</name></expr>:</case>
			<return>return <expr><literal type="string">"SPI_OK_UPDATE"</literal></expr>;</return>
		<case>case <expr><name>SPI_OK_CURSOR</name></expr>:</case>
			<return>return <expr><literal type="string">"SPI_OK_CURSOR"</literal></expr>;</return>
		<case>case <expr><name>SPI_OK_INSERT_RETURNING</name></expr>:</case>
			<return>return <expr><literal type="string">"SPI_OK_INSERT_RETURNING"</literal></expr>;</return>
		<case>case <expr><name>SPI_OK_DELETE_RETURNING</name></expr>:</case>
			<return>return <expr><literal type="string">"SPI_OK_DELETE_RETURNING"</literal></expr>;</return>
		<case>case <expr><name>SPI_OK_UPDATE_RETURNING</name></expr>:</case>
			<return>return <expr><literal type="string">"SPI_OK_UPDATE_RETURNING"</literal></expr>;</return>
		<case>case <expr><name>SPI_OK_REWRITTEN</name></expr>:</case>
			<return>return <expr><literal type="string">"SPI_OK_REWRITTEN"</literal></expr>;</return>
		<case>case <expr><name>SPI_OK_REL_REGISTER</name></expr>:</case>
			<return>return <expr><literal type="string">"SPI_OK_REL_REGISTER"</literal></expr>;</return>
		<case>case <expr><name>SPI_OK_REL_UNREGISTER</name></expr>:</case>
			<return>return <expr><literal type="string">"SPI_OK_REL_UNREGISTER"</literal></expr>;</return>
		<case>case <expr><name>SPI_OK_GRAPHWRITE</name></expr>:</case>
			<return>return <expr><literal type="string">"SPI_OK_GRAPHWRITE"</literal></expr>;</return>
	</block_content>}</block></switch>
	<comment type="block">/* Unrecognized code ... return something useful ... */</comment>
	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"Unrecognized SPI code %d"</literal></expr></argument>, <argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SPI_plan_get_plan_sources --- get a SPI plan's underlying list of
 * CachedPlanSources.
 *
 * This is exported so that PL/pgSQL can use it (this beats letting PL/pgSQL
 * look directly into the SPIPlan for itself).  It's not documented in
 * spi.sgml because we'd just as soon not have too many places using this.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>SPI_plan_get_plan_sources</name><parameter_list>(<parameter><decl><type><name>SPIPlanPtr</name></type> <name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <name>_SPI_PLAN_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>plan</name><operator>-&gt;</operator><name>plancache_list</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SPI_plan_get_cached_plan --- get a SPI plan's generic CachedPlan,
 * if the SPI plan contains exactly one CachedPlanSource.  If not,
 * return NULL.  Caller is responsible for doing ReleaseCachedPlan().
 *
 * This is exported so that PL/pgSQL can use it (this beats letting PL/pgSQL
 * look directly into the SPIPlan for itself).  It's not documented in
 * spi.sgml because we'd just as soon not have too many places using this.
 */</comment>
<function><type><name>CachedPlan</name> <modifier>*</modifier></type>
<name>SPI_plan_get_cached_plan</name><parameter_list>(<parameter><decl><type><name>SPIPlanPtr</name></type> <name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>plansource</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CachedPlan</name> <modifier>*</modifier></type><name>cplan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>spierrcontext</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <name>_SPI_PLAN_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Can't support one-shot plans here */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>oneshot</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Must have exactly one CachedPlanSource */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>plancache_list</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>plansource</name> <operator>=</operator> <operator>(</operator><name>CachedPlanSource</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>plancache_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Setup error traceback support for ereport() */</comment>
	<expr_stmt><expr><name><name>spierrcontext</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>_SPI_error_callback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>spierrcontext</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <call><name>unconstify</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>, <argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>query_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>spierrcontext</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>spierrcontext</name></expr>;</expr_stmt>

	<comment type="block">/* Get the generic plan for the query */</comment>
	<expr_stmt><expr><name>cplan</name> <operator>=</operator> <call><name>GetCachedPlan</name><argument_list>(<argument><expr><name>plansource</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>saved</name></name></expr></argument>,
						  <argument><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>queryEnv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cplan</name> <operator>==</operator> <name><name>plansource</name><operator>-&gt;</operator><name>gplan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Pop the error context stack */</comment>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>spierrcontext</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>

	<return>return <expr><name>cplan</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* =================== private functions =================== */</comment>

<comment type="block">/*
 * spi_dest_startup
 *		Initialize to receive tuples from Executor into SPITupleTable
 *		of current SPI procedure
 */</comment>
<function><type><name>void</name></type>
<name>spi_dest_startup</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>operation</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>typeinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SPITupleTable</name> <modifier>*</modifier></type><name>tuptable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>tuptabcxt</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>_SPI_current</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"spi_dest_startup called while not connected to SPI"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>tuptable</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"improper call to spi_dest_startup"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* We create the tuple table context as a child of procCxt */</comment>

	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>_SPI_procmem</name><argument_list>()</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* switch to procedure memory context */</comment>

	<expr_stmt><expr><name>tuptabcxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
									  <argument><expr><literal type="string">"SPI TupTable"</literal></expr></argument>,
									  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>tuptabcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>tuptable</name></name> <operator>=</operator> <name>tuptable</name> <operator>=</operator> <operator>(</operator><name>SPITupleTable</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SPITupleTable</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuptable</name><operator>-&gt;</operator><name>tuptabcxt</name></name> <operator>=</operator> <name>tuptabcxt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuptable</name><operator>-&gt;</operator><name>subid</name></name> <operator>=</operator> <call><name>GetCurrentSubTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The tuptable is now valid enough to be freed by AtEOSubXact_SPI, so put
	 * it onto the SPI context's tuptables list.  This will ensure it's not
	 * leaked even in the unlikely event the following few lines fail.
	 */</comment>
	<expr_stmt><expr><call><name>slist_push_head</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>_SPI_current</name><operator>-&gt;</operator><name>tuptables</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuptable</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set up initial allocations */</comment>
	<expr_stmt><expr><name><name>tuptable</name><operator>-&gt;</operator><name>alloced</name></name> <operator>=</operator> <literal type="number">128</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuptable</name><operator>-&gt;</operator><name>vals</name></name> <operator>=</operator> <operator>(</operator><name>HeapTuple</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>tuptable</name><operator>-&gt;</operator><name>alloced</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HeapTuple</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuptable</name><operator>-&gt;</operator><name>numvals</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuptable</name><operator>-&gt;</operator><name>tupdesc</name></name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name>typeinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * spi_printtup
 *		store tuple retrieved by Executor into SPITupleTable
 *		of current SPI procedure
 */</comment>
<function><type><name>bool</name></type>
<name>spi_printtup</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SPITupleTable</name> <modifier>*</modifier></type><name>tuptable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>_SPI_current</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"spi_printtup called while not connected to SPI"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tuptable</name> <operator>=</operator> <name><name>_SPI_current</name><operator>-&gt;</operator><name>tuptable</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tuptable</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"improper call to spi_printtup"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>tuptable</name><operator>-&gt;</operator><name>tuptabcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tuptable</name><operator>-&gt;</operator><name>numvals</name></name> <operator>&gt;=</operator> <name><name>tuptable</name><operator>-&gt;</operator><name>alloced</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Double the size of the pointer array */</comment>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>newalloced</name> <init>= <expr><name><name>tuptable</name><operator>-&gt;</operator><name>alloced</name></name> <operator>*</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>tuptable</name><operator>-&gt;</operator><name>vals</name></name> <operator>=</operator> <operator>(</operator><name>HeapTuple</name> <operator>*</operator><operator>)</operator> <call><name>repalloc_huge</name><argument_list>(<argument><expr><name><name>tuptable</name><operator>-&gt;</operator><name>vals</name></name></expr></argument>,
													 <argument><expr><name>newalloced</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HeapTuple</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tuptable</name><operator>-&gt;</operator><name>alloced</name></name> <operator>=</operator> <name>newalloced</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>tuptable</name><operator>-&gt;</operator><name>vals</name><index>[<expr><name><name>tuptable</name><operator>-&gt;</operator><name>numvals</name></name></expr>]</index></name> <operator>=</operator> <call><name>ExecCopySlotHeapTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name><name>tuptable</name><operator>-&gt;</operator><name>numvals</name></name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Static functions
 */</comment>

<comment type="block">/*
 * Parse and analyze a querystring.
 *
 * At entry, plan-&gt;argtypes and plan-&gt;nargs (or alternatively plan-&gt;parserSetup
 * and plan-&gt;parserSetupArg) must be valid, as must plan-&gt;cursor_options.
 *
 * Results are stored into *plan (specifically, plan-&gt;plancache_list).
 * Note that the result data is all in CurrentMemoryContext or child contexts
 * thereof; in practice this means it is in the SPI executor context, and
 * what we are creating is a "temporary" SPIPlan.  Cruft generated during
 * parsing is also left in CurrentMemoryContext.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_SPI_prepare_plan</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>SPIPlanPtr</name></type> <name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>raw_parsetree_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>plancache_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>list_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>spierrcontext</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Setup error traceback support for ereport()
	 */</comment>
	<expr_stmt><expr><name><name>spierrcontext</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>_SPI_error_callback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>spierrcontext</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <call><name>unconstify</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>spierrcontext</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>spierrcontext</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Parse the request string into a list of raw parse trees.
	 */</comment>
	<expr_stmt><expr><name>raw_parsetree_list</name> <operator>=</operator> <call><name>pg_parse_query</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Do parse analysis and rule rewrite for each raw parsetree, storing the
	 * results into unsaved plancache entries.
	 */</comment>
	<expr_stmt><expr><name>plancache_list</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>list_item</argument>, <argument>raw_parsetree_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RawStmt</name>    <modifier>*</modifier></type><name>parsetree</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RawStmt</name></expr></argument>, <argument><expr><name>list_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>stmt_list</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>plansource</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Create the CachedPlanSource before we do parse analysis, since it
		 * needs to see the unmodified raw parse tree.
		 */</comment>
		<expr_stmt><expr><name>plansource</name> <operator>=</operator> <call><name>CreateCachedPlan</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>,
									  <argument><expr><name>src</name></expr></argument>,
									  <argument><expr><call><name>CreateCommandTag</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Parameter datatypes are driven by parserSetup hook if provided,
		 * otherwise we use the fixed parameter list.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>parserSetup</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>nargs</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>stmt_list</name> <operator>=</operator> <call><name>pg_analyze_and_rewrite_params</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>,
													  <argument><expr><name>src</name></expr></argument>,
													  <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>parserSetup</name></name></expr></argument>,
													  <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>parserSetupArg</name></name></expr></argument>,
													  <argument><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>queryEnv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>stmt_list</name> <operator>=</operator> <call><name>pg_analyze_and_rewrite</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>,
											   <argument><expr><name>src</name></expr></argument>,
											   <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>argtypes</name></name></expr></argument>,
											   <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>nargs</name></name></expr></argument>,
											   <argument><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>queryEnv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Finish filling in the CachedPlanSource */</comment>
		<expr_stmt><expr><call><name>CompleteCachedPlan</name><argument_list>(<argument><expr><name>plansource</name></expr></argument>,
						   <argument><expr><name>stmt_list</name></expr></argument>,
						   <argument><expr><name>NULL</name></expr></argument>,
						   <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>argtypes</name></name></expr></argument>,
						   <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>nargs</name></name></expr></argument>,
						   <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>parserSetup</name></name></expr></argument>,
						   <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>parserSetupArg</name></name></expr></argument>,
						   <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>cursor_options</name></name></expr></argument>,
						   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* not fixed result */</comment>

		<expr_stmt><expr><name>plancache_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>plancache_list</name></expr></argument>, <argument><expr><name>plansource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plancache_list</name></name> <operator>=</operator> <name>plancache_list</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>oneshot</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Pop the error context stack
	 */</comment>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>spierrcontext</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Parse, but don't analyze, a querystring.
 *
 * This is a stripped-down version of _SPI_prepare_plan that only does the
 * initial raw parsing.  It creates "one shot" CachedPlanSources
 * that still require parse analysis before execution is possible.
 *
 * The advantage of using the "one shot" form of CachedPlanSource is that
 * we eliminate data copying and invalidation overhead.  Postponing parse
 * analysis also prevents issues if some of the raw parsetrees are DDL
 * commands that affect validity of later parsetrees.  Both of these
 * attributes are good things for SPI_execute() and similar cases.
 *
 * Results are stored into *plan (specifically, plan-&gt;plancache_list).
 * Note that the result data is all in CurrentMemoryContext or child contexts
 * thereof; in practice this means it is in the SPI executor context, and
 * what we are creating is a "temporary" SPIPlan.  Cruft generated during
 * parsing is also left in CurrentMemoryContext.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_SPI_prepare_oneshot_plan</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>SPIPlanPtr</name></type> <name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>raw_parsetree_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>plancache_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>list_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>spierrcontext</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Setup error traceback support for ereport()
	 */</comment>
	<expr_stmt><expr><name><name>spierrcontext</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>_SPI_error_callback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>spierrcontext</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <call><name>unconstify</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>spierrcontext</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>spierrcontext</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Parse the request string into a list of raw parse trees.
	 */</comment>
	<expr_stmt><expr><name>raw_parsetree_list</name> <operator>=</operator> <call><name>pg_parse_query</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Construct plancache entries, but don't do parse analysis yet.
	 */</comment>
	<expr_stmt><expr><name>plancache_list</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>list_item</argument>, <argument>raw_parsetree_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RawStmt</name>    <modifier>*</modifier></type><name>parsetree</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RawStmt</name></expr></argument>, <argument><expr><name>list_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>plansource</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>plansource</name> <operator>=</operator> <call><name>CreateOneShotCachedPlan</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>,
											 <argument><expr><name>src</name></expr></argument>,
											 <argument><expr><call><name>CreateCommandTag</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>plancache_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>plancache_list</name></expr></argument>, <argument><expr><name>plansource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plancache_list</name></name> <operator>=</operator> <name>plancache_list</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>oneshot</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Pop the error context stack
	 */</comment>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>spierrcontext</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Execute the given plan with the given parameter values
 *
 * snapshot: query snapshot to use, or InvalidSnapshot for the normal
 *		behavior of taking a new snapshot for each query.
 * crosscheck_snapshot: for RI use, all others pass InvalidSnapshot
 * read_only: true for read-only execution (no CommandCounterIncrement)
 * fire_triggers: true to fire AFTER triggers at end of query (normal case);
 *		false means any AFTER triggers are postponed to end of outer query
 * tcount: execution tuple-count limit, or 0 for none
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>_SPI_execute_plan</name><parameter_list>(<parameter><decl><type><name>SPIPlanPtr</name></type> <name>plan</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>paramLI</name></decl></parameter>,
				  <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>crosscheck_snapshot</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>read_only</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fire_triggers</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>tcount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>my_res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>my_processed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SPITupleTable</name> <modifier>*</modifier></type><name>my_tuptable</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>allow_nonatomic</name> <init>= <expr><name><name>plan</name><operator>-&gt;</operator><name>no_snapshots</name></name></expr></init></decl>;</decl_stmt>	<comment type="block">/* legacy API name */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>pushed_active_snap</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>spierrcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CachedPlan</name> <modifier>*</modifier></type><name>cplan</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Setup error traceback support for ereport()
	 */</comment>
	<expr_stmt><expr><name><name>spierrcontext</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>_SPI_error_callback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>spierrcontext</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* we'll fill this below */</comment>
	<expr_stmt><expr><name><name>spierrcontext</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>spierrcontext</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We support four distinct snapshot management behaviors:
	 *
	 * snapshot != InvalidSnapshot, read_only = true: use exactly the given
	 * snapshot.
	 *
	 * snapshot != InvalidSnapshot, read_only = false: use the given snapshot,
	 * modified by advancing its command ID before each querytree.
	 *
	 * snapshot == InvalidSnapshot, read_only = true: use the entry-time
	 * ActiveSnapshot, if any (if there isn't one, we run with no snapshot).
	 *
	 * snapshot == InvalidSnapshot, read_only = false: take a full new
	 * snapshot for each user command, and advance its command ID before each
	 * querytree within the command.
	 *
	 * In the first two cases, we can just push the snap onto the stack once
	 * for the whole plan list.
	 *
	 * Note that snapshot != InvalidSnapshot implies an atomic execution
	 * context.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>snapshot</name> <operator>!=</operator> <name>InvalidSnapshot</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>allow_nonatomic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>read_only</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pushed_active_snap</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Make sure we have a private copy of the snapshot to modify */</comment>
			<expr_stmt><expr><call><name>PushCopiedSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pushed_active_snap</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc1</argument>, <argument>plan-&gt;plancache_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>plansource</name> <init>= <expr><operator>(</operator><name>CachedPlanSource</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>stmt_list</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>spierrcontext</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <call><name>unconstify</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>, <argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>query_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If this is a one-shot plan, we still need to do parse analysis.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>oneshot</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RawStmt</name>    <modifier>*</modifier></type><name>parsetree</name> <init>= <expr><name><name>plansource</name><operator>-&gt;</operator><name>raw_parse_tree</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><name><name>plansource</name><operator>-&gt;</operator><name>query_string</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>stmt_list</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Parameter datatypes are driven by parserSetup hook if provided,
			 * otherwise we use the fixed parameter list.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>parsetree</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>stmt_list</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>parserSetup</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>nargs</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>stmt_list</name> <operator>=</operator> <call><name>pg_analyze_and_rewrite_params</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>,
														  <argument><expr><name>src</name></expr></argument>,
														  <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>parserSetup</name></name></expr></argument>,
														  <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>parserSetupArg</name></name></expr></argument>,
														  <argument><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>queryEnv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>stmt_list</name> <operator>=</operator> <call><name>pg_analyze_and_rewrite</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>,
												   <argument><expr><name>src</name></expr></argument>,
												   <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>argtypes</name></name></expr></argument>,
												   <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>nargs</name></name></expr></argument>,
												   <argument><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>queryEnv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/* Finish filling in the CachedPlanSource */</comment>
			<expr_stmt><expr><call><name>CompleteCachedPlan</name><argument_list>(<argument><expr><name>plansource</name></expr></argument>,
							   <argument><expr><name>stmt_list</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>argtypes</name></name></expr></argument>,
							   <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>nargs</name></name></expr></argument>,
							   <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>parserSetup</name></name></expr></argument>,
							   <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>parserSetupArg</name></name></expr></argument>,
							   <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>cursor_options</name></name></expr></argument>,
							   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* not fixed result */</comment>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Replan if needed, and increment plan refcount.  If it's a saved
		 * plan, the refcount must be backed by the CurrentResourceOwner.
		 */</comment>
		<expr_stmt><expr><name>cplan</name> <operator>=</operator> <call><name>GetCachedPlan</name><argument_list>(<argument><expr><name>plansource</name></expr></argument>, <argument><expr><name>paramLI</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>saved</name></name></expr></argument>, <argument><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>queryEnv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>stmt_list</name> <operator>=</operator> <name><name>cplan</name><operator>-&gt;</operator><name>stmt_list</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we weren't given a specific snapshot to use, and the statement
		 * list requires a snapshot, set that up.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>snapshot</name> <operator>==</operator> <name>InvalidSnapshot</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name>stmt_list</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator>
			 <operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name>stmt_list</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
			  <call><name>PlannedStmtRequiresSnapshot</name><argument_list>(<argument><expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>,
														<argument><expr><name>stmt_list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * First, ensure there's a Portal-level snapshot.  This back-fills
			 * the snapshot stack in case the previous operation was a COMMIT
			 * or ROLLBACK inside a procedure or DO block.  (We can't put back
			 * the Portal snapshot any sooner, or we'd break cases like doing
			 * SET or LOCK just after COMMIT.)  It's enough to check once per
			 * statement list, since COMMIT/ROLLBACK/CALL/DO can't appear
			 * within a multi-statement list.
			 */</comment>
			<expr_stmt><expr><call><name>EnsurePortalSnapshotExists</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * In the default non-read-only case, get a new per-statement-list
			 * snapshot, replacing any that we pushed in a previous cycle.
			 * Skip it when doing non-atomic execution, though (we rely
			 * entirely on the Portal snapshot in that case).
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>read_only</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>allow_nonatomic</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>pushed_active_snap</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>pushed_active_snap</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>stmt_list</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>, <argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>canSetTag</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>canSetTag</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>processed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>tuptable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

			<comment type="block">/* Check for unsupported cases. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>, <argument><expr><name>CopyStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>CopyStmt</name>   <modifier>*</modifier></type><name>cstmt</name> <init>= <expr><operator>(</operator><name>CopyStmt</name> <operator>*</operator><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>cstmt</name><operator>-&gt;</operator><name>filename</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>my_res</name> <operator>=</operator> <name>SPI_ERROR_COPY</name></expr>;</expr_stmt>
						<goto>goto <name>fail</name>;</goto>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>, <argument><expr><name>TransactionStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>my_res</name> <operator>=</operator> <name>SPI_ERROR_TRANSACTION</name></expr>;</expr_stmt>
					<goto>goto <name>fail</name>;</goto>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>read_only</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>CommandIsReadOnly</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				<comment type="block">/* translator: %s is a SQL statement name */</comment>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is not allowed in a non-volatile function"</literal></expr></argument>,
								<argument><expr><call><name>CreateCommandName</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * If not read-only mode, advance the command counter before each
			 * command and update the snapshot.  (But skip it if the snapshot
			 * isn't under our control.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>read_only</name> <operator>&amp;&amp;</operator> <name>pushed_active_snap</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>UpdateActiveSnapshotCommandId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>dest</name> <operator>=</operator> <call><name>CreateDestReceiver</name><argument_list>(<argument><expr><ternary><condition><expr><name>canSetTag</name></expr> ?</condition><then> <expr><name>DestSPI</name></expr> </then><else>: <expr><name>DestNone</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>QueryDesc</name>  <modifier>*</modifier></type><name>qdesc</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snap</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>ActiveSnapshotSet</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>snap</name> <operator>=</operator> <call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>snap</name> <operator>=</operator> <name>InvalidSnapshot</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><name>qdesc</name> <operator>=</operator> <call><name>CreateQueryDesc</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>,
										<argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>query_string</name></name></expr></argument>,
										<argument><expr><name>snap</name></expr></argument>, <argument><expr><name>crosscheck_snapshot</name></expr></argument>,
										<argument><expr><name>dest</name></expr></argument>,
										<argument><expr><name>paramLI</name></expr></argument>, <argument><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>queryEnv</name></name></expr></argument>,
										<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_SPI_pquery</name><argument_list>(<argument><expr><name>qdesc</name></expr></argument>, <argument><expr><name>fire_triggers</name></expr></argument>,
								  <argument><expr><ternary><condition><expr><name>canSetTag</name></expr> ?</condition><then> <expr><name>tcount</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>FreeQueryDesc</name><argument_list>(<argument><expr><name>qdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>ProcessUtilityContext</name></type> <name>context</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>QueryCompletion</name></type> <name>qc</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * If the SPI context is atomic, or we were not told to allow
				 * nonatomic operations, tell ProcessUtility this is an atomic
				 * execution context.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>atomic</name></name> <operator>||</operator> <operator>!</operator><name>allow_nonatomic</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>context</name> <operator>=</operator> <name>PROCESS_UTILITY_QUERY</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>context</name> <operator>=</operator> <name>PROCESS_UTILITY_QUERY_NONATOMIC</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><call><name>InitializeQueryCompletion</name><argument_list>(<argument><expr><operator>&amp;</operator><name>qc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ProcessUtility</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>,
							   <argument><expr><name><name>plansource</name><operator>-&gt;</operator><name>query_string</name></name></expr></argument>,
							   <argument><expr><name>context</name></expr></argument>,
							   <argument><expr><name>paramLI</name></expr></argument>,
							   <argument><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>queryEnv</name></name></expr></argument>,
							   <argument><expr><name>dest</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>qc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Update "processed" if stmt returned tuples */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>tuptable</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>processed</name></name> <operator>=</operator> <name><name>_SPI_current</name><operator>-&gt;</operator><name>tuptable</name><operator>-&gt;</operator><name>numvals</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>res</name> <operator>=</operator> <name>SPI_OK_UTILITY</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Some utility statements return a row count, even though the
				 * tuples are not returned to the caller.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>, <argument><expr><name>CreateTableAsStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>CreateTableAsStmt</name> <modifier>*</modifier></type><name>ctastmt</name> <init>= <expr><operator>(</operator><name>CreateTableAsStmt</name> <operator>*</operator><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>qc</name><operator>.</operator><name>commandTag</name></name> <operator>==</operator> <name>CMDTAG_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>processed</name></name> <operator>=</operator> <name><name>qc</name><operator>.</operator><name>nprocessed</name></name></expr>;</expr_stmt></block_content></block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/*
						 * Must be an IF NOT EXISTS that did nothing, or a
						 * CREATE ... WITH NO DATA.
						 */</comment>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ctastmt</name><operator>-&gt;</operator><name>if_not_exists</name></name> <operator>||</operator>
							   <name><name>ctastmt</name><operator>-&gt;</operator><name>into</name><operator>-&gt;</operator><name>skipData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>processed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>

					<comment type="block">/*
					 * For historical reasons, if CREATE TABLE AS was spelled
					 * as SELECT INTO, return a special return code.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>ctastmt</name><operator>-&gt;</operator><name>is_select_into</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>res</name> <operator>=</operator> <name>SPI_OK_SELINTO</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>, <argument><expr><name>CopyStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>qc</name><operator>.</operator><name>commandTag</name></name> <operator>==</operator> <name>CMDTAG_COPY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>processed</name></name> <operator>=</operator> <name><name>qc</name><operator>.</operator><name>nprocessed</name></name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/*
			 * The last canSetTag query sets the status values returned to the
			 * caller.  Be careful to free any tuptables not returned, to
			 * avoid intra-transaction memory leak.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>canSetTag</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>my_processed</name> <operator>=</operator> <name><name>_SPI_current</name><operator>-&gt;</operator><name>processed</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SPI_freetuptable</name><argument_list>(<argument><expr><name>my_tuptable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>my_tuptable</name> <operator>=</operator> <name><name>_SPI_current</name><operator>-&gt;</operator><name>tuptable</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>my_res</name> <operator>=</operator> <name>res</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>SPI_freetuptable</name><argument_list>(<argument><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>tuptable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>tuptable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<comment type="block">/* we know that the receiver doesn't need a destroy call */</comment>
			<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>my_res</name> <operator>=</operator> <name>res</name></expr>;</expr_stmt>
				<goto>goto <name>fail</name>;</goto>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/* Done with this plan, so release refcount */</comment>
		<expr_stmt><expr><call><name>ReleaseCachedPlan</name><argument_list>(<argument><expr><name>cplan</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>saved</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cplan</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If not read-only mode, advance the command counter after the last
		 * command.  This ensures that its effects are visible, in case it was
		 * DDL that would affect the next CachedPlanSource.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>read_only</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

<label><name>fail</name>:</label>

	<comment type="block">/* Pop the snapshot off the stack if we pushed one */</comment>
	<if_stmt><if>if <condition>(<expr><name>pushed_active_snap</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* We no longer need the cached plan refcount, if any */</comment>
	<if_stmt><if>if <condition>(<expr><name>cplan</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReleaseCachedPlan</name><argument_list>(<argument><expr><name>cplan</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>saved</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Pop the error context stack
	 */</comment>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>spierrcontext</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>

	<comment type="block">/* Save results for caller */</comment>
	<expr_stmt><expr><name>SPI_processed</name> <operator>=</operator> <name>my_processed</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>SPI_tuptable</name> <operator>=</operator> <name>my_tuptable</name></expr>;</expr_stmt>

	<comment type="block">/* tuptable now is caller's responsibility, not SPI's */</comment>
	<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>tuptable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If none of the queries had canSetTag, return SPI_OK_REWRITTEN. Prior to
	 * 8.4, we used return the last query's result code, but not its auxiliary
	 * results, but that's confusing.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>my_res</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>my_res</name> <operator>=</operator> <name>SPI_OK_REWRITTEN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>my_res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert arrays of query parameters to form wanted by planner and executor
 */</comment>
<function><type><specifier>static</specifier> <name>ParamListInfo</name></type>
<name>_SPI_convert_params</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>argtypes</name></decl></parameter>,
					<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>Values</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>Nulls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramLI</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>paramLI</name> <operator>=</operator> <call><name>makeParamList</name><argument_list>(<argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ParamExternData</name> <modifier>*</modifier></type><name>prm</name> <init>= <expr><operator>&amp;</operator><name><name>paramLI</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name><name>Values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <operator>(</operator><name>Nulls</name> <operator>&amp;&amp;</operator> <name><name>Nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'n'</literal><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>pflags</name></name> <operator>=</operator> <name>PARAM_FLAG_CONST</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name> <operator>=</operator> <name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>paramLI</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>paramLI</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>_SPI_pquery</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fire_triggers</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>tcount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>operation</name> <init>= <expr><name><name>queryDesc</name><operator>-&gt;</operator><name>operation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>eflags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>res</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>operation</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CMD_SELECT</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>dest</name><operator>-&gt;</operator><name>mydest</name></name> <operator>!=</operator> <name>DestSPI</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Don't return SPI_OK_SELECT if we're discarding result */</comment>
				<expr_stmt><expr><name>res</name> <operator>=</operator> <name>SPI_OK_UTILITY</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>res</name> <operator>=</operator> <name>SPI_OK_SELECT</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>CMD_INSERT</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>hasReturning</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>res</name> <operator>=</operator> <name>SPI_OK_INSERT_RETURNING</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>res</name> <operator>=</operator> <name>SPI_OK_INSERT</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>CMD_DELETE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>hasReturning</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>res</name> <operator>=</operator> <name>SPI_OK_DELETE_RETURNING</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>res</name> <operator>=</operator> <name>SPI_OK_DELETE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>hasReturning</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>res</name> <operator>=</operator> <name>SPI_OK_UPDATE_RETURNING</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>res</name> <operator>=</operator> <name>SPI_OK_UPDATE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>CMD_GRAPHWRITE</name></expr>:</case>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <name>SPI_OK_GRAPHWRITE</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<return>return <expr><name>SPI_ERROR_OPUNKNOWN</name></expr>;</return>
	</block_content>}</block></switch>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SPI_EXECUTOR_STATS</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>ShowExecutorStats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Select execution options */</comment>
	<if_stmt><if>if <condition>(<expr><name>fire_triggers</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>eflags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>				<comment type="block">/* default run-to-completion flags */</comment>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>eflags</name> <operator>=</operator> <name>EXEC_FLAG_SKIP_TRIGGERS</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>ExecutorStart</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecutorRun</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>, <argument><expr><name>tcount</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>processed</name></name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>==</operator> <name>SPI_OK_SELECT</name> <operator>||</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>hasReturning</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
		<name><name>queryDesc</name><operator>-&gt;</operator><name>dest</name><operator>-&gt;</operator><name>mydest</name></name> <operator>==</operator> <name>DestSPI</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>_SPI_checktuples</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"consistency check on SPI tuple count failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ExecutorFinish</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecutorEnd</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* FreeQueryDesc is done by the caller */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SPI_EXECUTOR_STATS</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>ShowExecutorStats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"SPI EXECUTOR STATS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _SPI_error_callback
 *
 * Add context information when a query invoked via SPI fails
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_SPI_error_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>syntaxerrposition</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>query</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>			<comment type="block">/* in case arg wasn't set yet */</comment>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If there is a syntax error position, convert to internal syntax error;
	 * otherwise treat the query as an item of context stack
	 */</comment>
	<expr_stmt><expr><name>syntaxerrposition</name> <operator>=</operator> <call><name>geterrposition</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>syntaxerrposition</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>errposition</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>internalerrposition</name><argument_list>(<argument><expr><name>syntaxerrposition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>internalerrquery</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"SQL statement \"%s\""</literal></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _SPI_cursor_operation()
 *
 *	Do a FETCH or MOVE in a cursor
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_SPI_cursor_operation</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>, <parameter><decl><type><name>FetchDirection</name></type> <name>direction</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>count</name></decl></parameter>,
					  <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>nfetched</name></decl>;</decl_stmt>

	<comment type="block">/* Check that the portal is valid */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PortalIsValid</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid portal in SPI cursor operation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Push the SPI stack */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>_SPI_begin_call</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI cursor operation called while not connected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Reset the SPI result (note we deliberately don't touch lastoid) */</comment>
	<expr_stmt><expr><name>SPI_processed</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>SPI_tuptable</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>processed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>tuptable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Run the cursor */</comment>
	<expr_stmt><expr><name>nfetched</name> <operator>=</operator> <call><name>PortalRunFetch</name><argument_list>(<argument><expr><name>portal</name></expr></argument>,
							  <argument><expr><name>direction</name></expr></argument>,
							  <argument><expr><name>count</name></expr></argument>,
							  <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Think not to combine this store with the preceding function call. If
	 * the portal contains calls to functions that use SPI, then _SPI_stack is
	 * likely to move around while the portal runs.  When control returns,
	 * _SPI_current will point to the correct stack entry... but the pointer
	 * may be different than it was beforehand. So we must be sure to re-fetch
	 * the pointer after the function call completes.
	 */</comment>
	<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>processed</name></name> <operator>=</operator> <name>nfetched</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dest</name><operator>-&gt;</operator><name>mydest</name></name> <operator>==</operator> <name>DestSPI</name> <operator>&amp;&amp;</operator> <call><name>_SPI_checktuples</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"consistency check on SPI tuple count failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Put the result into place for access by caller */</comment>
	<expr_stmt><expr><name>SPI_processed</name> <operator>=</operator> <name><name>_SPI_current</name><operator>-&gt;</operator><name>processed</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>SPI_tuptable</name> <operator>=</operator> <name><name>_SPI_current</name><operator>-&gt;</operator><name>tuptable</name></name></expr>;</expr_stmt>

	<comment type="block">/* tuptable now is caller's responsibility, not SPI's */</comment>
	<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>tuptable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Pop the SPI stack */</comment>
	<expr_stmt><expr><call><name>_SPI_end_call</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>MemoryContext</name></type>
<name>_SPI_execmem</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>execCxt</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>MemoryContext</name></type>
<name>_SPI_procmem</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>procCxt</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _SPI_begin_call: begin a SPI operation within a connected procedure
 *
 * use_exec is true if we intend to make use of the procedure's execCxt
 * during this SPI operation.  We'll switch into that context, and arrange
 * for it to be cleaned up at _SPI_end_call or if an error occurs.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>_SPI_begin_call</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>use_exec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>_SPI_current</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>SPI_ERROR_UNCONNECTED</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>use_exec</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* remember when the Executor operation started */</comment>
		<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>execSubid</name></name> <operator>=</operator> <call><name>GetCurrentSubTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* switch to the Executor memory context */</comment>
		<expr_stmt><expr><call><name>_SPI_execmem</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _SPI_end_call: end a SPI operation within a connected procedure
 *
 * use_exec must be the same as in the previous _SPI_begin_call
 *
 * Note: this currently has no failure return cases, so callers don't check
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>_SPI_end_call</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>use_exec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>use_exec</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* switch to the procedure memory context */</comment>
		<expr_stmt><expr><call><name>_SPI_procmem</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* mark Executor context no longer in use */</comment>
		<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>execSubid</name></name> <operator>=</operator> <name>InvalidSubTransactionId</name></expr>;</expr_stmt>
		<comment type="block">/* and free Executor memory */</comment>
		<expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>execCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_SPI_checktuples</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>processed</name> <init>= <expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>processed</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SPITupleTable</name> <modifier>*</modifier></type><name>tuptable</name> <init>= <expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>tuptable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>failed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>tuptable</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* spi_dest_startup was not called */</comment>
		<expr_stmt><expr><name>failed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>processed</name> <operator>!=</operator> <name><name>tuptable</name><operator>-&gt;</operator><name>numvals</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>failed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>failed</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert a "temporary" SPIPlan into an "unsaved" plan.
 *
 * The passed _SPI_plan struct is on the stack, and all its subsidiary data
 * is in or under the current SPI executor context.  Copy the plan into the
 * SPI procedure context so it will survive _SPI_end_call().  To minimize
 * data copying, this destructively modifies the input plan, by taking the
 * plancache entries away from it and reparenting them to the new SPIPlan.
 */</comment>
<function><type><specifier>static</specifier> <name>SPIPlanPtr</name></type>
<name>_SPI_make_plan_non_temp</name><parameter_list>(<parameter><decl><type><name>SPIPlanPtr</name></type> <name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SPIPlanPtr</name></type>	<name>newplan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>parentcxt</name> <init>= <expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>procCxt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>plancxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Assert the input is a temporary SPIPlan */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <name>_SPI_PLAN_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>plancxt</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* One-shot plans can't be saved */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>plan</name><operator>-&gt;</operator><name>oneshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create a memory context for the plan, underneath the procedure context.
	 * We don't expect the plan to be very large.
	 */</comment>
	<expr_stmt><expr><name>plancxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>parentcxt</name></expr></argument>,
									<argument><expr><literal type="string">"SPI Plan"</literal></expr></argument>,
									<argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>plancxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Copy the _SPI_plan struct and subsidiary data into the new context */</comment>
	<expr_stmt><expr><name>newplan</name> <operator>=</operator> <operator>(</operator><name>SPIPlanPtr</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>_SPI_plan</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newplan</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>_SPI_PLAN_MAGIC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newplan</name><operator>-&gt;</operator><name>plancxt</name></name> <operator>=</operator> <name>plancxt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newplan</name><operator>-&gt;</operator><name>cursor_options</name></name> <operator>=</operator> <name><name>plan</name><operator>-&gt;</operator><name>cursor_options</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newplan</name><operator>-&gt;</operator><name>nargs</name></name> <operator>=</operator> <name><name>plan</name><operator>-&gt;</operator><name>nargs</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>nargs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>newplan</name><operator>-&gt;</operator><name>argtypes</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>nargs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>newplan</name><operator>-&gt;</operator><name>argtypes</name></name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>argtypes</name></name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>nargs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>newplan</name><operator>-&gt;</operator><name>argtypes</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>newplan</name><operator>-&gt;</operator><name>parserSetup</name></name> <operator>=</operator> <name><name>plan</name><operator>-&gt;</operator><name>parserSetup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newplan</name><operator>-&gt;</operator><name>parserSetupArg</name></name> <operator>=</operator> <name><name>plan</name><operator>-&gt;</operator><name>parserSetupArg</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Reparent all the CachedPlanSources into the procedure context.  In
	 * theory this could fail partway through due to the pallocs, but we don't
	 * care too much since both the procedure context and the executor context
	 * would go away on error.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>plan-&gt;plancache_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>plansource</name> <init>= <expr><operator>(</operator><name>CachedPlanSource</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CachedPlanSetParentContext</name><argument_list>(<argument><expr><name>plansource</name></expr></argument>, <argument><expr><name>parentcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Build new list, with list cells in plancxt */</comment>
		<expr_stmt><expr><name><name>newplan</name><operator>-&gt;</operator><name>plancache_list</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>newplan</name><operator>-&gt;</operator><name>plancache_list</name></name></expr></argument>, <argument><expr><name>plansource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* For safety, unlink the CachedPlanSources from the temporary plan */</comment>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plancache_list</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<return>return <expr><name>newplan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Make a "saved" copy of the given plan.
 */</comment>
<function><type><specifier>static</specifier> <name>SPIPlanPtr</name></type>
<name>_SPI_save_plan</name><parameter_list>(<parameter><decl><type><name>SPIPlanPtr</name></type> <name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SPIPlanPtr</name></type>	<name>newplan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>plancxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* One-shot plans can't be saved */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>plan</name><operator>-&gt;</operator><name>oneshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create a memory context for the plan.  We don't expect the plan to be
	 * very large, so use smaller-than-default alloc parameters.  It's a
	 * transient context until we finish copying everything.
	 */</comment>
	<expr_stmt><expr><name>plancxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
									<argument><expr><literal type="string">"SPI Plan"</literal></expr></argument>,
									<argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>plancxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Copy the SPI plan into its own context */</comment>
	<expr_stmt><expr><name>newplan</name> <operator>=</operator> <operator>(</operator><name>SPIPlanPtr</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>_SPI_plan</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newplan</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>_SPI_PLAN_MAGIC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newplan</name><operator>-&gt;</operator><name>plancxt</name></name> <operator>=</operator> <name>plancxt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newplan</name><operator>-&gt;</operator><name>cursor_options</name></name> <operator>=</operator> <name><name>plan</name><operator>-&gt;</operator><name>cursor_options</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newplan</name><operator>-&gt;</operator><name>nargs</name></name> <operator>=</operator> <name><name>plan</name><operator>-&gt;</operator><name>nargs</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>nargs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>newplan</name><operator>-&gt;</operator><name>argtypes</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>nargs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>newplan</name><operator>-&gt;</operator><name>argtypes</name></name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>argtypes</name></name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>nargs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>newplan</name><operator>-&gt;</operator><name>argtypes</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>newplan</name><operator>-&gt;</operator><name>parserSetup</name></name> <operator>=</operator> <name><name>plan</name><operator>-&gt;</operator><name>parserSetup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newplan</name><operator>-&gt;</operator><name>parserSetupArg</name></name> <operator>=</operator> <name><name>plan</name><operator>-&gt;</operator><name>parserSetupArg</name></name></expr>;</expr_stmt>

	<comment type="block">/* Copy all the plancache entries */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>plan-&gt;plancache_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>plansource</name> <init>= <expr><operator>(</operator><name>CachedPlanSource</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>newsource</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newsource</name> <operator>=</operator> <call><name>CopyCachedPlan</name><argument_list>(<argument><expr><name>plansource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newplan</name><operator>-&gt;</operator><name>plancache_list</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>newplan</name><operator>-&gt;</operator><name>plancache_list</name></name></expr></argument>, <argument><expr><name>newsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Mark it saved, reparent it under CacheMemoryContext, and mark all the
	 * component CachedPlanSources as saved.  This sequence cannot fail
	 * partway through, so there's no risk of long-term memory leakage.
	 */</comment>
	<expr_stmt><expr><name><name>newplan</name><operator>-&gt;</operator><name>saved</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSetParent</name><argument_list>(<argument><expr><name><name>newplan</name><operator>-&gt;</operator><name>plancxt</name></name></expr></argument>, <argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>newplan-&gt;plancache_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>plansource</name> <init>= <expr><operator>(</operator><name>CachedPlanSource</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>SaveCachedPlan</name><argument_list>(<argument><expr><name>plansource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>newplan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Internal lookup of ephemeral named relation by name.
 */</comment>
<function><type><specifier>static</specifier> <name>EphemeralNamedRelation</name></type>
<name>_SPI_find_ENR_by_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* internal static function; any error is bug in SPI itself */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>name</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* fast exit if no tuplestores have been added */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>queryEnv</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>get_ENR</name><argument_list>(<argument><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>queryEnv</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Register an ephemeral named relation for use by the planner and executor on
 * subsequent calls using this SPI connection.
 */</comment>
<function><type><name>int</name></type>
<name>SPI_register_relation</name><parameter_list>(<parameter><decl><type><name>EphemeralNamedRelation</name></type> <name>enr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EphemeralNamedRelation</name></type> <name>match</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>res</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>enr</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>enr</name><operator>-&gt;</operator><name>md</name><operator>.</operator><name>name</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>SPI_ERROR_ARGUMENT</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_SPI_begin_call</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* keep current memory context */</comment>
	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>_SPI_find_ENR_by_name</name><argument_list>(<argument><expr><name><name>enr</name><operator>-&gt;</operator><name>md</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>match</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <name>SPI_ERROR_REL_DUPLICATE</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>queryEnv</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>queryEnv</name></name> <operator>=</operator> <call><name>create_queryEnv</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>register_ENR</name><argument_list>(<argument><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>queryEnv</name></name></expr></argument>, <argument><expr><name>enr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <name>SPI_OK_REL_REGISTER</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>_SPI_end_call</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Unregister an ephemeral named relation by name.  This will probably be a
 * rarely used function, since SPI_finish will clear it automatically.
 */</comment>
<function><type><name>int</name></type>
<name>SPI_unregister_relation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EphemeralNamedRelation</name></type> <name>match</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>res</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>SPI_ERROR_ARGUMENT</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_SPI_begin_call</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* keep current memory context */</comment>
	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>_SPI_find_ENR_by_name</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>match</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>unregister_ENR</name><argument_list>(<argument><expr><name><name>_SPI_current</name><operator>-&gt;</operator><name>queryEnv</name></name></expr></argument>, <argument><expr><name><name>match</name><operator>-&gt;</operator><name>md</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <name>SPI_OK_REL_UNREGISTER</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <name>SPI_ERROR_REL_NOT_FOUND</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>_SPI_end_call</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Register the transient relations from 'tdata' using this SPI connection.
 * This should be called by PL implementations' trigger handlers after
 * connecting, in order to make transition tables visible to any queries run
 * in this connection.
 */</comment>
<function><type><name>int</name></type>
<name>SPI_register_trigger_data</name><parameter_list>(<parameter><decl><type><name>TriggerData</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>tdata</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>SPI_ERROR_ARGUMENT</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_newtable</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EphemeralNamedRelation</name></type> <name>enr</name> <init>=
		<expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>EphemeralNamedRelationData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>enr</name><operator>-&gt;</operator><name>md</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name><name>tdata</name><operator>-&gt;</operator><name>tg_trigger</name><operator>-&gt;</operator><name>tgnewtable</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>enr</name><operator>-&gt;</operator><name>md</name><operator>.</operator><name>reliddesc</name></name> <operator>=</operator> <name><name>tdata</name><operator>-&gt;</operator><name>tg_relation</name><operator>-&gt;</operator><name>rd_id</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>enr</name><operator>-&gt;</operator><name>md</name><operator>.</operator><name>tupdesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>enr</name><operator>-&gt;</operator><name>md</name><operator>.</operator><name>enrtype</name></name> <operator>=</operator> <name>ENR_NAMED_TUPLESTORE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>enr</name><operator>-&gt;</operator><name>md</name><operator>.</operator><name>enrtuples</name></name> <operator>=</operator> <call><name>tuplestore_tuple_count</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_newtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>enr</name><operator>-&gt;</operator><name>reldata</name></name> <operator>=</operator> <name><name>tdata</name><operator>-&gt;</operator><name>tg_newtable</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SPI_register_relation</name><argument_list>(<argument><expr><name>enr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>SPI_OK_REL_REGISTER</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_oldtable</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EphemeralNamedRelation</name></type> <name>enr</name> <init>=
		<expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>EphemeralNamedRelationData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>enr</name><operator>-&gt;</operator><name>md</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name><name>tdata</name><operator>-&gt;</operator><name>tg_trigger</name><operator>-&gt;</operator><name>tgoldtable</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>enr</name><operator>-&gt;</operator><name>md</name><operator>.</operator><name>reliddesc</name></name> <operator>=</operator> <name><name>tdata</name><operator>-&gt;</operator><name>tg_relation</name><operator>-&gt;</operator><name>rd_id</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>enr</name><operator>-&gt;</operator><name>md</name><operator>.</operator><name>tupdesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>enr</name><operator>-&gt;</operator><name>md</name><operator>.</operator><name>enrtype</name></name> <operator>=</operator> <name>ENR_NAMED_TUPLESTORE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>enr</name><operator>-&gt;</operator><name>md</name><operator>.</operator><name>enrtuples</name></name> <operator>=</operator> <call><name>tuplestore_tuple_count</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_oldtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>enr</name><operator>-&gt;</operator><name>reldata</name></name> <operator>=</operator> <name><name>tdata</name><operator>-&gt;</operator><name>tg_oldtable</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SPI_register_relation</name><argument_list>(<argument><expr><name>enr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>SPI_OK_REL_REGISTER</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>SPI_OK_TD_REGISTER</name></expr>;</return>
</block_content>}</block></function>
</unit>
