<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/executor/nodeWindowAgg.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * nodeWindowAgg.c
 *	  routines to handle WindowAgg nodes.
 *
 * A WindowAgg node evaluates "window functions" across suitable partitions
 * of the input tuple set.  Any one WindowAgg works for just a single window
 * specification, though it can evaluate multiple window functions sharing
 * identical window specifications.  The input tuples are required to be
 * delivered in sorted order, with the PARTITION BY columns (if any) as
 * major sort keys and the ORDER BY columns (if any) as minor sort keys.
 * (The planner generates a stack of WindowAggs with intervening Sort nodes
 * as needed, if a query involves more than one window specification.)
 *
 * Since window functions can require access to any or all of the rows in
 * the current partition, we accumulate rows of the partition into a
 * tuplestore.  The window functions are called using the WindowObject API
 * so that they can access those rows as needed.
 *
 * We also support using plain aggregate functions as window functions.
 * For these, the regular Agg-node environment is emulated for each partition.
 * As required by the SQL spec, the output represents the value of the
 * aggregate function over all rows in the current row's window frame.
 *
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/executor/nodeWindowAgg.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/objectaccess.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_aggregate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeWindowAgg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_agg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/expandeddatum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/regproc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"windowapi.h"</cpp:file></cpp:include>

<comment type="block">/*
 * All the window function APIs are called with this object, which is passed
 * to window functions as fcinfo-&gt;context.
 */</comment>
<typedef>typedef <type><struct>struct <name>WindowObjectData</name>
<block>{
	<decl_stmt><decl><type><name>NodeTag</name></type>		<name>type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>winstate</name></decl>;</decl_stmt>	<comment type="block">/* parent WindowAggState */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>argstates</name></decl>;</decl_stmt>		<comment type="block">/* ExprState trees for fn's arguments */</comment>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>localmem</name></decl>;</decl_stmt>		<comment type="block">/* WinGetPartitionLocalMemory's chunk */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>markptr</name></decl>;</decl_stmt>		<comment type="block">/* tuplestore mark pointer for this fn */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>readptr</name></decl>;</decl_stmt>		<comment type="block">/* tuplestore read pointer for this fn */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		<name>markpos</name></decl>;</decl_stmt>		<comment type="block">/* row that markptr is positioned on */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		<name>seekpos</name></decl>;</decl_stmt>		<comment type="block">/* row that readptr is positioned on */</comment>
}</block></struct></type> <name>WindowObjectData</name>;</typedef>

<comment type="block">/*
 * We have one WindowStatePerFunc struct for each window function and
 * window aggregate handled by this node.
 */</comment>
<typedef>typedef <type><struct>struct <name>WindowStatePerFuncData</name>
<block>{
	<comment type="block">/* Links to WindowFunc expr and state nodes this working state is for */</comment>
	<decl_stmt><decl><type><name>WindowFuncExprState</name> <modifier>*</modifier></type><name>wfuncstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WindowFunc</name> <modifier>*</modifier></type><name>wfunc</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>numArguments</name></decl>;</decl_stmt>	<comment type="block">/* number of arguments */</comment>

	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>flinfo</name></decl>;</decl_stmt>			<comment type="block">/* fmgr lookup data for window function */</comment>

	<decl_stmt><decl><type><name>Oid</name></type>			<name>winCollation</name></decl>;</decl_stmt>	<comment type="block">/* collation derived for window function */</comment>

	<comment type="block">/*
	 * We need the len and byval info for the result of each function in order
	 * to know how to copy/delete values.
	 */</comment>
	<decl_stmt><decl><type><name>int16</name></type>		<name>resulttypeLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>resulttypeByVal</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type>		<name>plain_agg</name></decl>;</decl_stmt>		<comment type="block">/* is it just a plain aggregate function? */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>aggno</name></decl>;</decl_stmt>			<comment type="block">/* if so, index of its WindowStatePerAggData */</comment>

	<decl_stmt><decl><type><name>WindowObject</name></type> <name>winobj</name></decl>;</decl_stmt>		<comment type="block">/* object used in window function API */</comment>
}</block></struct></type>			<name>WindowStatePerFuncData</name>;</typedef>

<comment type="block">/*
 * For plain aggregate window functions, we also have one of these.
 */</comment>
<typedef>typedef <type><struct>struct <name>WindowStatePerAggData</name>
<block>{
	<comment type="block">/* Oids of transition functions */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>transfn_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>invtransfn_oid</name></decl>;</decl_stmt> <comment type="block">/* may be InvalidOid */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>finalfn_oid</name></decl>;</decl_stmt>	<comment type="block">/* may be InvalidOid */</comment>

	<comment type="block">/*
	 * fmgr lookup data for transition functions --- only valid when
	 * corresponding oid is not InvalidOid.  Note in particular that fn_strict
	 * flags are kept here.
	 */</comment>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>transfn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>invtransfn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>finalfn</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>numFinalArgs</name></decl>;</decl_stmt>	<comment type="block">/* number of arguments to pass to finalfn */</comment>

	<comment type="block">/*
	 * initial value from pg_aggregate entry
	 */</comment>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>initValue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>initValueIsNull</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * cached value for current frame boundaries
	 */</comment>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>resultValue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>resultValueIsNull</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We need the len and byval info for the agg's input, result, and
	 * transition data types in order to know how to copy/delete values.
	 */</comment>
	<decl_stmt><decl><type><name>int16</name></type>		<name>inputtypeLen</name></decl>,
				<name>resulttypeLen</name>,
				<name>transtypeLen</name>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>inputtypeByVal</name></decl>,
				<name>resulttypeByVal</name>,
				<name>transtypeByVal</name>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>wfuncno</name></decl>;</decl_stmt>		<comment type="block">/* index of associated WindowStatePerFuncData */</comment>

	<comment type="block">/* Context holding transition value and possibly other subsidiary data */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>aggcontext</name></decl>;</decl_stmt>	<comment type="block">/* may be private, or winstate-&gt;aggcontext */</comment>

	<comment type="block">/* Current transition value */</comment>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>transValue</name></decl>;</decl_stmt>		<comment type="block">/* current transition value */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>transValueIsNull</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int64</name></type>		<name>transValueCount</name></decl>;</decl_stmt>	<comment type="block">/* number of currently-aggregated rows */</comment>

	<comment type="block">/* Data local to eval_windowaggregates() */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>restart</name></decl>;</decl_stmt>		<comment type="block">/* need to restart this agg in this cycle? */</comment>
}</block></struct></type> <name>WindowStatePerAggData</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>initialize_windowaggregate</name><parameter_list>(<parameter><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>winstate</name></decl></parameter>,
									   <parameter><decl><type><name>WindowStatePerFunc</name></type> <name>perfuncstate</name></decl></parameter>,
									   <parameter><decl><type><name>WindowStatePerAgg</name></type> <name>peraggstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>advance_windowaggregate</name><parameter_list>(<parameter><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>winstate</name></decl></parameter>,
									<parameter><decl><type><name>WindowStatePerFunc</name></type> <name>perfuncstate</name></decl></parameter>,
									<parameter><decl><type><name>WindowStatePerAgg</name></type> <name>peraggstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>advance_windowaggregate_base</name><parameter_list>(<parameter><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>winstate</name></decl></parameter>,
										 <parameter><decl><type><name>WindowStatePerFunc</name></type> <name>perfuncstate</name></decl></parameter>,
										 <parameter><decl><type><name>WindowStatePerAgg</name></type> <name>peraggstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>finalize_windowaggregate</name><parameter_list>(<parameter><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>winstate</name></decl></parameter>,
									 <parameter><decl><type><name>WindowStatePerFunc</name></type> <name>perfuncstate</name></decl></parameter>,
									 <parameter><decl><type><name>WindowStatePerAgg</name></type> <name>peraggstate</name></decl></parameter>,
									 <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>eval_windowaggregates</name><parameter_list>(<parameter><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>winstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>eval_windowfunction</name><parameter_list>(<parameter><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>winstate</name></decl></parameter>,
								<parameter><decl><type><name>WindowStatePerFunc</name></type> <name>perfuncstate</name></decl></parameter>,
								<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>begin_partition</name><parameter_list>(<parameter><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>winstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>spool_tuples</name><parameter_list>(<parameter><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>winstate</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>pos</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>release_partition</name><parameter_list>(<parameter><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>winstate</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>row_is_in_frame</name><parameter_list>(<parameter><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>winstate</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>pos</name></decl></parameter>,
							<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>update_frameheadpos</name><parameter_list>(<parameter><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>winstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>update_frametailpos</name><parameter_list>(<parameter><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>winstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>update_grouptailpos</name><parameter_list>(<parameter><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>winstate</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>WindowStatePerAggData</name> <modifier>*</modifier></type><name>initialize_peragg</name><parameter_list>(<parameter><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>winstate</name></decl></parameter>,
												<parameter><decl><type><name>WindowFunc</name> <modifier>*</modifier></type><name>wfunc</name></decl></parameter>,
												<parameter><decl><type><name>WindowStatePerAgg</name></type> <name>peraggstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>GetAggInitVal</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>textInitVal</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>transtype</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>are_peers</name><parameter_list>(<parameter><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>winstate</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot1</name></decl></parameter>,
					  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>window_gettupleslot</name><parameter_list>(<parameter><decl><type><name>WindowObject</name></type> <name>winobj</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>pos</name></decl></parameter>,
								<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * initialize_windowaggregate
 * parallel to initialize_aggregates in nodeAgg.c
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>initialize_windowaggregate</name><parameter_list>(<parameter><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>winstate</name></decl></parameter>,
						   <parameter><decl><type><name>WindowStatePerFunc</name></type> <name>perfuncstate</name></decl></parameter>,
						   <parameter><decl><type><name>WindowStatePerAgg</name></type> <name>peraggstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If we're using a private aggcontext, we may reset it here.  But if the
	 * context is shared, we don't know which other aggregates may still need
	 * it, so we must leave it to the caller to reset at an appropriate time.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>peraggstate</name><operator>-&gt;</operator><name>aggcontext</name></name> <operator>!=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>aggcontext</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>aggcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>peraggstate</name><operator>-&gt;</operator><name>initValueIsNull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transValue</name></name> <operator>=</operator> <name><name>peraggstate</name><operator>-&gt;</operator><name>initValue</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>aggcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transValue</name></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>initValue</name></name></expr></argument>,
											<argument><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transtypeByVal</name></name></expr></argument>,
											<argument><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name> <operator>=</operator> <name><name>peraggstate</name><operator>-&gt;</operator><name>initValueIsNull</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transValueCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>resultValue</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>resultValueIsNull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * advance_windowaggregate
 * parallel to advance_aggregates in nodeAgg.c
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>advance_windowaggregate</name><parameter_list>(<parameter><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>winstate</name></decl></parameter>,
						<parameter><decl><type><name>WindowStatePerFunc</name></type> <name>perfuncstate</name></decl></parameter>,
						<parameter><decl><type><name>WindowStatePerAgg</name></type> <name>peraggstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>FUNC_MAX_ARGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>WindowFuncExprState</name> <modifier>*</modifier></type><name>wfuncstate</name> <init>= <expr><name><name>perfuncstate</name><operator>-&gt;</operator><name>wfuncstate</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numArguments</name> <init>= <expr><name><name>perfuncstate</name><operator>-&gt;</operator><name>numArguments</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>newVal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>winstate</name><operator>-&gt;</operator><name>tmpcontext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>filter</name> <init>= <expr><name><name>wfuncstate</name><operator>-&gt;</operator><name>aggfilter</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Skip anything FILTERed out */</comment>
	<if_stmt><if>if <condition>(<expr><name>filter</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>res</name> <init>= <expr><call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name>filter</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>isnull</name> <operator>||</operator> <operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We start from 1, since the 0th arg will be the transition value */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>arg</argument>, <argument>wfuncstate-&gt;args</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>argstate</name> <init>= <expr><operator>(</operator><name>ExprState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name>argstate</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transfn</name><operator>.</operator><name>fn_strict</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For a strict transfn, nothing happens when there's a NULL input; we
		 * just keep the prior transValue.  Note transValueCount doesn't
		 * change either.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>numArguments</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * For strict transition functions with initial value NULL we use the
		 * first non-NULL input as the initial state.  (We already checked
		 * that the agg's input type is binary-compatible with its transtype,
		 * so straight copy here is OK.)
		 *
		 * We must copy the datum into aggcontext if it is pass-by-ref.  We do
		 * not need to pfree the old transValue, since it's NULL.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transValueCount</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>peraggstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>aggcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transValue</name></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>,
												<argument><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transtypeByVal</name></name></expr></argument>,
												<argument><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transValueCount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Don't call a strict function with NULL inputs.  Note it is
			 * possible to get here despite the above tests, if the transfn is
			 * strict *and* returned a NULL on a prior cycle.  If that happens
			 * we will propagate the NULL all the way to the end.  That can
			 * only happen if there's no inverse transition function, though,
			 * since we disallow transitions back to NULL when there is one.
			 */</comment>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>invtransfn_oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * OK to call the transition function.  Set winstate-&gt;curaggcontext while
	 * calling it, for possible use by AggCheckCallContext.
	 */</comment>
	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>peraggstate</name><operator>-&gt;</operator><name>transfn</name></name><operator>)</operator></expr></argument>,
							 <argument><expr><name>numArguments</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
							 <argument><expr><name><name>perfuncstate</name><operator>-&gt;</operator><name>winCollation</name></name></expr></argument>,
							 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>winstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name><name>peraggstate</name><operator>-&gt;</operator><name>transValue</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name><name>peraggstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>curaggcontext</name></name> <operator>=</operator> <name><name>peraggstate</name><operator>-&gt;</operator><name>aggcontext</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>newVal</name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>curaggcontext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Moving-aggregate transition functions must not return null, see
	 * advance_windowaggregate_base().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>invtransfn_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"moving-aggregate transition function must not return null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We must track the number of rows included in transValue, since to
	 * remove the last input, advance_windowaggregate_base() mustn't call the
	 * inverse transition function, but simply reset transValue back to its
	 * initial value.
	 */</comment>
	<expr_stmt><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transValueCount</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * If pass-by-ref datatype, must copy the new value into aggcontext and
	 * free the prior transValue.  But if transfn returned a pointer to its
	 * first input, we don't need to do anything.  Also, if transfn returned a
	 * pointer to a R/W expanded object that is already a child of the
	 * aggcontext, assume we can adopt that value without copying it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>peraggstate</name><operator>-&gt;</operator><name>transtypeByVal</name></name> <operator>&amp;&amp;</operator>
		<call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>newVal</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transValue</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>aggcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>DatumIsReadWriteExpandedObject</name><argument_list>(<argument><expr><name>newVal</name></expr></argument>,
											   <argument><expr><name>false</name></expr></argument>,
											   <argument><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>MemoryContextGetParent</name><argument_list>(<argument><expr><call><name>DatumGetEOHP</name><argument_list>(<argument><expr><name>newVal</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>eoh_context</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CurrentMemoryContext</name></expr>)</condition><block type="pseudo"><block_content>
				 <comment type="block">/* do nothing */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>newVal</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name>newVal</name></expr></argument>,
								   <argument><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transtypeByVal</name></name></expr></argument>,
								   <argument><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>peraggstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>DatumIsReadWriteExpandedObject</name><argument_list>(<argument><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transValue</name></name></expr></argument>,
											   <argument><expr><name>false</name></expr></argument>,
											   <argument><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>DeleteExpandedObject</name><argument_list>(<argument><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transValue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transValue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transValue</name></name> <operator>=</operator> <name>newVal</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * advance_windowaggregate_base
 * Remove the oldest tuple from an aggregation.
 *
 * This is very much like advance_windowaggregate, except that we will call
 * the inverse transition function (which caller must have checked is
 * available).
 *
 * Returns true if we successfully removed the current row from this
 * aggregate, false if not (in the latter case, caller is responsible
 * for cleaning up by restarting the aggregation).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>advance_windowaggregate_base</name><parameter_list>(<parameter><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>winstate</name></decl></parameter>,
							 <parameter><decl><type><name>WindowStatePerFunc</name></type> <name>perfuncstate</name></decl></parameter>,
							 <parameter><decl><type><name>WindowStatePerAgg</name></type> <name>peraggstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>FUNC_MAX_ARGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>WindowFuncExprState</name> <modifier>*</modifier></type><name>wfuncstate</name> <init>= <expr><name><name>perfuncstate</name><operator>-&gt;</operator><name>wfuncstate</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numArguments</name> <init>= <expr><name><name>perfuncstate</name><operator>-&gt;</operator><name>numArguments</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>newVal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>winstate</name><operator>-&gt;</operator><name>tmpcontext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>filter</name> <init>= <expr><name><name>wfuncstate</name><operator>-&gt;</operator><name>aggfilter</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Skip anything FILTERed out */</comment>
	<if_stmt><if>if <condition>(<expr><name>filter</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>res</name> <init>= <expr><call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name>filter</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>isnull</name> <operator>||</operator> <operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We start from 1, since the 0th arg will be the transition value */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>arg</argument>, <argument>wfuncstate-&gt;args</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>argstate</name> <init>= <expr><operator>(</operator><name>ExprState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name>argstate</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name><name>peraggstate</name><operator>-&gt;</operator><name>invtransfn</name><operator>.</operator><name>fn_strict</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For a strict (inv)transfn, nothing happens when there's a NULL
		 * input; we just keep the prior transValue.  Note transValueCount
		 * doesn't change either.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>numArguments</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* There should still be an added but not yet removed value */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transValueCount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In moving-aggregate mode, the state must never be NULL, except possibly
	 * before any rows have been aggregated (which is surely not the case at
	 * this point).  This restriction allows us to interpret a NULL result
	 * from the inverse function as meaning "sorry, can't do an inverse
	 * transition in this case".  We already checked this in
	 * advance_windowaggregate, but just for safety, check again.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"aggregate transition value is NULL before inverse transition"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We mustn't use the inverse transition function to remove the last
	 * input.  Doing so would yield a non-NULL state, whereas we should be in
	 * the initial state afterwards which may very well be NULL.  So instead,
	 * we simply re-initialize the aggregate in this case.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transValueCount</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>initialize_windowaggregate</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name><name>winstate</name><operator>-&gt;</operator><name>perfunc</name><index>[<expr><name><name>peraggstate</name><operator>-&gt;</operator><name>wfuncno</name></name></expr>]</index></name></expr></argument>,
								   <argument><expr><name>peraggstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * OK to call the inverse transition function.  Set
	 * winstate-&gt;curaggcontext while calling it, for possible use by
	 * AggCheckCallContext.
	 */</comment>
	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>peraggstate</name><operator>-&gt;</operator><name>invtransfn</name></name><operator>)</operator></expr></argument>,
							 <argument><expr><name>numArguments</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
							 <argument><expr><name><name>perfuncstate</name><operator>-&gt;</operator><name>winCollation</name></name></expr></argument>,
							 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>winstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name><name>peraggstate</name><operator>-&gt;</operator><name>transValue</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name><name>peraggstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>curaggcontext</name></name> <operator>=</operator> <name><name>peraggstate</name><operator>-&gt;</operator><name>aggcontext</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>newVal</name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>curaggcontext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the function returns NULL, report failure, forcing a restart.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Update number of rows included in transValue */</comment>
	<expr_stmt><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transValueCount</name></name><operator>--</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * If pass-by-ref datatype, must copy the new value into aggcontext and
	 * free the prior transValue.  But if invtransfn returned a pointer to its
	 * first input, we don't need to do anything.  Also, if invtransfn
	 * returned a pointer to a R/W expanded object that is already a child of
	 * the aggcontext, assume we can adopt that value without copying it.
	 *
	 * Note: the checks for null values here will never fire, but it seems
	 * best to have this stanza look just like advance_windowaggregate.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>peraggstate</name><operator>-&gt;</operator><name>transtypeByVal</name></name> <operator>&amp;&amp;</operator>
		<call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>newVal</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transValue</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>aggcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>DatumIsReadWriteExpandedObject</name><argument_list>(<argument><expr><name>newVal</name></expr></argument>,
											   <argument><expr><name>false</name></expr></argument>,
											   <argument><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>MemoryContextGetParent</name><argument_list>(<argument><expr><call><name>DatumGetEOHP</name><argument_list>(<argument><expr><name>newVal</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>eoh_context</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CurrentMemoryContext</name></expr>)</condition><block type="pseudo"><block_content>
				 <comment type="block">/* do nothing */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>newVal</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name>newVal</name></expr></argument>,
								   <argument><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transtypeByVal</name></name></expr></argument>,
								   <argument><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>peraggstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>DatumIsReadWriteExpandedObject</name><argument_list>(<argument><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transValue</name></name></expr></argument>,
											   <argument><expr><name>false</name></expr></argument>,
											   <argument><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>DeleteExpandedObject</name><argument_list>(<argument><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transValue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transValue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transValue</name></name> <operator>=</operator> <name>newVal</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * finalize_windowaggregate
 * parallel to finalize_aggregate in nodeAgg.c
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>finalize_windowaggregate</name><parameter_list>(<parameter><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>winstate</name></decl></parameter>,
						 <parameter><decl><type><name>WindowStatePerFunc</name></type> <name>perfuncstate</name></decl></parameter>,
						 <parameter><decl><type><name>WindowStatePerAgg</name></type> <name>peraggstate</name></decl></parameter>,
						 <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Apply the agg's finalfn if one is provided, else return transValue.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>finalfn_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>FUNC_MAX_ARGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>numFinalArgs</name> <init>= <expr><name><name>peraggstate</name><operator>-&gt;</operator><name>numFinalArgs</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>anynull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><name><name>fcinfodata</name><operator>.</operator><name>fcinfo</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>peraggstate</name><operator>-&gt;</operator><name>finalfn</name></name><operator>)</operator></expr></argument>,
								 <argument><expr><name>numFinalArgs</name></expr></argument>,
								 <argument><expr><name><name>perfuncstate</name><operator>-&gt;</operator><name>winCollation</name></name></expr></argument>,
								 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>winstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator>
			<call><name>MakeExpandedObjectReadOnly</name><argument_list>(<argument><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transValue</name></name></expr></argument>,
									   <argument><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr></argument>,
									   <argument><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name><name>peraggstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>anynull</name> <operator>=</operator> <name><name>peraggstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr>;</expr_stmt>

		<comment type="block">/* Fill any remaining argument positions with nulls */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numFinalArgs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>anynull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_strict</name></name> <operator>&amp;&amp;</operator> <name>anynull</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* don't call a strict function with NULL inputs */</comment>
			<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>curaggcontext</name></name> <operator>=</operator> <name><name>peraggstate</name><operator>-&gt;</operator><name>aggcontext</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>curaggcontext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Don't need MakeExpandedObjectReadOnly; datumCopy will copy it */</comment>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name><name>peraggstate</name><operator>-&gt;</operator><name>transValue</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name><name>peraggstate</name><operator>-&gt;</operator><name>transValueIsNull</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * If result is pass-by-ref, make sure it is in the right context.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>peraggstate</name><operator>-&gt;</operator><name>resulttypeByVal</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>*</operator><name>isnull</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>MemoryContextContains</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
							   <argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><operator>*</operator><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><operator>*</operator><name>result</name></expr></argument>,
							<argument><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>resulttypeByVal</name></name></expr></argument>,
							<argument><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>resulttypeLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * eval_windowaggregates
 * evaluate plain aggregates being used as window functions
 *
 * This differs from nodeAgg.c in two ways.  First, if the window's frame
 * start position moves, we use the inverse transition function (if it exists)
 * to remove rows from the transition value.  And second, we expect to be
 * able to call aggregate final functions repeatedly after aggregating more
 * data onto the same transition value.  This is not a behavior required by
 * nodeAgg.c.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>eval_windowaggregates</name><parameter_list>(<parameter><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>winstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WindowStatePerAgg</name></type> <name>peraggstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>wfuncno</name></decl>,
				<decl><type ref="prev"/><name>numaggs</name></decl>,
				<decl><type ref="prev"/><name>numaggs_restart</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>aggregatedupto_nonrestarted</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WindowObject</name></type> <name>agg_winobj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>agg_row_slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>temp_slot</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>numaggs</name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>numaggs</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>numaggs</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* nothing to do */</comment>

	<comment type="block">/* final output execution is in ps_ExprContext */</comment>
	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>agg_winobj</name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>agg_winobj</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>agg_row_slot</name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>agg_row_slot</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>temp_slot</name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>temp_slot_1</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the window's frame start clause is UNBOUNDED_PRECEDING and no
	 * exclusion clause is specified, then the window frame consists of a
	 * contiguous group of rows extending forward from the start of the
	 * partition, and rows only enter the frame, never exit it, as the current
	 * row advances forward.  This makes it possible to use an incremental
	 * strategy for evaluating aggregates: we run the transition function for
	 * each row added to the frame, and run the final function whenever we
	 * need the current aggregate value.  This is considerably more efficient
	 * than the naive approach of re-running the entire aggregate calculation
	 * for each current row.  It does assume that the final function doesn't
	 * damage the running transition value, but we have the same assumption in
	 * nodeAgg.c too (when it rescans an existing hash table).
	 *
	 * If the frame start does sometimes move, we can still optimize as above
	 * whenever successive rows share the same frame head, but if the frame
	 * head moves beyond the previous head we try to remove those rows using
	 * the aggregate's inverse transition function.  This function restores
	 * the aggregate's current state to what it would be if the removed row
	 * had never been aggregated in the first place.  Inverse transition
	 * functions may optionally return NULL, indicating that the function was
	 * unable to remove the tuple from aggregation.  If this happens, or if
	 * the aggregate doesn't have an inverse transition function at all, we
	 * must perform the aggregation all over again for all tuples within the
	 * new frame boundaries.
	 *
	 * If there's any exclusion clause, then we may have to aggregate over a
	 * non-contiguous set of rows, so we punt and recalculate for every row.
	 * (For some frame end choices, it might be that the frame is always
	 * contiguous anyway, but that's an optimization to investigate later.)
	 *
	 * In many common cases, multiple rows share the same frame and hence the
	 * same aggregate value. (In particular, if there's no ORDER BY in a RANGE
	 * window, then all rows are peers and so they all have window frame equal
	 * to the whole partition.)  We optimize such cases by calculating the
	 * aggregate value once when we reach the first row of a peer group, and
	 * then returning the saved value for all subsequent rows.
	 *
	 * 'aggregatedupto' keeps track of the first row that has not yet been
	 * accumulated into the aggregate transition values.  Whenever we start a
	 * new peer group, we accumulate forward to the end of the peer group.
	 */</comment>

	<comment type="block">/*
	 * First, update the frame head position.
	 *
	 * The frame head should never move backwards, and the code below wouldn't
	 * cope if it did, so for safety we complain if it does.
	 */</comment>
	<expr_stmt><expr><call><name>update_frameheadpos</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>frameheadpos</name></name> <operator>&lt;</operator> <name><name>winstate</name><operator>-&gt;</operator><name>aggregatedbase</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"window frame head moved backward"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the frame didn't change compared to the previous row, we can re-use
	 * the result values that were previously saved at the bottom of this
	 * function.  Since we don't know the current frame's end yet, this is not
	 * possible to check for fully.  But if the frame end mode is UNBOUNDED
	 * FOLLOWING or CURRENT ROW, no exclusion clause is specified, and the
	 * current row lies within the previous row's frame, then the two frames'
	 * ends must coincide.  Note that on the first row aggregatedbase ==
	 * aggregatedupto, meaning this test must fail, so we don't need to check
	 * the "there was no previous row" case explicitly here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>aggregatedbase</name></name> <operator>==</operator> <name><name>winstate</name><operator>-&gt;</operator><name>frameheadpos</name></name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>winstate</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <operator>(</operator><name>FRAMEOPTION_END_UNBOUNDED_FOLLOWING</name> <operator>|</operator>
								   <name>FRAMEOPTION_END_CURRENT_ROW</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>!</operator><operator>(</operator><name><name>winstate</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_EXCLUSION</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<name><name>winstate</name><operator>-&gt;</operator><name>aggregatedbase</name></name> <operator>&lt;=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>currentpos</name></name> <operator>&amp;&amp;</operator>
		<name><name>winstate</name><operator>-&gt;</operator><name>aggregatedupto</name></name> <operator>&gt;</operator> <name><name>winstate</name><operator>-&gt;</operator><name>currentpos</name></name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numaggs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>peraggstate</name> <operator>=</operator> <operator>&amp;</operator><name><name>winstate</name><operator>-&gt;</operator><name>peragg</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>wfuncno</name> <operator>=</operator> <name><name>peraggstate</name><operator>-&gt;</operator><name>wfuncno</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_aggvalues</name><index>[<expr><name>wfuncno</name></expr>]</index></name> <operator>=</operator> <name><name>peraggstate</name><operator>-&gt;</operator><name>resultValue</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_aggnulls</name><index>[<expr><name>wfuncno</name></expr>]</index></name> <operator>=</operator> <name><name>peraggstate</name><operator>-&gt;</operator><name>resultValueIsNull</name></name></expr>;</expr_stmt>
		</block_content>}</block></for>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*----------
	 * Initialize restart flags.
	 *
	 * We restart the aggregation:
	 *	 - if we're processing the first row in the partition, or
	 *	 - if the frame's head moved and we cannot use an inverse
	 *	   transition function, or
	 *	 - we have an EXCLUSION clause, or
	 *	 - if the new frame doesn't overlap the old one
	 *
	 * Note that we don't strictly need to restart in the last case, but if
	 * we're going to remove all rows from the aggregation anyway, a restart
	 * surely is faster.
	 *----------
	 */</comment>
	<expr_stmt><expr><name>numaggs_restart</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numaggs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>peraggstate</name> <operator>=</operator> <operator>&amp;</operator><name><name>winstate</name><operator>-&gt;</operator><name>peragg</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>currentpos</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<operator>(</operator><name><name>winstate</name><operator>-&gt;</operator><name>aggregatedbase</name></name> <operator>!=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>frameheadpos</name></name> <operator>&amp;&amp;</operator>
			 <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>invtransfn_oid</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
			<operator>(</operator><name><name>winstate</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_EXCLUSION</name><operator>)</operator> <operator>||</operator>
			<name><name>winstate</name><operator>-&gt;</operator><name>aggregatedupto</name></name> <operator>&lt;=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>frameheadpos</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>restart</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>numaggs_restart</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>restart</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If we have any possibly-moving aggregates, attempt to advance
	 * aggregatedbase to match the frame's head by removing input rows that
	 * fell off the top of the frame from the aggregations.  This can fail,
	 * i.e. advance_windowaggregate_base() can return false, in which case
	 * we'll restart that aggregate below.
	 */</comment>
	<while>while <condition>(<expr><name>numaggs_restart</name> <operator>&lt;</operator> <name>numaggs</name> <operator>&amp;&amp;</operator>
		   <name><name>winstate</name><operator>-&gt;</operator><name>aggregatedbase</name></name> <operator>&lt;</operator> <name><name>winstate</name><operator>-&gt;</operator><name>frameheadpos</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Fetch the next tuple of those being removed. This should never fail
		 * as we should have been here before.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>window_gettupleslot</name><argument_list>(<argument><expr><name>agg_winobj</name></expr></argument>, <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>aggregatedbase</name></name></expr></argument>,
								 <argument><expr><name>temp_slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not re-fetch previously fetched frame row"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Set tuple context for evaluation of aggregate arguments */</comment>
		<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>tmpcontext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>temp_slot</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Perform the inverse transition for each aggregate function in the
		 * window, unless it has already been marked as needing a restart.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numaggs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>ok</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>peraggstate</name> <operator>=</operator> <operator>&amp;</operator><name><name>winstate</name><operator>-&gt;</operator><name>peragg</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>peraggstate</name><operator>-&gt;</operator><name>restart</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>wfuncno</name> <operator>=</operator> <name><name>peraggstate</name><operator>-&gt;</operator><name>wfuncno</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name>advance_windowaggregate_base</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name><name>winstate</name><operator>-&gt;</operator><name>perfunc</name><index>[<expr><name>wfuncno</name></expr>]</index></name></expr></argument>,
											  <argument><expr><name>peraggstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Inverse transition function has failed, must restart */</comment>
				<expr_stmt><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>restart</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>numaggs_restart</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Reset per-input-tuple context after each tuple */</comment>
		<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>tmpcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* And advance the aggregated-row state */</comment>
		<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>aggregatedbase</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>temp_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * If we successfully advanced the base rows of all the aggregates,
	 * aggregatedbase now equals frameheadpos; but if we failed for any, we
	 * must forcibly update aggregatedbase.
	 */</comment>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>aggregatedbase</name></name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>frameheadpos</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we created a mark pointer for aggregates, keep it pushed up to frame
	 * head, so that tuplestore can discard unnecessary rows.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>agg_winobj</name><operator>-&gt;</operator><name>markptr</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>WinSetMarkPosition</name><argument_list>(<argument><expr><name>agg_winobj</name></expr></argument>, <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>frameheadpos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Now restart the aggregates that require it.
	 *
	 * We assume that aggregates using the shared context always restart if
	 * *any* aggregate restarts, and we may thus clean up the shared
	 * aggcontext if that is the case.  Private aggcontexts are reset by
	 * initialize_windowaggregate() if their owning aggregate restarts. If we
	 * aren't restarting an aggregate, we need to free any previously saved
	 * result for it, else we'll leak memory.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>numaggs_restart</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>aggcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numaggs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>peraggstate</name> <operator>=</operator> <operator>&amp;</operator><name><name>winstate</name><operator>-&gt;</operator><name>peragg</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/* Aggregates using the shared ctx must restart if *any* agg does */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>aggcontext</name></name> <operator>!=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>aggcontext</name></name> <operator>||</operator>
			   <name>numaggs_restart</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			   <name><name>peraggstate</name><operator>-&gt;</operator><name>restart</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>peraggstate</name><operator>-&gt;</operator><name>restart</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>wfuncno</name> <operator>=</operator> <name><name>peraggstate</name><operator>-&gt;</operator><name>wfuncno</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>initialize_windowaggregate</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name><name>winstate</name><operator>-&gt;</operator><name>perfunc</name><index>[<expr><name>wfuncno</name></expr>]</index></name></expr></argument>,
									   <argument><expr><name>peraggstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>peraggstate</name><operator>-&gt;</operator><name>resultValueIsNull</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>peraggstate</name><operator>-&gt;</operator><name>resulttypeByVal</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>resultValue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>resultValue</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>resultValueIsNull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Non-restarted aggregates now contain the rows between aggregatedbase
	 * (i.e., frameheadpos) and aggregatedupto, while restarted aggregates
	 * contain no rows.  If there are any restarted aggregates, we must thus
	 * begin aggregating anew at frameheadpos, otherwise we may simply
	 * continue at aggregatedupto.  We must remember the old value of
	 * aggregatedupto to know how long to skip advancing non-restarted
	 * aggregates.  If we modify aggregatedupto, we must also clear
	 * agg_row_slot, per the loop invariant below.
	 */</comment>
	<expr_stmt><expr><name>aggregatedupto_nonrestarted</name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>aggregatedupto</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>numaggs_restart</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name><name>winstate</name><operator>-&gt;</operator><name>aggregatedupto</name></name> <operator>!=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>frameheadpos</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>aggregatedupto</name></name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>frameheadpos</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>agg_row_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Advance until we reach a row not in frame (or end of partition).
	 *
	 * Note the loop invariant: agg_row_slot is either empty or holds the row
	 * at position aggregatedupto.  We advance aggregatedupto after processing
	 * a row.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>

		<comment type="block">/* Fetch next row if we didn't already */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>agg_row_slot</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>window_gettupleslot</name><argument_list>(<argument><expr><name>agg_winobj</name></expr></argument>, <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>aggregatedupto</name></name></expr></argument>,
									 <argument><expr><name>agg_row_slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>			<comment type="block">/* must be end of partition */</comment>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Exit loop if no more rows can be in frame.  Skip aggregation if
		 * current row is not in frame but there might be more in the frame.
		 */</comment>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>row_is_in_frame</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>, <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>aggregatedupto</name></name></expr></argument>, <argument><expr><name>agg_row_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>next_tuple</name>;</goto></block_content></block></if></if_stmt>

		<comment type="block">/* Set tuple context for evaluation of aggregate arguments */</comment>
		<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>tmpcontext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>agg_row_slot</name></expr>;</expr_stmt>

		<comment type="block">/* Accumulate row into the aggregates */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numaggs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>peraggstate</name> <operator>=</operator> <operator>&amp;</operator><name><name>winstate</name><operator>-&gt;</operator><name>peragg</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

			<comment type="block">/* Non-restarted aggs skip until aggregatedupto_nonrestarted */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>peraggstate</name><operator>-&gt;</operator><name>restart</name></name> <operator>&amp;&amp;</operator>
				<name><name>winstate</name><operator>-&gt;</operator><name>aggregatedupto</name></name> <operator>&lt;</operator> <name>aggregatedupto_nonrestarted</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>wfuncno</name> <operator>=</operator> <name><name>peraggstate</name><operator>-&gt;</operator><name>wfuncno</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>advance_windowaggregate</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>winstate</name><operator>-&gt;</operator><name>perfunc</name><index>[<expr><name>wfuncno</name></expr>]</index></name></expr></argument>,
									<argument><expr><name>peraggstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

<label><name>next_tuple</name>:</label>
		<comment type="block">/* Reset per-input-tuple context after each tuple */</comment>
		<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>tmpcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* And advance the aggregated-row state */</comment>
		<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>aggregatedupto</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>agg_row_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* The frame's end is not supposed to move backwards, ever */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>aggregatedupto_nonrestarted</name> <operator>&lt;=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>aggregatedupto</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * finalize aggregates and fill result/isnull fields.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numaggs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>isnull</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>peraggstate</name> <operator>=</operator> <operator>&amp;</operator><name><name>winstate</name><operator>-&gt;</operator><name>peragg</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>wfuncno</name> <operator>=</operator> <name><name>peraggstate</name><operator>-&gt;</operator><name>wfuncno</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>&amp;</operator><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_aggvalues</name><index>[<expr><name>wfuncno</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>isnull</name> <operator>=</operator> <operator>&amp;</operator><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_aggnulls</name><index>[<expr><name>wfuncno</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>finalize_windowaggregate</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name><name>winstate</name><operator>-&gt;</operator><name>perfunc</name><index>[<expr><name>wfuncno</name></expr>]</index></name></expr></argument>,
								 <argument><expr><name>peraggstate</name></expr></argument>,
								 <argument><expr><name>result</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * save the result in case next row shares the same frame.
		 *
		 * XXX in some framing modes, eg ROWS/END_CURRENT_ROW, we can know in
		 * advance that the next row can't possibly share the same frame. Is
		 * it worth detecting that and skipping this code?
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>peraggstate</name><operator>-&gt;</operator><name>resulttypeByVal</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>*</operator><name>isnull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>aggcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>resultValue</name></name> <operator>=</operator>
				<call><name>datumCopy</name><argument_list>(<argument><expr><operator>*</operator><name>result</name></expr></argument>,
						  <argument><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>resulttypeByVal</name></name></expr></argument>,
						  <argument><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>resulttypeLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>resultValue</name></name> <operator>=</operator> <operator>*</operator><name>result</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>resultValueIsNull</name></name> <operator>=</operator> <operator>*</operator><name>isnull</name></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * eval_windowfunction
 *
 * Arguments of window functions are not evaluated here, because a window
 * function can need random access to arbitrary rows in the partition.
 * The window function uses the special WinGetFuncArgInPartition and
 * WinGetFuncArgInFrame functions to evaluate the arguments for the rows
 * it wants.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>eval_windowfunction</name><parameter_list>(<parameter><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>winstate</name></decl></parameter>, <parameter><decl><type><name>WindowStatePerFunc</name></type> <name>perfuncstate</name></decl></parameter>,
					<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>FUNC_MAX_ARGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We don't pass any normal arguments to a window function, but we do pass
	 * it the number of arguments, in order to permit window function
	 * implementations to support varying numbers of arguments.  The real info
	 * goes through the WindowObject, which is passed via fcinfo-&gt;context.
	 */</comment>
	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>perfuncstate</name><operator>-&gt;</operator><name>flinfo</name></name><operator>)</operator></expr></argument>,
							 <argument><expr><name><name>perfuncstate</name><operator>-&gt;</operator><name>numArguments</name></name></expr></argument>,
							 <argument><expr><name><name>perfuncstate</name><operator>-&gt;</operator><name>winCollation</name></name></expr></argument>,
							 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>perfuncstate</name><operator>-&gt;</operator><name>winobj</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Just in case, make all the regular argument slots be null */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>argno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>argno</name> <operator>&lt;</operator> <name><name>perfuncstate</name><operator>-&gt;</operator><name>numArguments</name></name></expr>;</condition> <incr><expr><name>argno</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>argno</name></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></for>
	<comment type="block">/* Window functions don't have a current aggregate context, either */</comment>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>curaggcontext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make sure pass-by-ref data is allocated in the appropriate context. (We
	 * need this in case the function returns a pointer into some short-lived
	 * tuple, as is entirely possible.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>perfuncstate</name><operator>-&gt;</operator><name>resulttypeByVal</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>MemoryContextContains</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
							   <argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><operator>*</operator><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><operator>*</operator><name>result</name></expr></argument>,
							<argument><expr><name><name>perfuncstate</name><operator>-&gt;</operator><name>resulttypeByVal</name></name></expr></argument>,
							<argument><expr><name><name>perfuncstate</name><operator>-&gt;</operator><name>resulttypeLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * begin_partition
 * Start buffering rows of the next partition.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>begin_partition</name><parameter_list>(<parameter><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>winstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WindowAgg</name>  <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>WindowAgg</name> <operator>*</operator><operator>)</operator> <name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>outerPlan</name> <init>= <expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>frameOptions</name> <init>= <expr><name><name>winstate</name><operator>-&gt;</operator><name>frameOptions</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numfuncs</name> <init>= <expr><name><name>winstate</name><operator>-&gt;</operator><name>numfuncs</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>partition_spooled</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>framehead_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametail_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>grouptail_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>spooled_rows</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>currentpos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>frameheadpos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametailpos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>currentgroup</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>frameheadgroup</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametailgroup</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>groupheadpos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>grouptailpos</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* see update_grouptailpos */</comment>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>agg_row_slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>framehead_slot</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>framehead_slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>frametail_slot</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametail_slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If this is the very first partition, we need to fetch the first input
	 * row to store in first_part_slot.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>first_part_slot</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>outerslot</name> <init>= <expr><call><name>ExecProcNode</name><argument_list>(<argument><expr><name>outerPlan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>outerslot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecCopySlot</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>first_part_slot</name></name></expr></argument>, <argument><expr><name>outerslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* outer plan is empty, so we have nothing to do */</comment>
			<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>partition_spooled</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>more_partitions</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Create new tuplestore for this partition */</comment>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up read pointers for the tuplestore.  The current pointer doesn't
	 * need BACKWARD capability, but the per-window-function read pointers do,
	 * and the aggregate pointer does if we might need to restart aggregation.
	 */</comment>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>current_ptr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/* read pointer 0 is pre-allocated */</comment>

	<comment type="block">/* reset default REWIND capability bit for current ptr */</comment>
	<expr_stmt><expr><call><name>tuplestore_set_eflags</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* create read pointers for aggregates, if needed */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>numaggs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WindowObject</name></type> <name>agg_winobj</name> <init>= <expr><name><name>winstate</name><operator>-&gt;</operator><name>agg_winobj</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>readptr_flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If the frame head is potentially movable, or we have an EXCLUSION
		 * clause, we might need to restart aggregation ...
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_START_UNBOUNDED_PRECEDING</name><operator>)</operator> <operator>||</operator>
			<operator>(</operator><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_EXCLUSION</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* ... so create a mark pointer to track the frame head */</comment>
			<expr_stmt><expr><name><name>agg_winobj</name><operator>-&gt;</operator><name>markptr</name></name> <operator>=</operator> <call><name>tuplestore_alloc_read_pointer</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* and the read pointer will need BACKWARD capability */</comment>
			<expr_stmt><expr><name>readptr_flags</name> <operator>|=</operator> <name>EXEC_FLAG_BACKWARD</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>agg_winobj</name><operator>-&gt;</operator><name>readptr</name></name> <operator>=</operator> <call><name>tuplestore_alloc_read_pointer</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>,
															<argument><expr><name>readptr_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>agg_winobj</name><operator>-&gt;</operator><name>markpos</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>agg_winobj</name><operator>-&gt;</operator><name>seekpos</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<comment type="block">/* Also reset the row counters for aggregates */</comment>
		<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>aggregatedbase</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>aggregatedupto</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* create mark and read pointers for each real window function */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numfuncs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WindowStatePerFunc</name></type> <name>perfuncstate</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>winstate</name><operator>-&gt;</operator><name>perfunc</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>perfuncstate</name><operator>-&gt;</operator><name>plain_agg</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>WindowObject</name></type> <name>winobj</name> <init>= <expr><name><name>perfuncstate</name><operator>-&gt;</operator><name>winobj</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>winobj</name><operator>-&gt;</operator><name>markptr</name></name> <operator>=</operator> <call><name>tuplestore_alloc_read_pointer</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>,
															<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>winobj</name><operator>-&gt;</operator><name>readptr</name></name> <operator>=</operator> <call><name>tuplestore_alloc_read_pointer</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>,
															<argument><expr><name>EXEC_FLAG_BACKWARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>winobj</name><operator>-&gt;</operator><name>markpos</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>winobj</name><operator>-&gt;</operator><name>seekpos</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If we are in RANGE or GROUPS mode, then determining frame boundaries
	 * requires physical access to the frame endpoint rows, except in certain
	 * degenerate cases.  We create read pointers to point to those rows, to
	 * simplify access and ensure that the tuplestore doesn't discard the
	 * endpoint rows prematurely.  (Must create pointers in exactly the same
	 * cases that update_frameheadpos and update_frametailpos need them.)
	 */</comment>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>framehead_ptr</name></name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>frametail_ptr</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* if not used */</comment>

	<if_stmt><if>if <condition>(<expr><name>frameOptions</name> <operator>&amp;</operator> <operator>(</operator><name>FRAMEOPTION_RANGE</name> <operator>|</operator> <name>FRAMEOPTION_GROUPS</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_START_CURRENT_ROW</name><operator>)</operator> <operator>&amp;&amp;</operator>
			 <name><name>node</name><operator>-&gt;</operator><name>ordNumCols</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
			<operator>(</operator><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_START_OFFSET</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>framehead_ptr</name></name> <operator>=</operator>
				<call><name>tuplestore_alloc_read_pointer</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_END_CURRENT_ROW</name><operator>)</operator> <operator>&amp;&amp;</operator>
			 <name><name>node</name><operator>-&gt;</operator><name>ordNumCols</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
			<operator>(</operator><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_END_OFFSET</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametail_ptr</name></name> <operator>=</operator>
				<call><name>tuplestore_alloc_read_pointer</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we have an exclusion clause that requires knowing the boundaries of
	 * the current row's peer group, we create a read pointer to track the
	 * tail position of the peer group (i.e., first row of the next peer
	 * group).  The head position does not require its own pointer because we
	 * maintain that as a side effect of advancing the current row.
	 */</comment>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>grouptail_ptr</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>frameOptions</name> <operator>&amp;</operator> <operator>(</operator><name>FRAMEOPTION_EXCLUDE_GROUP</name> <operator>|</operator>
						 <name>FRAMEOPTION_EXCLUDE_TIES</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
		<name><name>node</name><operator>-&gt;</operator><name>ordNumCols</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>grouptail_ptr</name></name> <operator>=</operator>
			<call><name>tuplestore_alloc_read_pointer</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Store the first tuple into the tuplestore (it's always available now;
	 * we either read it above, or saved it at the end of previous partition)
	 */</comment>
	<expr_stmt><expr><call><name>tuplestore_puttupleslot</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>first_part_slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>spooled_rows</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Read tuples from the outer node, up to and including position 'pos', and
 * store them into the tuplestore. If pos is -1, reads the whole partition.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>spool_tuples</name><parameter_list>(<parameter><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>winstate</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>pos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WindowAgg</name>  <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>WindowAgg</name> <operator>*</operator><operator>)</operator> <name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>outerPlan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>outerslot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* just a safety check */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>partition_spooled</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* whole partition done already */</comment>

	<comment type="block">/*
	 * If the tuplestore has spilled to disk, alternate reading and writing
	 * becomes quite expensive due to frequent buffer flushes.  It's cheaper
	 * to force the entire partition to get spooled in one go.
	 *
	 * XXX this is a horrid kluge --- it'd be better to fix the performance
	 * problem inside tuplestore.  FIXME
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplestore_in_memory</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>pos</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>outerPlan</name> <operator>=</operator> <call><name>outerPlanState</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Must be in query context to call outerplan */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>spooled_rows</name></name> <operator>&lt;=</operator> <name>pos</name> <operator>||</operator> <name>pos</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>outerslot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>outerPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>outerslot</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* reached the end of the last partition */</comment>
			<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>partition_spooled</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>more_partitions</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>partNumCols</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>winstate</name><operator>-&gt;</operator><name>tmpcontext</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_innertuple</name></name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>first_part_slot</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>outerslot</name></expr>;</expr_stmt>

			<comment type="block">/* Check if this tuple still belongs to the current partition */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecQualAndReset</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>partEqfunction</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * end of partition; copy the tuple for the next cycle.
				 */</comment>
				<expr_stmt><expr><call><name>ExecCopySlot</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>first_part_slot</name></name></expr></argument>, <argument><expr><name>outerslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>partition_spooled</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>more_partitions</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Still in partition, so save it into the tuplestore */</comment>
		<expr_stmt><expr><call><name>tuplestore_puttupleslot</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>outerslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>spooled_rows</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * release_partition
 * clear information kept within a partition, including
 * tuplestore and aggregate results.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>release_partition</name><parameter_list>(<parameter><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>winstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>winstate</name><operator>-&gt;</operator><name>numfuncs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WindowStatePerFunc</name></type> <name>perfuncstate</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>winstate</name><operator>-&gt;</operator><name>perfunc</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Release any partition-local state of this window function */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>perfuncstate</name><operator>-&gt;</operator><name>winobj</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>perfuncstate</name><operator>-&gt;</operator><name>winobj</name><operator>-&gt;</operator><name>localmem</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Release all partition-local memory (in particular, any partition-local
	 * state that we might have trashed our pointers to in the above loop, and
	 * any aggregate temp data).  We don't rely on retail pfree because some
	 * aggregates might have allocated data we don't have direct pointers to.
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>partcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>aggcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>winstate</name><operator>-&gt;</operator><name>numaggs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>peragg</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>aggcontext</name> <operator>!=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>aggcontext</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>peragg</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>aggcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tuplestore_end</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>partition_spooled</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * row_is_in_frame
 * Determine whether a row is in the current row's window frame according
 * to our window framing rule
 *
 * The caller must have already determined that the row is in the partition
 * and fetched it into a slot.  This function just encapsulates the framing
 * rules.
 *
 * Returns:
 * -1, if the row is out of frame and no succeeding rows can be in frame
 * 0, if the row is out of frame but succeeding rows might be in frame
 * 1, if the row is in frame
 *
 * May clobber winstate-&gt;temp_slot_2.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>row_is_in_frame</name><parameter_list>(<parameter><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>winstate</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>frameOptions</name> <init>= <expr><name><name>winstate</name><operator>-&gt;</operator><name>frameOptions</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pos</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>			<comment type="block">/* else caller error */</comment>

	<comment type="block">/*
	 * First, check frame starting conditions.  We might as well delegate this
	 * to update_frameheadpos always; it doesn't add any notable cost.
	 */</comment>
	<expr_stmt><expr><call><name>update_frameheadpos</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name><name>winstate</name><operator>-&gt;</operator><name>frameheadpos</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Okay so far, now check frame ending conditions.  Here, we avoid calling
	 * update_frametailpos in simple cases, so as not to spool tuples further
	 * ahead than necessary.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_END_CURRENT_ROW</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_ROWS</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* rows after current row are out of frame */</comment>
			<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;</operator> <name><name>winstate</name><operator>-&gt;</operator><name>currentpos</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>frameOptions</name> <operator>&amp;</operator> <operator>(</operator><name>FRAMEOPTION_RANGE</name> <operator>|</operator> <name>FRAMEOPTION_GROUPS</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* following row that is not peer is out of frame */</comment>
			<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;</operator> <name><name>winstate</name><operator>-&gt;</operator><name>currentpos</name></name> <operator>&amp;&amp;</operator>
				<operator>!</operator><call><name>are_peers</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_END_OFFSET</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_ROWS</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int64</name></type>		<name>offset</name> <init>= <expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>endOffsetValue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* rows after current row + offset are out of frame */</comment>
			<if_stmt><if>if <condition>(<expr><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_END_OFFSET_PRECEDING</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>-</operator><name>offset</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;</operator> <name><name>winstate</name><operator>-&gt;</operator><name>currentpos</name></name> <operator>+</operator> <name>offset</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>frameOptions</name> <operator>&amp;</operator> <operator>(</operator><name>FRAMEOPTION_RANGE</name> <operator>|</operator> <name>FRAMEOPTION_GROUPS</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* hard cases, so delegate to update_frametailpos */</comment>
			<expr_stmt><expr><call><name>update_frametailpos</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>frametailpos</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Check exclusion clause */</comment>
	<if_stmt><if>if <condition>(<expr><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_EXCLUDE_CURRENT_ROW</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>==</operator> <name><name>winstate</name><operator>-&gt;</operator><name>currentpos</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_EXCLUDE_GROUP</name><operator>)</operator> <operator>||</operator>
			 <operator>(</operator><operator>(</operator><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_EXCLUDE_TIES</name><operator>)</operator> <operator>&amp;&amp;</operator>
			  <name>pos</name> <operator>!=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>currentpos</name></name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WindowAgg</name>  <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>WindowAgg</name> <operator>*</operator><operator>)</operator> <name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* If no ORDER BY, all rows are peers with each other */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ordNumCols</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
		<comment type="block">/* Otherwise, check the group boundaries */</comment>
		<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>groupheadpos</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>update_grouptailpos</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name><name>winstate</name><operator>-&gt;</operator><name>grouptailpos</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If we get here, it's in frame */</comment>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * update_frameheadpos
 * make frameheadpos valid for the current row
 *
 * Note that frameheadpos is computed without regard for any window exclusion
 * clause; the current row and/or its peers are considered part of the frame
 * for this purpose even if they must be excluded later.
 *
 * May clobber winstate-&gt;temp_slot_2.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>update_frameheadpos</name><parameter_list>(<parameter><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>winstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WindowAgg</name>  <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>WindowAgg</name> <operator>*</operator><operator>)</operator> <name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>frameOptions</name> <init>= <expr><name><name>winstate</name><operator>-&gt;</operator><name>frameOptions</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>framehead_valid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* already known for current row */</comment>

	<comment type="block">/* We may be called in a short-lived context */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_START_UNBOUNDED_PRECEDING</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* In UNBOUNDED PRECEDING mode, frame head is always row 0 */</comment>
		<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>frameheadpos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>framehead_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_START_CURRENT_ROW</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_ROWS</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* In ROWS mode, frame head is the same as current */</comment>
			<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>frameheadpos</name></name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>currentpos</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>framehead_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>frameOptions</name> <operator>&amp;</operator> <operator>(</operator><name>FRAMEOPTION_RANGE</name> <operator>|</operator> <name>FRAMEOPTION_GROUPS</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* If no ORDER BY, all rows are peers with each other */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ordNumCols</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>frameheadpos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>framehead_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * In RANGE or GROUPS START_CURRENT_ROW mode, frame head is the
			 * first row that is a peer of current row.  We keep a copy of the
			 * last-known frame head row in framehead_slot, and advance as
			 * necessary.  Note that if we reach end of partition, we will
			 * leave frameheadpos = end+1 and framehead_slot empty.
			 */</comment>
			<expr_stmt><expr><call><name>tuplestore_select_read_pointer</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>,
										   <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>framehead_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>frameheadpos</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<call><name>TupIsNull</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>framehead_slot</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* fetch first row into framehead_slot, if we didn't already */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
											 <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>framehead_slot</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected end of tuplestore"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<while>while <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>framehead_slot</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>are_peers</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>, <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>framehead_slot</name></name></expr></argument>,
							  <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>		<comment type="block">/* this row is the correct frame head */</comment>
				<comment type="block">/* Note we advance frameheadpos even if the fetch fails */</comment>
				<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>frameheadpos</name></name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>spool_tuples</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>, <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>frameheadpos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
											 <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>framehead_slot</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>		<comment type="block">/* end of partition */</comment>
			</block_content>}</block></while>
			<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>framehead_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_START_OFFSET</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_ROWS</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* In ROWS mode, bound is physically n before/after current */</comment>
			<decl_stmt><decl><type><name>int64</name></type>		<name>offset</name> <init>= <expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>startOffsetValue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_START_OFFSET_PRECEDING</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>-</operator><name>offset</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>frameheadpos</name></name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>currentpos</name></name> <operator>+</operator> <name>offset</name></expr>;</expr_stmt>
			<comment type="block">/* frame head can't go before first row */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>frameheadpos</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>frameheadpos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>frameheadpos</name></name> <operator>&gt;</operator> <name><name>winstate</name><operator>-&gt;</operator><name>currentpos</name></name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* make sure frameheadpos is not past end of partition */</comment>
				<expr_stmt><expr><call><name>spool_tuples</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>, <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>frameheadpos</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>frameheadpos</name></name> <operator>&gt;</operator> <name><name>winstate</name><operator>-&gt;</operator><name>spooled_rows</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>frameheadpos</name></name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>spooled_rows</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>framehead_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_RANGE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * In RANGE START_OFFSET mode, frame head is the first row that
			 * satisfies the in_range constraint relative to the current row.
			 * We keep a copy of the last-known frame head row in
			 * framehead_slot, and advance as necessary.  Note that if we
			 * reach end of partition, we will leave frameheadpos = end+1 and
			 * framehead_slot empty.
			 */</comment>
			<decl_stmt><decl><type><name>int</name></type>			<name>sortCol</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ordColIdx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>sub</name></decl>,
						<decl><type ref="prev"/><name>less</name></decl>;</decl_stmt>

			<comment type="block">/* We must have an ordering column */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ordNumCols</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Precompute flags for in_range checks */</comment>
			<if_stmt><if>if <condition>(<expr><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_START_OFFSET_PRECEDING</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>sub</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>		<comment type="block">/* subtract startOffset from current row */</comment>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>sub</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* add it */</comment>
			<expr_stmt><expr><name>less</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>		<comment type="block">/* normally, we want frame head &gt;= sum */</comment>
			<comment type="block">/* If sort order is descending, flip both flags */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>winstate</name><operator>-&gt;</operator><name>inRangeAsc</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>sub</name> <operator>=</operator> <operator>!</operator><name>sub</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>less</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>tuplestore_select_read_pointer</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>,
										   <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>framehead_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>frameheadpos</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<call><name>TupIsNull</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>framehead_slot</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* fetch first row into framehead_slot, if we didn't already */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
											 <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>framehead_slot</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected end of tuplestore"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<while>while <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>framehead_slot</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Datum</name></type>		<name>headval</name></decl>,
							<decl><type ref="prev"/><name>currval</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>headisnull</name></decl>,
							<decl><type ref="prev"/><name>currisnull</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>headval</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>framehead_slot</name></name></expr></argument>, <argument><expr><name>sortCol</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>headisnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>currval</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr></argument>, <argument><expr><name>sortCol</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>currisnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>headisnull</name> <operator>||</operator> <name>currisnull</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* order of the rows depends only on nulls_first */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>inRangeNullsFirst</name></name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* advance head if head is null and curr is not */</comment>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>headisnull</name> <operator>||</operator> <name>currisnull</name></expr>)</condition><block type="pseudo"><block_content>
							<break>break;</break></block_content></block></if></if_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* advance head if head is not null and curr is null */</comment>
						<if_stmt><if>if <condition>(<expr><name>headisnull</name> <operator>||</operator> <operator>!</operator><name>currisnull</name></expr>)</condition><block type="pseudo"><block_content>
							<break>break;</break></block_content></block></if></if_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>FunctionCall5Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>winstate</name><operator>-&gt;</operator><name>startInRangeFunc</name></name></expr></argument>,
													   <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>inRangeColl</name></name></expr></argument>,
													   <argument><expr><name>headval</name></expr></argument>,
													   <argument><expr><name>currval</name></expr></argument>,
													   <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>startOffsetValue</name></name></expr></argument>,
													   <argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr></argument>,
													   <argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>less</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>	<comment type="block">/* this row is the correct frame head */</comment>
				</block_content>}</block></else></if_stmt>
				<comment type="block">/* Note we advance frameheadpos even if the fetch fails */</comment>
				<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>frameheadpos</name></name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>spool_tuples</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>, <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>frameheadpos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
											 <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>framehead_slot</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>		<comment type="block">/* end of partition */</comment>
			</block_content>}</block></while>
			<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>framehead_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_GROUPS</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * In GROUPS START_OFFSET mode, frame head is the first row of the
			 * first peer group whose number satisfies the offset constraint.
			 * We keep a copy of the last-known frame head row in
			 * framehead_slot, and advance as necessary.  Note that if we
			 * reach end of partition, we will leave frameheadpos = end+1 and
			 * framehead_slot empty.
			 */</comment>
			<decl_stmt><decl><type><name>int64</name></type>		<name>offset</name> <init>= <expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>startOffsetValue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int64</name></type>		<name>minheadgroup</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_START_OFFSET_PRECEDING</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>minheadgroup</name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>currentgroup</name></name> <operator>-</operator> <name>offset</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>minheadgroup</name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>currentgroup</name></name> <operator>+</operator> <name>offset</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><call><name>tuplestore_select_read_pointer</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>,
										   <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>framehead_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>frameheadpos</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<call><name>TupIsNull</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>framehead_slot</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* fetch first row into framehead_slot, if we didn't already */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
											 <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>framehead_slot</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected end of tuplestore"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<while>while <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>framehead_slot</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>frameheadgroup</name></name> <operator>&gt;=</operator> <name>minheadgroup</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>		<comment type="block">/* this row is the correct frame head */</comment>
				<expr_stmt><expr><call><name>ExecCopySlot</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>temp_slot_2</name></name></expr></argument>, <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>framehead_slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Note we advance frameheadpos even if the fetch fails */</comment>
				<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>frameheadpos</name></name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>spool_tuples</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>, <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>frameheadpos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
											 <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>framehead_slot</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>		<comment type="block">/* end of partition */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>are_peers</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>, <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>temp_slot_2</name></name></expr></argument>,
							   <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>framehead_slot</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>frameheadgroup</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></while>
			<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>temp_slot_2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>framehead_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * update_frametailpos
 * make frametailpos valid for the current row
 *
 * Note that frametailpos is computed without regard for any window exclusion
 * clause; the current row and/or its peers are considered part of the frame
 * for this purpose even if they must be excluded later.
 *
 * May clobber winstate-&gt;temp_slot_2.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>update_frametailpos</name><parameter_list>(<parameter><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>winstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WindowAgg</name>  <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>WindowAgg</name> <operator>*</operator><operator>)</operator> <name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>frameOptions</name> <init>= <expr><name><name>winstate</name><operator>-&gt;</operator><name>frameOptions</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>frametail_valid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* already known for current row */</comment>

	<comment type="block">/* We may be called in a short-lived context */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_END_UNBOUNDED_FOLLOWING</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* In UNBOUNDED FOLLOWING mode, all partition rows are in frame */</comment>
		<expr_stmt><expr><call><name>spool_tuples</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametailpos</name></name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>spooled_rows</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametail_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_END_CURRENT_ROW</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_ROWS</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* In ROWS mode, exactly the rows up to current are in frame */</comment>
			<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametailpos</name></name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>currentpos</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametail_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>frameOptions</name> <operator>&amp;</operator> <operator>(</operator><name>FRAMEOPTION_RANGE</name> <operator>|</operator> <name>FRAMEOPTION_GROUPS</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* If no ORDER BY, all rows are peers with each other */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ordNumCols</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>spool_tuples</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametailpos</name></name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>spooled_rows</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametail_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * In RANGE or GROUPS END_CURRENT_ROW mode, frame end is the last
			 * row that is a peer of current row, frame tail is the row after
			 * that (if any).  We keep a copy of the last-known frame tail row
			 * in frametail_slot, and advance as necessary.  Note that if we
			 * reach end of partition, we will leave frametailpos = end+1 and
			 * frametail_slot empty.
			 */</comment>
			<expr_stmt><expr><call><name>tuplestore_select_read_pointer</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>,
										   <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametail_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>frametailpos</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<call><name>TupIsNull</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametail_slot</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* fetch first row into frametail_slot, if we didn't already */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
											 <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametail_slot</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected end of tuplestore"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<while>while <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametail_slot</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>frametailpos</name></name> <operator>&gt;</operator> <name><name>winstate</name><operator>-&gt;</operator><name>currentpos</name></name> <operator>&amp;&amp;</operator>
					<operator>!</operator><call><name>are_peers</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>, <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametail_slot</name></name></expr></argument>,
							   <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>		<comment type="block">/* this row is the frame tail */</comment>
				<comment type="block">/* Note we advance frametailpos even if the fetch fails */</comment>
				<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametailpos</name></name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>spool_tuples</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>, <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametailpos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
											 <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametail_slot</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>		<comment type="block">/* end of partition */</comment>
			</block_content>}</block></while>
			<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametail_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_END_OFFSET</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_ROWS</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* In ROWS mode, bound is physically n before/after current */</comment>
			<decl_stmt><decl><type><name>int64</name></type>		<name>offset</name> <init>= <expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>endOffsetValue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_END_OFFSET_PRECEDING</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>-</operator><name>offset</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametailpos</name></name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>currentpos</name></name> <operator>+</operator> <name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<comment type="block">/* smallest allowable value of frametailpos is 0 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>frametailpos</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametailpos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>frametailpos</name></name> <operator>&gt;</operator> <name><name>winstate</name><operator>-&gt;</operator><name>currentpos</name></name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* make sure frametailpos is not past end of partition */</comment>
				<expr_stmt><expr><call><name>spool_tuples</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>, <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametailpos</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>frametailpos</name></name> <operator>&gt;</operator> <name><name>winstate</name><operator>-&gt;</operator><name>spooled_rows</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametailpos</name></name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>spooled_rows</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametail_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_RANGE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * In RANGE END_OFFSET mode, frame end is the last row that
			 * satisfies the in_range constraint relative to the current row,
			 * frame tail is the row after that (if any).  We keep a copy of
			 * the last-known frame tail row in frametail_slot, and advance as
			 * necessary.  Note that if we reach end of partition, we will
			 * leave frametailpos = end+1 and frametail_slot empty.
			 */</comment>
			<decl_stmt><decl><type><name>int</name></type>			<name>sortCol</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ordColIdx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>sub</name></decl>,
						<decl><type ref="prev"/><name>less</name></decl>;</decl_stmt>

			<comment type="block">/* We must have an ordering column */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ordNumCols</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Precompute flags for in_range checks */</comment>
			<if_stmt><if>if <condition>(<expr><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_END_OFFSET_PRECEDING</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>sub</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>		<comment type="block">/* subtract endOffset from current row */</comment>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>sub</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* add it */</comment>
			<expr_stmt><expr><name>less</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>		<comment type="block">/* normally, we want frame tail &lt;= sum */</comment>
			<comment type="block">/* If sort order is descending, flip both flags */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>winstate</name><operator>-&gt;</operator><name>inRangeAsc</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>sub</name> <operator>=</operator> <operator>!</operator><name>sub</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>less</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>tuplestore_select_read_pointer</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>,
										   <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametail_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>frametailpos</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<call><name>TupIsNull</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametail_slot</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* fetch first row into frametail_slot, if we didn't already */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
											 <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametail_slot</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected end of tuplestore"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<while>while <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametail_slot</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Datum</name></type>		<name>tailval</name></decl>,
							<decl><type ref="prev"/><name>currval</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>tailisnull</name></decl>,
							<decl><type ref="prev"/><name>currisnull</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>tailval</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametail_slot</name></name></expr></argument>, <argument><expr><name>sortCol</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>tailisnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>currval</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr></argument>, <argument><expr><name>sortCol</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>currisnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>tailisnull</name> <operator>||</operator> <name>currisnull</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* order of the rows depends only on nulls_first */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>inRangeNullsFirst</name></name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* advance tail if tail is null or curr is not */</comment>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tailisnull</name></expr>)</condition><block type="pseudo"><block_content>
							<break>break;</break></block_content></block></if></if_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* advance tail if tail is not null or curr is null */</comment>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>currisnull</name></expr>)</condition><block type="pseudo"><block_content>
							<break>break;</break></block_content></block></if></if_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>FunctionCall5Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>winstate</name><operator>-&gt;</operator><name>endInRangeFunc</name></name></expr></argument>,
														<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>inRangeColl</name></name></expr></argument>,
														<argument><expr><name>tailval</name></expr></argument>,
														<argument><expr><name>currval</name></expr></argument>,
														<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>endOffsetValue</name></name></expr></argument>,
														<argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr></argument>,
														<argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>less</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>	<comment type="block">/* this row is the correct frame tail */</comment>
				</block_content>}</block></else></if_stmt>
				<comment type="block">/* Note we advance frametailpos even if the fetch fails */</comment>
				<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametailpos</name></name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>spool_tuples</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>, <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametailpos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
											 <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametail_slot</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>		<comment type="block">/* end of partition */</comment>
			</block_content>}</block></while>
			<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametail_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_GROUPS</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * In GROUPS END_OFFSET mode, frame end is the last row of the
			 * last peer group whose number satisfies the offset constraint,
			 * and frame tail is the row after that (if any).  We keep a copy
			 * of the last-known frame tail row in frametail_slot, and advance
			 * as necessary.  Note that if we reach end of partition, we will
			 * leave frametailpos = end+1 and frametail_slot empty.
			 */</comment>
			<decl_stmt><decl><type><name>int64</name></type>		<name>offset</name> <init>= <expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>endOffsetValue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int64</name></type>		<name>maxtailgroup</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_END_OFFSET_PRECEDING</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>maxtailgroup</name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>currentgroup</name></name> <operator>-</operator> <name>offset</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>maxtailgroup</name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>currentgroup</name></name> <operator>+</operator> <name>offset</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><call><name>tuplestore_select_read_pointer</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>,
										   <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametail_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>frametailpos</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<call><name>TupIsNull</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametail_slot</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* fetch first row into frametail_slot, if we didn't already */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
											 <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametail_slot</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected end of tuplestore"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<while>while <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametail_slot</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>frametailgroup</name></name> <operator>&gt;</operator> <name>maxtailgroup</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>		<comment type="block">/* this row is the correct frame tail */</comment>
				<expr_stmt><expr><call><name>ExecCopySlot</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>temp_slot_2</name></name></expr></argument>, <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametail_slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Note we advance frametailpos even if the fetch fails */</comment>
				<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametailpos</name></name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>spool_tuples</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>, <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametailpos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
											 <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametail_slot</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>		<comment type="block">/* end of partition */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>are_peers</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>, <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>temp_slot_2</name></name></expr></argument>,
							   <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametail_slot</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametailgroup</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></while>
			<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>temp_slot_2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametail_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * update_grouptailpos
 * make grouptailpos valid for the current row
 *
 * May clobber winstate-&gt;temp_slot_2.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>update_grouptailpos</name><parameter_list>(<parameter><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>winstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WindowAgg</name>  <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>WindowAgg</name> <operator>*</operator><operator>)</operator> <name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>grouptail_valid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* already known for current row */</comment>

	<comment type="block">/* We may be called in a short-lived context */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If no ORDER BY, all rows are peers with each other */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ordNumCols</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>spool_tuples</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>grouptailpos</name></name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>spooled_rows</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>grouptail_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Because grouptail_valid is reset only when current row advances into a
	 * new peer group, we always reach here knowing that grouptailpos needs to
	 * be advanced by at least one row.  Hence, unlike the otherwise similar
	 * case for frame tail tracking, we do not need persistent storage of the
	 * group tail row.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>grouptailpos</name></name> <operator>&lt;=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>currentpos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tuplestore_select_read_pointer</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>,
								   <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>grouptail_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/* Note we advance grouptailpos even if the fetch fails */</comment>
		<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>grouptailpos</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>spool_tuples</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>, <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>grouptailpos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
									 <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>temp_slot_2</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>				<comment type="block">/* end of partition */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>grouptailpos</name></name> <operator>&gt;</operator> <name><name>winstate</name><operator>-&gt;</operator><name>currentpos</name></name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>are_peers</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>, <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>temp_slot_2</name></name></expr></argument>,
					   <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>				<comment type="block">/* this row is the group tail */</comment>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>temp_slot_2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>grouptail_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* -----------------
 * ExecWindowAgg
 *
 *	ExecWindowAgg receives tuples from its outer subplan and
 *	stores them into a tuplestore, then processes window functions.
 *	This node doesn't reduce nor qualify any row so the number of
 *	returned rows is exactly the same as its outer subplan's result.
 * -----------------
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecWindowAgg</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>winstate</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>WindowAggState</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numfuncs</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>all_done</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Compute frame offset values, if any, during first call (or after a
	 * rescan).  These are assumed to hold constant throughout the scan; if
	 * user gives us a volatile expression, we'll only use its initial value.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>all_first</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>frameOptions</name> <init>= <expr><name><name>winstate</name><operator>-&gt;</operator><name>frameOptions</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int16</name></type>		<name>len</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>byval</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_START_OFFSET</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>startOffset</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>ExecEvalExprSwitchContext</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>startOffset</name></name></expr></argument>,
											  <argument><expr><name>econtext</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"frame starting offset must not be null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* copy value into query-lifespan context */</comment>
			<expr_stmt><expr><call><name>get_typlenbyval</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>winstate</name><operator>-&gt;</operator><name>startOffset</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>byval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>startOffsetValue</name></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>byval</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>frameOptions</name> <operator>&amp;</operator> <operator>(</operator><name>FRAMEOPTION_ROWS</name> <operator>|</operator> <name>FRAMEOPTION_GROUPS</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* value is known to be int8 */</comment>
				<decl_stmt><decl><type><name>int64</name></type>		<name>offset</name> <init>= <expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"frame starting offset must not be negative"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_END_OFFSET</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>endOffset</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>ExecEvalExprSwitchContext</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>endOffset</name></name></expr></argument>,
											  <argument><expr><name>econtext</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"frame ending offset must not be null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* copy value into query-lifespan context */</comment>
			<expr_stmt><expr><call><name>get_typlenbyval</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>winstate</name><operator>-&gt;</operator><name>endOffset</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>byval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>endOffsetValue</name></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>byval</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>frameOptions</name> <operator>&amp;</operator> <operator>(</operator><name>FRAMEOPTION_ROWS</name> <operator>|</operator> <name>FRAMEOPTION_GROUPS</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* value is known to be int8 */</comment>
				<decl_stmt><decl><type><name>int64</name></type>		<name>offset</name> <init>= <expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"frame ending offset must not be negative"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>all_first</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Initialize for first partition and set current row = 0 */</comment>
		<expr_stmt><expr><call><name>begin_partition</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* If there are no input rows, we'll detect that and exit below */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Advance current row within partition */</comment>
		<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>currentpos</name></name><operator>++</operator></expr>;</expr_stmt>
		<comment type="block">/* This might mean that the frame moves, too */</comment>
		<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>framehead_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametail_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<comment type="block">/* we don't need to invalidate grouptail here; see below */</comment>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Spool all tuples up to and including the current row, if we haven't
	 * already
	 */</comment>
	<expr_stmt><expr><call><name>spool_tuples</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>, <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>currentpos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Move to the next partition if we reached the end of this partition */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>partition_spooled</name></name> <operator>&amp;&amp;</operator>
		<name><name>winstate</name><operator>-&gt;</operator><name>currentpos</name></name> <operator>&gt;=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>spooled_rows</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>release_partition</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>more_partitions</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>begin_partition</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>spooled_rows</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>all_done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* final output execution is in ps_ExprContext */</comment>
	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>

	<comment type="block">/* Clear the per-output-tuple context for current row */</comment>
	<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Read the current row from the tuplestore, and save in ScanTupleSlot.
	 * (We can't rely on the outerplan's output slot because we may have to
	 * read beyond the current row.  Also, we have to actually copy the row
	 * out of the tuplestore, since window function evaluation might cause the
	 * tuplestore to dump its state to disk.)
	 *
	 * In GROUPS mode, or when tracking a group-oriented exclusion clause, we
	 * must also detect entering a new peer group and update associated state
	 * when that happens.  We use temp_slot_2 to temporarily hold the previous
	 * row for this purpose.
	 *
	 * Current row must be in the tuplestore, since we spooled it above.
	 */</comment>
	<expr_stmt><expr><call><name>tuplestore_select_read_pointer</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>current_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>winstate</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <operator>(</operator><name>FRAMEOPTION_GROUPS</name> <operator>|</operator>
								   <name>FRAMEOPTION_EXCLUDE_GROUP</name> <operator>|</operator>
								   <name>FRAMEOPTION_EXCLUDE_TIES</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
		<name><name>winstate</name><operator>-&gt;</operator><name>currentpos</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecCopySlot</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>temp_slot_2</name></name></expr></argument>, <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
									 <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected end of tuplestore"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>are_peers</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>, <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>temp_slot_2</name></name></expr></argument>,
					   <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>currentgroup</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>groupheadpos</name></name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>currentpos</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>grouptail_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>temp_slot_2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
									 <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected end of tuplestore"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Evaluate true window functions
	 */</comment>
	<expr_stmt><expr><name>numfuncs</name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>numfuncs</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numfuncs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WindowStatePerFunc</name></type> <name>perfuncstate</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>winstate</name><operator>-&gt;</operator><name>perfunc</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>perfuncstate</name><operator>-&gt;</operator><name>plain_agg</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>eval_windowfunction</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>, <argument><expr><name>perfuncstate</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_aggvalues</name><index>[<expr><name><name>perfuncstate</name><operator>-&gt;</operator><name>wfuncstate</name><operator>-&gt;</operator><name>wfuncno</name></name></expr>]</index></name><operator>)</operator></expr></argument>,
							<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_aggnulls</name><index>[<expr><name><name>perfuncstate</name><operator>-&gt;</operator><name>wfuncstate</name><operator>-&gt;</operator><name>wfuncno</name></name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Evaluate aggregates
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>numaggs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>eval_windowaggregates</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we have created auxiliary read pointers for the frame or group
	 * boundaries, force them to be kept up-to-date, because we don't know
	 * whether the window function(s) will do anything that requires that.
	 * Failing to advance the pointers would result in being unable to trim
	 * data from the tuplestore, which is bad.  (If we could know in advance
	 * whether the window functions will use frame boundary info, we could
	 * skip creating these pointers in the first place ... but unfortunately
	 * the window function API doesn't require that.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>framehead_ptr</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>update_frameheadpos</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>frametail_ptr</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>update_frametailpos</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>grouptail_ptr</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>update_grouptailpos</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Truncate any no-longer-needed rows from the tuplestore.
	 */</comment>
	<expr_stmt><expr><call><name>tuplestore_trim</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Form and return a projection tuple using the windowfunc results and the
	 * current row.  Setting ecxt_outertuple arranges that any Vars will be
	 * evaluated with respect to that row.
	 */</comment>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr>;</expr_stmt>

	<return>return <expr><call><name>ExecProject</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ProjInfo</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -----------------
 * ExecInitWindowAgg
 *
 *	Creates the run-time information for the WindowAgg node produced by the
 *	planner and initializes its outer subtree
 * -----------------
 */</comment>
<function><type><name>WindowAggState</name> <modifier>*</modifier></type>
<name>ExecInitWindowAgg</name><parameter_list>(<parameter><decl><type><name>WindowAgg</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>winstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>outerPlan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>tmpcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WindowStatePerFunc</name></type> <name>perfunc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WindowStatePerAgg</name></type> <name>peragg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>frameOptions</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>frameOptions</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numfuncs</name></decl>,
				<decl><type ref="prev"/><name>wfuncno</name></decl>,
				<decl><type ref="prev"/><name>numaggs</name></decl>,
				<decl><type ref="prev"/><name>aggno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>scanDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/* check for unsupported flags */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <operator>(</operator><name>EXEC_FLAG_BACKWARD</name> <operator>|</operator> <name>EXEC_FLAG_MARK</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * create state structure
	 */</comment>
	<expr_stmt><expr><name>winstate</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>WindowAggState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ExecProcNode</name></name> <operator>=</operator> <name>ExecWindowAgg</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create expression contexts.  We need two, one for per-input-tuple
	 * processing and one for per-output-tuple processing.  We cheat a little
	 * by using ExecAssignExprContext() to build both.
	 */</comment>
	<expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmpcontext</name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>tmpcontext</name></name> <operator>=</operator> <name>tmpcontext</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create long-lived context for storage of partition-local memory etc */</comment>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>partcontext</name></name> <operator>=</operator>
		<call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
							  <argument><expr><literal type="string">"WindowAgg Partition"</literal></expr></argument>,
							  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create mid-lived context for aggregate trans values etc.
	 *
	 * Note that moving aggregates each use their own private context, not
	 * this one.
	 */</comment>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>aggcontext</name></name> <operator>=</operator>
		<call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
							  <argument><expr><literal type="string">"WindowAgg Aggregates"</literal></expr></argument>,
							  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * WindowAgg nodes never have quals, since they can only occur at the
	 * logical top level of a query (ie, after any WHERE or HAVING filters)
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>qual</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * initialize child nodes
	 */</comment>
	<expr_stmt><expr><name>outerPlan</name> <operator>=</operator> <call><name>outerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><name>outerPlan</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * initialize source tuple type (which is also the tuple type that we'll
	 * store in the tuplestore and use in all our working slots).
	 */</comment>
	<expr_stmt><expr><call><name>ExecCreateScanSlotFromOuterPlan</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>winstate</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scanDesc</name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr>;</expr_stmt>

	<comment type="block">/* the outer tuple isn't the child's tuple, but always a minimal tuple */</comment>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>outeropsset</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>outerops</name></name> <operator>=</operator> <operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>outeropsfixed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * tuple table initialization
	 */</comment>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>first_part_slot</name></name> <operator>=</operator> <call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>scanDesc</name></expr></argument>,
													   <argument><expr><operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>agg_row_slot</name></name> <operator>=</operator> <call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>scanDesc</name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>temp_slot_1</name></name> <operator>=</operator> <call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>scanDesc</name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>temp_slot_2</name></name> <operator>=</operator> <call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>scanDesc</name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * create frame head and tail slots only if needed (must create slots in
	 * exactly the same cases that update_frameheadpos and update_frametailpos
	 * need them)
	 */</comment>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>framehead_slot</name></name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>frametail_slot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>frameOptions</name> <operator>&amp;</operator> <operator>(</operator><name>FRAMEOPTION_RANGE</name> <operator>|</operator> <name>FRAMEOPTION_GROUPS</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_START_CURRENT_ROW</name><operator>)</operator> <operator>&amp;&amp;</operator>
			 <name><name>node</name><operator>-&gt;</operator><name>ordNumCols</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
			<operator>(</operator><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_START_OFFSET</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>framehead_slot</name></name> <operator>=</operator> <call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>scanDesc</name></expr></argument>,
															  <argument><expr><operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_END_CURRENT_ROW</name><operator>)</operator> <operator>&amp;&amp;</operator>
			 <name><name>node</name><operator>-&gt;</operator><name>ordNumCols</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
			<operator>(</operator><name>frameOptions</name> <operator>&amp;</operator> <name>FRAMEOPTION_END_OFFSET</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametail_slot</name></name> <operator>=</operator> <call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>scanDesc</name></expr></argument>,
															  <argument><expr><operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Initialize result slot, type and projection.
	 */</comment>
	<expr_stmt><expr><call><name>ExecInitResultTupleSlotTL</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecAssignProjectionInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up data for comparing tuples */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>partNumCols</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>partEqfunction</name></name> <operator>=</operator>
			<call><name>execTuplesMatchPrepare</name><argument_list>(<argument><expr><name>scanDesc</name></expr></argument>,
								   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>partNumCols</name></name></expr></argument>,
								   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>partColIdx</name></name></expr></argument>,
								   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>partOperators</name></name></expr></argument>,
								   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>partCollations</name></name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ordNumCols</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>ordEqfunction</name></name> <operator>=</operator>
			<call><name>execTuplesMatchPrepare</name><argument_list>(<argument><expr><name>scanDesc</name></expr></argument>,
								   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ordNumCols</name></name></expr></argument>,
								   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ordColIdx</name></name></expr></argument>,
								   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ordOperators</name></name></expr></argument>,
								   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ordCollations</name></name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * WindowAgg nodes use aggvalues and aggnulls as well as Agg nodes.
	 */</comment>
	<expr_stmt><expr><name>numfuncs</name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>numfuncs</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>numaggs</name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>numaggs</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_aggvalues</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numfuncs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_aggnulls</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numfuncs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * allocate per-wfunc/per-agg state information.
	 */</comment>
	<expr_stmt><expr><name>perfunc</name> <operator>=</operator> <operator>(</operator><name>WindowStatePerFunc</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WindowStatePerFuncData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numfuncs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>peragg</name> <operator>=</operator> <operator>(</operator><name>WindowStatePerAgg</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WindowStatePerAggData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numaggs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>perfunc</name></name> <operator>=</operator> <name>perfunc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>peragg</name></name> <operator>=</operator> <name>peragg</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>wfuncno</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>aggno</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>winstate-&gt;funcs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WindowFuncExprState</name> <modifier>*</modifier></type><name>wfuncstate</name> <init>= <expr><operator>(</operator><name>WindowFuncExprState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>WindowFunc</name> <modifier>*</modifier></type><name>wfunc</name> <init>= <expr><name><name>wfuncstate</name><operator>-&gt;</operator><name>wfunc</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>WindowStatePerFunc</name></type> <name>perfuncstate</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>wfunc</name><operator>-&gt;</operator><name>winref</name></name> <operator>!=</operator> <name><name>node</name><operator>-&gt;</operator><name>winref</name></name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* planner screwed up? */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"WindowFunc with winref %u assigned to WindowAgg with winref %u"</literal></expr></argument>,
				 <argument><expr><name><name>wfunc</name><operator>-&gt;</operator><name>winref</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>winref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Look for a previous duplicate window function */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>wfuncno</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>wfunc</name></expr></argument>, <argument><expr><name><name>perfunc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>wfunc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<operator>!</operator><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>wfunc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;=</operator> <name>wfuncno</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Found a match to an existing entry, so just mark it */</comment>
			<expr_stmt><expr><name><name>wfuncstate</name><operator>-&gt;</operator><name>wfuncno</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Nope, so assign a new PerAgg record */</comment>
		<expr_stmt><expr><name>perfuncstate</name> <operator>=</operator> <operator>&amp;</operator><name><name>perfunc</name><index>[<expr><operator>++</operator><name>wfuncno</name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/* Mark WindowFunc state node with assigned index in the result array */</comment>
		<expr_stmt><expr><name><name>wfuncstate</name><operator>-&gt;</operator><name>wfuncno</name></name> <operator>=</operator> <name>wfuncno</name></expr>;</expr_stmt>

		<comment type="block">/* Check permission to call window function */</comment>
		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_proc_aclcheck</name><argument_list>(<argument><expr><name><name>wfunc</name><operator>-&gt;</operator><name>winfnoid</name></name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
									 <argument><expr><name>ACL_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_FUNCTION</name></expr></argument>,
						   <argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name><name>wfunc</name><operator>-&gt;</operator><name>winfnoid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>InvokeFunctionExecuteHook</name><argument_list>(<argument><expr><name><name>wfunc</name><operator>-&gt;</operator><name>winfnoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Fill in the perfuncstate data */</comment>
		<expr_stmt><expr><name><name>perfuncstate</name><operator>-&gt;</operator><name>wfuncstate</name></name> <operator>=</operator> <name>wfuncstate</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>perfuncstate</name><operator>-&gt;</operator><name>wfunc</name></name> <operator>=</operator> <name>wfunc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>perfuncstate</name><operator>-&gt;</operator><name>numArguments</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>wfuncstate</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><name><name>wfunc</name><operator>-&gt;</operator><name>winfnoid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>perfuncstate</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>,
					  <argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fmgr_info_set_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>wfunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>perfuncstate</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>perfuncstate</name><operator>-&gt;</operator><name>winCollation</name></name> <operator>=</operator> <name><name>wfunc</name><operator>-&gt;</operator><name>inputcollid</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>get_typlenbyval</name><argument_list>(<argument><expr><name><name>wfunc</name><operator>-&gt;</operator><name>wintype</name></name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name><name>perfuncstate</name><operator>-&gt;</operator><name>resulttypeLen</name></name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name><name>perfuncstate</name><operator>-&gt;</operator><name>resulttypeByVal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If it's really just a plain aggregate function, we'll emulate the
		 * Agg environment for it.
		 */</comment>
		<expr_stmt><expr><name><name>perfuncstate</name><operator>-&gt;</operator><name>plain_agg</name></name> <operator>=</operator> <name><name>wfunc</name><operator>-&gt;</operator><name>winagg</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>wfunc</name><operator>-&gt;</operator><name>winagg</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>WindowStatePerAgg</name></type> <name>peraggstate</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>perfuncstate</name><operator>-&gt;</operator><name>aggno</name></name> <operator>=</operator> <operator>++</operator><name>aggno</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>peraggstate</name> <operator>=</operator> <operator>&amp;</operator><name><name>winstate</name><operator>-&gt;</operator><name>peragg</name><index>[<expr><name>aggno</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>initialize_peragg</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>, <argument><expr><name>wfunc</name></expr></argument>, <argument><expr><name>peraggstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>wfuncno</name></name> <operator>=</operator> <name>wfuncno</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>WindowObject</name></type> <name>winobj</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>WindowObjectData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>winobj</name><operator>-&gt;</operator><name>winstate</name></name> <operator>=</operator> <name>winstate</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>winobj</name><operator>-&gt;</operator><name>argstates</name></name> <operator>=</operator> <name><name>wfuncstate</name><operator>-&gt;</operator><name>args</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>winobj</name><operator>-&gt;</operator><name>localmem</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>perfuncstate</name><operator>-&gt;</operator><name>winobj</name></name> <operator>=</operator> <name>winobj</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Update numfuncs, numaggs to match number of unique functions found */</comment>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>numfuncs</name></name> <operator>=</operator> <name>wfuncno</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>numaggs</name></name> <operator>=</operator> <name>aggno</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* Set up WindowObject for aggregates, if needed */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>numaggs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WindowObject</name></type> <name>agg_winobj</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>WindowObjectData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>agg_winobj</name><operator>-&gt;</operator><name>winstate</name></name> <operator>=</operator> <name>winstate</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>agg_winobj</name><operator>-&gt;</operator><name>argstates</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>agg_winobj</name><operator>-&gt;</operator><name>localmem</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<comment type="block">/* make sure markptr = -1 to invalidate. It may not get used */</comment>
		<expr_stmt><expr><name><name>agg_winobj</name><operator>-&gt;</operator><name>markptr</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>agg_winobj</name><operator>-&gt;</operator><name>readptr</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>agg_winobj</name></name> <operator>=</operator> <name>agg_winobj</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* copy frame options to state node for easy access */</comment>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>=</operator> <name>frameOptions</name></expr>;</expr_stmt>

	<comment type="block">/* initialize frame bound offset expressions */</comment>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>startOffset</name></name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>startOffset</name></name></expr></argument>,
										 <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>winstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>endOffset</name></name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>endOffset</name></name></expr></argument>,
									   <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>winstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Lookup in_range support functions if needed */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>startInRangeFunc</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>startInRangeFunc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>winstate</name><operator>-&gt;</operator><name>startInRangeFunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>endInRangeFunc</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>endInRangeFunc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>winstate</name><operator>-&gt;</operator><name>endInRangeFunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>inRangeColl</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>inRangeColl</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>inRangeAsc</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>inRangeAsc</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>inRangeNullsFirst</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>inRangeNullsFirst</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>all_first</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>partition_spooled</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>more_partitions</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<return>return <expr><name>winstate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -----------------
 * ExecEndWindowAgg
 * -----------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecEndWindowAgg</name><parameter_list>(<parameter><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>outerPlan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>release_partition</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>first_part_slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>agg_row_slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>temp_slot_1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>temp_slot_2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>framehead_slot</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>framehead_slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>frametail_slot</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>frametail_slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Free both the expr contexts.
	 */</comment>
	<expr_stmt><expr><call><name>ExecFreeExprContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>tmpcontext</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecFreeExprContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numaggs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>peragg</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>aggcontext</name> <operator>!=</operator> <name><name>node</name><operator>-&gt;</operator><name>aggcontext</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>peragg</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>aggcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>partcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>aggcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>perfunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>peragg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>outerPlan</name> <operator>=</operator> <call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><name>outerPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* -----------------
 * ExecReScanWindowAgg
 * -----------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecReScanWindowAgg</name><parameter_list>(<parameter><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>outerPlan</name> <init>= <expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>all_done</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>all_first</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* release tuplestore et al */</comment>
	<expr_stmt><expr><call><name>release_partition</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* release all temp tuples, but especially first_part_slot */</comment>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>first_part_slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>agg_row_slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>temp_slot_1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>temp_slot_2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>framehead_slot</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>framehead_slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>frametail_slot</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>frametail_slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Forget current wfunc values */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_aggvalues</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>node</name><operator>-&gt;</operator><name>numfuncs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_aggnulls</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>node</name><operator>-&gt;</operator><name>numfuncs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * if chgParam of subnode is not null then plan will be re-scanned by
	 * first ExecProcNode.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>outerPlan</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecReScan</name><argument_list>(<argument><expr><name>outerPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * initialize_peragg
 *
 * Almost same as in nodeAgg.c, except we don't support DISTINCT currently.
 */</comment>
<function><type><specifier>static</specifier> <name>WindowStatePerAggData</name> <modifier>*</modifier></type>
<name>initialize_peragg</name><parameter_list>(<parameter><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>winstate</name></decl></parameter>, <parameter><decl><type><name>WindowFunc</name> <modifier>*</modifier></type><name>wfunc</name></decl></parameter>,
				  <parameter><decl><type><name>WindowStatePerAgg</name></type> <name>peraggstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>inputTypes</name><index>[<expr><name>FUNC_MAX_ARGS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numArguments</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>aggTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_aggregate</name></type> <name>aggform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>aggtranstype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>initvalAttNo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>use_ma_code</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>transfn_oid</name></decl>,
				<decl><type ref="prev"/><name>invtransfn_oid</name></decl>,
				<decl><type ref="prev"/><name>finalfn_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>finalextra</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>finalmodify</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>transfnexpr</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>invtransfnexpr</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>finalfnexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>textInitVal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>numArguments</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>wfunc</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>wfunc-&gt;args</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name><name>inputTypes</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>aggTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AGGFNOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>wfunc</name><operator>-&gt;</operator><name>winfnoid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>aggTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for aggregate %u"</literal></expr></argument>,
			 <argument><expr><name><name>wfunc</name><operator>-&gt;</operator><name>winfnoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>aggform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_aggregate</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>aggTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Figure out whether we want to use the moving-aggregate implementation,
	 * and collect the right set of fields from the pg_attribute entry.
	 *
	 * It's possible that an aggregate would supply a safe moving-aggregate
	 * implementation and an unsafe normal one, in which case our hand is
	 * forced.  Otherwise, if the frame head can't move, we don't need
	 * moving-aggregate code.  Even if we'd like to use it, don't do so if the
	 * aggregate's arguments (and FILTER clause if any) contain any calls to
	 * volatile functions.  Otherwise, the difference between restarting and
	 * not restarting the aggregation would be user-visible.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>aggform</name><operator>-&gt;</operator><name>aggminvtransfn</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>use_ma_code</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* sine qua non */</comment>
	<if type="elseif">else if <condition>(<expr><name><name>aggform</name><operator>-&gt;</operator><name>aggmfinalmodify</name></name> <operator>==</operator> <name>AGGMODIFY_READ_ONLY</name> <operator>&amp;&amp;</operator>
			 <name><name>aggform</name><operator>-&gt;</operator><name>aggfinalmodify</name></name> <operator>!=</operator> <name>AGGMODIFY_READ_ONLY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>use_ma_code</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>		<comment type="block">/* decision forced by safety */</comment>
	<if type="elseif">else if <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_START_UNBOUNDED_PRECEDING</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>use_ma_code</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* non-moving frame head */</comment>
	<if type="elseif">else if <condition>(<expr><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>wfunc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>use_ma_code</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* avoid possible behavioral change */</comment>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>use_ma_code</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>		<comment type="block">/* yes, let's use it */</comment>
	<if_stmt><if>if <condition>(<expr><name>use_ma_code</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transfn_oid</name></name> <operator>=</operator> <name>transfn_oid</name> <operator>=</operator> <name><name>aggform</name><operator>-&gt;</operator><name>aggmtransfn</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>invtransfn_oid</name></name> <operator>=</operator> <name>invtransfn_oid</name> <operator>=</operator> <name><name>aggform</name><operator>-&gt;</operator><name>aggminvtransfn</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>finalfn_oid</name></name> <operator>=</operator> <name>finalfn_oid</name> <operator>=</operator> <name><name>aggform</name><operator>-&gt;</operator><name>aggmfinalfn</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>finalextra</name> <operator>=</operator> <name><name>aggform</name><operator>-&gt;</operator><name>aggmfinalextra</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>finalmodify</name> <operator>=</operator> <name><name>aggform</name><operator>-&gt;</operator><name>aggmfinalmodify</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>aggtranstype</name> <operator>=</operator> <name><name>aggform</name><operator>-&gt;</operator><name>aggmtranstype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>initvalAttNo</name> <operator>=</operator> <name>Anum_pg_aggregate_aggminitval</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transfn_oid</name></name> <operator>=</operator> <name>transfn_oid</name> <operator>=</operator> <name><name>aggform</name><operator>-&gt;</operator><name>aggtransfn</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>invtransfn_oid</name></name> <operator>=</operator> <name>invtransfn_oid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>finalfn_oid</name></name> <operator>=</operator> <name>finalfn_oid</name> <operator>=</operator> <name><name>aggform</name><operator>-&gt;</operator><name>aggfinalfn</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>finalextra</name> <operator>=</operator> <name><name>aggform</name><operator>-&gt;</operator><name>aggfinalextra</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>finalmodify</name> <operator>=</operator> <name><name>aggform</name><operator>-&gt;</operator><name>aggfinalmodify</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>aggtranstype</name> <operator>=</operator> <name><name>aggform</name><operator>-&gt;</operator><name>aggtranstype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>initvalAttNo</name> <operator>=</operator> <name>Anum_pg_aggregate_agginitval</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * ExecInitWindowAgg already checked permission to call aggregate function
	 * ... but we still need to check the component functions
	 */</comment>

	<comment type="block">/* Check that aggregate owner has permission to call component fns */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>procTuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>aggOwner</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>procTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>,
									<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>wfunc</name><operator>-&gt;</operator><name>winfnoid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>procTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>,
				 <argument><expr><name><name>wfunc</name><operator>-&gt;</operator><name>winfnoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>aggOwner</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>procTuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>proowner</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>procTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_proc_aclcheck</name><argument_list>(<argument><expr><name>transfn_oid</name></expr></argument>, <argument><expr><name>aggOwner</name></expr></argument>,
									 <argument><expr><name>ACL_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_FUNCTION</name></expr></argument>,
						   <argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name>transfn_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>InvokeFunctionExecuteHook</name><argument_list>(<argument><expr><name>transfn_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>invtransfn_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_proc_aclcheck</name><argument_list>(<argument><expr><name>invtransfn_oid</name></expr></argument>, <argument><expr><name>aggOwner</name></expr></argument>,
										 <argument><expr><name>ACL_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_FUNCTION</name></expr></argument>,
							   <argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name>invtransfn_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>InvokeFunctionExecuteHook</name><argument_list>(<argument><expr><name>invtransfn_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>finalfn_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_proc_aclcheck</name><argument_list>(<argument><expr><name>finalfn_oid</name></expr></argument>, <argument><expr><name>aggOwner</name></expr></argument>,
										 <argument><expr><name>ACL_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_FUNCTION</name></expr></argument>,
							   <argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name>finalfn_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>InvokeFunctionExecuteHook</name><argument_list>(<argument><expr><name>finalfn_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If the selected finalfn isn't read-only, we can't run this aggregate as
	 * a window function.  This is a user-facing error, so we take a bit more
	 * care with the error message than elsewhere in this function.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>finalmodify</name> <operator>!=</operator> <name>AGGMODIFY_READ_ONLY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aggregate function %s does not support use as a window function"</literal></expr></argument>,
						<argument><expr><call><name>format_procedure</name><argument_list>(<argument><expr><name><name>wfunc</name><operator>-&gt;</operator><name>winfnoid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Detect how many arguments to pass to the finalfn */</comment>
	<if_stmt><if>if <condition>(<expr><name>finalextra</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>numFinalArgs</name></name> <operator>=</operator> <name>numArguments</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>numFinalArgs</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* resolve actual type of transition state, if polymorphic */</comment>
	<expr_stmt><expr><name>aggtranstype</name> <operator>=</operator> <call><name>resolve_aggregate_transtype</name><argument_list>(<argument><expr><name><name>wfunc</name><operator>-&gt;</operator><name>winfnoid</name></name></expr></argument>,
											   <argument><expr><name>aggtranstype</name></expr></argument>,
											   <argument><expr><name>inputTypes</name></expr></argument>,
											   <argument><expr><name>numArguments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* build expression trees using actual argument &amp; result types */</comment>
	<expr_stmt><expr><call><name>build_aggregate_transfn_expr</name><argument_list>(<argument><expr><name>inputTypes</name></expr></argument>,
								 <argument><expr><name>numArguments</name></expr></argument>,
								 <argument><expr><literal type="number">0</literal></expr></argument>, <comment type="block">/* no ordered-set window functions yet */</comment>
								 <argument><expr><name>false</name></expr></argument>, <comment type="block">/* no variadic window functions yet */</comment>
								 <argument><expr><name>aggtranstype</name></expr></argument>,
								 <argument><expr><name><name>wfunc</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>,
								 <argument><expr><name>transfn_oid</name></expr></argument>,
								 <argument><expr><name>invtransfn_oid</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>transfnexpr</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>invtransfnexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set up infrastructure for calling the transfn(s) and finalfn */</comment>
	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>transfn_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>peraggstate</name><operator>-&gt;</operator><name>transfn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fmgr_info_set_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>transfnexpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>peraggstate</name><operator>-&gt;</operator><name>transfn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>invtransfn_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>invtransfn_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>peraggstate</name><operator>-&gt;</operator><name>invtransfn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fmgr_info_set_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>invtransfnexpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>peraggstate</name><operator>-&gt;</operator><name>invtransfn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>finalfn_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>build_aggregate_finalfn_expr</name><argument_list>(<argument><expr><name>inputTypes</name></expr></argument>,
									 <argument><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>numFinalArgs</name></name></expr></argument>,
									 <argument><expr><name>aggtranstype</name></expr></argument>,
									 <argument><expr><name><name>wfunc</name><operator>-&gt;</operator><name>wintype</name></name></expr></argument>,
									 <argument><expr><name><name>wfunc</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>,
									 <argument><expr><name>finalfn_oid</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>finalfnexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>finalfn_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>peraggstate</name><operator>-&gt;</operator><name>finalfn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fmgr_info_set_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>finalfnexpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>peraggstate</name><operator>-&gt;</operator><name>finalfn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* get info about relevant datatypes */</comment>
	<expr_stmt><expr><call><name>get_typlenbyval</name><argument_list>(<argument><expr><name><name>wfunc</name><operator>-&gt;</operator><name>wintype</name></name></expr></argument>,
					<argument><expr><operator>&amp;</operator><name><name>peraggstate</name><operator>-&gt;</operator><name>resulttypeLen</name></name></expr></argument>,
					<argument><expr><operator>&amp;</operator><name><name>peraggstate</name><operator>-&gt;</operator><name>resulttypeByVal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>get_typlenbyval</name><argument_list>(<argument><expr><name>aggtranstype</name></expr></argument>,
					<argument><expr><operator>&amp;</operator><name><name>peraggstate</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>,
					<argument><expr><operator>&amp;</operator><name><name>peraggstate</name><operator>-&gt;</operator><name>transtypeByVal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * initval is potentially null, so don't try to access it as a struct
	 * field. Must do it the hard way with SysCacheGetAttr.
	 */</comment>
	<expr_stmt><expr><name>textInitVal</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>AGGFNOID</name></expr></argument>, <argument><expr><name>aggTuple</name></expr></argument>, <argument><expr><name>initvalAttNo</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name><name>peraggstate</name><operator>-&gt;</operator><name>initValueIsNull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>peraggstate</name><operator>-&gt;</operator><name>initValueIsNull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>initValue</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>initValue</name></name> <operator>=</operator> <call><name>GetAggInitVal</name><argument_list>(<argument><expr><name>textInitVal</name></expr></argument>,
											   <argument><expr><name>aggtranstype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * If the transfn is strict and the initval is NULL, make sure input type
	 * and transtype are the same (or at least binary-compatible), so that
	 * it's OK to use the first input value as the initial transValue.  This
	 * should have been checked at agg definition time, but we must check
	 * again in case the transfn's strictness property has been changed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>peraggstate</name><operator>-&gt;</operator><name>transfn</name><operator>.</operator><name>fn_strict</name></name> <operator>&amp;&amp;</operator> <name><name>peraggstate</name><operator>-&gt;</operator><name>initValueIsNull</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>numArguments</name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator>
			<operator>!</operator><call><name>IsBinaryCoercible</name><argument_list>(<argument><expr><name><name>inputTypes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>aggtranstype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aggregate %u needs to have compatible input type and transition type"</literal></expr></argument>,
							<argument><expr><name><name>wfunc</name><operator>-&gt;</operator><name>winfnoid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Insist that forward and inverse transition functions have the same
	 * strictness setting.  Allowing them to differ would require handling
	 * more special cases in advance_windowaggregate and
	 * advance_windowaggregate_base, for no discernible benefit.  This should
	 * have been checked at agg definition time, but we must check again in
	 * case either function's strictness property has been changed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>invtransfn_oid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name><name>peraggstate</name><operator>-&gt;</operator><name>transfn</name><operator>.</operator><name>fn_strict</name></name> <operator>!=</operator> <name><name>peraggstate</name><operator>-&gt;</operator><name>invtransfn</name><operator>.</operator><name>fn_strict</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"strictness of aggregate's forward and inverse transition functions must match"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Moving aggregates use their own aggcontext.
	 *
	 * This is necessary because they might restart at different times, so we
	 * might never be able to reset the shared context otherwise.  We can't
	 * make it the aggregates' responsibility to clean up after themselves,
	 * because strict aggregates must be restarted whenever we remove their
	 * last non-NULL input, which the aggregate won't be aware is happening.
	 * Also, just pfree()ing the transValue upon restarting wouldn't help,
	 * since we'd miss any indirectly referenced data.  We could, in theory,
	 * make the memory allocation rules for moving aggregates different than
	 * they have historically been for plain aggregates, but that seems grotty
	 * and likely to lead to memory leaks.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>invtransfn_oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>aggcontext</name></name> <operator>=</operator>
			<call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
								  <argument><expr><literal type="string">"WindowAgg Per Aggregate"</literal></expr></argument>,
								  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>peraggstate</name><operator>-&gt;</operator><name>aggcontext</name></name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>aggcontext</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>aggTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>peraggstate</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>GetAggInitVal</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>textInitVal</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>transtype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typinput</name></decl>,
				<decl><type ref="prev"/><name>typioparam</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>strInitVal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>initVal</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>getTypeInputInfo</name><argument_list>(<argument><expr><name>transtype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typinput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typioparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>strInitVal</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>textInitVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>initVal</name> <operator>=</operator> <call><name>OidInputFunctionCall</name><argument_list>(<argument><expr><name>typinput</name></expr></argument>, <argument><expr><name>strInitVal</name></expr></argument>,
								   <argument><expr><name>typioparam</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>strInitVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>initVal</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * are_peers
 * compare two rows to see if they are equal according to the ORDER BY clause
 *
 * NB: this does not consider the window frame mode.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>are_peers</name><parameter_list>(<parameter><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>winstate</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot1</name></decl></parameter>,
		  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WindowAgg</name>  <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>WindowAgg</name> <operator>*</operator><operator>)</operator> <name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>winstate</name><operator>-&gt;</operator><name>tmpcontext</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* If no ORDER BY, all rows are peers with each other */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ordNumCols</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>slot1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_innertuple</name></name> <operator>=</operator> <name>slot2</name></expr>;</expr_stmt>
	<return>return <expr><call><name>ExecQualAndReset</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>ordEqfunction</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * window_gettupleslot
 *	Fetch the pos'th tuple of the current partition into the slot,
 *	using the winobj's read pointer
 *
 * Returns true if successful, false if no such row
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>window_gettupleslot</name><parameter_list>(<parameter><decl><type><name>WindowObject</name></type> <name>winobj</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>winstate</name> <init>= <expr><name><name>winobj</name><operator>-&gt;</operator><name>winstate</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/* often called repeatedly in a row */</comment>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Don't allow passing -1 to spool_tuples here */</comment>
	<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If necessary, fetch the tuple into the spool */</comment>
	<expr_stmt><expr><call><name>spool_tuples</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>spooled_rows</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name><name>winobj</name><operator>-&gt;</operator><name>markpos</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot fetch row before WindowObject's mark position"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>tuplestore_select_read_pointer</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name><name>winobj</name><operator>-&gt;</operator><name>readptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Advance or rewind until we are within one tuple of the one we want.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>winobj</name><operator>-&gt;</operator><name>seekpos</name></name> <operator>&lt;</operator> <name>pos</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplestore_skiptuples</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>,
								   <argument><expr><name>pos</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name><name>winobj</name><operator>-&gt;</operator><name>seekpos</name></name></expr></argument>,
								   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected end of tuplestore"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>winobj</name><operator>-&gt;</operator><name>seekpos</name></name> <operator>=</operator> <name>pos</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>winobj</name><operator>-&gt;</operator><name>seekpos</name></name> <operator>&gt;</operator> <name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplestore_skiptuples</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>,
								   <argument><expr><name><name>winobj</name><operator>-&gt;</operator><name>seekpos</name></name> <operator>-</operator> <operator>(</operator><name>pos</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>,
								   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected end of tuplestore"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>winobj</name><operator>-&gt;</operator><name>seekpos</name></name> <operator>=</operator> <name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>winobj</name><operator>-&gt;</operator><name>seekpos</name></name> <operator>==</operator> <name>pos</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * There's no API to refetch the tuple at the current position.  We
		 * have to move one tuple forward, and then one backward.  (We don't
		 * do it the other way because we might try to fetch the row before
		 * our mark, which isn't allowed.)  XXX this case could stand to be
		 * optimized.
		 */</comment>
		<expr_stmt><expr><call><name>tuplestore_advance</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>winobj</name><operator>-&gt;</operator><name>seekpos</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now we should be on the tuple immediately before or after the one we
	 * want, so just fetch forwards or backwards as appropriate.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>winobj</name><operator>-&gt;</operator><name>seekpos</name></name> <operator>&gt;</operator> <name>pos</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected end of tuplestore"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>winobj</name><operator>-&gt;</operator><name>seekpos</name></name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected end of tuplestore"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>winobj</name><operator>-&gt;</operator><name>seekpos</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>winobj</name><operator>-&gt;</operator><name>seekpos</name></name> <operator>==</operator> <name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/***********************************************************************
 * API exposed to window functions
 ***********************************************************************/</comment>


<comment type="block">/*
 * WinGetPartitionLocalMemory
 *		Get working memory that lives till end of partition processing
 *
 * On first call within a given partition, this allocates and zeroes the
 * requested amount of space.  Subsequent calls just return the same chunk.
 *
 * Memory obtained this way is normally used to hold state that should be
 * automatically reset for each new partition.  If a window function wants
 * to hold state across the whole query, fcinfo-&gt;fn_extra can be used in the
 * usual way for that.
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>WinGetPartitionLocalMemory</name><parameter_list>(<parameter><decl><type><name>WindowObject</name></type> <name>winobj</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>sz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>WindowObjectIsValid</name><argument_list>(<argument><expr><name>winobj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>winobj</name><operator>-&gt;</operator><name>localmem</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>winobj</name><operator>-&gt;</operator><name>localmem</name></name> <operator>=</operator>
			<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name><name>winobj</name><operator>-&gt;</operator><name>winstate</name><operator>-&gt;</operator><name>partcontext</name></name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name><name>winobj</name><operator>-&gt;</operator><name>localmem</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * WinGetCurrentPosition
 *		Return the current row's position (counting from 0) within the current
 *		partition.
 */</comment>
<function><type><name>int64</name></type>
<name>WinGetCurrentPosition</name><parameter_list>(<parameter><decl><type><name>WindowObject</name></type> <name>winobj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>WindowObjectIsValid</name><argument_list>(<argument><expr><name>winobj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>winobj</name><operator>-&gt;</operator><name>winstate</name><operator>-&gt;</operator><name>currentpos</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * WinGetPartitionRowCount
 *		Return total number of rows contained in the current partition.
 *
 * Note: this is a relatively expensive operation because it forces the
 * whole partition to be "spooled" into the tuplestore at once.  Once
 * executed, however, additional calls within the same partition are cheap.
 */</comment>
<function><type><name>int64</name></type>
<name>WinGetPartitionRowCount</name><parameter_list>(<parameter><decl><type><name>WindowObject</name></type> <name>winobj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>WindowObjectIsValid</name><argument_list>(<argument><expr><name>winobj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>spool_tuples</name><argument_list>(<argument><expr><name><name>winobj</name><operator>-&gt;</operator><name>winstate</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>winobj</name><operator>-&gt;</operator><name>winstate</name><operator>-&gt;</operator><name>spooled_rows</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * WinSetMarkPosition
 *		Set the "mark" position for the window object, which is the oldest row
 *		number (counting from 0) it is allowed to fetch during all subsequent
 *		operations within the current partition.
 *
 * Window functions do not have to call this, but are encouraged to move the
 * mark forward when possible to keep the tuplestore size down and prevent
 * having to spill rows to disk.
 */</comment>
<function><type><name>void</name></type>
<name>WinSetMarkPosition</name><parameter_list>(<parameter><decl><type><name>WindowObject</name></type> <name>winobj</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>markpos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>winstate</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>WindowObjectIsValid</name><argument_list>(<argument><expr><name>winobj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>winstate</name> <operator>=</operator> <name><name>winobj</name><operator>-&gt;</operator><name>winstate</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>markpos</name> <operator>&lt;</operator> <name><name>winobj</name><operator>-&gt;</operator><name>markpos</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot move WindowObject's mark position backward"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>tuplestore_select_read_pointer</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name><name>winobj</name><operator>-&gt;</operator><name>markptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>markpos</name> <operator>&gt;</operator> <name><name>winobj</name><operator>-&gt;</operator><name>markpos</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>tuplestore_skiptuples</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>,
							  <argument><expr><name>markpos</name> <operator>-</operator> <name><name>winobj</name><operator>-&gt;</operator><name>markpos</name></name></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>winobj</name><operator>-&gt;</operator><name>markpos</name></name> <operator>=</operator> <name>markpos</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>tuplestore_select_read_pointer</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name><name>winobj</name><operator>-&gt;</operator><name>readptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>markpos</name> <operator>&gt;</operator> <name><name>winobj</name><operator>-&gt;</operator><name>seekpos</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>tuplestore_skiptuples</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>,
							  <argument><expr><name>markpos</name> <operator>-</operator> <name><name>winobj</name><operator>-&gt;</operator><name>seekpos</name></name></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>winobj</name><operator>-&gt;</operator><name>seekpos</name></name> <operator>=</operator> <name>markpos</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * WinRowsArePeers
 *		Compare two rows (specified by absolute position in partition) to see
 *		if they are equal according to the ORDER BY clause.
 *
 * NB: this does not consider the window frame mode.
 */</comment>
<function><type><name>bool</name></type>
<name>WinRowsArePeers</name><parameter_list>(<parameter><decl><type><name>WindowObject</name></type> <name>winobj</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>pos1</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>pos2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>winstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WindowAgg</name>  <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>WindowObjectIsValid</name><argument_list>(<argument><expr><name>winobj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>winstate</name> <operator>=</operator> <name><name>winobj</name><operator>-&gt;</operator><name>winstate</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>node</name> <operator>=</operator> <operator>(</operator><name>WindowAgg</name> <operator>*</operator><operator>)</operator> <name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr>;</expr_stmt>

	<comment type="block">/* If no ORDER BY, all rows are peers; don't bother to fetch them */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ordNumCols</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Note: OK to use temp_slot_2 here because we aren't calling any
	 * frame-related functions (those tend to clobber temp_slot_2).
	 */</comment>
	<expr_stmt><expr><name>slot1</name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>temp_slot_1</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>slot2</name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>temp_slot_2</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>window_gettupleslot</name><argument_list>(<argument><expr><name>winobj</name></expr></argument>, <argument><expr><name>pos1</name></expr></argument>, <argument><expr><name>slot1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"specified position is out of window: "</literal> <name>INT64_FORMAT</name></expr></argument>,
			 <argument><expr><name>pos1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>window_gettupleslot</name><argument_list>(<argument><expr><name>winobj</name></expr></argument>, <argument><expr><name>pos2</name></expr></argument>, <argument><expr><name>slot2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"specified position is out of window: "</literal> <name>INT64_FORMAT</name></expr></argument>,
			 <argument><expr><name>pos2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>are_peers</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>, <argument><expr><name>slot1</name></expr></argument>, <argument><expr><name>slot2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * WinGetFuncArgInPartition
 *		Evaluate a window function's argument expression on a specified
 *		row of the partition.  The row is identified in lseek(2) style,
 *		i.e. relative to the current, first, or last row.
 *
 * argno: argument number to evaluate (counted from 0)
 * relpos: signed rowcount offset from the seek position
 * seektype: WINDOW_SEEK_CURRENT, WINDOW_SEEK_HEAD, or WINDOW_SEEK_TAIL
 * set_mark: If the row is found and set_mark is true, the mark is moved to
 *		the row as a side-effect.
 * isnull: output argument, receives isnull status of result
 * isout: output argument, set to indicate whether target row position
 *		is out of partition (can pass NULL if caller doesn't care about this)
 *
 * Specifying a nonexistent row is not an error, it just causes a null result
 * (plus setting *isout true, if isout isn't NULL).
 */</comment>
<function><type><name>Datum</name></type>
<name>WinGetFuncArgInPartition</name><parameter_list>(<parameter><decl><type><name>WindowObject</name></type> <name>winobj</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argno</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>relpos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>seektype</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>set_mark</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>winstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>gottuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>abs_pos</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>WindowObjectIsValid</name><argument_list>(<argument><expr><name>winobj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>winstate</name> <operator>=</operator> <name><name>winobj</name><operator>-&gt;</operator><name>winstate</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>temp_slot_1</name></name></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>seektype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>WINDOW_SEEK_CURRENT</name></expr>:</case>
			<expr_stmt><expr><name>abs_pos</name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>currentpos</name></name> <operator>+</operator> <name>relpos</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>WINDOW_SEEK_HEAD</name></expr>:</case>
			<expr_stmt><expr><name>abs_pos</name> <operator>=</operator> <name>relpos</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>WINDOW_SEEK_TAIL</name></expr>:</case>
			<expr_stmt><expr><call><name>spool_tuples</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>abs_pos</name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>spooled_rows</name></name> <operator>-</operator> <literal type="number">1</literal> <operator>+</operator> <name>relpos</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized window seek type: %d"</literal></expr></argument>, <argument><expr><name>seektype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>abs_pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>		<comment type="block">/* keep compiler quiet */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><name>gottuple</name> <operator>=</operator> <call><name>window_gettupleslot</name><argument_list>(<argument><expr><name>winobj</name></expr></argument>, <argument><expr><name>abs_pos</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gottuple</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>isout</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>isout</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>isout</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>isout</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>set_mark</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>WinSetMarkPosition</name><argument_list>(<argument><expr><name>winobj</name></expr></argument>, <argument><expr><name>abs_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
		<return>return <expr><call><name>ExecEvalExpr</name><argument_list>(<argument><expr><operator>(</operator><name>ExprState</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>winobj</name><operator>-&gt;</operator><name>argstates</name></name></expr></argument>, <argument><expr><name>argno</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>econtext</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * WinGetFuncArgInFrame
 *		Evaluate a window function's argument expression on a specified
 *		row of the window frame.  The row is identified in lseek(2) style,
 *		i.e. relative to the first or last row of the frame.  (We do not
 *		support WINDOW_SEEK_CURRENT here, because it's not very clear what
 *		that should mean if the current row isn't part of the frame.)
 *
 * argno: argument number to evaluate (counted from 0)
 * relpos: signed rowcount offset from the seek position
 * seektype: WINDOW_SEEK_HEAD or WINDOW_SEEK_TAIL
 * set_mark: If the row is found/in frame and set_mark is true, the mark is
 *		moved to the row as a side-effect.
 * isnull: output argument, receives isnull status of result
 * isout: output argument, set to indicate whether target row position
 *		is out of frame (can pass NULL if caller doesn't care about this)
 *
 * Specifying a nonexistent or not-in-frame row is not an error, it just
 * causes a null result (plus setting *isout true, if isout isn't NULL).
 *
 * Note that some exclusion-clause options lead to situations where the
 * rows that are in-frame are not consecutive in the partition.  But we
 * count only in-frame rows when measuring relpos.
 *
 * The set_mark flag is interpreted as meaning that the caller will specify
 * a constant (or, perhaps, monotonically increasing) relpos in successive
 * calls, so that *if there is no exclusion clause* there will be no need
 * to fetch a row before the previously fetched row.  But we do not expect
 * the caller to know how to account for exclusion clauses.  Therefore,
 * if there is an exclusion clause we take responsibility for adjusting the
 * mark request to something that will be safe given the above assumption
 * about relpos.
 */</comment>
<function><type><name>Datum</name></type>
<name>WinGetFuncArgInFrame</name><parameter_list>(<parameter><decl><type><name>WindowObject</name></type> <name>winobj</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argno</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>relpos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>seektype</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>set_mark</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>winstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>abs_pos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>mark_pos</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>WindowObjectIsValid</name><argument_list>(<argument><expr><name>winobj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>winstate</name> <operator>=</operator> <name><name>winobj</name><operator>-&gt;</operator><name>winstate</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>temp_slot_1</name></name></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>seektype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>WINDOW_SEEK_CURRENT</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"WINDOW_SEEK_CURRENT is not supported for WinGetFuncArgInFrame"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>abs_pos</name> <operator>=</operator> <name>mark_pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* keep compiler quiet */</comment>
			<break>break;</break>
		<case>case <expr><name>WINDOW_SEEK_HEAD</name></expr>:</case>
			<comment type="block">/* rejecting relpos &lt; 0 is easy and simplifies code below */</comment>
			<if_stmt><if>if <condition>(<expr><name>relpos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>out_of_frame</name>;</goto></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>update_frameheadpos</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>abs_pos</name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>frameheadpos</name></name> <operator>+</operator> <name>relpos</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>mark_pos</name> <operator>=</operator> <name>abs_pos</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Account for exclusion option if one is active, but advance only
			 * abs_pos not mark_pos.  This prevents changes of the current
			 * row's peer group from resulting in trying to fetch a row before
			 * some previous mark position.
			 *
			 * Note that in some corner cases such as current row being
			 * outside frame, these calculations are theoretically too simple,
			 * but it doesn't matter because we'll end up deciding the row is
			 * out of frame.  We do not attempt to avoid fetching rows past
			 * end of frame; that would happen in some cases anyway.
			 */</comment>
			<switch>switch <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_EXCLUSION</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><literal type="number">0</literal></expr>:</case>
					<comment type="block">/* no adjustment needed */</comment>
					<break>break;</break>
				<case>case <expr><name>FRAMEOPTION_EXCLUDE_CURRENT_ROW</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name>abs_pos</name> <operator>&gt;=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>currentpos</name></name> <operator>&amp;&amp;</operator>
						<name><name>winstate</name><operator>-&gt;</operator><name>currentpos</name></name> <operator>&gt;=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>frameheadpos</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>abs_pos</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				<case>case <expr><name>FRAMEOPTION_EXCLUDE_GROUP</name></expr>:</case>
					<expr_stmt><expr><call><name>update_grouptailpos</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>abs_pos</name> <operator>&gt;=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>groupheadpos</name></name> <operator>&amp;&amp;</operator>
						<name><name>winstate</name><operator>-&gt;</operator><name>grouptailpos</name></name> <operator>&gt;</operator> <name><name>winstate</name><operator>-&gt;</operator><name>frameheadpos</name></name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>int64</name></type>		<name>overlapstart</name> <init>= <expr><call><name>Max</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>groupheadpos</name></name></expr></argument>,
													   <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>frameheadpos</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><name>abs_pos</name> <operator>+=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>grouptailpos</name></name> <operator>-</operator> <name>overlapstart</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<break>break;</break>
				<case>case <expr><name>FRAMEOPTION_EXCLUDE_TIES</name></expr>:</case>
					<expr_stmt><expr><call><name>update_grouptailpos</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>abs_pos</name> <operator>&gt;=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>groupheadpos</name></name> <operator>&amp;&amp;</operator>
						<name><name>winstate</name><operator>-&gt;</operator><name>grouptailpos</name></name> <operator>&gt;</operator> <name><name>winstate</name><operator>-&gt;</operator><name>frameheadpos</name></name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>int64</name></type>		<name>overlapstart</name> <init>= <expr><call><name>Max</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>groupheadpos</name></name></expr></argument>,
													   <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>frameheadpos</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><name>abs_pos</name> <operator>==</operator> <name>overlapstart</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>abs_pos</name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>currentpos</name></name></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><name>abs_pos</name> <operator>+=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>grouptailpos</name></name> <operator>-</operator> <name>overlapstart</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
					</block_content>}</block></if></if_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized frame option state: 0x%x"</literal></expr></argument>,
						 <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>frameOptions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
			<break>break;</break>
		<case>case <expr><name>WINDOW_SEEK_TAIL</name></expr>:</case>
			<comment type="block">/* rejecting relpos &gt; 0 is easy and simplifies code below */</comment>
			<if_stmt><if>if <condition>(<expr><name>relpos</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>out_of_frame</name>;</goto></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>update_frametailpos</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>abs_pos</name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>frametailpos</name></name> <operator>-</operator> <literal type="number">1</literal> <operator>+</operator> <name>relpos</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Account for exclusion option if one is active.  If there is no
			 * exclusion, we can safely set the mark at the accessed row.  But
			 * if there is, we can only mark the frame start, because we can't
			 * be sure how far back in the frame the exclusion might cause us
			 * to fetch in future.  Furthermore, we have to actually check
			 * against frameheadpos here, since it's unsafe to try to fetch a
			 * row before frame start if the mark might be there already.
			 */</comment>
			<switch>switch <condition>(<expr><name><name>winstate</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_EXCLUSION</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><literal type="number">0</literal></expr>:</case>
					<comment type="block">/* no adjustment needed */</comment>
					<expr_stmt><expr><name>mark_pos</name> <operator>=</operator> <name>abs_pos</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>FRAMEOPTION_EXCLUDE_CURRENT_ROW</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name>abs_pos</name> <operator>&lt;=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>currentpos</name></name> <operator>&amp;&amp;</operator>
						<name><name>winstate</name><operator>-&gt;</operator><name>currentpos</name></name> <operator>&lt;</operator> <name><name>winstate</name><operator>-&gt;</operator><name>frametailpos</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>abs_pos</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>update_frameheadpos</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>abs_pos</name> <operator>&lt;</operator> <name><name>winstate</name><operator>-&gt;</operator><name>frameheadpos</name></name></expr>)</condition><block type="pseudo"><block_content>
						<goto>goto <name>out_of_frame</name>;</goto></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>mark_pos</name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>frameheadpos</name></name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>FRAMEOPTION_EXCLUDE_GROUP</name></expr>:</case>
					<expr_stmt><expr><call><name>update_grouptailpos</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>abs_pos</name> <operator>&lt;</operator> <name><name>winstate</name><operator>-&gt;</operator><name>grouptailpos</name></name> <operator>&amp;&amp;</operator>
						<name><name>winstate</name><operator>-&gt;</operator><name>groupheadpos</name></name> <operator>&lt;</operator> <name><name>winstate</name><operator>-&gt;</operator><name>frametailpos</name></name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>int64</name></type>		<name>overlapend</name> <init>= <expr><call><name>Min</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>grouptailpos</name></name></expr></argument>,
													 <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametailpos</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><name>abs_pos</name> <operator>-=</operator> <name>overlapend</name> <operator>-</operator> <name><name>winstate</name><operator>-&gt;</operator><name>groupheadpos</name></name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><call><name>update_frameheadpos</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>abs_pos</name> <operator>&lt;</operator> <name><name>winstate</name><operator>-&gt;</operator><name>frameheadpos</name></name></expr>)</condition><block type="pseudo"><block_content>
						<goto>goto <name>out_of_frame</name>;</goto></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>mark_pos</name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>frameheadpos</name></name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>FRAMEOPTION_EXCLUDE_TIES</name></expr>:</case>
					<expr_stmt><expr><call><name>update_grouptailpos</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>abs_pos</name> <operator>&lt;</operator> <name><name>winstate</name><operator>-&gt;</operator><name>grouptailpos</name></name> <operator>&amp;&amp;</operator>
						<name><name>winstate</name><operator>-&gt;</operator><name>groupheadpos</name></name> <operator>&lt;</operator> <name><name>winstate</name><operator>-&gt;</operator><name>frametailpos</name></name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>int64</name></type>		<name>overlapend</name> <init>= <expr><call><name>Min</name><argument_list>(<argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>grouptailpos</name></name></expr></argument>,
													 <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>frametailpos</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><name>abs_pos</name> <operator>==</operator> <name>overlapend</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>abs_pos</name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>currentpos</name></name></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><name>abs_pos</name> <operator>-=</operator> <name>overlapend</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name><name>winstate</name><operator>-&gt;</operator><name>groupheadpos</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><call><name>update_frameheadpos</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>abs_pos</name> <operator>&lt;</operator> <name><name>winstate</name><operator>-&gt;</operator><name>frameheadpos</name></name></expr>)</condition><block type="pseudo"><block_content>
						<goto>goto <name>out_of_frame</name>;</goto></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>mark_pos</name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>frameheadpos</name></name></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized frame option state: 0x%x"</literal></expr></argument>,
						 <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>frameOptions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>mark_pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
					<break>break;</break>
			</block_content>}</block></switch>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized window seek type: %d"</literal></expr></argument>, <argument><expr><name>seektype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>abs_pos</name> <operator>=</operator> <name>mark_pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* keep compiler quiet */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>window_gettupleslot</name><argument_list>(<argument><expr><name>winobj</name></expr></argument>, <argument><expr><name>abs_pos</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>out_of_frame</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/* The code above does not detect all out-of-frame cases, so check */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>row_is_in_frame</name><argument_list>(<argument><expr><name>winstate</name></expr></argument>, <argument><expr><name>abs_pos</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>out_of_frame</name>;</goto></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>isout</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>isout</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>set_mark</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>WinSetMarkPosition</name><argument_list>(<argument><expr><name>winobj</name></expr></argument>, <argument><expr><name>mark_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
	<return>return <expr><call><name>ExecEvalExpr</name><argument_list>(<argument><expr><operator>(</operator><name>ExprState</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>winobj</name><operator>-&gt;</operator><name>argstates</name></name></expr></argument>, <argument><expr><name>argno</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>econtext</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</return>

<label><name>out_of_frame</name>:</label>
	<if_stmt><if>if <condition>(<expr><name>isout</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>isout</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * WinGetFuncArgCurrent
 *		Evaluate a window function's argument expression on the current row.
 *
 * argno: argument number to evaluate (counted from 0)
 * isnull: output argument, receives isnull status of result
 *
 * Note: this isn't quite equivalent to WinGetFuncArgInPartition or
 * WinGetFuncArgInFrame targeting the current row, because it will succeed
 * even if the WindowObject's mark has been set beyond the current row.
 * This should generally be used for "ordinary" arguments of a window
 * function, such as the offset argument of lead() or lag().
 */</comment>
<function><type><name>Datum</name></type>
<name>WinGetFuncArgCurrent</name><parameter_list>(<parameter><decl><type><name>WindowObject</name></type> <name>winobj</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argno</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>winstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>WindowObjectIsValid</name><argument_list>(<argument><expr><name>winobj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>winstate</name> <operator>=</operator> <name><name>winobj</name><operator>-&gt;</operator><name>winstate</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr>;</expr_stmt>
	<return>return <expr><call><name>ExecEvalExpr</name><argument_list>(<argument><expr><operator>(</operator><name>ExprState</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>winobj</name><operator>-&gt;</operator><name>argstates</name></name></expr></argument>, <argument><expr><name>argno</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>econtext</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
