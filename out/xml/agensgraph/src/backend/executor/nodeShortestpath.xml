<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/executor/nodeShortestpath.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * nodeHash2Sidejoin.c
 *	  Routines to handle hash join nodes
 *
 * Copyright (c) 2018 by Bitnine Global, Inc.
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/executor/nodeHash2Sidejoin.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/ag_vertex_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/hashjoin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeHash2Side.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeShortestpath.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tupdesc.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>

<comment type="block">/*
 * States of the ExecShortestpath state machine
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SP_GET_PARAMETER</name></cpp:macro>        <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SP_ROTATE_PLANSTATE</name></cpp:macro>     <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SP_BUILD_HASHTABLE</name></cpp:macro>      <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SP_NEED_NEW_OUTER</name></cpp:macro>       <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SP_SCAN_BUCKET</name></cpp:macro>			<cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SP_NEED_NEW_BATCH</name></cpp:macro>       <cpp:value>6</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>ExecShortestpathOuterGetTuple</name><parameter_list>(<parameter><decl><type><name>ShortestpathState</name> <modifier>*</modifier></type><name>spstate</name></decl></parameter>,
													 <parameter><decl><type><name>uint32</name>            <modifier>*</modifier></type><name>hashvalue</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>ExecShortestpathProcOuterNode</name><parameter_list>(<parameter><decl><type><name>PlanState</name>         <modifier>*</modifier></type><name>node</name></decl></parameter>,
													 <parameter><decl><type><name>ShortestpathState</name> <modifier>*</modifier></type><name>spstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ExecShortestpathRescanOuterNode</name><parameter_list>(<parameter><decl><type><name>Hash2SideState</name>    <modifier>*</modifier></type><name>node</name></decl></parameter>,
											<parameter><decl><type><name>ShortestpathState</name> <modifier>*</modifier></type><name>spstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ExecShortestpathNewBatch</name><parameter_list>(<parameter><decl><type><name>ShortestpathState</name> <modifier>*</modifier></type><name>spstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>ExecShortestpathProjectEvalArray</name><parameter_list>(<parameter><decl><type><name>Oid</name></type>            <name>element_typeid</name></decl></parameter>,
											  <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>elems</name></decl></parameter>,
											  <parameter><decl><type><name>long</name></type>           <name>len</name></decl></parameter>,
											  <parameter><decl><type><name>ExprContext</name>   <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>ExecShortestpathProject</name><parameter_list>(<parameter><decl><type><name>ShortestpathState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
											   <parameter><decl><type><name>unsigned</name> <name>char</name>     <modifier>*</modifier></type><name>outerids</name></decl></parameter>,
											   <parameter><decl><type><name>long</name></type>               <name>lenOuterids</name></decl></parameter>,
											   <parameter><decl><type><name>unsigned</name> <name>char</name>     <modifier>*</modifier></type><name>innerids</name></decl></parameter>,
											   <parameter><decl><type><name>long</name></type>               <name>lenInnerids</name></decl></parameter>,
											   <parameter><decl><type><name>int</name></type>                <name>sizeGraphid</name></decl></parameter>,
											   <parameter><decl><type><name>int</name></type>                <name>sizeRowid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HeapTuple</name></type> <name>replace_vertexRow_graphid</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>,
										   <parameter><decl><type><name>HeapTuple</name></type> <name>vertexRow</name></decl></parameter>,
										   <parameter><decl><type><name>Datum</name></type> <name>graphid</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecShortestpath
 *
 *		This function implements the Hybrid Hash2Sidejoin algorithm.
 *
 *		Note: the relation we build hash table on is the "inner"
 *			  the other one is "outer".
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>				<comment type="block">/* return: a tuple or NULL */</comment>
<name>ExecShortestpath</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ShortestpathState</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>ShortestpathState</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hash2SideState</name> <modifier>*</modifier></type><name>outerNode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hash2SideState</name> <modifier>*</modifier></type><name>innerNode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprState</name>      <modifier>*</modifier></type><name>joinqual</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprState</name>      <modifier>*</modifier></type><name>otherqual</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name>    <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HashJoinTable</name></type>   <name>keytable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HashJoinTable</name></type>   <name>outertable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HashJoinTable</name></type>   <name>hashtable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>outerTupleSlot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MinimalTuple</name></type>    <name>outerTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MinimalTuple</name></type>    <name>innerTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>          <name>hashvalue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>             <name>batchno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>            <name>isNull</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * get information from Shortestpath node
	 */</comment>
	<expr_stmt><expr><name>joinqual</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>joinqual</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>otherqual</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>qual</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>outerNode</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>outerNode</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>innerNode</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>innerNode</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>keytable</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>sp_KeyTable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>outertable</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>sp_OuterTable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>hashtable</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>sp_HashTable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Reset per-tuple memory context to free any expression evaluation
	 * storage allocated in the previous tuple cycle.
	 */</comment>
	<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * run the hash join state machine
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * It's possible to iterate this loop many times before returning a
		 * tuple, in some pathological cases such as needing to move much of
		 * the current batch to a later batch.  So let's check for interrupts
		 * each time through.
		 */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>sp_JoinState</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>SP_GET_PARAMETER</name></expr>:</case>

				<expr_stmt><expr><name><name>outerNode</name><operator>-&gt;</operator><name>hops</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>innerNode</name><operator>-&gt;</operator><name>hops</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>startVid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>startVid</name></name> <operator>=</operator> <call><name>DatumGetGraphid</name><argument_list>(<argument><expr><call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>source</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>endVid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>endVid</name></name> <operator>=</operator> <call><name>DatumGetGraphid</name><argument_list>(<argument><expr><call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sp_JoinState</name></name> <operator>=</operator> <name>SP_ROTATE_PLANSTATE</name></expr>;</expr_stmt>

				<expr_stmt><expr><name>hashtable</name> <operator>=</operator> <call><name>ExecHash2SideTableCreate</name><argument_list>(<argument><expr><name>outerNode</name></expr></argument>,
													 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sp_HashOperators</name></name></expr></argument>,
													 <argument><expr><literal type="number">1</literal></expr></argument>,
													 <argument><expr><literal type="number">1</literal></expr></argument>,
													 <argument><expr><name><name>outerNode</name><operator>-&gt;</operator><name>hops</name></name></expr></argument>,
													 <argument><expr><name><name>outerNode</name><operator>-&gt;</operator><name>spacePeak</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>hashvalue</name> <operator>=</operator> <call><name>hash_any</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>startVid</name></name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Graphid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExecHash2SideTableInsertGraphid</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>,
												<argument><expr><name><name>node</name><operator>-&gt;</operator><name>startVid</name></name></expr></argument>,
												<argument><expr><name>hashvalue</name></expr></argument>,
												<argument><expr><name>outerNode</name></expr></argument>,
												<argument><expr><name>node</name></expr></argument>,
												<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>growEnabled</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>totalTuples</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>outerNode</name><operator>-&gt;</operator><name>totalPaths</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>outerNode</name><operator>-&gt;</operator><name>hashtable</name></name> <operator>=</operator> <name>hashtable</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>hashtable</name> <operator>=</operator> <call><name>ExecHash2SideTableCreate</name><argument_list>(<argument><expr><name>innerNode</name></expr></argument>,
													 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sp_HashOperators</name></name></expr></argument>,
													 <argument><expr><literal type="number">1</literal></expr></argument>,
													 <argument><expr><literal type="number">1</literal></expr></argument>,
													 <argument><expr><name><name>innerNode</name><operator>-&gt;</operator><name>hops</name></name></expr></argument>,
													 <argument><expr><name><name>innerNode</name><operator>-&gt;</operator><name>spacePeak</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>hashvalue</name> <operator>=</operator> <call><name>hash_any</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>endVid</name></name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Graphid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExecHash2SideTableInsertGraphid</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>,
												<argument><expr><name><name>node</name><operator>-&gt;</operator><name>endVid</name></name></expr></argument>,
												<argument><expr><name>hashvalue</name></expr></argument>,
												<argument><expr><name>innerNode</name></expr></argument>,
												<argument><expr><name>node</name></expr></argument>,
												<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>growEnabled</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>totalTuples</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>innerNode</name><operator>-&gt;</operator><name>totalPaths</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>innerNode</name><operator>-&gt;</operator><name>hashtable</name></name> <operator>=</operator> <name>hashtable</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>hashtable</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>minhops</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>startVid</name></name> <operator>==</operator> <name><name>node</name><operator>-&gt;</operator><name>endVid</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecShortestpathProject</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
													 <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>startVid</name></name><operator>)</operator><operator>)</operator></expr></argument>,
													 <argument><expr><literal type="number">0</literal></expr></argument>,
													 <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>endVid</name></name><operator>)</operator><operator>)</operator></expr></argument>,
													 <argument><expr><literal type="number">0</literal></expr></argument>,
													 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Graphid</name></expr></argument>)</argument_list></sizeof></expr></argument>,
													 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sp_RowidSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>numResults</name></name><operator>++</operator></expr>;</expr_stmt>
					<return>return <expr><name>result</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* FALL THRU */</comment>

			<case>case <expr><name>SP_ROTATE_PLANSTATE</name></expr>:</case>

				<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>numResults</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>node</name><operator>-&gt;</operator><name>hops</name></name> <operator>&gt;=</operator> <name><name>node</name><operator>-&gt;</operator><name>maxhops</name></name> <operator>||</operator>
					<name><name>outerNode</name><operator>-&gt;</operator><name>totalPaths</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>innerNode</name><operator>-&gt;</operator><name>totalPaths</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<return>return <expr><name>NULL</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hops</name></name><operator>++</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>hops</name></name> <operator>&gt;=</operator> <name><name>node</name><operator>-&gt;</operator><name>sp_Hops</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sp_Hops</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sp_OuterTuple</name></name> <operator>=</operator> <operator>(</operator><name>MinimalTuple</name><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>sp_OuterTuple</name></name></expr></argument>,
																  <argument><expr><name>HJTUPLE_OVERHEAD</name> <operator>+</operator>
																  <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>SizeofMinimalTupleHeader</name></expr></argument>)</argument_list></call> <operator>+</operator>
																  <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>outerNode</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>plan_width</name></name> <operator>*</operator>
																		   <name><name>node</name><operator>-&gt;</operator><name>sp_Hops</name></name> <operator>+</operator>
																		   <sizeof>sizeof<argument_list>(<argument><expr><name>Graphid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sp_Vertexids</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>sp_Vertexids</name></name></expr></argument>,
																	<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Graphid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>sp_Hops</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sp_Edgeids</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>sp_Edgeids</name></name></expr></argument>,
																  <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sp_RowidSize</name></name> <operator>*</operator> <name><name>node</name><operator>-&gt;</operator><name>sp_Hops</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>outerNode</name><operator>-&gt;</operator><name>hashtable</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
					   <name><name>node</name><operator>-&gt;</operator><name>innerNode</name><operator>-&gt;</operator><name>hashtable</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>outerNode</name><operator>-&gt;</operator><name>totalPaths</name></name> <operator>&gt;</operator> <name><name>innerNode</name><operator>-&gt;</operator><name>totalPaths</name></name><operator>)</operator> <operator>||</operator>
					<operator>(</operator><name><name>outerNode</name><operator>-&gt;</operator><name>totalPaths</name></name> <operator>==</operator> <name><name>innerNode</name><operator>-&gt;</operator><name>totalPaths</name></name> <operator>&amp;&amp;</operator>
					 <name><name>outerNode</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>plan_rows</name></name> <operator>&gt;</operator> <name><name>innerNode</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>plan_rows</name></name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>outerNode</name></name> <operator>=</operator> <name>innerNode</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>innerNode</name></name> <operator>=</operator> <name>outerNode</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>outerNode</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>outerNode</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>innerNode</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>innerNode</name></name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>innerNode</name><operator>-&gt;</operator><name>keytable</name></name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name><name>innerNode</name><operator>-&gt;</operator><name>keytable</name><operator>-&gt;</operator><name>spacePeak</name></name> <operator>&gt;</operator> <name><name>innerNode</name><operator>-&gt;</operator><name>spacePeak</name></name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>innerNode</name><operator>-&gt;</operator><name>spacePeak</name></name> <operator>=</operator> <name><name>innerNode</name><operator>-&gt;</operator><name>keytable</name><operator>-&gt;</operator><name>spacePeak</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><call><name>ExecHash2SideTableDestroy</name><argument_list>(<argument><expr><name><name>innerNode</name><operator>-&gt;</operator><name>keytable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>innerNode</name><operator>-&gt;</operator><name>keytable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>innerNode</name><operator>-&gt;</operator><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>int</name></type> <name>nbuckets</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>int</name></type> <name>nbatch</name></decl>;</decl_stmt>

						<expr_stmt><expr><call><name>ExecChooseHash2SideTableSize</name><argument_list>(<argument><expr><name><name>innerNode</name><operator>-&gt;</operator><name>hashtable</name><operator>-&gt;</operator><name>totalTuples</name></name></expr></argument>,
													 <argument><expr><name><name>innerNode</name><operator>-&gt;</operator><name>totalPaths</name></name></expr></argument>,
													 <argument><expr><name><name>innerNode</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>plan_width</name></name></expr></argument>,
													 <argument><expr><name><name>innerNode</name><operator>-&gt;</operator><name>hops</name></name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name>nbuckets</name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name>nbatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>nbatch</name> <operator>!=</operator> <name><name>innerNode</name><operator>-&gt;</operator><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name> <operator>||</operator>
							<name>nbuckets</name> <operator>!=</operator> <name><name>innerNode</name><operator>-&gt;</operator><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name></expr>)</condition>
						<block>{<block_content>
							<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
							<if_stmt><if>if <condition>(<expr><name><name>innerNode</name><operator>-&gt;</operator><name>hashtable</name><operator>-&gt;</operator><name>spacePeak</name></name> <operator>&gt;</operator> <name><name>innerNode</name><operator>-&gt;</operator><name>spacePeak</name></name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><name><name>innerNode</name><operator>-&gt;</operator><name>spacePeak</name></name> <operator>=</operator> <name><name>innerNode</name><operator>-&gt;</operator><name>hashtable</name><operator>-&gt;</operator><name>spacePeak</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
							<expr_stmt><expr><name>hashtable</name> <operator>=</operator> <call><name>ExecHash2SideTableCreate</name><argument_list>(<argument><expr><name>innerNode</name></expr></argument>,
																 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sp_HashOperators</name></name></expr></argument>,
																 <argument><expr><name><name>innerNode</name><operator>-&gt;</operator><name>hashtable</name><operator>-&gt;</operator><name>totalTuples</name></name></expr></argument>,
																 <argument><expr><name><name>innerNode</name><operator>-&gt;</operator><name>totalPaths</name></name></expr></argument>,
																 <argument><expr><name><name>innerNode</name><operator>-&gt;</operator><name>hops</name></name></expr></argument>,
																 <argument><expr><name><name>innerNode</name><operator>-&gt;</operator><name>spacePeak</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>innerNode</name><operator>-&gt;</operator><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
							<block>{<block_content>
								<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <name><name>innerNode</name><operator>-&gt;</operator><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name> <operator>&amp;&amp;</operator>
									<name><name>innerNode</name><operator>-&gt;</operator><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
								<block>{<block_content>
									<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
									<if_stmt><if>if <condition>(<expr><call><name>BufFileSeek</name><argument_list>(<argument><expr><name><name>innerNode</name><operator>-&gt;</operator><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
										<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
												<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
														<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not rewind hash-join temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
									<while>while <condition>(<expr><operator>(</operator><name>slot</name> <operator>=</operator> <call><name>ExecShortestpathGetSavedTuple</name><argument_list>(
											<argument><expr><name><name>innerNode</name><operator>-&gt;</operator><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>hashvalue</name></expr></argument>,
											<argument><expr><name><name>node</name><operator>-&gt;</operator><name>sp_HashTupleSlot</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
									<block>{<block_content>
										<comment type="block">/*
										 * NOTE: some tuples may be sent to future batches.  Also, it is
										 * possible for hashtable-&gt;nbatch to be increased here!
										 */</comment>
										<if_stmt><if>if <condition>(<expr><call><name>ExecHash2SideTableInsert</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>,
																	 <argument><expr><name>slot</name></expr></argument>,
																	 <argument><expr><name>hashvalue</name></expr></argument>,
																	 <argument><expr><name>innerNode</name></expr></argument>,
																	 <argument><expr><name>node</name></expr></argument>,
																	 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
										<block>{<block_content>
											<decl_stmt><decl><type><name>bool</name></type> <name>shouldFree</name></decl>;</decl_stmt>
											<decl_stmt><decl><type><name>MinimalTuple</name></type> <name>tuple</name> <init>= <expr><call><name>ExecFetchSlotMinimalTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shouldFree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
											<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>totalTuples</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
											<if_stmt><if>if <condition>(<expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>!=</operator>
												<sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>tuple</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Graphid</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>node</name><operator>-&gt;</operator><name>sp_RowidSize</name></name></expr>)</condition><block type="pseudo"><block_content>
												<expr_stmt><expr><name><name>innerNode</name><operator>-&gt;</operator><name>totalPaths</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

											<if_stmt><if>if <condition>(<expr><name>shouldFree</name></expr>)</condition>
											<block>{<block_content>
												<expr_stmt><expr><call><name>heap_free_minimal_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
											</block_content>}</block></if></if_stmt>
										</block_content>}</block></if></if_stmt>
									</block_content>}</block></while>
								</block_content>}</block></if>
								<else>else
								<block>{<block_content>
									<decl_stmt><decl><type><name>HashMemoryChunk</name></type> <name>oldchunks</name> <init>= <expr><name><name>innerNode</name><operator>-&gt;</operator><name>hashtable</name><operator>-&gt;</operator><name>chunks</name></name></expr></init></decl>;</decl_stmt>
									<expr_stmt><expr><name><name>innerNode</name><operator>-&gt;</operator><name>hashtable</name><operator>-&gt;</operator><name>chunks</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

									<comment type="block">/* so, let's scan through the old chunks, and all tuples in each chunk */</comment>
									<while>while <condition>(<expr><name>oldchunks</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
									<block>{<block_content>
										<decl_stmt><decl><type><name>HashMemoryChunk</name></type> <name>nextchunk</name> <init>= <expr><name><name>oldchunks</name><operator>-&gt;</operator><name>next</name><operator>.</operator><name>unshared</name></name></expr></init></decl>;</decl_stmt>

										<comment type="block">/* position within the buffer (up to oldchunks-&gt;used) */</comment>
										<decl_stmt><decl><type><name>size_t</name></type>		<name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

										<comment type="block">/* process all tuples stored in this chunk (and then free it) */</comment>
										<while>while <condition>(<expr><name>idx</name> <operator>&lt;</operator> <name><name>oldchunks</name><operator>-&gt;</operator><name>used</name></name></expr>)</condition>
										<block>{<block_content>
											<decl_stmt><decl><type><name>HashJoinTuple</name></type> <name>hashTuple</name> <init>= <expr><operator>(</operator><name>HashJoinTuple</name><operator>)</operator> <operator>(</operator><call><name>HASH_CHUNK_DATA</name><argument_list>(<argument><expr><name>oldchunks</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>idx</name><operator>)</operator></expr></init></decl>;</decl_stmt>
											<decl_stmt><decl><type><name>MinimalTuple</name></type>  <name>tuple</name> <init>= <expr><call><name>HJTUPLE_MINTUPLE</name><argument_list>(<argument><expr><name>hashTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
											<decl_stmt><decl><type><name>int</name></type>           <name>hashTupleSize</name> <init>= <expr><operator>(</operator><name>HJTUPLE_OVERHEAD</name> <operator>+</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

											<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><operator>(</operator><name>Graphid</name><operator>*</operator><operator>)</operator><operator>(</operator><name>tuple</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
											<block>{<block_content>
												<if_stmt><if>if <condition>(<expr><call><name>ExecHash2SideTableInsertTuple</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>,
																				  <argument><expr><name>tuple</name></expr></argument>,
																				  <argument><expr><name><name>hashTuple</name><operator>-&gt;</operator><name>hashvalue</name></name></expr></argument>,
																				  <argument><expr><name>innerNode</name></expr></argument>,
																				  <argument><expr><name>node</name></expr></argument>,
																				  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
												<block>{<block_content>
													<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>totalTuples</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
													<if_stmt><if>if <condition>(<expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>!=</operator>
														<sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>tuple</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Graphid</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>node</name><operator>-&gt;</operator><name>sp_RowidSize</name></name></expr>)</condition><block type="pseudo"><block_content>
														<expr_stmt><expr><name><name>innerNode</name><operator>-&gt;</operator><name>totalPaths</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
												</block_content>}</block></if></if_stmt>
											</block_content>}</block></if></if_stmt>
											<expr_stmt><expr><name><name>innerNode</name><operator>-&gt;</operator><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>-=</operator> <name>hashTupleSize</name></expr>;</expr_stmt>

											<comment type="block">/* next tuple in this chunk */</comment>
											<expr_stmt><expr><name>idx</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>hashTupleSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
										</block_content>}</block></while>

										<comment type="block">/* we're done with this chunk - free it and proceed to the next one */</comment>
										<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>oldchunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
										<expr_stmt><expr><name>oldchunks</name> <operator>=</operator> <name>nextchunk</name></expr>;</expr_stmt>
									</block_content>}</block></while>
								</block_content>}</block></else></if_stmt>
							</block_content>}</block></for>
							<comment type="block">/* Account for the buckets in spaceUsed (reported in EXPLAIN ANALYZE) */</comment>
							<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>+=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTuple</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>&gt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>spacePeak</name></name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spacePeak</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
							<if_stmt><if>if <condition>(<expr><name><name>innerNode</name><operator>-&gt;</operator><name>hashtable</name><operator>-&gt;</operator><name>spacePeak</name></name> <operator>&gt;</operator> <name><name>innerNode</name><operator>-&gt;</operator><name>spacePeak</name></name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><name><name>innerNode</name><operator>-&gt;</operator><name>spacePeak</name></name> <operator>=</operator> <name><name>innerNode</name><operator>-&gt;</operator><name>hashtable</name><operator>-&gt;</operator><name>spacePeak</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
							<expr_stmt><expr><call><name>ExecHash2SideTableDestroy</name><argument_list>(<argument><expr><name><name>innerNode</name><operator>-&gt;</operator><name>hashtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>growEnabled</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>innerNode</name><operator>-&gt;</operator><name>hashtable</name></name> <operator>=</operator> <name>hashtable</name></expr>;</expr_stmt>
							<expr_stmt><expr><name>hashtable</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sp_JoinState</name></name> <operator>=</operator> <name>SP_BUILD_HASHTABLE</name></expr>;</expr_stmt>

				<comment type="block">/* FALL THRU */</comment>

			<case>case <expr><name>SP_BUILD_HASHTABLE</name></expr>:</case>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>keytable</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>outertable</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>hashtable</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>hashtable</name> <operator>=</operator> <name><name>innerNode</name><operator>-&gt;</operator><name>hashtable</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sp_HashTable</name></name> <operator>=</operator> <name>hashtable</name></expr>;</expr_stmt>

				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>MultiExecProcNode</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>innerNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * need to remember whether nbatch has increased since we
				 * began scanning the outer relation
				 */</comment>
				<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbatch_outstart</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>outerNode</name><operator>-&gt;</operator><name>hops</name></name><operator>++</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>outerNode</name><operator>-&gt;</operator><name>keytable</name></name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>outerNode</name><operator>-&gt;</operator><name>keytable</name><operator>-&gt;</operator><name>spacePeak</name></name> <operator>&gt;</operator> <name><name>outerNode</name><operator>-&gt;</operator><name>spacePeak</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>outerNode</name><operator>-&gt;</operator><name>spacePeak</name></name> <operator>=</operator> <name><name>outerNode</name><operator>-&gt;</operator><name>keytable</name><operator>-&gt;</operator><name>spacePeak</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>ExecHash2SideTableDestroy</name><argument_list>(<argument><expr><name><name>outerNode</name><operator>-&gt;</operator><name>keytable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>outerNode</name><operator>-&gt;</operator><name>keytable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sp_KeyTable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name><name>outerNode</name><operator>-&gt;</operator><name>keytable</name></name> <operator>=</operator> <name><name>outerNode</name><operator>-&gt;</operator><name>hashtable</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>outerNode</name><operator>-&gt;</operator><name>keytable</name><operator>-&gt;</operator><name>spacePeak</name></name> <operator>&gt;</operator> <name><name>outerNode</name><operator>-&gt;</operator><name>spacePeak</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>outerNode</name><operator>-&gt;</operator><name>spacePeak</name></name> <operator>=</operator> <name><name>outerNode</name><operator>-&gt;</operator><name>keytable</name><operator>-&gt;</operator><name>spacePeak</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block>{<block_content>
					<expr_stmt><expr><name><name>outerNode</name><operator>-&gt;</operator><name>hashtable</name></name> <operator>=</operator> <call><name>ExecHash2SideTableClone</name><argument_list>(<argument><expr><name>outerNode</name></expr></argument>,
																   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sp_HashOperators</name></name></expr></argument>,
																   <argument><expr><name>hashtable</name></expr></argument>,
																   <argument><expr><name><name>outerNode</name><operator>-&gt;</operator><name>spacePeak</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name><name>outerNode</name><operator>-&gt;</operator><name>hashtable</name></name> <operator>=</operator> <call><name>ExecHash2SideTableCreate</name><argument_list>(<argument><expr><name>outerNode</name></expr></argument>,
																	<argument><expr><name><name>node</name><operator>-&gt;</operator><name>sp_HashOperators</name></name></expr></argument>,
																	<argument><expr><name><name>outerNode</name><operator>-&gt;</operator><name>keytable</name><operator>-&gt;</operator><name>totalTuples</name></name> <operator>+</operator>
																	<name><name>outerNode</name><operator>-&gt;</operator><name>totalPaths</name></name> <operator>*</operator>
																	<name><name>outerNode</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>plan_rows</name></name></expr></argument>,
																	<argument><expr><name><name>outerNode</name><operator>-&gt;</operator><name>totalPaths</name></name> <operator>*</operator>
																	<name><name>outerNode</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>plan_rows</name></name></expr></argument>,
																	<argument><expr><name><name>outerNode</name><operator>-&gt;</operator><name>hops</name></name></expr></argument>,
																	<argument><expr><name><name>outerNode</name><operator>-&gt;</operator><name>spacePeak</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sp_KeyTable</name></name> <operator>=</operator> <name><name>outerNode</name><operator>-&gt;</operator><name>keytable</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sp_OuterTable</name></name> <operator>=</operator> <name><name>outerNode</name><operator>-&gt;</operator><name>hashtable</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>keytable</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>sp_KeyTable</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>outertable</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>sp_OuterTable</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sp_CurKeyBatch</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sp_CurKeyIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>keytable</name><operator>-&gt;</operator><name>innerBatchFile</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>keytable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>BufFileSeek</name><argument_list>(<argument><expr><name><name>keytable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
											<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not rewind hash-join temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>ExecShortestpathRescanOuterNode</name><argument_list>(<argument><expr><name>outerNode</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>outerTupleSlot</name> <operator>=</operator> <call><name>ExecShortestpathProcOuterNode</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>outerNode</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<while>while <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>outerTupleSlot</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * We have to compute the tuple's hash value.
					 */</comment>
					<decl_stmt><decl><type><name>bool</name></type> <name>shouldFree</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>outerTupleSlot</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>outerTupleSlot</name><operator>-&gt;</operator><name>tts_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>outerTuple</name> <operator>=</operator> <call><name>ExecFetchSlotMinimalTuple</name><argument_list>(<argument><expr><name>outerTupleSlot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shouldFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>sp_OuterTuple</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
						   <argument><expr><name>outerTuple</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
						   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Graphid</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>node</name><operator>-&gt;</operator><name>sp_RowidSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>hashvalue</name> <operator>=</operator> <call><name>hash_any</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>outerTuple</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Graphid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>shouldFree</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>heap_free_minimal_tuple</name><argument_list>(<argument><expr><name>outerTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>ExecHash2SideTableInsertTuple</name><argument_list>(<argument><expr><name>outertable</name></expr></argument>,
													  <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sp_OuterTuple</name></name></expr></argument>,
													  <argument><expr><name>hashvalue</name></expr></argument>,
													  <argument><expr><name>outerNode</name></expr></argument>,
													  <argument><expr><name>node</name></expr></argument>,
													  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>outertable</name><operator>-&gt;</operator><name>totalTuples</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>outerNode</name><operator>-&gt;</operator><name>totalPaths</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<comment type="block">/*
					 * That tuple couldn't match because of a NULL, so discard it and
					 * continue with the next one.
					 */</comment>
					<expr_stmt><expr><name>outerTupleSlot</name> <operator>=</operator> <call><name>ExecShortestpathProcOuterNode</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>outerNode</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></while>

				<comment type="block">/* resize the hash table if needed (NTUP_PER_BUCKET exceeded) */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>outertable</name><operator>-&gt;</operator><name>nbuckets</name></name> <operator>!=</operator> <name><name>outertable</name><operator>-&gt;</operator><name>nbuckets_optimal</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>outertable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>-=</operator> <name><name>outertable</name><operator>-&gt;</operator><name>nbuckets</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTuple</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ExecHash2SideIncreaseNumBuckets</name><argument_list>(<argument><expr><name>outertable</name></expr></argument>, <argument><expr><name>outerNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* Account for the buckets in spaceUsed (reported in EXPLAIN ANALYZE) */</comment>
					<expr_stmt><expr><name><name>outertable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>+=</operator> <name><name>outertable</name><operator>-&gt;</operator><name>nbuckets</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTuple</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>outertable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>&gt;</operator> <name><name>outertable</name><operator>-&gt;</operator><name>spacePeak</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>outertable</name><operator>-&gt;</operator><name>spacePeak</name></name> <operator>=</operator> <name><name>outertable</name><operator>-&gt;</operator><name>spaceUsed</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name><name>outertable</name><operator>-&gt;</operator><name>growEnabled</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sp_CurOuterChunks</name></name> <operator>=</operator> <name><name>outertable</name><operator>-&gt;</operator><name>chunks</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sp_CurOuterIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sp_JoinState</name></name> <operator>=</operator> <name>SP_NEED_NEW_OUTER</name></expr>;</expr_stmt>

				<comment type="block">/* FALL THRU */</comment>

			<case>case <expr><name>SP_NEED_NEW_OUTER</name></expr>:</case>

				<comment type="block">/*
				 * We don't have an outer tuple, try to get the next one
				 */</comment>
				<expr_stmt><expr><name>outerTupleSlot</name> <operator>=</operator> <call><name>ExecShortestpathOuterGetTuple</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hashvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>outerTupleSlot</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sp_JoinState</name></name> <operator>=</operator> <name>SP_NEED_NEW_BATCH</name></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Find the corresponding bucket for this tuple in the main
				 * hash table or skew hash table.
				 */</comment>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sp_CurHashValue</name></name> <operator>=</operator> <name>hashvalue</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExecHash2SideGetBucketAndBatch</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>sp_CurBucketNo</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>batchno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sp_CurTuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/* OK, let's scan the bucket for matches */</comment>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sp_JoinState</name></name> <operator>=</operator> <name>SP_SCAN_BUCKET</name></expr>;</expr_stmt>

				<comment type="block">/* FALL THRU */</comment>

			<case>case <expr><name>SP_SCAN_BUCKET</name></expr>:</case>

				<comment type="block">/*
				 * Scan the selected hash bucket for matches to current outer
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecScanHash2SideBucket</name><argument_list>(<argument><expr><name>innerNode</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* out of matches; check for possible outer-join fill */</comment>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sp_JoinState</name></name> <operator>=</operator> <name>SP_NEED_NEW_OUTER</name></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * We've got a match, but still need to test non-hashed quals.
				 * ExecScanHash2SideBucket already set up all the state needed to
				 * call ExecQual.
				 *
				 * If we pass the qual, then save state for next call and have
				 * ExecProject form the projection, store it in the tuple
				 * table, and return the slot.
				 *
				 * Only the joinquals determine tuple match status, but all
				 * quals must pass to actually return the tuple.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>joinqual</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>ExecQual</name><argument_list>(<argument><expr><name>joinqual</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>HeapTupleHeaderSetMatch</name><argument_list>(<argument><expr><call><name>HJTUPLE_MINTUPLE</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>sp_CurTuple</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>otherqual</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>ExecQual</name><argument_list>(<argument><expr><name>otherqual</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>bool</name></type> <name>outerShouldFree</name></decl>, <decl><type ref="prev"/><name>innerShouldFree</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>int</name></type>             <name>outerHops</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>int</name></type>             <name>innerHops</name></decl>;</decl_stmt>
						<if_stmt><if>if <condition>(<expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>outerNode</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>outerTuple</name> <operator>=</operator> <call><name>ExecFetchSlotMinimalTuple</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outerShouldFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>innerTuple</name> <operator>=</operator> <call><name>ExecFetchSlotMinimalTuple</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_innertuple</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>innerShouldFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>outerHops</name> <operator>=</operator> <name><name>outerNode</name><operator>-&gt;</operator><name>hops</name></name></expr>;</expr_stmt>
							<expr_stmt><expr><name>innerHops</name> <operator>=</operator> <name><name>innerNode</name><operator>-&gt;</operator><name>hops</name></name></expr>;</expr_stmt>
						</block_content>}</block></if>
						<else>else
						<block>{<block_content>
							<expr_stmt><expr><name>outerTuple</name> <operator>=</operator> <call><name>ExecFetchSlotMinimalTuple</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_innertuple</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outerShouldFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>innerTuple</name> <operator>=</operator> <call><name>ExecFetchSlotMinimalTuple</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>innerShouldFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>outerHops</name> <operator>=</operator> <name><name>innerNode</name><operator>-&gt;</operator><name>hops</name></name></expr>;</expr_stmt>
							<expr_stmt><expr><name>innerHops</name> <operator>=</operator> <name><name>outerNode</name><operator>-&gt;</operator><name>hops</name></name></expr>;</expr_stmt>
						</block_content>}</block></else></if_stmt>
						<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecShortestpathProject</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
														 <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>outerTuple</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>,
														 <argument><expr><name>outerHops</name></expr></argument>,
														 <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>innerTuple</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>,
														 <argument><expr><name>innerHops</name></expr></argument>,
														 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Graphid</name></expr></argument>)</argument_list></sizeof></expr></argument>,
														 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sp_RowidSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><name>outerShouldFree</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>heap_free_minimal_tuple</name><argument_list>(<argument><expr><name>outerTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>

						<if_stmt><if>if <condition>(<expr><name>innerShouldFree</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>heap_free_minimal_tuple</name><argument_list>(<argument><expr><name>innerTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>

						<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>numResults</name></name><operator>++</operator></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>numResults</name></name> <operator>&gt;=</operator> <name><name>node</name><operator>-&gt;</operator><name>limit</name></name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sp_KeyTable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sp_OuterTable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sp_HashTable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
							<expr_stmt><expr><name>keytable</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>sp_KeyTable</name></name></expr>;</expr_stmt>
							<expr_stmt><expr><name>outertable</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>sp_OuterTable</name></name></expr>;</expr_stmt>
							<expr_stmt><expr><name>hashtable</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>sp_HashTable</name></name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sp_JoinState</name></name> <operator>=</operator> <name>SP_ROTATE_PLANSTATE</name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
						<return>return <expr><name>result</name></expr>;</return>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>InstrCountFiltered2</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>InstrCountFiltered1</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>

			<case>case <expr><name>SP_NEED_NEW_BATCH</name></expr>:</case>

				<comment type="block">/*
				 * Try to advance to next batch.  Done if there are no more.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecShortestpathNewBatch</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sp_KeyTable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sp_OuterTable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sp_HashTable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>keytable</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>sp_KeyTable</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>outertable</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>sp_OuterTable</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>hashtable</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>sp_HashTable</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sp_JoinState</name></name> <operator>=</operator> <name>SP_ROTATE_PLANSTATE</name></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sp_JoinState</name></name> <operator>=</operator> <name>SP_NEED_NEW_OUTER</name></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized shortestpath state: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>sp_JoinState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecInitShortestpath
 *
 *		Init routine for Shortestpath node.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>ShortestpathState</name> <modifier>*</modifier></type>
<name>ExecInitShortestpath</name><parameter_list>(<parameter><decl><type><name>Shortestpath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ShortestpathState</name> <modifier>*</modifier></type><name>spstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>outerNode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>innerNode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>lclauses</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rclauses</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>hoperators</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hash2SideState</name> <modifier>*</modifier></type><name>outerH2SNode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hash2SideState</name> <modifier>*</modifier></type><name>innerH2SNode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>		<name>vertexRow</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>		<name>tupleDesc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* check for unsupported flags */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <operator>(</operator><name>EXEC_FLAG_BACKWARD</name> <operator>|</operator> <name>EXEC_FLAG_MARK</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * create state structure
	 */</comment>
	<expr_stmt><expr><name>spstate</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ShortestpathState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>ExecProcNode</name></name> <operator>=</operator> <name>ExecShortestpath</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Miscellaneous initialization
	 *
	 * create expression context for node
	 */</comment>
	<expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>spstate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * initialize child expressions
	 */</comment>
	<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>qual</name></name> <operator>=</operator>
			<call><name>ExecInitQual</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>spstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>jointype</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>jointype</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>joinqual</name></name> <operator>=</operator>
			<call><name>ExecInitQual</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>joinqual</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>spstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>hashclauses</name></name> <operator>=</operator>
			<call><name>ExecInitQual</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hashclauses</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>spstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>source</name></name>     <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>source</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>spstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>target</name></name>     <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>spstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>minhops</name></name>    <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>minhops</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>maxhops</name></name>    <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>maxhops</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>limit</name></name>      <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>limit</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>startVid</name></name>   <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>endVid</name></name>     <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>hops</name></name>       <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>numResults</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * initialize child nodes
	 *
	 * Note: we could suppress the REWIND flag for the inner input, which
	 * would amount to betting that the hash will be a single batch.  Not
	 * clear if this would be a win or not.
	 */</comment>
	<expr_stmt><expr><name>outerNode</name> <operator>=</operator> <call><name>outerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>innerNode</name> <operator>=</operator> <call><name>innerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>spstate</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><name>outerNode</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>innerPlanState</name><argument_list>(<argument><expr><name>spstate</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><name>innerNode</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Hash2SideState</name> <operator>*</operator><operator>)</operator> <call><name>outerPlanState</name><argument_list>(<argument><expr><name>spstate</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>key</name> <operator>=</operator> <name><name>spstate</name><operator>-&gt;</operator><name>source</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Hash2SideState</name> <operator>*</operator><operator>)</operator> <call><name>innerPlanState</name><argument_list>(<argument><expr><name>spstate</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>key</name> <operator>=</operator> <name><name>spstate</name><operator>-&gt;</operator><name>target</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Hash2SideState</name> <operator>*</operator><operator>)</operator> <call><name>outerPlanState</name><argument_list>(<argument><expr><name>spstate</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>spstate</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>spstate</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Hash2SideState</name> <operator>*</operator><operator>)</operator> <call><name>innerPlanState</name><argument_list>(<argument><expr><name>spstate</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>spstate</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>spstate</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * tuple table initialization
	 */</comment>
	<expr_stmt><expr><call><name>ExecInitResultTupleSlotTL</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>spstate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_OuterTupleSlot</name></name> <operator>=</operator> <call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecSetSlotDescriptor</name><argument_list>(<argument><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_OuterTupleSlot</name></name></expr></argument>, <argument><expr><call><name>ExecGetResultType</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>spstate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * now for some voodoo.  our temporary tuple slot is actually the result
	 * tuple slot of the Hash2Side node (which is our inner plan).  we can do this
	 * because Hash2Side nodes don't return tuples via ExecProcNode() -- instead
	 * the hash join node uses ExecScanHash2SideBucket() to get at the contents of
	 * the hash table.  -cim 6/9/91
	 */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Hash2SideState</name> <modifier>*</modifier></type><name>hashstate</name> <init>= <expr><operator>(</operator><name>Hash2SideState</name> <operator>*</operator><operator>)</operator> <call><name>innerPlanState</name><argument_list>(<argument><expr><name>spstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>hashstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_HashTupleSlot</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Hash2SideState</name> <operator>*</operator><operator>)</operator> <call><name>outerPlanState</name><argument_list>(<argument><expr><name>spstate</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>slot</name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Hash2SideState</name> <operator>*</operator><operator>)</operator> <call><name>innerPlanState</name><argument_list>(<argument><expr><name>spstate</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>slot</name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * initialize tuple type and projection info
	 */</comment>
	<expr_stmt><expr><call><name>ExecAssignProjectionInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>spstate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecSetSlotDescriptor</name><argument_list>(<argument><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_OuterTupleSlot</name></name></expr></argument>,
						  <argument><expr><call><name>ExecGetResultType</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>spstate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * initialize hash-specific info
	 */</comment>
	<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_KeyTable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_OuterTable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_HashTable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_CurHashValue</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_CurBucketNo</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_CurSkewBucketNo</name></name> <operator>=</operator> <name>INVALID_SKEW_BUCKET_NO</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_CurTuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Deconstruct the hash clauses into outer and inner argument values, so
	 * that we can evaluate those subexpressions separately.  Also make a list
	 * of the hash operator OIDs, in preparation for looking up the hash
	 * functions to use.
	 */</comment>
	<expr_stmt><expr><name>lclauses</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rclauses</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>hoperators</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>node-&gt;hashclauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>hclause</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>lclauses</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>lclauses</name></expr></argument>, <argument><expr><call><name>ExecInitExpr</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>hclause</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>spstate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rclauses</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rclauses</name></expr></argument>, <argument><expr><call><name>ExecInitExpr</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>hclause</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>spstate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>hoperators</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>hoperators</name></expr></argument>, <argument><expr><name><name>hclause</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_OuterHashKeys</name></name> <operator>=</operator> <name>lclauses</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_InnerHashKeys</name></name> <operator>=</operator> <name>rclauses</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_HashOperators</name></name> <operator>=</operator> <name>hoperators</name></expr>;</expr_stmt>
	<comment type="block">/* child Hash2Side node needs to evaluate inner hash keys, too */</comment>
	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Hash2SideState</name> <operator>*</operator><operator>)</operator> <call><name>innerPlanState</name><argument_list>(<argument><expr><name>spstate</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>hashkeys</name> <operator>=</operator> <name>rclauses</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_Hops</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>maxhops</name></name> <operator>&lt;</operator> <literal type="number">32</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>node</name><operator>-&gt;</operator><name>maxhops</name></name></expr> </then><else>: <expr><literal type="number">32</literal></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_RowidSize</name></name> <operator>=</operator> <name><name>outerNode</name><operator>-&gt;</operator><name>plan_width</name></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Graphid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_GraphidTuple</name></name> <operator>=</operator> <operator>(</operator><name>MinimalTuple</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>HJTUPLE_OVERHEAD</name> <operator>+</operator>
													 <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>SizeofMinimalTupleHeader</name></expr></argument>)</argument_list></call> <operator>+</operator>
													 <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>outerNode</name><operator>-&gt;</operator><name>plan_width</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_OuterTuple</name></name> <operator>=</operator> <operator>(</operator><name>MinimalTuple</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>HJTUPLE_OVERHEAD</name> <operator>+</operator>
												   <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>SizeofMinimalTupleHeader</name></expr></argument>)</argument_list></call> <operator>+</operator>
												   <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>outerNode</name><operator>-&gt;</operator><name>plan_width</name></name> <operator>*</operator> <name><name>spstate</name><operator>-&gt;</operator><name>sp_Hops</name></name> <operator>+</operator>
															<sizeof>sizeof<argument_list>(<argument><expr><name>Graphid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_Vertexids</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Graphid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>spstate</name><operator>-&gt;</operator><name>sp_Hops</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_Edgeids</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_RowidSize</name></name> <operator>*</operator> <name><name>spstate</name><operator>-&gt;</operator><name>sp_Hops</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_GraphidTuple</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name><name>spstate</name><operator>-&gt;</operator><name>sp_GraphidTuple</name></name><operator>)</operator></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>outerNode</name><operator>-&gt;</operator><name>plan_width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_GraphidTuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name><name>spstate</name><operator>-&gt;</operator><name>sp_GraphidTuple</name></name><operator>)</operator></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>outerNode</name><operator>-&gt;</operator><name>plan_width</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_GraphidTuple</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_GraphidTuple</name><operator>-&gt;</operator><name>t_hoff</name></name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name><name>spstate</name><operator>-&gt;</operator><name>sp_GraphidTuple</name></name><operator>)</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator> <name>MINIMAL_TUPLE_OFFSET</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_JoinState</name></name> <operator>=</operator> <name>SP_GET_PARAMETER</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>outerNode</name></name> <operator>=</operator> <operator>(</operator><name>Hash2SideState</name> <operator>*</operator><operator>)</operator><call><name>outerPlanState</name><argument_list>(<argument><expr><name>spstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>innerNode</name></name> <operator>=</operator> <operator>(</operator><name>Hash2SideState</name> <operator>*</operator><operator>)</operator><call><name>innerPlanState</name><argument_list>(<argument><expr><name>spstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>outerH2SNode</name> <operator>=</operator> <name><name>spstate</name><operator>-&gt;</operator><name>outerNode</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>innerH2SNode</name> <operator>=</operator> <name><name>spstate</name><operator>-&gt;</operator><name>innerNode</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Shortestpath was originally written without expectations that the
	 * start and end nodes might reside in FieldSelect expressions. This
	 * code is to address that deficit. Additionally, it is added here to
	 * help with memory conservation by providing two vertex rows that
	 * can reused - one for the start, the other for the end.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>outerH2SNode</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>FieldSelect</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>IsA</name><argument_list>(<argument><expr><name><name>innerH2SNode</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>FieldSelect</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_ag_vertex</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>isnull</name><index>[<expr><name>Natts_ag_vertex</name></expr>]</index></name> <init>= <expr><block>{<expr><name>false</name></expr>, <expr><name>true</name></expr>, <expr><name>true</name></expr>}</block></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>tupleDesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc</name><argument_list>(<argument><expr><name>VERTEXOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>==</operator> <name>Natts_ag_vertex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>vertexRow</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>outerH2SNode</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>FieldSelect</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FieldSelect</name>		<modifier>*</modifier></type><name>fs</name> <init>= <expr><operator>(</operator><name>FieldSelect</name> <operator>*</operator><operator>)</operator> <name><name>outerH2SNode</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>outerH2SNode</name><operator>-&gt;</operator><name>isFieldSelect</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>outerH2SNode</name><operator>-&gt;</operator><name>correctedParam</name></name> <operator>=</operator> <operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>fs</name><operator>-&gt;</operator><name>arg</name></name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>outerH2SNode</name><operator>-&gt;</operator><name>isFieldSelect</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>outerH2SNode</name><operator>-&gt;</operator><name>correctedParam</name></name> <operator>=</operator> <operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name><name>outerH2SNode</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>outerH2SNode</name><operator>-&gt;</operator><name>vertexRow</name></name> <operator>=</operator> <name>vertexRow</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>outerH2SNode</name><operator>-&gt;</operator><name>tupleDesc</name></name> <operator>=</operator>  <name>tupleDesc</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>innerH2SNode</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>FieldSelect</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FieldSelect</name>		<modifier>*</modifier></type><name>fs</name> <init>= <expr><operator>(</operator><name>FieldSelect</name> <operator>*</operator><operator>)</operator> <name><name>innerH2SNode</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>innerH2SNode</name><operator>-&gt;</operator><name>isFieldSelect</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>innerH2SNode</name><operator>-&gt;</operator><name>correctedParam</name></name> <operator>=</operator> <operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>fs</name><operator>-&gt;</operator><name>arg</name></name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>innerH2SNode</name><operator>-&gt;</operator><name>isFieldSelect</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>innerH2SNode</name><operator>-&gt;</operator><name>correctedParam</name></name> <operator>=</operator> <operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name><name>innerH2SNode</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>innerH2SNode</name><operator>-&gt;</operator><name>vertexRow</name></name> <operator>=</operator> <name>vertexRow</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>innerH2SNode</name><operator>-&gt;</operator><name>tupleDesc</name></name> <operator>=</operator> <name>tupleDesc</name></expr>;</expr_stmt>

	<return>return <expr><name>spstate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecEndShortestpath
 *
 *		clean up routine for Shortestpath node
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecEndShortestpath</name><parameter_list>(<parameter><decl><type><name>ShortestpathState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Release the tuple descriptor in the Hash2SideState nodes */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>outerNode</name><operator>-&gt;</operator><name>tupleDesc</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>outerNode</name><operator>-&gt;</operator><name>tupleDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>innerNode</name><operator>-&gt;</operator><name>tupleDesc</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>innerNode</name><operator>-&gt;</operator><name>tupleDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Release the vertexRow container in the Hash2SideState nodes */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>outerNode</name><operator>-&gt;</operator><name>vertexRow</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>outerNode</name><operator>-&gt;</operator><name>vertexRow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>innerNode</name><operator>-&gt;</operator><name>vertexRow</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>innerNode</name><operator>-&gt;</operator><name>vertexRow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Free the exprcontext
	 */</comment>
	<expr_stmt><expr><call><name>ExecFreeExprContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * clean out the tuple table
	 */</comment>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>sp_OuterTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>sp_HashTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>sp_GraphidTuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>sp_OuterTuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>sp_Vertexids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>sp_Edgeids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * clean up subtrees
	 */</comment>
	<expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><call><name>innerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecShortestpathOuterGetTuple
 *
 *		get the next outer tuple for hashjoin: either by
 *		executing the outer plan node in the first pass, or from
 *		the temp files for the hashjoin batches.
 *
 * Returns a null slot if no more outer tuples (within the current batch).
 *
 * On success, the tuple's hash value is stored at *hashvalue --- this is
 * either originally computed, or re-read from the temp file.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecShortestpathOuterGetTuple</name><parameter_list>(<parameter><decl><type><name>ShortestpathState</name> <modifier>*</modifier></type><name>spstate</name></decl></parameter>, <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>hashvalue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HashMemoryChunk</name></type> <name>chunks</name> <init>= <expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_CurOuterChunks</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HashJoinTuple</name></type>   <name>hashTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MinimalTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>chunks</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>chunks</name><operator>-&gt;</operator><name>used</name></name> <operator>&lt;=</operator> <name><name>spstate</name><operator>-&gt;</operator><name>sp_CurOuterIdx</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>chunks</name> <operator>=</operator> <name><name>chunks</name><operator>-&gt;</operator><name>next</name><operator>.</operator><name>unshared</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_CurOuterChunks</name></name> <operator>=</operator> <name>chunks</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_CurOuterIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>hashTuple</name> <operator>=</operator> <operator>(</operator><name>HashJoinTuple</name><operator>)</operator> <operator>(</operator><call><name>HASH_CHUNK_DATA</name><argument_list>(<argument><expr><name>chunks</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>spstate</name><operator>-&gt;</operator><name>sp_CurOuterIdx</name></name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>HJTUPLE_MINTUPLE</name><argument_list>(<argument><expr><name>hashTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_CurOuterIdx</name></name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>HJTUPLE_OVERHEAD</name> <operator>+</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><operator>(</operator><name>Graphid</name><operator>*</operator><operator>)</operator><operator>(</operator><name>tuple</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>tuple</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Graphid</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>spstate</name><operator>-&gt;</operator><name>sp_RowidSize</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecStoreMinimalTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_OuterTupleSlot</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We have to compute the tuple's hash value.
			 */</comment>
			<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>spstate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><operator>*</operator><name>hashvalue</name> <operator>=</operator> <name><name>hashTuple</name><operator>-&gt;</operator><name>hashvalue</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
			<return>return <expr><name>slot</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* End of this batch */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecShortestpathProcOuterNode</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ShortestpathState</name> <modifier>*</modifier></type><name>spstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExecShortestpathRescanOuterNode</name><argument_list>(<argument><expr><operator>(</operator><name>Hash2SideState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>spstate</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to replace the graphid portion of a vertex
 * row. It requires the vertex row and tuple descriptor be non NULL and
 * the attbyval attribute be set. It returns a pointer to the updated
 * vertex row as a HeapTuple on conclusion.
 */</comment>
<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>replace_vertexRow_graphid</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>vertexRow</name></decl></parameter>,
						  <parameter><decl><type><name>Datum</name></type> <name>graphid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type>	<name>vheader</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attribute</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>			<modifier>*</modifier></type><name>vgdata</name></decl>;</decl_stmt>

	<comment type="block">/* Verify input constraints */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tupleDesc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>vertexRow</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>attribute</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>Anum_ag_vertex_id</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* This function only works for element 1, graphid, by value */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>attbyval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>vheader</name> <operator>=</operator> <name><name>vertexRow</name><operator>-&gt;</operator><name>t_data</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>vgdata</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>vheader</name> <operator>+</operator> <name><name>vheader</name><operator>-&gt;</operator><name>t_hoff</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>vgdata</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>vgdata</name></expr></argument>, <argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>store_att_byval</name><argument_list>(<argument><expr><name>vgdata</name></expr></argument>, <argument><expr><name>graphid</name></expr></argument>, <argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>vertexRow</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExecShortestpathRescanOuterNode</name><parameter_list>(<parameter><decl><type><name>Hash2SideState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ShortestpathState</name> <modifier>*</modifier></type><name>spstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HashJoinTable</name></type>   <name>keytable</name> <init>= <expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_KeyTable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_CurKeyBatch</name></name> <operator>&lt;</operator> <name><name>keytable</name><operator>-&gt;</operator><name>nbatch</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_CurKeyBatch</name></name> <operator>==</operator> <name><name>keytable</name><operator>-&gt;</operator><name>curbatch</name></name></expr>)</condition>
		<block>{<block_content>
			<while>while <condition>(<expr><name><name>keytable</name><operator>-&gt;</operator><name>chunks</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>HashMemoryChunk</name></type> <name>oldchunks</name> <init>= <expr><name><name>keytable</name><operator>-&gt;</operator><name>chunks</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>HashMemoryChunk</name></type> <name>nextchunk</name> <init>= <expr><name><name>oldchunks</name><operator>-&gt;</operator><name>next</name><operator>.</operator><name>unshared</name></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if<condition>(<expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_CurKeyIdx</name></name> <operator>&lt;</operator> <name><name>oldchunks</name><operator>-&gt;</operator><name>used</name></name></expr>)</condition>
				<block>{<block_content>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>oldchunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>keytable</name><operator>-&gt;</operator><name>chunks</name></name> <operator>=</operator> <name>nextchunk</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_CurKeyIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></while>
			<if_stmt><if>if <condition>(<expr><name><name>keytable</name><operator>-&gt;</operator><name>chunks</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>HashMemoryChunk</name></type>  <name>oldchunks</name> <init>= <expr><name><name>keytable</name><operator>-&gt;</operator><name>chunks</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>HashJoinTuple</name></type>    <name>hashTuple</name> <init>= <expr><operator>(</operator><name>HashJoinTuple</name><operator>)</operator> <operator>(</operator><call><name>HASH_CHUNK_DATA</name><argument_list>(<argument><expr><name>oldchunks</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>spstate</name><operator>-&gt;</operator><name>sp_CurKeyIdx</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>MinimalTuple</name></type>     <name>tuple</name> <init>= <expr><call><name>HJTUPLE_MINTUPLE</name><argument_list>(<argument><expr><name>hashTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>              <name>hashTupleSize</name> <init>= <expr><operator>(</operator><name>HJTUPLE_OVERHEAD</name> <operator>+</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>              <name>paramno</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ParamExecData</name>   <modifier>*</modifier></type><name>prm</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Graphid</name>			<modifier>*</modifier></type><name>graphid</name></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>keytable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>-=</operator> <name>hashTupleSize</name></expr>;</expr_stmt>

				<comment type="block">/* next tuple in this chunk */</comment>
				<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_CurKeyIdx</name></name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>hashTupleSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>graphid</name> <operator>=</operator> <operator>(</operator><name>Graphid</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>tuple</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>graphid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>hops</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
					 <name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>tuple</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Graphid</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>spstate</name><operator>-&gt;</operator><name>sp_RowidSize</name></name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ExecHash2SideTableInsertGraphid</name><argument_list>(<argument><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_OuterTable</name></name></expr></argument>,
													<argument><expr><operator>*</operator><name>graphid</name></expr></argument>,
													<argument><expr><name><name>hashTuple</name><operator>-&gt;</operator><name>hashvalue</name></name></expr></argument>,
													<argument><expr><name>node</name></expr></argument>,
													<argument><expr><name>spstate</name></expr></argument>,
													<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_OuterTable</name><operator>-&gt;</operator><name>totalTuples</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_OuterTuple</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>tuple</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>spstate</name><operator>-&gt;</operator><name>sp_OuterTuple</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>+</operator>
					   <sizeof>sizeof<argument_list>(<argument><expr><name>Graphid</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>spstate</name><operator>-&gt;</operator><name>sp_RowidSize</name></name></expr></argument>,
					   <argument><expr><name>tuple</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
					   <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>tuple</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_OuterTuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Graphid</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>spstate</name><operator>-&gt;</operator><name>sp_RowidSize</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>paramno</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>correctedParam</name><operator>-&gt;</operator><name>paramid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>prm</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>spstate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name><operator>-&gt;</operator><name>ecxt_param_exec_vals</name><index>[<expr><name>paramno</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>isFieldSelect</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>vertexRow</name></name> <operator>=</operator> <call><name>replace_vertexRow_graphid</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>tupleDesc</name></name></expr></argument>,
																<argument><expr><name><name>node</name><operator>-&gt;</operator><name>vertexRow</name></name></expr></argument>,
																<argument><expr><operator>*</operator><name>graphid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>vertexRow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <operator>*</operator><name>graphid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>chgParam</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>chgParam</name></expr></argument>,
																<argument><expr><name>paramno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExecReScan</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>hops</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ExecHash2SideTableInsertGraphid</name><argument_list>(<argument><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_OuterTable</name></name></expr></argument>,
													<argument><expr><operator>*</operator><name>graphid</name></expr></argument>,
													<argument><expr><name><name>hashTuple</name><operator>-&gt;</operator><name>hashvalue</name></name></expr></argument>,
													<argument><expr><name>node</name></expr></argument>,
													<argument><expr><name>spstate</name></expr></argument>,
													<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_OuterTable</name><operator>-&gt;</operator><name>totalTuples</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>keytable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_CurKeyBatch</name></name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint32</name></type> <name>hashvalue</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecShortestpathGetSavedTuple</name><argument_list>(<argument><expr><name><name>keytable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_CurKeyBatch</name></name></expr>]</index></name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name>hashvalue</name></expr></argument>,
												 <argument><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_OuterTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type> <name>shouldFree</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>MinimalTuple</name></type>   <name>tuple</name> <init>= <expr><call><name>ExecFetchSlotMinimalTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shouldFree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>            <name>paramno</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ParamExecData</name> <modifier>*</modifier></type><name>prm</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Graphid</name>		   <modifier>*</modifier></type><name>graphid</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>graphid</name> <operator>=</operator> <operator>(</operator><name>Graphid</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>tuple</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>graphid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>hops</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
					 <name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>tuple</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Graphid</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>spstate</name><operator>-&gt;</operator><name>sp_RowidSize</name></name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ExecHash2SideTableInsertGraphid</name><argument_list>(<argument><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_OuterTable</name></name></expr></argument>,
													<argument><expr><operator>*</operator><name>graphid</name></expr></argument>,
													<argument><expr><name>hashvalue</name></expr></argument>,
													<argument><expr><name>node</name></expr></argument>,
													<argument><expr><name>spstate</name></expr></argument>,
													<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_OuterTable</name><operator>-&gt;</operator><name>totalTuples</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_OuterTuple</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>tuple</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>spstate</name><operator>-&gt;</operator><name>sp_OuterTuple</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>+</operator>
					   <sizeof>sizeof<argument_list>(<argument><expr><name>Graphid</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>spstate</name><operator>-&gt;</operator><name>sp_RowidSize</name></name></expr></argument>,
					   <argument><expr><name>tuple</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
					   <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>tuple</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>shouldFree</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>heap_free_minimal_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_OuterTuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Graphid</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>spstate</name><operator>-&gt;</operator><name>sp_RowidSize</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>paramno</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>correctedParam</name><operator>-&gt;</operator><name>paramid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>prm</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>spstate</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name><operator>-&gt;</operator><name>ecxt_param_exec_vals</name><index>[<expr><name>paramno</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>isFieldSelect</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>vertexRow</name></name> <operator>=</operator> <call><name>replace_vertexRow_graphid</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>tupleDesc</name></name></expr></argument>,
																<argument><expr><name><name>node</name><operator>-&gt;</operator><name>vertexRow</name></name></expr></argument>,
																<argument><expr><operator>*</operator><name>graphid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>vertexRow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <operator>*</operator><name>graphid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>chgParam</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>chgParam</name></expr></argument>,
																<argument><expr><name>paramno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExecReScan</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>hops</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ExecHash2SideTableInsertGraphid</name><argument_list>(<argument><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_OuterTable</name></name></expr></argument>,
													<argument><expr><operator>*</operator><name>graphid</name></expr></argument>,
													<argument><expr><name>hashvalue</name></expr></argument>,
													<argument><expr><name>node</name></expr></argument>,
													<argument><expr><name>spstate</name></expr></argument>,
													<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_OuterTable</name><operator>-&gt;</operator><name>totalTuples</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>keytable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_CurKeyBatch</name></name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>BufFileClose</name><argument_list>(<argument><expr><name><name>keytable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_CurKeyBatch</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>keytable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_CurKeyBatch</name></name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_CurKeyBatch</name></name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_CurKeyBatch</name></name> <operator>&lt;</operator> <name><name>keytable</name><operator>-&gt;</operator><name>nbatch</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_CurKeyIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>keytable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_CurKeyBatch</name></name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>BufFileSeek</name><argument_list>(<argument><expr><name><name>keytable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_CurKeyBatch</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
									<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not rewind hash-join temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecShortestpathNewBatch
 *		switch to a new hashjoin batch
 *
 * Returns true if successful, false if there are no more batches.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExecShortestpathNewBatch</name><parameter_list>(<parameter><decl><type><name>ShortestpathState</name> <modifier>*</modifier></type><name>spstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HashJoinTable</name></type>   <name>outertable</name> <init>= <expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_OuterTable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HashJoinTable</name></type>   <name>hashtable</name> <init>= <expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_HashTable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>             <name>nextbatch</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufFile</name>        <modifier>*</modifier></type><name>innerFile</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>          <name>hashvalue</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>outertable</name><operator>-&gt;</operator><name>nbatch</name></name> <operator>&gt;=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name> <operator>&amp;&amp;</operator>
		   <name><name>outertable</name><operator>-&gt;</operator><name>nbatch</name></name> <operator>%</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>nextbatch</name> <operator>=</operator> <name><name>outertable</name><operator>-&gt;</operator><name>curbatch</name></name> <operator>+</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nextbatch</name> <operator>&gt;=</operator> <name><name>outertable</name><operator>-&gt;</operator><name>nbatch</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>nextbatch</name> <operator>=</operator> <name>nextbatch</name> <operator>%</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>nextbatch</name> <operator>&gt;=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>outertable</name><operator>-&gt;</operator><name>curbatch</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>outertable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name><name>outertable</name><operator>-&gt;</operator><name>curbatch</name></name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HashMemoryChunk</name></type> <name>oldchunks</name> <init>= <expr><name><name>outertable</name><operator>-&gt;</operator><name>chunks</name></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>outertable</name><operator>-&gt;</operator><name>chunks</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

			<comment type="block">/* so, let's scan through the old chunks, and all tuples in each chunk */</comment>
			<while>while <condition>(<expr><name>oldchunks</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>HashMemoryChunk</name></type> <name>nextchunk</name> <init>= <expr><name><name>oldchunks</name><operator>-&gt;</operator><name>next</name><operator>.</operator><name>unshared</name></name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* position within the buffer (up to oldchunks-&gt;used) */</comment>
				<decl_stmt><decl><type><name>size_t</name></type>		<name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

				<comment type="block">/* process all tuples stored in this chunk (and then free it) */</comment>
				<while>while <condition>(<expr><name>idx</name> <operator>&lt;</operator> <name><name>oldchunks</name><operator>-&gt;</operator><name>used</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>HashJoinTuple</name></type> <name>hashTuple</name> <init>= <expr><operator>(</operator><name>HashJoinTuple</name><operator>)</operator> <operator>(</operator><call><name>HASH_CHUNK_DATA</name><argument_list>(<argument><expr><name>oldchunks</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>idx</name><operator>)</operator></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>MinimalTuple</name></type>  <name>tuple</name> <init>= <expr><call><name>HJTUPLE_MINTUPLE</name><argument_list>(<argument><expr><name>hashTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>           <name>hashTupleSize</name> <init>= <expr><operator>(</operator><name>HJTUPLE_OVERHEAD</name> <operator>+</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><operator>(</operator><name>Graphid</name><operator>*</operator><operator>)</operator><operator>(</operator><name>tuple</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ExecShortestpathSaveTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
												  <argument><expr><name><name>hashTuple</name><operator>-&gt;</operator><name>hashvalue</name></name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name><name>outertable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name><name>outertable</name><operator>-&gt;</operator><name>curbatch</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><name><name>outertable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>-=</operator> <name>hashTupleSize</name></expr>;</expr_stmt>

					<comment type="block">/* next tuple in this chunk */</comment>
					<expr_stmt><expr><name>idx</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>hashTupleSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></while>

				<comment type="block">/* we're done with this chunk - free it and proceed to the next one */</comment>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>oldchunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>oldchunks</name> <operator>=</operator> <name>nextchunk</name></expr>;</expr_stmt>
			</block_content>}</block></while>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>outertable</name><operator>-&gt;</operator><name>curbatch</name></name> <operator>=</operator> <name>nextbatch</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecHash2SideTableReset</name><argument_list>(<argument><expr><name>outertable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>innerFile</name> <operator>=</operator> <name><name>outertable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>nextbatch</name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>innerFile</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>long</name></type> <name>saved</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>BufFileSeek</name><argument_list>(<argument><expr><name>innerFile</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not rewind hash-join temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<while>while <condition>(<expr><operator>(</operator><name>slot</name> <operator>=</operator> <call><name>ExecShortestpathGetSavedTuple</name><argument_list>(<argument><expr><name>innerFile</name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name>hashvalue</name></expr></argument>,
													 <argument><expr><name><name>spstate</name><operator>-&gt;</operator><name>outerNode</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * NOTE: some tuples may be sent to future batches.  Also, it is
			 * possible for outertable-&gt;nbatch to be increased here!
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecHash2SideTableInsert</name><argument_list>(<argument><expr><name>outertable</name></expr></argument>,
										  <argument><expr><name>slot</name></expr></argument>,
										  <argument><expr><name>hashvalue</name></expr></argument>,
										  <argument><expr><name><name>spstate</name><operator>-&gt;</operator><name>outerNode</name></name></expr></argument>,
										  <argument><expr><name>spstate</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>saved</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>saved</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></while>
		<if_stmt><if>if <condition>(<expr><name>saved</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>BufFileClose</name><argument_list>(<argument><expr><name>innerFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>outertable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>nextbatch</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_CurOuterChunks</name></name> <operator>=</operator> <name><name>outertable</name><operator>-&gt;</operator><name>chunks</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_CurOuterIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nextbatch</name> <operator>&lt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>HashMemoryChunk</name></type> <name>oldchunks</name> <init>= <expr><name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name></name></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/* so, let's scan through the old chunks, and all tuples in each chunk */</comment>
				<while>while <condition>(<expr><name>oldchunks</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>HashMemoryChunk</name></type> <name>nextchunk</name> <init>= <expr><name><name>oldchunks</name><operator>-&gt;</operator><name>next</name><operator>.</operator><name>unshared</name></name></expr></init></decl>;</decl_stmt>

					<comment type="block">/* position within the buffer (up to oldchunks-&gt;used) */</comment>
					<decl_stmt><decl><type><name>size_t</name></type>		<name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

					<comment type="block">/* process all tuples stored in this chunk (and then free it) */</comment>
					<while>while <condition>(<expr><name>idx</name> <operator>&lt;</operator> <name><name>oldchunks</name><operator>-&gt;</operator><name>used</name></name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>HashJoinTuple</name></type> <name>hashTuple</name> <init>= <expr><operator>(</operator><name>HashJoinTuple</name><operator>)</operator> <operator>(</operator><call><name>HASH_CHUNK_DATA</name><argument_list>(<argument><expr><name>oldchunks</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>idx</name><operator>)</operator></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>MinimalTuple</name></type>  <name>tuple</name> <init>= <expr><call><name>HJTUPLE_MINTUPLE</name><argument_list>(<argument><expr><name>hashTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>int</name></type>           <name>hashTupleSize</name> <init>= <expr><operator>(</operator><name>HJTUPLE_OVERHEAD</name> <operator>+</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><operator>(</operator><name>Graphid</name><operator>*</operator><operator>)</operator><operator>(</operator><name>tuple</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ExecShortestpathSaveTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
													  <argument><expr><name><name>hashTuple</name><operator>-&gt;</operator><name>hashvalue</name></name></expr></argument>,
													  <argument><expr><operator>&amp;</operator><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>-=</operator> <name>hashTupleSize</name></expr>;</expr_stmt>

						<comment type="block">/* next tuple in this chunk */</comment>
						<expr_stmt><expr><name>idx</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>hashTupleSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></while>

					<comment type="block">/* we're done with this chunk - free it and proceed to the next one */</comment>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>oldchunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>oldchunks</name> <operator>=</operator> <name>nextchunk</name></expr>;</expr_stmt>
				</block_content>}</block></while>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name> <operator>=</operator> <name>nextbatch</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecHash2SideTableReset</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>innerFile</name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>nextbatch</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>innerFile</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>long</name></type> <name>saved</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>BufFileSeek</name><argument_list>(<argument><expr><name>innerFile</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not rewind hash-join temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<while>while <condition>(<expr><operator>(</operator><name>slot</name> <operator>=</operator> <call><name>ExecShortestpathGetSavedTuple</name><argument_list>(<argument><expr><name>innerFile</name></expr></argument>,
														 <argument><expr><operator>&amp;</operator><name>hashvalue</name></expr></argument>,
														 <argument><expr><name><name>spstate</name><operator>-&gt;</operator><name>innerNode</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * NOTE: some tuples may be sent to future batches.  Also, it is
				 * possible for hashtable-&gt;nbatch to be increased here!
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecHash2SideTableInsert</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>,
											  <argument><expr><name>slot</name></expr></argument>,
											  <argument><expr><name>hashvalue</name></expr></argument>,
											  <argument><expr><name><name>spstate</name><operator>-&gt;</operator><name>innerNode</name></name></expr></argument>,
											  <argument><expr><name>spstate</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>saved</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>saved</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></while>
			<if_stmt><if>if <condition>(<expr><name>saved</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>BufFileClose</name><argument_list>(<argument><expr><name>innerFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>nextbatch</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecShortestpathSaveTuple
 *		save a tuple to a batch file.
 *
 * The data recorded in the file for each tuple is its hash value,
 * then the tuple in MinimalTuple format.
 *
 * Note: it is important always to call this in the regular executor
 * context, not in a shorter-lived context; else the temp file buffers
 * will get messed up.
 */</comment>
<function><type><name>void</name></type>
<name>ExecShortestpathSaveTuple</name><parameter_list>(<parameter><decl><type><name>MinimalTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hashvalue</name></decl></parameter>,
						  <parameter><decl><type><name>BufFile</name> <modifier>*</modifier><modifier>*</modifier></type><name>fileptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufFile</name>    <modifier>*</modifier></type><name>file</name> <init>= <expr><operator>*</operator><name>fileptr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>written</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>file</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* First write to this batch file, so open it. */</comment>
		<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>BufFileCreateTemp</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>fileptr</name> <operator>=</operator> <name>file</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>written</name> <operator>=</operator> <call><name>BufFileWrite</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>hashvalue</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>written</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to hash-join temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>written</name> <operator>=</operator> <call><name>BufFileWrite</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>tuple</name></expr></argument>, <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>written</name> <operator>!=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to hash-join temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecShortestpathGetSavedTuple
 *		read the next tuple from a batch file.  Return NULL if no more.
 *
 * On success, *hashvalue is set to the tuple's hash value, and the tuple
 * itself is stored in the given slot.
 */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecShortestpathGetSavedTuple</name><parameter_list>(<parameter><decl><type><name>BufFile</name> <modifier>*</modifier></type><name>file</name></decl></parameter>,
							  <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>hashvalue</name></decl></parameter>,
							  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>tupleSlot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name><name>header</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>nread</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MinimalTuple</name></type> <name>tuple</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We check for interrupts here because this is typically taken as an
	 * alternative code path to an ExecProcNode() call, which would include
	 * such a check.
	 */</comment>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since both the hash value and the MinimalTuple length word are uint32,
	 * we can read them both in one BufFileRead() call without any type
	 * cheating.
	 */</comment>
	<expr_stmt><expr><name>nread</name> <operator>=</operator> <call><name>BufFileRead</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>header</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nread</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>				<comment type="block">/* end of file */</comment>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>tupleSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>nread</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from hash-join temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>hashvalue</name> <operator>=</operator> <name><name>header</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <operator>(</operator><name>MinimalTuple</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>header</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>=</operator> <name><name>header</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nread</name> <operator>=</operator> <call><name>BufFileRead</name><argument_list>(<argument><expr><name>file</name></expr></argument>,
						<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tuple</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>,
						<argument><expr><name><name>header</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nread</name> <operator>!=</operator> <name><name>header</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from hash-join temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><call><name>ExecStoreMinimalTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>tupleSlot</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>ExecShortestpathProjectEvalArray</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>element_typeid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>elems</name></decl></parameter>,
								 <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type>  <name>oldContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>         <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>          <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>            <name><name>dims</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>            <name><name>lbs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>     <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>          <name>elemlength</name></decl>;</decl_stmt>     <comment type="block">/* typlen of the array element type */</comment>
	<decl_stmt><decl><type><name>bool</name></type>           <name>elembyval</name></decl>;</decl_stmt>      <comment type="block">/* is the element type pass-by-value? */</comment>
	<decl_stmt><decl><type><name>char</name></type>           <name>elemalign</name></decl>;</decl_stmt>      <comment type="block">/* typalign of the element type */</comment>

	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><name>element_typeid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elemlength</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elembyval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elemalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>construct_empty_array</name><argument_list>(<argument><expr><name>element_typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>values</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nulls</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>elembyval</name> <operator>==</operator> <name>true</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>UInt64GetDatum</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>Datum</name><operator>*</operator><operator>)</operator> <name>elems</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator><name>elems</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>elems</name> <operator>+=</operator> <name>elemlength</name></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name><name>dims</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lbs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>construct_md_array</name><argument_list>(<argument><expr><operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>dims</name></expr></argument>, <argument><expr><name>lbs</name></expr></argument>, <argument><expr><name>element_typeid</name></expr></argument>,
									<argument><expr><name>elemlength</name></expr></argument>, <argument><expr><name>elembyval</name></expr></argument>, <argument><expr><name>elemalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecShortestpathProject</name><parameter_list>(<parameter><decl><type><name>ShortestpathState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
						<parameter><decl><type><name>unsigned</name> <name>char</name>     <modifier>*</modifier></type><name>outerids</name></decl></parameter>,
						<parameter><decl><type><name>long</name></type>               <name>lenOuterids</name></decl></parameter>,
						<parameter><decl><type><name>unsigned</name> <name>char</name>     <modifier>*</modifier></type><name>innerids</name></decl></parameter>,
						<parameter><decl><type><name>long</name></type>               <name>lenInnerids</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type>                <name>sizeGraphid</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type>                <name>sizeRowid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ProjectionInfo</name> <modifier>*</modifier></type><name>projInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name>    <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>          <modifier>*</modifier></type><name>tts_values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>           <modifier>*</modifier></type><name>tts_isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name>  <modifier>*</modifier></type><name>oids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name>  <modifier>*</modifier></type><name>iids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name>  <modifier>*</modifier></type><name>vids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name>  <modifier>*</modifier></type><name>eids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>            <name>lenVids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>            <name>lenEids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>            <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oids</name> <operator>=</operator> <name>outerids</name> <operator>+</operator> <operator>(</operator><name>sizeGraphid</name> <operator>+</operator> <name>sizeRowid</name><operator>)</operator> <operator>*</operator> <name>lenOuterids</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>iids</name> <operator>=</operator> <name>innerids</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>vids</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>sp_Vertexids</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>eids</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>sp_Edgeids</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>lenVids</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>lenEids</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>lenOuterids</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>vids</name></expr></argument>, <argument><expr><name>oids</name></expr></argument>, <argument><expr><name>sizeGraphid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>vids</name> <operator>+=</operator> <name>sizeGraphid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>oids</name> <operator>-=</operator> <name>sizeRowid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>lenVids</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>eids</name></expr></argument>, <argument><expr><name>oids</name></expr></argument>, <argument><expr><name>sizeRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>eids</name> <operator>+=</operator> <name>sizeRowid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>oids</name> <operator>-=</operator> <name>sizeGraphid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>lenEids</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>vids</name></expr></argument>, <argument><expr><name>iids</name></expr></argument>, <argument><expr><name>sizeGraphid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>vids</name> <operator>+=</operator> <name>sizeGraphid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>iids</name> <operator>+=</operator> <name>sizeGraphid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>lenVids</name><operator>++</operator></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>lenInnerids</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>eids</name></expr></argument>, <argument><expr><name>iids</name></expr></argument>, <argument><expr><name>sizeRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>eids</name> <operator>+=</operator> <name>sizeRowid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>iids</name> <operator>+=</operator> <name>sizeRowid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>lenEids</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>vids</name></expr></argument>, <argument><expr><name>iids</name></expr></argument>, <argument><expr><name>sizeGraphid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>vids</name> <operator>+=</operator> <name>sizeGraphid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>iids</name> <operator>+=</operator> <name>sizeGraphid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>lenVids</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>projInfo</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ProjInfo</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>projInfo</name><operator>-&gt;</operator><name>pi_state</name><operator>.</operator><name>resultslot</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>projInfo</name><operator>-&gt;</operator><name>pi_exprContext</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tts_values</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tts_isnull</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>tts_values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>ExecShortestpathProjectEvalArray</name><argument_list>(<argument><expr><name>GRAPHIDOID</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sp_Vertexids</name></name></expr></argument>, <argument><expr><name>lenVids</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tts_isnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tts_values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ExecShortestpathProjectEvalArray</name><argument_list>(<argument><expr><name>ROWIDOID</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sp_Edgeids</name></name></expr></argument>, <argument><expr><name>lenEids</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tts_isnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<return>return <expr><call><name>ExecStoreVirtualTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecReScanShortestpath</name><parameter_list>(<parameter><decl><type><name>ShortestpathState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sp_KeyTable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sp_OuterTable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sp_HashTable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sp_JoinState</name></name> <operator>=</operator> <name>SP_GET_PARAMETER</name></expr>;</expr_stmt>

	<comment type="block">/* Always reset intra-tuple state */</comment>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sp_CurHashValue</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sp_CurBucketNo</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sp_CurSkewBucketNo</name></name> <operator>=</operator> <name>INVALID_SKEW_BUCKET_NO</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sp_CurTuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>chgParam</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Param</name> <modifier>*</modifier></type><name>sParam</name> <init>= <expr><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>source</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Param</name> <modifier>*</modifier></type><name>tParam</name> <init>= <expr><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>target</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If we have FieldSelect expressions grab the Param expression
		 * from the FieldSelect's arg value.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>sParam</name></expr></argument>, <argument><expr><name>FieldSelect</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>sParam</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>FieldSelect</name> <operator>*</operator><operator>)</operator><name>sParam</name><operator>)</operator><operator>-&gt;</operator><name>arg</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>tParam</name></expr></argument>, <argument><expr><name>FieldSelect</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>tParam</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>FieldSelect</name> <operator>*</operator><operator>)</operator><name>tParam</name><operator>)</operator><operator>-&gt;</operator><name>arg</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>sParam</name><operator>-&gt;</operator><name>paramid</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>chgParam</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>startVid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>tParam</name><operator>-&gt;</operator><name>paramid</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>chgParam</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>endVid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hops</name></name>       <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>numResults</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>outerNode</name></name> <operator>=</operator> <operator>(</operator><name>Hash2SideState</name> <operator>*</operator><operator>)</operator><call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>innerNode</name></name> <operator>=</operator> <operator>(</operator><name>Hash2SideState</name> <operator>*</operator><operator>)</operator><call><name>innerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecReScan</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>lefttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecReScan</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>js</name><operator>.</operator><name>ps</name><operator>.</operator><name>righttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
