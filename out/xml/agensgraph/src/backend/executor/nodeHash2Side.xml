<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/executor/nodeHash2Side.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * nodeHash2Side.c
 *	  Routines to hash relations for shortestpath
 *
 * Copyright (c) 2018 by Bitnine Global, Inc.
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/executor/nodeHash2Side.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<comment type="block">/*
 * INTERFACE ROUTINES
 *		MultiExecHash2Side	- generate an in-memory hash table of the relation
 *		ExecInitHash2Side	- initialize node and subnodes
 *		ExecEndHash2Side		- shutdown node and subnodes
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execdebug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/hashjoin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeHash2Side.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeShortestpath.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/dynahash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecHash2SideIncreaseNumBatches</name><parameter_list>(<parameter><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>dense_alloc</name><parameter_list>(<parameter><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecHash2Side
 *
 *		stub for pro forma compliance
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecHash2Side</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ExecProcNode</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		MultiExecHash2Side
 *
 *		build hash table for hashjoin, doing partitioning if more
 *		than one batch is required.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>MultiExecHash2Side</name><parameter_list>(<parameter><decl><type><name>Hash2SideState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HashJoinTable</name></type>   <name>hashtable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>          <name>hashvalue</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * get state info from node
	 */</comment>
	<expr_stmt><expr><name>hashtable</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>hashtable</name></name></expr>;</expr_stmt>

	<comment type="block">/* resize the hash table if needed (NTUP_PER_BUCKET exceeded) */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name> <operator>!=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets_optimal</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>-=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTuple</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecHash2SideIncreaseNumBuckets</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Account for the buckets in spaceUsed (reported in EXPLAIN ANALYZE) */</comment>
		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>+=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTuple</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>&gt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>spacePeak</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spacePeak</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>HashMemoryChunk</name></type> <name>oldchunks</name> <init>= <expr><name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name></name></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/* so, let's scan through the old chunks, and all tuples in each chunk */</comment>
				<while>while <condition>(<expr><name>oldchunks</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>HashMemoryChunk</name></type> <name>nextchunk</name> <init>= <expr><name><name>oldchunks</name><operator>-&gt;</operator><name>next</name><operator>.</operator><name>unshared</name></name></expr></init></decl>;</decl_stmt>

					<comment type="block">/* position within the buffer (up to oldchunks-&gt;used) */</comment>
					<decl_stmt><decl><type><name>size_t</name></type>		<name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

					<comment type="block">/* process all tuples stored in this chunk (and then free it) */</comment>
					<while>while <condition>(<expr><name>idx</name> <operator>&lt;</operator> <name><name>oldchunks</name><operator>-&gt;</operator><name>used</name></name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>HashJoinTuple</name></type> <name>hashTuple</name> <init>= <expr><operator>(</operator><name>HashJoinTuple</name><operator>)</operator> <operator>(</operator><call><name>HASH_CHUNK_DATA</name><argument_list>(<argument><expr><name>oldchunks</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>idx</name><operator>)</operator></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>MinimalTuple</name></type>  <name>tuple</name> <init>= <expr><call><name>HJTUPLE_MINTUPLE</name><argument_list>(<argument><expr><name>hashTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>int</name></type>           <name>hashTupleSize</name> <init>= <expr><operator>(</operator><name>HJTUPLE_OVERHEAD</name> <operator>+</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><operator>(</operator><name>Graphid</name><operator>*</operator><operator>)</operator><operator>(</operator><name>tuple</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ExecShortestpathSaveTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
													  <argument><expr><name><name>hashTuple</name><operator>-&gt;</operator><name>hashvalue</name></name></expr></argument>,
													  <argument><expr><operator>&amp;</operator><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>-=</operator> <name>hashTupleSize</name></expr>;</expr_stmt>

						<comment type="block">/* next tuple in this chunk */</comment>
						<expr_stmt><expr><name>idx</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>hashTupleSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></while>

					<comment type="block">/* we're done with this chunk - free it and proceed to the next one */</comment>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>oldchunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>oldchunks</name> <operator>=</operator> <name>nextchunk</name></expr>;</expr_stmt>
				</block_content>}</block></while>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecHash2SideTableReset</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>long</name></type> <name>saved</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>BufFileSeek</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not rewind hash-join temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<while>while <condition>(<expr><operator>(</operator><name>slot</name> <operator>=</operator> <call><name>ExecShortestpathGetSavedTuple</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
														 <argument><expr><operator>&amp;</operator><name>hashvalue</name></expr></argument>,
														 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * NOTE: some tuples may be sent to future batches.  Also, it is
				 * possible for hashtable-&gt;nbatch to be increased here!
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecHash2SideTableInsert</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>,
											  <argument><expr><name>slot</name></expr></argument>,
											  <argument><expr><name>hashvalue</name></expr></argument>,
											  <argument><expr><name>node</name></expr></argument>,
											  <argument><expr><operator>(</operator><name>ShortestpathState</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>spstate</name></name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>saved</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>saved</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></while>
			<if_stmt><if>if <condition>(<expr><name>saved</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>BufFileClose</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We do not return the hash table directly because it's not a subtype of
	 * Node, and so would violate the MultiExecProcNode API.  Instead, our
	 * parent Shortestpath node is expected to know how to fish it out of our node
	 * state.  Ugly but not really worth cleaning up, since Hashjoin knows
	 * quite a bit more about Hash besides that.
	 */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecInitHash2Side
 *
 *		Init routine for Hash2Side node
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>Hash2SideState</name> <modifier>*</modifier></type>
<name>ExecInitHash2Side</name><parameter_list>(<parameter><decl><type><name>Hash2Side</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Hash2SideState</name>  <modifier>*</modifier></type><name>hashstate</name></decl>;</decl_stmt>

	<comment type="block">/* check for unsupported flags */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <operator>(</operator><name>EXEC_FLAG_BACKWARD</name> <operator>|</operator> <name>EXEC_FLAG_MARK</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * create state structure
	 */</comment>
	<expr_stmt><expr><name>hashstate</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Hash2SideState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ExecProcNode</name></name> <operator>=</operator> <name>ExecHash2Side</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashstate</name><operator>-&gt;</operator><name>keytable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashstate</name><operator>-&gt;</operator><name>hashtable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashstate</name><operator>-&gt;</operator><name>hashkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>	<comment type="block">/* will be set by parent Shortestpath */</comment>
	<expr_stmt><expr><name><name>hashstate</name><operator>-&gt;</operator><name>spstate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashstate</name><operator>-&gt;</operator><name>totalPaths</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashstate</name><operator>-&gt;</operator><name>hops</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashstate</name><operator>-&gt;</operator><name>spacePeak</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Miscellaneous initialization
	 *
	 * create expression context for node
	 */</comment>
	<expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>hashstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecInitResultTupleSlotTL</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hashstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * initialize child expressions
	 */</comment>
	<expr_stmt><expr><name><name>hashstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>qual</name></name> <operator>=</operator>
			<call><name>ExecInitQual</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>hashstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * initialize child nodes
	 */</comment>
	<expr_stmt><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>hashstate</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><call><name>outerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>hashstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ProjInfo</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><name>hashstate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ---------------------------------------------------------------
 *		ExecEndHash2Side
 *
 *		clean up routine for Hash2Side node
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecEndHash2Side</name><parameter_list>(<parameter><decl><type><name>Hash2SideState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>outerPlan</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>keytable</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecHash2SideTableDestroy</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>keytable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>keytable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>hashtable</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecHash2SideTableDestroy</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hashtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hashtable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * free exprcontext
	 */</comment>
	<expr_stmt><expr><call><name>ExecFreeExprContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * shut down the subplan
	 */</comment>
	<expr_stmt><expr><name>outerPlan</name> <operator>=</operator> <call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><name>outerPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------
 *		ExecHash2SideTableCreate
 *
 *		create an empty hashtable data structure for hashjoin.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>HashJoinTable</name></type>
<name>ExecHash2SideTableCreate</name><parameter_list>(<parameter><decl><type><name>Hash2SideState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>hashOperators</name></decl></parameter>,
						 <parameter><decl><type><name>double</name></type> <name>ntuples</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>npaths</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>hops</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>spacePeak</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>outerNode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nbuckets</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nbatch</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>log2_nbuckets</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nkeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ho</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Get information about the size of the relation to be hashed (it's the
	 * "outer" subtree of this node, but the inner relation of the hashjoin).
	 * Compute the appropriate size of the hash table.
	 */</comment>
	<expr_stmt><expr><name>outerNode</name> <operator>=</operator> <call><name>outerPlan</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecChooseHash2SideTableSize</name><argument_list>(<argument><expr><name>ntuples</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>totalPaths</name></name></expr></argument>, <argument><expr><name><name>outerNode</name><operator>-&gt;</operator><name>plan_width</name></name></expr></argument>, <argument><expr><name>hops</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>nbuckets</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nbatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* nbuckets must be a power of 2 */</comment>
	<expr_stmt><expr><name>log2_nbuckets</name> <operator>=</operator> <call><name>my_log2</name><argument_list>(<argument><expr><name>nbuckets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nbuckets</name> <operator>==</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>log2_nbuckets</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize the hash table control block.
	 *
	 * The hashtable control block is just palloc'd from the executor's
	 * per-query memory context.
	 */</comment>
	<expr_stmt><expr><name>hashtable</name> <operator>=</operator> <operator>(</operator><name>HashJoinTable</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTableData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name> <operator>=</operator> <name>nbuckets</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets_original</name></name> <operator>=</operator> <name>nbuckets</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets_optimal</name></name> <operator>=</operator> <name>nbuckets</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>log2_nbuckets</name></name> <operator>=</operator> <name>log2_nbuckets</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>log2_nbuckets_optimal</name></name> <operator>=</operator> <name>log2_nbuckets</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name><operator>.</operator><name>unshared</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>keepNulls</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewEnabled</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewBucket</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewBucketLen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nSkewBuckets</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewBucketNums</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name> <operator>=</operator> <name>nbatch</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbatch_original</name></name> <operator>=</operator> <name>nbatch</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbatch_outstart</name></name> <operator>=</operator> <name>nbatch</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>growEnabled</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>totalTuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewTuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spacePeak</name></name> <operator>=</operator> <name>spacePeak</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceAllowed</name></name> <operator>=</operator> <name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsedSkew</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceAllowedSkew</name></name> <operator>=</operator>
			<name><name>hashtable</name><operator>-&gt;</operator><name>spaceAllowed</name></name> <operator>*</operator> <name>SKEW_HASH_MEM_PERCENT</name> <operator>/</operator> <literal type="number">100</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>totalPaths</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HJDEBUG</name></cpp:ifdef>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Shortestpath %p: initial nbatch = %d, nbuckets = %d\n"</literal></expr></argument>,
		   <argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>nbatch</name></expr></argument>, <argument><expr><name>nbuckets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Get info about the hash functions to be used for each hash key. Also
	 * remember whether the join operators are strict.
	 */</comment>
	<expr_stmt><expr><name>nkeys</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>hashOperators</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>outer_hashfunctions</name></name> <operator>=</operator>
			<operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>inner_hashfunctions</name></name> <operator>=</operator>
			<operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>hashStrict</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>ho</argument>, <argument>hashOperators</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>hashop</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>ho</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>left_hashfn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>right_hashfn</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_op_hash_functions</name><argument_list>(<argument><expr><name>hashop</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>left_hashfn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>right_hashfn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find hash function for hash operator %u"</literal></expr></argument>,
				 <argument><expr><name>hashop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>left_hashfn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>hashtable</name><operator>-&gt;</operator><name>outer_hashfunctions</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>right_hashfn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>hashtable</name><operator>-&gt;</operator><name>inner_hashfunctions</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>hashStrict</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>op_strict</name><argument_list>(<argument><expr><name>hashop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Create temporary memory contexts in which to keep the hashtable working
	 * storage.  See notes in executor/hashjoin.h.
	 */</comment>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>hashCxt</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
											   <argument><expr><literal type="string">"Hash2SideTableContext"</literal></expr></argument>,
											   <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>batchCxt</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>hashCxt</name></name></expr></argument>,
												<argument><expr><literal type="string">"Hash2SideBatchContext"</literal></expr></argument>,
												<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Allocate data that will live for the life of the hashjoin */</comment>

	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>hashCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nbatch</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * allocate and initialize the file arrays in hashCxt
		 */</comment>
		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name></name> <operator>=</operator> <operator>(</operator><name>BufFile</name> <operator>*</operator><operator>*</operator><operator>)</operator>
				<call><name>palloc0</name><argument_list>(<argument><expr><name>nbatch</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BufFile</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name></name> <operator>=</operator> <operator>(</operator><name>BufFile</name> <operator>*</operator><operator>*</operator><operator>)</operator>
				<call><name>palloc0</name><argument_list>(<argument><expr><name>nbatch</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BufFile</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* The files will not be opened until needed... */</comment>
		<comment type="block">/* ... but make sure we have temp tablespaces established for them */</comment>
		<expr_stmt><expr><call><name>PrepareTempTablespaces</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Prepare context for the first-scan space allocations; allocate the
	 * hashbucket array therein, and set each bucket "empty".
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>batchCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name><operator>.</operator><name>unshared</name></name> <operator>=</operator> <operator>(</operator><name>HashJoinTuple</name> <operator>*</operator><operator>)</operator>
			<call><name>palloc0</name><argument_list>(<argument><expr><name>nbuckets</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTuple</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>hashtable</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>HashJoinTable</name></type>
<name>ExecHash2SideTableClone</name><parameter_list>(<parameter><decl><type><name>Hash2SideState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>hashOperators</name></decl></parameter>,
						<parameter><decl><type><name>HashJoinTable</name></type> <name>sourcetable</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>spacePeak</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HashJoinTable</name></type>  <name>hashtable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			   <name>nkeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			   <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>      <modifier>*</modifier></type><name>ho</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type>  <name>oldcxt</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Initialize the hash table control block.
	 *
	 * The hashtable control block is just palloc'd from the executor's
	 * per-query memory context.
	 */</comment>
	<expr_stmt><expr><name>hashtable</name> <operator>=</operator> <operator>(</operator><name>HashJoinTable</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTableData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name> <operator>=</operator> <name><name>sourcetable</name><operator>-&gt;</operator><name>nbuckets</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets_original</name></name> <operator>=</operator> <name><name>sourcetable</name><operator>-&gt;</operator><name>nbuckets</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets_optimal</name></name> <operator>=</operator> <name><name>sourcetable</name><operator>-&gt;</operator><name>nbuckets</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>log2_nbuckets</name></name> <operator>=</operator> <name><name>sourcetable</name><operator>-&gt;</operator><name>log2_nbuckets</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>log2_nbuckets_optimal</name></name> <operator>=</operator> <name><name>sourcetable</name><operator>-&gt;</operator><name>log2_nbuckets</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name><operator>.</operator><name>unshared</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>keepNulls</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewEnabled</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewBucket</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewBucketLen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nSkewBuckets</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewBucketNums</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name> <operator>=</operator> <name><name>sourcetable</name><operator>-&gt;</operator><name>nbatch</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbatch_original</name></name> <operator>=</operator> <name><name>sourcetable</name><operator>-&gt;</operator><name>nbatch</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbatch_outstart</name></name> <operator>=</operator> <name><name>sourcetable</name><operator>-&gt;</operator><name>nbatch</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>growEnabled</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>totalTuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>skewTuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spacePeak</name></name> <operator>=</operator> <name>spacePeak</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceAllowed</name></name> <operator>=</operator> <name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsedSkew</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceAllowedSkew</name></name> <operator>=</operator>
			<name><name>hashtable</name><operator>-&gt;</operator><name>spaceAllowed</name></name> <operator>*</operator> <name>SKEW_HASH_MEM_PERCENT</name> <operator>/</operator> <literal type="number">100</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>totalPaths</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HJDEBUG</name></cpp:ifdef>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Shortestpath %p: initial nbatch = %d, nbuckets = %d\n"</literal></expr></argument>,
		   <argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name><name>sourcetable</name><operator>-&gt;</operator><name>nbatch</name></name></expr></argument>, <argument><expr><name><name>sourcetable</name><operator>-&gt;</operator><name>nbuckets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Get info about the hash functions to be used for each hash key. Also
	 * remember whether the join operators are strict.
	 */</comment>
	<expr_stmt><expr><name>nkeys</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>hashOperators</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>outer_hashfunctions</name></name> <operator>=</operator>
			<operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>inner_hashfunctions</name></name> <operator>=</operator>
			<operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>hashStrict</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>ho</argument>, <argument>hashOperators</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>hashop</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>ho</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>left_hashfn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>right_hashfn</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_op_hash_functions</name><argument_list>(<argument><expr><name>hashop</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>left_hashfn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>right_hashfn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find hash function for hash operator %u"</literal></expr></argument>,
				 <argument><expr><name>hashop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>left_hashfn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>hashtable</name><operator>-&gt;</operator><name>outer_hashfunctions</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>right_hashfn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>hashtable</name><operator>-&gt;</operator><name>inner_hashfunctions</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>hashStrict</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>op_strict</name><argument_list>(<argument><expr><name>hashop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Create temporary memory contexts in which to keep the hashtable working
	 * storage.  See notes in executor/hashjoin.h.
	 */</comment>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>hashCxt</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
											   <argument><expr><literal type="string">"Hash2SideTableContext"</literal></expr></argument>,
											   <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>batchCxt</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>hashCxt</name></name></expr></argument>,
												<argument><expr><literal type="string">"Hash2SideBatchContext"</literal></expr></argument>,
												<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Allocate data that will live for the life of the hashjoin */</comment>

	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>hashCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * allocate and initialize the file arrays in hashCxt
		 */</comment>
		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name></name> <operator>=</operator> <operator>(</operator><name>BufFile</name> <operator>*</operator><operator>*</operator><operator>)</operator>
				<call><name>palloc0</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BufFile</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name></name> <operator>=</operator> <operator>(</operator><name>BufFile</name> <operator>*</operator><operator>*</operator><operator>)</operator>
				<call><name>palloc0</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BufFile</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* The files will not be opened until needed... */</comment>
		<comment type="block">/* ... but make sure we have temp tablespaces established for them */</comment>
		<expr_stmt><expr><call><name>PrepareTempTablespaces</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Prepare context for the first-scan space allocations; allocate the
	 * hashbucket array therein, and set each bucket "empty".
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>batchCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name><operator>.</operator><name>unshared</name></name> <operator>=</operator> <operator>(</operator><name>HashJoinTuple</name> <operator>*</operator><operator>)</operator>
			<call><name>palloc0</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTuple</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>hashtable</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Compute appropriate size for hashtable given the estimated size of the
 * relation to be hashed (number of rows and average row width).
 *
 * This is exported so that the planner's costsize.c can use it.
 */</comment>

<comment type="block">/* Target bucket loading (tuples per bucket) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTUP_PER_BUCKET</name></cpp:macro>			<cpp:value>1</cpp:value></cpp:define>

<function><type><name>void</name></type>
<name>ExecChooseHash2SideTableSize</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>ntuples</name></decl></parameter>,
							 <parameter><decl><type><name>double</name></type> <name>npaths</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>tupwidth</name></decl></parameter>,
							 <parameter><decl><type><name>long</name></type> <name>hops</name></decl></parameter>,
							 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numbuckets</name></decl></parameter>,
							 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numbatches</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>tupsize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>inner_rel_bytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>bucket_bytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>hash_table_bytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>max_pointers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>mppow2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nbatch</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nbuckets</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>dbuckets</name></decl>;</decl_stmt>

	<comment type="block">/* Force a plausible relation size if no info */</comment>
	<if_stmt><if>if <condition>(<expr><name>npaths</name> <operator>&lt;=</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>npaths</name> <operator>=</operator> <literal type="number">1000.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>ntuples</name> <operator>&lt;=</operator> <name>npaths</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ntuples</name> <operator>=</operator> <name>npaths</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Estimate tupsize based on footprint of tuple in hashtable... note this
	 * does not allow for any palloc overhead.  The manipulations of spaceUsed
	 * don't count palloc overhead either.
	 */</comment>
	<expr_stmt><expr><name>tupsize</name> <operator>=</operator> <name>HJTUPLE_OVERHEAD</name> <operator>+</operator>
			  <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>SizeofMinimalTupleHeader</name></expr></argument>)</argument_list></call> <operator>+</operator>
			  <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>tupwidth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>inner_rel_bytes</name> <operator>=</operator> <operator>(</operator><name>ntuples</name> <operator>-</operator> <name>npaths</name><operator>)</operator> <operator>*</operator> <name>tupsize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupsize</name> <operator>=</operator> <name>HJTUPLE_OVERHEAD</name> <operator>+</operator>
			  <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>SizeofMinimalTupleHeader</name></expr></argument>)</argument_list></call> <operator>+</operator>
			  <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>tupwidth</name> <operator>*</operator> <name>hops</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Graphid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>inner_rel_bytes</name> <operator>+=</operator> <name>npaths</name> <operator>*</operator> <name>tupsize</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Target in-memory hashtable size is work_mem kilobytes.
	 */</comment>
	<expr_stmt><expr><name>hash_table_bytes</name> <operator>=</operator> <name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set nbuckets to achieve an average bucket load of NTUP_PER_BUCKET when
	 * memory is filled, assuming a single batch; but limit the value so that
	 * the pointer arrays we'll try to allocate do not exceed work_mem nor
	 * MaxAllocSize.
	 *
	 * Note that both nbuckets and nbatch must be powers of 2 to make
	 * ExecHash2SideGetBucketAndBatch fast.
	 */</comment>
	<expr_stmt><expr><name>max_pointers</name> <operator>=</operator> <operator>(</operator><name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal><operator>)</operator> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTuple</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>max_pointers</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>max_pointers</name></expr></argument>, <argument><expr><name>MaxAllocSize</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTuple</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* If max_pointers isn't a power of 2, must round it down to one */</comment>
	<expr_stmt><expr><name>mppow2</name> <operator>=</operator> <literal type="number">1L</literal> <operator>&lt;&lt;</operator> <call><name>my_log2</name><argument_list>(<argument><expr><name>max_pointers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>max_pointers</name> <operator>!=</operator> <name>mppow2</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>max_pointers</name> <operator>=</operator> <name>mppow2</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Also ensure we avoid integer overflow in nbatch and nbuckets */</comment>
	<comment type="block">/* (this step is redundant given the current value of MaxAllocSize) */</comment>
	<expr_stmt><expr><name>max_pointers</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>max_pointers</name></expr></argument>, <argument><expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>dbuckets</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name>ntuples</name> <operator>/</operator> <name>NTUP_PER_BUCKET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dbuckets</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>dbuckets</name></expr></argument>, <argument><expr><name>max_pointers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nbuckets</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>dbuckets</name></expr>;</expr_stmt>
	<comment type="block">/* don't let nbuckets be really small, though ... */</comment>
	<expr_stmt><expr><name>nbuckets</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>nbuckets</name></expr></argument>, <argument><expr><literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* ... and force it to be a power of 2. */</comment>
	<expr_stmt><expr><name>nbuckets</name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <call><name>my_log2</name><argument_list>(<argument><expr><name>nbuckets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there's not enough space to store the projected number of tuples and
	 * the required bucket headers, we will need multiple batches.
	 */</comment>
	<expr_stmt><expr><name>bucket_bytes</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTuple</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nbuckets</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>inner_rel_bytes</name> <operator>+</operator> <name>bucket_bytes</name> <operator>&gt;</operator> <name>hash_table_bytes</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We'll need multiple batches */</comment>
		<decl_stmt><decl><type><name>long</name></type>		<name>lbuckets</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>dbatch</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>minbatch</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>long</name></type>		<name>bucket_size</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Estimate the number of buckets we'll want to have when work_mem is
		 * entirely full.  Each bucket will contain a bucket pointer plus
		 * NTUP_PER_BUCKET tuples, whose projected size already includes
		 * overhead for the hash code, pointer to the next tuple, etc.
		 */</comment>
		<expr_stmt><expr><name>bucket_size</name> <operator>=</operator> <operator>(</operator><name>tupsize</name> <operator>*</operator> <name>NTUP_PER_BUCKET</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTuple</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>lbuckets</name> <operator>=</operator> <literal type="number">1L</literal> <operator>&lt;&lt;</operator> <call><name>my_log2</name><argument_list>(<argument><expr><name>hash_table_bytes</name> <operator>/</operator> <name>bucket_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lbuckets</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>lbuckets</name></expr></argument>, <argument><expr><name>max_pointers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nbuckets</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>lbuckets</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nbuckets</name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <call><name>my_log2</name><argument_list>(<argument><expr><name>nbuckets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bucket_bytes</name> <operator>=</operator> <name>nbuckets</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTuple</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

		<comment type="block">/*
		 * Buckets are simple pointers to hashjoin tuples, while tupsize
		 * includes the pointer, hash code, and MinimalTupleData.  So buckets
		 * should never really exceed 25% of work_mem (even for
		 * NTUP_PER_BUCKET=1); except maybe for work_mem values that are not
		 * 2^N bytes, where we might get more because of doubling. So let's
		 * look for 50% here.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bucket_bytes</name> <operator>&lt;=</operator> <name>hash_table_bytes</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Calculate required number of batches. */</comment>
		<expr_stmt><expr><name>dbatch</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name>inner_rel_bytes</name> <operator>/</operator> <operator>(</operator><name>hash_table_bytes</name> <operator>-</operator> <name>bucket_bytes</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dbatch</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>dbatch</name></expr></argument>, <argument><expr><name>max_pointers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>minbatch</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>dbatch</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nbatch</name> <operator>=</operator> <call><name>pg_nextpower2_32</name><argument_list>(<argument><expr><call><name>Max</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>minbatch</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nbuckets</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nbatch</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>numbuckets</name> <operator>=</operator> <name>nbuckets</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>numbatches</name> <operator>=</operator> <name>nbatch</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------
 *		ExecHash2SideTableDestroy
 *
 *		destroy a hash table
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecHash2SideTableDestroy</name><parameter_list>(<parameter><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Make sure all the temp files are closed.  We skip batch 0, since it
	 * can't have any temp files (and the arrays might not even exist if
	 * nbatch is only 1).
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name></name></expr>)</condition><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>BufFileClose</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name></name></expr>)</condition><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>BufFileClose</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>outer_hashfunctions</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>outer_hashfunctions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>inner_hashfunctions</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>inner_hashfunctions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>hashStrict</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>hashStrict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Release working memory (batchCxt is a child, so it goes away too) */</comment>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>hashCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* And drop the control block */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecHash2SideIncreaseNumBatches
 *		increase the original number of batches in order to reduce
 *		current memory consumption
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecHash2SideIncreaseNumBatches</name><parameter_list>(<parameter><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>oldnbatch</name> <init>= <expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>curbatch</name> <init>= <expr><name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nbatch</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>ninmemory</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>nfreed</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HashMemoryChunk</name></type> <name>oldchunks</name></decl>;</decl_stmt>

	<comment type="block">/* do nothing if we've decided to shut off growth */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>hashtable</name><operator>-&gt;</operator><name>growEnabled</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* safety check to avoid overflow */</comment>
	<if_stmt><if>if <condition>(<expr><name>oldnbatch</name> <operator>&gt;</operator> <call><name>Min</name><argument_list>(<argument><expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>MaxAllocSize</name> <operator>/</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>nbatch</name> <operator>=</operator> <name>oldnbatch</name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nbatch</name> <operator>&gt;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HJDEBUG</name></cpp:ifdef>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Shortestpath %p: increasing nbatch to %d because space = %zu\n"</literal></expr></argument>,
		   <argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>nbatch</name></expr></argument>, <argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>hashCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we had no file arrays before */</comment>
		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name></name> <operator>=</operator> <operator>(</operator><name>BufFile</name> <operator>*</operator><operator>*</operator><operator>)</operator>
				<call><name>palloc0</name><argument_list>(<argument><expr><name>nbatch</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BufFile</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name></name> <operator>=</operator> <operator>(</operator><name>BufFile</name> <operator>*</operator><operator>*</operator><operator>)</operator>
				<call><name>palloc0</name><argument_list>(<argument><expr><name>nbatch</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BufFile</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* time to establish the temp tablespaces, too */</comment>
		<expr_stmt><expr><call><name>PrepareTempTablespaces</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* enlarge arrays and zero out added entries */</comment>
		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name></name> <operator>=</operator> <operator>(</operator><name>BufFile</name> <operator>*</operator><operator>*</operator><operator>)</operator>
				<call><name>repalloc</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name></name></expr></argument>, <argument><expr><name>nbatch</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BufFile</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name></name> <operator>=</operator> <operator>(</operator><name>BufFile</name> <operator>*</operator><operator>*</operator><operator>)</operator>
				<call><name>repalloc</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name></name></expr></argument>, <argument><expr><name>nbatch</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BufFile</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name></name> <operator>+</operator> <name>oldnbatch</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
			   <argument><expr><operator>(</operator><name>nbatch</name> <operator>-</operator> <name>oldnbatch</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BufFile</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>outerBatchFile</name></name> <operator>+</operator> <name>oldnbatch</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
			   <argument><expr><operator>(</operator><name>nbatch</name> <operator>-</operator> <name>oldnbatch</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BufFile</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name> <operator>=</operator> <name>nbatch</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Scan through the existing hash table entries and dump out any that are
	 * no longer of the current batch.
	 */</comment>
	<expr_stmt><expr><name>ninmemory</name> <operator>=</operator> <name>nfreed</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* If know we need to resize nbuckets, we can do it while rebatching. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets_optimal</name></name> <operator>!=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we never decrease the number of buckets */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets_optimal</name></name> <operator>&gt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets_optimal</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>log2_nbuckets</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>log2_nbuckets_optimal</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name><operator>.</operator><name>unshared</name></name> <operator>=</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name><operator>.</operator><name>unshared</name></name></expr></argument>,
											   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTuple</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We will scan through the chunks directly, so that we can reset the
	 * buckets now and not have to keep track which tuples in the buckets have
	 * already been processed. We will free the old chunks as we go.
	 */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name><operator>.</operator><name>unshared</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTuple</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldchunks</name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* so, let's scan through the old chunks, and all tuples in each chunk */</comment>
	<while>while <condition>(<expr><name>oldchunks</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HashMemoryChunk</name></type> <name>nextchunk</name> <init>= <expr><name><name>oldchunks</name><operator>-&gt;</operator><name>next</name><operator>.</operator><name>unshared</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* position within the buffer (up to oldchunks-&gt;used) */</comment>
		<decl_stmt><decl><type><name>size_t</name></type>		<name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/* process all tuples stored in this chunk (and then free it) */</comment>
		<while>while <condition>(<expr><name>idx</name> <operator>&lt;</operator> <name><name>oldchunks</name><operator>-&gt;</operator><name>used</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HashJoinTuple</name></type> <name>hashTuple</name> <init>= <expr><operator>(</operator><name>HashJoinTuple</name><operator>)</operator> <operator>(</operator><call><name>HASH_CHUNK_DATA</name><argument_list>(<argument><expr><name>oldchunks</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>idx</name><operator>)</operator></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>MinimalTuple</name></type> <name>tuple</name> <init>= <expr><call><name>HJTUPLE_MINTUPLE</name><argument_list>(<argument><expr><name>hashTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>hashTupleSize</name> <init>= <expr><operator>(</operator><name>HJTUPLE_OVERHEAD</name> <operator>+</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>bucketno</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>batchno</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>ninmemory</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExecHash2SideGetBucketAndBatch</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name><name>hashTuple</name><operator>-&gt;</operator><name>hashvalue</name></name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>bucketno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>batchno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>batchno</name> <operator>==</operator> <name>curbatch</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* keep tuple in memory - copy it into the new chunk */</comment>
				<decl_stmt><decl><type><name>HashJoinTuple</name></type> <name>copyTuple</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>copyTuple</name> <operator>=</operator> <operator>(</operator><name>HashJoinTuple</name><operator>)</operator> <call><name>dense_alloc</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>hashTupleSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>copyTuple</name></expr></argument>, <argument><expr><name>hashTuple</name></expr></argument>, <argument><expr><name>hashTupleSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* and add it back to the appropriate bucket */</comment>
				<expr_stmt><expr><name><name>copyTuple</name><operator>-&gt;</operator><name>next</name><operator>.</operator><name>unshared</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name><operator>.</operator><name>unshared</name><index>[<expr><name>bucketno</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name><operator>.</operator><name>unshared</name><index>[<expr><name>bucketno</name></expr>]</index></name> <operator>=</operator> <name>copyTuple</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* dump it out */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>batchno</name> <operator>&gt;</operator> <name>curbatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExecShortestpathSaveTuple</name><argument_list>(<argument><expr><call><name>HJTUPLE_MINTUPLE</name><argument_list>(<argument><expr><name>hashTuple</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name><name>hashTuple</name><operator>-&gt;</operator><name>hashvalue</name></name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>batchno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>-=</operator> <name>hashTupleSize</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>nfreed</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/* next tuple in this chunk */</comment>
			<expr_stmt><expr><name>idx</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>hashTupleSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* allow this loop to be cancellable */</comment>
			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>

		<comment type="block">/* we're done with this chunk - free it and proceed to the next one */</comment>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>oldchunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldchunks</name> <operator>=</operator> <name>nextchunk</name></expr>;</expr_stmt>
	</block_content>}</block></while>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HJDEBUG</name></cpp:ifdef>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Shortestpath %p: freed %ld of %ld tuples, space now %zu\n"</literal></expr></argument>,
		   <argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>nfreed</name></expr></argument>, <argument><expr><name>ninmemory</name></expr></argument>, <argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * If we dumped out either all or none of the tuples in the table, disable
	 * further expansion of nbatch.  This situation implies that we have
	 * enough tuples of identical hashvalues to overflow spaceAllowed.
	 * Increasing nbatch will not fix it since there's no way to subdivide the
	 * group any more finely. We have to just gut it out and hope the server
	 * has enough RAM.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nfreed</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>nfreed</name> <operator>==</operator> <name>ninmemory</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>growEnabled</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HJDEBUG</name></cpp:ifdef>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Shortestpath %p: disabling further increase of nbatch\n"</literal></expr></argument>,
			   <argument><expr><name>hashtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecHash2SideIncreaseNumBuckets
 *		increase the original number of buckets in order to reduce
 *		number of tuples per bucket
 */</comment>
<function><type><name>void</name></type>
<name>ExecHash2SideIncreaseNumBuckets</name><parameter_list>(<parameter><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl></parameter>, <parameter><decl><type><name>Hash2SideState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HashMemoryChunk</name></type>    <name>chunk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShortestpathState</name> <modifier>*</modifier></type><name>spstate</name> <init>= <expr><operator>(</operator><name>ShortestpathState</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>spstate</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* do nothing if not an increase (it's called increase for a reason) */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name> <operator>&gt;=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets_optimal</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HJDEBUG</name></cpp:ifdef>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Shortestpath %p: increasing nbuckets %d =&gt; %d\n"</literal></expr></argument>,
		   <argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name></expr></argument>, <argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets_optimal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets_optimal</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>log2_nbuckets</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>log2_nbuckets_optimal</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name> <operator>&lt;=</operator> <operator>(</operator><name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name> <operator>==</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>log2_nbuckets</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Just reallocate the proper number of buckets - we don't need to walk
	 * through them - we can walk the dense-allocated chunks (just like in
	 * ExecHash2SideIncreaseNumBatches, but without all the copying into new
	 * chunks)
	 */</comment>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name><operator>.</operator><name>unshared</name></name> <operator>=</operator>
			<operator>(</operator><name>HashJoinTuple</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name><operator>.</operator><name>unshared</name></name></expr></argument>,
									   <argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTuple</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name><operator>.</operator><name>unshared</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTuple</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* scan through all tuples in all chunks to rebuild the hash table */</comment>
	<for>for <control>(<init><expr><name>chunk</name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name></name></expr>;</init> <condition><expr><name>chunk</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>chunk</name> <operator>=</operator> <name><name>chunk</name><operator>-&gt;</operator><name>next</name><operator>.</operator><name>unshared</name></name></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* process all tuples stored in this chunk */</comment>
		<decl_stmt><decl><type><name>size_t</name></type>		<name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><name>idx</name> <operator>&lt;</operator> <name><name>chunk</name><operator>-&gt;</operator><name>used</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HashJoinTuple</name></type> <name>hashTuple</name> <init>= <expr><operator>(</operator><name>HashJoinTuple</name><operator>)</operator> <operator>(</operator><call><name>HASH_CHUNK_DATA</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>idx</name><operator>)</operator></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>MinimalTuple</name></type>  <name>tuple</name> <init>= <expr><call><name>HJTUPLE_MINTUPLE</name><argument_list>(<argument><expr><name>hashTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HashJoinTuple</name></type> <name>cursorTuple</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>MinimalTuple</name></type>  <name>body</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>           <name>bucketno</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>           <name>batchno</name></decl>;</decl_stmt>

			<comment type="block">/* advance index past the tuple */</comment>
			<expr_stmt><expr><name>idx</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>HJTUPLE_OVERHEAD</name> <operator>+</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><operator>(</operator><name>Graphid</name><operator>*</operator><operator>)</operator><operator>(</operator><name>tuple</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ExecHash2SideGetBucketAndBatch</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name><name>hashTuple</name><operator>-&gt;</operator><name>hashvalue</name></name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>bucketno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>batchno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>tuple</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Graphid</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>spstate</name><operator>-&gt;</operator><name>sp_RowidSize</name></name></expr>)</condition>
				<block>{<block_content>
					<for>for <control>(<init><expr><name>cursorTuple</name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name><operator>.</operator><name>unshared</name><index>[<expr><name>bucketno</name></expr>]</index></name></expr>;</init>
						 <condition><expr><name>cursorTuple</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
						 <incr><expr><name>cursorTuple</name> <operator>=</operator> <name><name>cursorTuple</name><operator>-&gt;</operator><name>next</name><operator>.</operator><name>unshared</name></name></expr></incr>)</control>
					<block>{<block_content>
						<expr_stmt><expr><name>body</name> <operator>=</operator> <call><name>HJTUPLE_MINTUPLE</name><argument_list>(<argument><expr><name>cursorTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>spstate</name><operator>-&gt;</operator><name>limit</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator>
							 <name><name>body</name><operator>-&gt;</operator><name>t_len</name></name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>tuple</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Graphid</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>spstate</name><operator>-&gt;</operator><name>sp_RowidSize</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
							<operator>*</operator><operator>(</operator><operator>(</operator><name>Graphid</name><operator>*</operator><operator>)</operator><operator>(</operator><name>body</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>==</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>Graphid</name><operator>*</operator><operator>)</operator><operator>(</operator><name>tuple</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>totalTuples</name></name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>totalPaths</name></name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
							<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>Graphid</name><operator>*</operator><operator>)</operator><operator>(</operator><name>tuple</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></for>
					<if_stmt><if>if <condition>(<expr><name>cursorTuple</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* add the tuple to the proper bucket */</comment>
				<expr_stmt><expr><name><name>hashTuple</name><operator>-&gt;</operator><name>next</name><operator>.</operator><name>unshared</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name><operator>.</operator><name>unshared</name><index>[<expr><name>bucketno</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name><operator>.</operator><name>unshared</name><index>[<expr><name>bucketno</name></expr>]</index></name> <operator>=</operator> <name>hashTuple</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>tuple</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Graphid</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>spstate</name><operator>-&gt;</operator><name>sp_RowidSize</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>cursorTuple</name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name><operator>.</operator><name>unshared</name><index>[<expr><name>bucketno</name></expr>]</index></name></expr>;</expr_stmt>
					<while>while <condition>(<expr><name><name>cursorTuple</name><operator>-&gt;</operator><name>next</name><operator>.</operator><name>unshared</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>body</name> <operator>=</operator> <call><name>HJTUPLE_MINTUPLE</name><argument_list>(<argument><expr><name><name>cursorTuple</name><operator>-&gt;</operator><name>next</name><operator>.</operator><name>unshared</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><operator>(</operator><name>Graphid</name><operator>*</operator><operator>)</operator><operator>(</operator><name>body</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>==</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>Graphid</name><operator>*</operator><operator>)</operator><operator>(</operator><name>tuple</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>totalTuples</name></name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>t_len</name></name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>tuple</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Graphid</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>spstate</name><operator>-&gt;</operator><name>sp_RowidSize</name></name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>totalPaths</name></name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
							<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>Graphid</name><operator>*</operator><operator>)</operator><operator>(</operator><name>body</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>cursorTuple</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>cursorTuple</name><operator>-&gt;</operator><name>next</name><operator>.</operator><name>unshared</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
							<continue>continue;</continue>
						</block_content>}</block></if></if_stmt>
						<expr_stmt><expr><name>cursorTuple</name> <operator>=</operator> <name><name>cursorTuple</name><operator>-&gt;</operator><name>next</name><operator>.</operator><name>unshared</name></name></expr>;</expr_stmt>
					</block_content>}</block></while>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></while>

		<comment type="block">/* allow this loop to be cancellable */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
 * ExecHash2SideTableInsert
 *		insert a tuple into the hash table depending on the hash value
 *		it may just go to a temp file for later batches
 *
 * Note: the passed TupleTableSlot may contain a regular, minimal, or virtual
 * tuple; the minimal case in particular is certain to happen while reloading
 * tuples from batch files.  We could save some cycles in the regular-tuple
 * case by not forcing the slot contents into minimal form; not clear if it's
 * worth the messiness required.
 */</comment>
<function><type><name>bool</name></type>
<name>ExecHash2SideTableInsert</name><parameter_list>(<parameter><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl></parameter>,
						 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
						 <parameter><decl><type><name>uint32</name></type> <name>hashvalue</name></decl></parameter>,
						 <parameter><decl><type><name>Hash2SideState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
						 <parameter><decl><type><name>ShortestpathState</name> <modifier>*</modifier></type><name>spstate</name></decl></parameter>,
						 <parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>saved</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>shouldFree</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MinimalTuple</name></type> <name>tuple</name> <init>= <expr><call><name>ExecFetchSlotMinimalTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shouldFree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>inserted</name> <init>=  <expr><call><name>ExecHash2SideTableInsertTuple</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>,
												   <argument><expr><name>tuple</name></expr></argument>,
												   <argument><expr><name>hashvalue</name></expr></argument>,
												   <argument><expr><name>node</name></expr></argument>,
												   <argument><expr><name>spstate</name></expr></argument>,
												   <argument><expr><name>saved</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>shouldFree</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>heap_free_minimal_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>inserted</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ExecHash2SideTableInsertTuple</name><parameter_list>(<parameter><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl></parameter>,
							  <parameter><decl><type><name>MinimalTuple</name></type> <name>tuple</name></decl></parameter>,
							  <parameter><decl><type><name>uint32</name></type> <name>hashvalue</name></decl></parameter>,
							  <parameter><decl><type><name>Hash2SideState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
							  <parameter><decl><type><name>ShortestpathState</name> <modifier>*</modifier></type><name>spstate</name></decl></parameter>,
							  <parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>saved</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>bucketno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>batchno</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExecHash2SideGetBucketAndBatch</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>bucketno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>batchno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * decide whether to put the tuple in the hash table or a temp file
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>batchno</name> <operator>==</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * put the tuple in hash table
		 */</comment>
		<decl_stmt><decl><type><name>HashJoinTuple</name></type> <name>hashTuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MinimalTuple</name></type> <name>body</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>hashTupleSize</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>ntuples</name> <init>= <expr><operator>(</operator><name><name>hashtable</name><operator>-&gt;</operator><name>totalTuples</name></name> <operator>-</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>skewTuples</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>tuple</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Graphid</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>spstate</name><operator>-&gt;</operator><name>sp_RowidSize</name></name></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>hashTuple</name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name><operator>.</operator><name>unshared</name><index>[<expr><name>bucketno</name></expr>]</index></name></expr>;</init>
				 <condition><expr><name>hashTuple</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
				 <incr><expr><name>hashTuple</name> <operator>=</operator> <name><name>hashTuple</name><operator>-&gt;</operator><name>next</name><operator>.</operator><name>unshared</name></name></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>body</name> <operator>=</operator> <call><name>HJTUPLE_MINTUPLE</name><argument_list>(<argument><expr><name>hashTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>spstate</name><operator>-&gt;</operator><name>limit</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator>
					 <name><name>body</name><operator>-&gt;</operator><name>t_len</name></name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>tuple</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Graphid</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>spstate</name><operator>-&gt;</operator><name>sp_RowidSize</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
					<operator>*</operator><operator>(</operator><operator>(</operator><name>Graphid</name><operator>*</operator><operator>)</operator><operator>(</operator><name>body</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>==</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>Graphid</name><operator>*</operator><operator>)</operator><operator>(</operator><name>tuple</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Create the HashJoinTuple */</comment>
		<expr_stmt><expr><name>hashTupleSize</name> <operator>=</operator> <name>HJTUPLE_OVERHEAD</name> <operator>+</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hashTuple</name> <operator>=</operator> <operator>(</operator><name>HashJoinTuple</name><operator>)</operator> <call><name>dense_alloc</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>, <argument><expr><name>hashTupleSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>hashTuple</name><operator>-&gt;</operator><name>hashvalue</name></name> <operator>=</operator> <name>hashvalue</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>HJTUPLE_MINTUPLE</name><argument_list>(<argument><expr><name>hashTuple</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We always reset the tuple-matched flag on insertion.  This is okay
		 * even when reloading a tuple from a batch file, since the tuple
		 * could not possibly have been matched to an outer tuple before it
		 * went into the batch file.
		 */</comment>
		<expr_stmt><expr><call><name>HeapTupleHeaderClearMatch</name><argument_list>(<argument><expr><call><name>HJTUPLE_MINTUPLE</name><argument_list>(<argument><expr><name>hashTuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Push it onto the front of the bucket's list */</comment>
		<expr_stmt><expr><name><name>hashTuple</name><operator>-&gt;</operator><name>next</name><operator>.</operator><name>unshared</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name><operator>.</operator><name>unshared</name><index>[<expr><name>bucketno</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name><operator>.</operator><name>unshared</name><index>[<expr><name>bucketno</name></expr>]</index></name> <operator>=</operator> <name>hashTuple</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>tuple</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Graphid</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>spstate</name><operator>-&gt;</operator><name>sp_RowidSize</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>hashTuple</name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name><operator>.</operator><name>unshared</name><index>[<expr><name>bucketno</name></expr>]</index></name></expr>;</expr_stmt>
			<while>while <condition>(<expr><name><name>hashTuple</name><operator>-&gt;</operator><name>next</name><operator>.</operator><name>unshared</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>body</name> <operator>=</operator> <call><name>HJTUPLE_MINTUPLE</name><argument_list>(<argument><expr><name><name>hashTuple</name><operator>-&gt;</operator><name>next</name><operator>.</operator><name>unshared</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><operator>(</operator><name>Graphid</name><operator>*</operator><operator>)</operator><operator>(</operator><name>body</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>==</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>Graphid</name><operator>*</operator><operator>)</operator><operator>(</operator><name>tuple</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>totalTuples</name></name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>t_len</name></name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>tuple</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Graphid</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>spstate</name><operator>-&gt;</operator><name>sp_RowidSize</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>totalPaths</name></name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>Graphid</name><operator>*</operator><operator>)</operator><operator>(</operator><name>body</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>hashTuple</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>hashTuple</name><operator>-&gt;</operator><name>next</name><operator>.</operator><name>unshared</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>hashTuple</name> <operator>=</operator> <name><name>hashTuple</name><operator>-&gt;</operator><name>next</name><operator>.</operator><name>unshared</name></name></expr>;</expr_stmt>
			</block_content>}</block></while>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Increase the (optimal) number of buckets if we just exceeded the
		 * NTUP_PER_BUCKET threshold, but only when there's still a single
		 * batch.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
			<name>ntuples</name> <operator>&gt;</operator> <operator>(</operator><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets_optimal</name></name> <operator>*</operator> <name>NTUP_PER_BUCKET</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Guard against integer overflow and alloc size overflow */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets_optimal</name></name> <operator>&lt;=</operator> <name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
				<name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets_optimal</name></name> <operator>*</operator> <literal type="number">2</literal> <operator>&lt;=</operator> <name>MaxAllocSize</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTuple</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets_optimal</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>log2_nbuckets_optimal</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Account for space used, and back off if we've used too much */</comment>
		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>+=</operator> <name>hashTupleSize</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>&gt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>spacePeak</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spacePeak</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>+</operator>
			<name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets_optimal</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTuple</name></expr></argument>)</argument_list></sizeof>
			<operator>&gt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>spaceAllowed</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecHash2SideIncreaseNumBatches</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * put the tuple into a temp file for later batches
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>batchno</name> <operator>&gt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>curbatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecShortestpathSaveTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
								  <argument><expr><name>hashvalue</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name><name>hashtable</name><operator>-&gt;</operator><name>innerBatchFile</name><index>[<expr><name>batchno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>saved</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>(</operator><operator>*</operator><name>saved</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ExecHash2SideTableInsertGraphid</name><parameter_list>(<parameter><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl></parameter>,
								<parameter><decl><type><name>Graphid</name></type> <name>id</name></decl></parameter>,
								<parameter><decl><type><name>uint32</name></type> <name>hashvalue</name></decl></parameter>,
								<parameter><decl><type><name>Hash2SideState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
								<parameter><decl><type><name>ShortestpathState</name> <modifier>*</modifier></type><name>spstate</name></decl></parameter>,
								<parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>saved</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>Graphid</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>spstate</name><operator>-&gt;</operator><name>sp_GraphidTuple</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>=</operator> <name>id</name></expr>;</expr_stmt>

	<return>return <expr><call><name>ExecHash2SideTableInsertTuple</name><argument_list>(<argument><expr><name>hashtable</name></expr></argument>,
										 <argument><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_GraphidTuple</name></name></expr></argument>,
										 <argument><expr><name>hashvalue</name></expr></argument>,
										 <argument><expr><name>node</name></expr></argument>,
										 <argument><expr><name>spstate</name></expr></argument>,
										 <argument><expr><name>saved</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecHash2SideGetBucketAndBatch
 *		Determine the bucket number and batch number for a hash value
 *
 * Note: on-the-fly increases of nbatch must not change the bucket number
 * for a given hash code (since we don't move tuples to different hash
 * chains), and must only cause the batch number to remain the same or
 * increase.  Our algorithm is
 *		bucketno = hashvalue MOD nbuckets
 *		batchno = (hashvalue DIV nbuckets) MOD nbatch
 * where nbuckets and nbatch are both expected to be powers of 2, so we can
 * do the computations by shifting and masking.  (This assumes that all hash
 * functions are good about randomizing all their output bits, else we are
 * likely to have very skewed bucket or batch occupancy.)
 *
 * nbuckets and log2_nbuckets may change while nbatch == 1 because of dynamic
 * bucket count growth.  Once we start batching, the value is fixed and does
 * not change over the course of the join (making it possible to compute batch
 * number the way we do here).
 *
 * nbatch is always a power of 2; we increase it only by doubling it.  This
 * effectively adds one more bit to the top of the batchno.
 */</comment>
<function><type><name>void</name></type>
<name>ExecHash2SideGetBucketAndBatch</name><parameter_list>(<parameter><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl></parameter>,
							   <parameter><decl><type><name>uint32</name></type> <name>hashvalue</name></decl></parameter>,
							   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>bucketno</name></decl></parameter>,
							   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>batchno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>nbuckets</name> <init>= <expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>nbatch</name> <init>= <expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>nbatch</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we can do MOD by masking, DIV by shifting */</comment>
		<expr_stmt><expr><operator>*</operator><name>bucketno</name> <operator>=</operator> <name>hashvalue</name> <operator>&amp;</operator> <operator>(</operator><name>nbuckets</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>batchno</name> <operator>=</operator> <operator>(</operator><name>hashvalue</name> <operator>&gt;&gt;</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>log2_nbuckets</name></name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>nbatch</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>bucketno</name> <operator>=</operator> <name>hashvalue</name> <operator>&amp;</operator> <operator>(</operator><name>nbuckets</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>batchno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecScanHash2SideBucket
 *		scan a hash bucket for matches to the current outer tuple
 *
 * The current outer tuple must be stored in econtext-&gt;ecxt_outertuple.
 *
 * On success, the inner tuple is stored into spstate-&gt;sp_CurTuple and
 * econtext-&gt;ecxt_innertuple, using spstate-&gt;sp_HashTupleSlot as the slot
 * for the latter.
 */</comment>
<function><type><name>bool</name></type>
<name>ExecScanHash2SideBucket</name><parameter_list>(<parameter><decl><type><name>Hash2SideState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
						<parameter><decl><type><name>ShortestpathState</name> <modifier>*</modifier></type><name>spstate</name></decl></parameter>,
						<parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>spclauses</name> <init>= <expr><name><name>spstate</name><operator>-&gt;</operator><name>hashclauses</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HashJoinTable</name></type> <name>hashtable</name> <init>= <expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_HashTable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HashJoinTuple</name></type> <name>hashTuple</name> <init>= <expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_CurTuple</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>hashvalue</name> <init>= <expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_CurHashValue</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * sp_CurTuple is the address of the tuple last returned from the current
	 * bucket, or NULL if it's time to start scanning a new bucket.
	 *
	 * If the tuple hashed to a skew bucket then scan the skew bucket
	 * otherwise scan the standard hashtable bucket.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>hashTuple</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>hashTuple</name> <operator>=</operator> <name><name>hashTuple</name><operator>-&gt;</operator><name>next</name><operator>.</operator><name>unshared</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>hashTuple</name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name><operator>.</operator><name>unshared</name><index>[<expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_CurBucketNo</name></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<while>while <condition>(<expr><name>hashTuple</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>hashTuple</name><operator>-&gt;</operator><name>hashvalue</name></name> <operator>==</operator> <name>hashvalue</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>inntuple</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>MinimalTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>HJTUPLE_MINTUPLE</name><argument_list>(<argument><expr><name>hashTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* insert hashtable's tuple into exec slot so ExecQual sees it */</comment>
			<expr_stmt><expr><name>inntuple</name> <operator>=</operator> <call><name>ExecStoreMinimalTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
											 <argument><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_HashTupleSlot</name></name></expr></argument>,
											 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* do not pfree */</comment>
			<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_innertuple</name></name> <operator>=</operator> <name>inntuple</name></expr>;</expr_stmt>

			<comment type="block">/* reset temp memory each time to avoid leaks from qual expr */</comment>
			<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>hops</name></name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator>
				 <name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>tuple</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Graphid</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>spstate</name><operator>-&gt;</operator><name>sp_RowidSize</name></name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>ExecQual</name><argument_list>(<argument><expr><name>spclauses</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>spstate</name><operator>-&gt;</operator><name>sp_CurTuple</name></name> <operator>=</operator> <name>hashTuple</name></expr>;</expr_stmt>
					<return>return <expr><name>true</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>hashTuple</name> <operator>=</operator> <name><name>hashTuple</name><operator>-&gt;</operator><name>next</name><operator>.</operator><name>unshared</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * no match
	 */</comment>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecHash2SideTableReset
 *
 *		reset hash table header for new batch
 */</comment>
<function><type><name>void</name></type>
<name>ExecHash2SideTableReset</name><parameter_list>(<parameter><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nbuckets</name> <init>= <expr><name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Release all the hash buckets and tuples acquired in the prior pass, and
	 * reinitialize the context for a new pass.
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>batchCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>batchCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reallocate and reinitialize the hash bucket headers. */</comment>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>buckets</name><operator>.</operator><name>unshared</name></name> <operator>=</operator> <operator>(</operator><name>HashJoinTuple</name> <operator>*</operator><operator>)</operator>
			<call><name>palloc0</name><argument_list>(<argument><expr><name>nbuckets</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashJoinTuple</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>spaceUsed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Forget the chunks (the memory was freed by the context reset above). */</comment>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecReScanHash2Side</name><parameter_list>(<parameter><decl><type><name>Hash2SideState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>keytable</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>keytable</name><operator>-&gt;</operator><name>spacePeak</name></name> <operator>&gt;</operator> <name><name>node</name><operator>-&gt;</operator><name>spacePeak</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>spacePeak</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>keytable</name><operator>-&gt;</operator><name>spacePeak</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ExecHash2SideTableDestroy</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>keytable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>keytable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>hashtable</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>hashtable</name><operator>-&gt;</operator><name>spacePeak</name></name> <operator>&gt;</operator> <name><name>node</name><operator>-&gt;</operator><name>spacePeak</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>spacePeak</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>hashtable</name><operator>-&gt;</operator><name>spacePeak</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ExecHash2SideTableDestroy</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hashtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hashtable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>ExecReScan</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>lefttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Allocate 'size' bytes from the currently active HashMemoryChunk
 */</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>dense_alloc</name><parameter_list>(<parameter><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HashMemoryChunk</name></type> <name>newChunk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

	<comment type="block">/* just in case the size is not already aligned properly */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If tuple size is larger than of 1/4 of chunk size, allocate a separate
	 * chunk.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&gt;</operator> <name>HASH_CHUNK_THRESHOLD</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* allocate new chunk and put it at the beginning of the list */</comment>
		<expr_stmt><expr><name>newChunk</name> <operator>=</operator> <operator>(</operator><name>HashMemoryChunk</name><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>batchCxt</name></name></expr></argument>,
														<argument><expr><name>HASH_CHUNK_HEADER_SIZE</name> <operator>+</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newChunk</name><operator>-&gt;</operator><name>maxlen</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newChunk</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newChunk</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * Add this chunk to the list after the first existing chunk, so that
		 * we don't lose the remaining space in the "current" chunk.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>newChunk</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name><operator>-&gt;</operator><name>next</name><operator>.</operator><name>unshared</name></name> <operator>=</operator> <name>newChunk</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>newChunk</name><operator>-&gt;</operator><name>next</name><operator>.</operator><name>unshared</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name></name> <operator>=</operator> <name>newChunk</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>newChunk</name><operator>-&gt;</operator><name>used</name></name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newChunk</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<return>return <expr><call><name>HASH_CHUNK_DATA</name><argument_list>(<argument><expr><name>newChunk</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * See if we have enough space for it in the current chunk (if any). If
	 * not, allocate a fresh chunk.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name><operator>-&gt;</operator><name>maxlen</name></name> <operator>-</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name><operator>-&gt;</operator><name>used</name></name><operator>)</operator> <operator>&lt;</operator> <name>size</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* allocate new chunk and put it at the beginning of the list */</comment>
		<expr_stmt><expr><name>newChunk</name> <operator>=</operator> <operator>(</operator><name>HashMemoryChunk</name><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>batchCxt</name></name></expr></argument>,
														<argument><expr><name>HASH_CHUNK_HEADER_SIZE</name> <operator>+</operator> <name>HASH_CHUNK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>newChunk</name><operator>-&gt;</operator><name>maxlen</name></name> <operator>=</operator> <name>HASH_CHUNK_SIZE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newChunk</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newChunk</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>newChunk</name><operator>-&gt;</operator><name>next</name><operator>.</operator><name>unshared</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name></name> <operator>=</operator> <name>newChunk</name></expr>;</expr_stmt>

		<return>return <expr><call><name>HASH_CHUNK_DATA</name><argument_list>(<argument><expr><name>newChunk</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* There is enough space in the current chunk, let's add the tuple */</comment>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>HASH_CHUNK_DATA</name><argument_list>(<argument><expr><name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name><operator>-&gt;</operator><name>used</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name><operator>-&gt;</operator><name>used</name></name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashtable</name><operator>-&gt;</operator><name>chunks</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* return pointer to the start of the tuple memory */</comment>
	<return>return <expr><name>ptr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Copy the instrumentation data from 'hashtable' into a HashInstrumentation
 * struct.
 */</comment>
<function><type><name>void</name></type>
<name>ExecHash2SideGetInstrumentation</name><parameter_list>(<parameter><decl><type><name>HashInstrumentation</name> <modifier>*</modifier></type><name>instrument</name></decl></parameter>,
								<parameter><decl><type><name>HashJoinTable</name></type> <name>hashtable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>instrument</name><operator>-&gt;</operator><name>nbuckets</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>instrument</name><operator>-&gt;</operator><name>nbuckets_original</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbuckets_original</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>instrument</name><operator>-&gt;</operator><name>nbatch</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>instrument</name><operator>-&gt;</operator><name>nbatch_original</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>nbatch_original</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>instrument</name><operator>-&gt;</operator><name>space_peak</name></name> <operator>=</operator> <name><name>hashtable</name><operator>-&gt;</operator><name>spacePeak</name></name></expr>;</expr_stmt>
</block_content>}</block></function></unit>
