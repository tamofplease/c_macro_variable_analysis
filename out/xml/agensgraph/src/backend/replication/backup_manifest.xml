<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/replication/backup_manifest.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * backup_manifest.c
 *	  code for generating and sending a backup manifest
 *
 * Portions Copyright (c) 2010-2020, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *	  src/backend/replication/backup_manifest.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/timeline.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/backup_manifest.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/json.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AppendStringToManifest</name><parameter_list>(<parameter><decl><type><name>backup_manifest_info</name> <modifier>*</modifier></type><name>manifest</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Does the user want a backup manifest?
 *
 * It's simplest to always have a manifest_info object, so that we don't need
 * checks for NULL pointers in too many places. However, if the user doesn't
 * want a manifest, we set manifest-&gt;buffile to NULL.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>IsManifestEnabled</name><parameter_list>(<parameter><decl><type><name>backup_manifest_info</name> <modifier>*</modifier></type><name>manifest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name><name>manifest</name><operator>-&gt;</operator><name>buffile</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convenience macro for appending data to the backup manifest.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AppendToManifest</name><parameter_list>(<parameter><type><name>manifest</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>{ \
		char *_manifest_s = psprintf(__VA_ARGS__);	\
		AppendStringToManifest(manifest, _manifest_s);	\
		pfree(_manifest_s);	\
	}</cpp:value></cpp:define>

<comment type="block">/*
 * Initialize state so that we can construct a backup manifest.
 *
 * NB: Although the checksum type for the data files is configurable, the
 * checksum for the manifest itself always uses SHA-256. See comments in
 * SendBackupManifest.
 */</comment>
<function><type><name>void</name></type>
<name>InitializeBackupManifest</name><parameter_list>(<parameter><decl><type><name>backup_manifest_info</name> <modifier>*</modifier></type><name>manifest</name></decl></parameter>,
						 <parameter><decl><type><name>backup_manifest_option</name></type> <name>want_manifest</name></decl></parameter>,
						 <parameter><decl><type><name>pg_checksum_type</name></type> <name>manifest_checksum_type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>backup_manifest_info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>manifest</name><operator>-&gt;</operator><name>checksum_type</name></name> <operator>=</operator> <name>manifest_checksum_type</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>want_manifest</name> <operator>==</operator> <name>MANIFEST_OPTION_NO</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>manifest</name><operator>-&gt;</operator><name>buffile</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>manifest</name><operator>-&gt;</operator><name>buffile</name></name> <operator>=</operator> <call><name>BufFileCreateTemp</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_sha256_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>manifest</name><operator>-&gt;</operator><name>manifest_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>manifest</name><operator>-&gt;</operator><name>manifest_size</name></name> <operator>=</operator> <call><name>UINT64CONST</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>manifest</name><operator>-&gt;</operator><name>force_encode</name></name> <operator>=</operator> <operator>(</operator><name>want_manifest</name> <operator>==</operator> <name>MANIFEST_OPTION_FORCE_ENCODE</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>manifest</name><operator>-&gt;</operator><name>first_file</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>manifest</name><operator>-&gt;</operator><name>still_checksumming</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>want_manifest</name> <operator>!=</operator> <name>MANIFEST_OPTION_NO</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AppendToManifest</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>,
						 <argument><expr><literal type="string">"{ \"PostgreSQL-Backup-Manifest-Version\": 1,\n"</literal>
						 <literal type="string">"\"Files\": ["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add an entry to the backup manifest for a file.
 */</comment>
<function><type><name>void</name></type>
<name>AddFileToBackupManifest</name><parameter_list>(<parameter><decl><type><name>backup_manifest_info</name> <modifier>*</modifier></type><name>manifest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>spcoid</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pathname</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>pg_time_t</name></type> <name>mtime</name></decl></parameter>,
						<parameter><decl><type><name>pg_checksum_context</name> <modifier>*</modifier></type><name>checksum_ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>pathbuf</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>pathlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsManifestEnabled</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If this file is part of a tablespace, the pathname passed to this
	 * function will be relative to the tar file that contains it. We want the
	 * pathname relative to the data directory (ignoring the intermediate
	 * symlink traversal).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>spcoid</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>pathbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pathbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"pg_tblspc/%s/%s"</literal></expr></argument>, <argument><expr><name>spcoid</name></expr></argument>,
				 <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pathname</name> <operator>=</operator> <name>pathbuf</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Each file's entry needs to be separated from any entry that follows by
	 * a comma, but there's no comma before the first one or after the last
	 * one. To make that work, adding a file to the manifest starts by
	 * terminating the most recently added line, with a comma if appropriate,
	 * but does not terminate the line inserted for this file.
	 */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>manifest</name><operator>-&gt;</operator><name>first_file</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>manifest</name><operator>-&gt;</operator><name>first_file</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">",\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Write the relative pathname to this file out to the manifest. The
	 * manifest is always stored in UTF-8, so we have to encode paths that are
	 * not valid in that encoding.
	 */</comment>
	<expr_stmt><expr><name>pathlen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>manifest</name><operator>-&gt;</operator><name>force_encode</name></name> <operator>&amp;&amp;</operator>
		<call><name>pg_verify_mbstr</name><argument_list>(<argument><expr><name>PG_UTF8</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>pathlen</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"{ \"Path\": "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>escape_json</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"{ \"Encoded-Path\": \""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>enlargeStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <name>pathlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><operator>.</operator><name>len</name></name> <operator>+=</operator> <call><name>hex_encode</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>pathlen</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name><name>buf</name><operator>.</operator><name>data</name><index>[<expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\"Size\": %zu, "</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Convert last modification time to a string and append it to the
	 * manifest. Since it's not clear what time zone to use and since time
	 * zone definitions can change, possibly causing confusion, use GMT
	 * always.
	 */</comment>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\"Last-Modified\": \""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>enlargeStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><operator>.</operator><name>len</name></name> <operator>+=</operator> <call><name>pg_strftime</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf</name><operator>.</operator><name>data</name><index>[<expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>, <argument><expr><literal type="string">"%Y-%m-%d %H:%M:%S %Z"</literal></expr></argument>,
						   <argument><expr><call><name>pg_gmtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mtime</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add checksum information. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>checksum_ctx</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>CHECKSUM_TYPE_NONE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint8</name></type>		<name><name>checksumbuf</name><index>[<expr><name>PG_CHECKSUM_MAX_LENGTH</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>checksumlen</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>checksumlen</name> <operator>=</operator> <call><name>pg_checksum_final</name><argument_list>(<argument><expr><name>checksum_ctx</name></expr></argument>, <argument><expr><name>checksumbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						 <argument><expr><literal type="string">", \"Checksum-Algorithm\": \"%s\", \"Checksum\": \""</literal></expr></argument>,
						 <argument><expr><call><name>pg_checksum_type_name</name><argument_list>(<argument><expr><name><name>checksum_ctx</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>enlargeStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <name>checksumlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><operator>.</operator><name>len</name></name> <operator>+=</operator> <call><name>hex_encode</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>checksumbuf</name></expr></argument>, <argument><expr><name>checksumlen</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name><name>buf</name><operator>.</operator><name>data</name><index>[<expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Close out the object. */</comment>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" }"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* OK, add it to the manifest. */</comment>
	<expr_stmt><expr><call><name>AppendStringToManifest</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Avoid leaking memory. */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add information about the WAL that will need to be replayed when restoring
 * this backup to the manifest.
 */</comment>
<function><type><name>void</name></type>
<name>AddWALInfoToBackupManifest</name><parameter_list>(<parameter><decl><type><name>backup_manifest_info</name> <modifier>*</modifier></type><name>manifest</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>startptr</name></decl></parameter>,
						   <parameter><decl><type><name>TimeLineID</name></type> <name>starttli</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>endptr</name></decl></parameter>,
						   <parameter><decl><type><name>TimeLineID</name></type> <name>endtli</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>timelines</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>first_wal_range</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found_start_timeline</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsManifestEnabled</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Terminate the list of files. */</comment>
	<expr_stmt><expr><call><name>AppendStringToManifest</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><literal type="string">"\n],\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Read the timeline history for the ending timeline. */</comment>
	<expr_stmt><expr><name>timelines</name> <operator>=</operator> <call><name>readTimeLineHistory</name><argument_list>(<argument><expr><name>endtli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Start a list of LSN ranges. */</comment>
	<expr_stmt><expr><call><name>AppendStringToManifest</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><literal type="string">"\"WAL-Ranges\": [\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>timelines</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TimeLineHistoryEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>tl_beginptr</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We only care about timelines that were active during the backup.
		 * Skip any that ended before the backup started. (Note that if
		 * entry-&gt;end is InvalidXLogRecPtr, it means that the timeline has not
		 * yet ended.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>end</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>end</name></name> <operator>&lt;</operator> <name>startptr</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Because the timeline history file lists newer timelines before
		 * older ones, the first timeline we encounter that is new enough to
		 * matter ought to match the ending timeline of the backup.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>first_wal_range</name> <operator>&amp;&amp;</operator> <name>endtli</name> <operator>!=</operator> <name><name>entry</name><operator>-&gt;</operator><name>tli</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"expected end timeline %u but found timeline %u"</literal></expr></argument>,
						   <argument><expr><name>starttli</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>tli</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If this timeline entry matches with the timeline on which the
		 * backup started, WAL needs to be checked from the start LSN of the
		 * backup.  If this entry refers to a newer timeline, WAL needs to be
		 * checked since the beginning of this timeline, so use the LSN where
		 * the timeline began.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>starttli</name> <operator>==</operator> <name><name>entry</name><operator>-&gt;</operator><name>tli</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>tl_beginptr</name> <operator>=</operator> <name>startptr</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>tl_beginptr</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>begin</name></name></expr>;</expr_stmt>

			<comment type="block">/*
			 * If we reach a TLI that has no valid beginning LSN, there can't
			 * be any more timelines in the history after this point, so we'd
			 * better have arrived at the expected starting TLI. If not,
			 * something's gone horribly wrong.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>begin</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"expected start timeline %u but found timeline %u"</literal></expr></argument>,
							   <argument><expr><name>starttli</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>tli</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>AppendToManifest</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>,
						 <argument><expr><literal type="string">"%s{ \"Timeline\": %u, \"Start-LSN\": \"%X/%X\", \"End-LSN\": \"%X/%X\" }"</literal></expr></argument>,
						 <argument><expr><ternary><condition><expr><name>first_wal_range</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">",\n"</literal></expr></else></ternary></expr></argument>,
						 <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>tli</name></name></expr></argument>,
						 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>tl_beginptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>tl_beginptr</name></expr></argument>,
						 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>endptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>endptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>starttli</name> <operator>==</operator> <name><name>entry</name><operator>-&gt;</operator><name>tli</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>found_start_timeline</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>endptr</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>begin</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>first_wal_range</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * The last entry in the timeline history for the ending timeline should
	 * be the ending timeline itself. Verify that this is what we observed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found_start_timeline</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"start timeline %u not found in history of timeline %u"</literal></expr></argument>,
					   <argument><expr><name>starttli</name></expr></argument>, <argument><expr><name>endtli</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Terminate the list of WAL ranges. */</comment>
	<expr_stmt><expr><call><name>AppendStringToManifest</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><literal type="string">"\n],\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Finalize the backup manifest, and send it to the client.
 */</comment>
<function><type><name>void</name></type>
<name>SendBackupManifest</name><parameter_list>(<parameter><decl><type><name>backup_manifest_info</name> <modifier>*</modifier></type><name>manifest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>protobuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type>		<name><name>checksumbuf</name><index>[<expr><name>PG_SHA256_DIGEST_LENGTH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>checksumstringbuf</name><index>[<expr><name>PG_SHA256_DIGEST_STRING_LENGTH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>manifest_bytes_done</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsManifestEnabled</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Append manifest checksum, so that the problems with the manifest itself
	 * can be detected.
	 *
	 * We always use SHA-256 for this, regardless of what algorithm is chosen
	 * for checksumming the files.  If we ever want to make the checksum
	 * algorithm used for the manifest file variable, the client will need a
	 * way to figure out which algorithm to use as close to the beginning of
	 * the manifest file as possible, to avoid having to read the whole thing
	 * twice.
	 */</comment>
	<expr_stmt><expr><name><name>manifest</name><operator>-&gt;</operator><name>still_checksumming</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_sha256_final</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>manifest</name><operator>-&gt;</operator><name>manifest_ctx</name></name></expr></argument>, <argument><expr><name>checksumbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AppendStringToManifest</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><literal type="string">"\"Manifest-Checksum\": \""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>hex_encode</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>checksumbuf</name></expr></argument>, <argument><expr><sizeof>sizeof <name>checksumbuf</name></sizeof></expr></argument>, <argument><expr><name>checksumstringbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checksumstringbuf</name><index>[<expr><name>PG_SHA256_DIGEST_STRING_LENGTH</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AppendStringToManifest</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>checksumstringbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AppendStringToManifest</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><literal type="string">"\"}\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We've written all the data to the manifest file.  Rewind the file so
	 * that we can read it all back.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>BufFileSeek</name><argument_list>(<argument><expr><name><name>manifest</name><operator>-&gt;</operator><name>buffile</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not rewind temporary file"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Send CopyOutResponse message */</comment>
	<expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>protobuf</name></expr></argument>, <argument><expr><literal type="char">'H'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>protobuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* overall format */</comment>
	<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>protobuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* natts */</comment>
	<expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>protobuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Send CopyData messages.
	 *
	 * We choose to read back the data from the temporary file in chunks of
	 * size BLCKSZ; this isn't necessary, but buffile.c uses that as the I/O
	 * size, so it seems to make sense to match that value here.
	 */</comment>
	<while>while <condition>(<expr><name>manifest_bytes_done</name> <operator>&lt;</operator> <name><name>manifest</name><operator>-&gt;</operator><name>manifest_size</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>manifestbuf</name><index>[<expr><name>BLCKSZ</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type>		<name>bytes_to_read</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type>		<name>rc</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>bytes_to_read</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>manifestbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
							<argument><expr><name><name>manifest</name><operator>-&gt;</operator><name>manifest_size</name></name> <operator>-</operator> <name>manifest_bytes_done</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>BufFileRead</name><argument_list>(<argument><expr><name><name>manifest</name><operator>-&gt;</operator><name>buffile</name></name></expr></argument>, <argument><expr><name>manifestbuf</name></expr></argument>, <argument><expr><name>bytes_to_read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>bytes_to_read</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>pq_putmessage</name><argument_list>(<argument><expr><literal type="char">'d'</literal></expr></argument>, <argument><expr><name>manifestbuf</name></expr></argument>, <argument><expr><name>bytes_to_read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>manifest_bytes_done</name> <operator>+=</operator> <name>bytes_to_read</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* No more data, so send CopyDone message */</comment>
	<expr_stmt><expr><call><name>pq_putemptymessage</name><argument_list>(<argument><expr><literal type="char">'c'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Release resources */</comment>
	<expr_stmt><expr><call><name>BufFileClose</name><argument_list>(<argument><expr><name><name>manifest</name><operator>-&gt;</operator><name>buffile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Append a cstring to the manifest.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AppendStringToManifest</name><parameter_list>(<parameter><decl><type><name>backup_manifest_info</name> <modifier>*</modifier></type><name>manifest</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>manifest</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>manifest</name><operator>-&gt;</operator><name>still_checksumming</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_sha256_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>manifest</name><operator>-&gt;</operator><name>manifest_ctx</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint8</name> <operator>*</operator><operator>)</operator> <name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>BufFileWrite</name><argument_list>(<argument><expr><name><name>manifest</name><operator>-&gt;</operator><name>buffile</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>manifest</name><operator>-&gt;</operator><name>manifest_size</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
