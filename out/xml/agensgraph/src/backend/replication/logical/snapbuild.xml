<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/replication/logical/snapbuild.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * snapbuild.c
 *
 *	  Infrastructure for building historic catalog snapshots based on contents
 *	  of the WAL, for the purpose of decoding heapam.c style values in the
 *	  WAL.
 *
 * NOTES:
 *
 * We build snapshots which can *only* be used to read catalog contents and we
 * do so by reading and interpreting the WAL stream. The aim is to build a
 * snapshot that behaves the same as a freshly taken MVCC snapshot would have
 * at the time the XLogRecord was generated.
 *
 * To build the snapshots we reuse the infrastructure built for Hot
 * Standby. The in-memory snapshots we build look different than HS' because
 * we have different needs. To successfully decode data from the WAL we only
 * need to access catalog tables and (sys|rel|cat)cache, not the actual user
 * tables since the data we decode is wholly contained in the WAL
 * records. Also, our snapshots need to be different in comparison to normal
 * MVCC ones because in contrast to those we cannot fully rely on the clog and
 * pg_subtrans for information about committed transactions because they might
 * commit in the future from the POV of the WAL entry we're currently
 * decoding. This definition has the advantage that we only need to prevent
 * removal of catalog rows, while normal table's rows can still be
 * removed. This is achieved by using the replication slot mechanism.
 *
 * As the percentage of transactions modifying the catalog normally is fairly
 * small in comparisons to ones only manipulating user data, we keep track of
 * the committed catalog modifying ones inside [xmin, xmax) instead of keeping
 * track of all running transactions like it's done in a normal snapshot. Note
 * that we're generally only looking at transactions that have acquired an
 * xid. That is we keep a list of transactions between snapshot-&gt;(xmin, xmax)
 * that we consider committed, everything else is considered aborted/in
 * progress. That also allows us not to care about subtransactions before they
 * have committed which means this module, in contrast to HS, doesn't have to
 * care about suboverflowed subtransactions and similar.
 *
 * One complexity of doing this is that to e.g. handle mixed DDL/DML
 * transactions we need Snapshots that see intermediate versions of the
 * catalog in a transaction. During normal operation this is achieved by using
 * CommandIds/cmin/cmax. The problem with that however is that for space
 * efficiency reasons only one value of that is stored
 * (cf. combocid.c). Since ComboCids are only available in memory we log
 * additional information which allows us to get the original (cmin, cmax)
 * pair during visibility checks. Check the reorderbuffer.c's comment above
 * ResolveCminCmaxDuringDecoding() for details.
 *
 * To facilitate all this we need our own visibility routine, as the normal
 * ones are optimized for different usecases.
 *
 * To replace the normal catalog snapshots with decoding ones use the
 * SetupHistoricSnapshot() and TeardownHistoricSnapshot() functions.
 *
 *
 *
 * The snapbuild machinery is starting up in several stages, as illustrated
 * by the following graph describing the SnapBuild-&gt;state transitions:
 *
 *		   +-------------------------+
 *	  +----|		 START			 |-------------+
 *	  |    +-------------------------+			   |
 *	  |					|						   |
 *	  |					|						   |
 *	  |		   running_xacts #1					   |
 *	  |					|						   |
 *	  |					|						   |
 *	  |					v						   |
 *	  |    +-------------------------+			   v
 *	  |    |   BUILDING_SNAPSHOT	 |------------&gt;|
 *	  |    +-------------------------+			   |
 *	  |					|						   |
 *	  |					|						   |
 *	  | running_xacts #2, xacts from #1 finished   |
 *	  |					|						   |
 *	  |					|						   |
 *	  |					v						   |
 *	  |    +-------------------------+			   v
 *	  |    |	   FULL_SNAPSHOT	 |------------&gt;|
 *	  |    +-------------------------+			   |
 *	  |					|						   |
 * running_xacts		|					   saved snapshot
 * with zero xacts		|				  at running_xacts's lsn
 *	  |					|						   |
 *	  | running_xacts with xacts from #2 finished  |
 *	  |					|						   |
 *	  |					v						   |
 *	  |    +-------------------------+			   |
 *	  +---&gt;|SNAPBUILD_CONSISTENT	 |&lt;------------+
 *		   +-------------------------+
 *
 * Initially the machinery is in the START stage. When an xl_running_xacts
 * record is read that is sufficiently new (above the safe xmin horizon),
 * there's a state transition. If there were no running xacts when the
 * running_xacts record was generated, we'll directly go into CONSISTENT
 * state, otherwise we'll switch to the BUILDING_SNAPSHOT state. Having a full
 * snapshot means that all transactions that start henceforth can be decoded
 * in their entirety, but transactions that started previously can't. In
 * FULL_SNAPSHOT we'll switch into CONSISTENT once all those previously
 * running transactions have committed or aborted.
 *
 * Only transactions that commit after CONSISTENT state has been reached will
 * be replayed, even though they might have started while still in
 * FULL_SNAPSHOT. That ensures that we'll reach a point where no previous
 * changes has been exported, but all the following ones will be. That point
 * is a convenient point to initialize replication from, which is why we
 * export a snapshot at that point, which *can* be used to read normal data.
 *
 * Copyright (c) 2012-2020, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *	  src/backend/replication/snapbuild.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam_xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/logical.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/reorderbuffer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/snapbuild.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/block.h"</cpp:file></cpp:include>		<comment type="block">/* debugging output */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/standby.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapshot.h"</cpp:file></cpp:include>

<comment type="block">/*
 * This struct contains the current state of the snapshot building
 * machinery. Besides a forward declaration in the header, it is not exposed
 * to the public, so we can easily change its contents.
 */</comment>
<struct>struct <name>SnapBuild</name>
<block>{
	<comment type="block">/* how far are we along building our first full snapshot */</comment>
	<decl_stmt><decl><type><name>SnapBuildState</name></type> <name>state</name></decl>;</decl_stmt>

	<comment type="block">/* private memory context used to allocate memory for this module. */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>context</name></decl>;</decl_stmt>

	<comment type="block">/* all transactions &lt; than this have committed/aborted */</comment>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xmin</name></decl>;</decl_stmt>

	<comment type="block">/* all transactions &gt;= than this are uncommitted */</comment>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xmax</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Don't replay commits from an LSN &lt; this LSN. This can be set externally
	 * but it will also be advanced (never retreat) from within snapbuild.c.
	 */</comment>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>start_decoding_at</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Don't start decoding WAL until the "xl_running_xacts" information
	 * indicates there are no running xids with an xid smaller than this.
	 */</comment>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>initial_xmin_horizon</name></decl>;</decl_stmt>

	<comment type="block">/* Indicates if we are building full snapshot or just catalog one. */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>building_full_snapshot</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Snapshot that's valid to see the catalog state seen at this moment.
	 */</comment>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snapshot</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * LSN of the last location we are sure a snapshot has been serialized to.
	 */</comment>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>last_serialized_snapshot</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The reorderbuffer we need to update with usable snapshots et al.
	 */</comment>
	<decl_stmt><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>reorder</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Outdated: This struct isn't used for its original purpose anymore, but
	 * can't be removed / changed in a minor version, because it's stored
	 * on-disk.
	 */</comment>
	<struct>struct
	<block>{
		<comment type="block">/*
		 * NB: This field is misused, until a major version can break on-disk
		 * compatibility. See SnapBuildNextPhaseAt() /
		 * SnapBuildStartNextPhaseAt().
		 */</comment>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>was_xmin</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>was_xmax</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>size_t</name></type>		<name>was_xcnt</name></decl>;</decl_stmt>	<comment type="block">/* number of used xip entries */</comment>
		<decl_stmt><decl><type><name>size_t</name></type>		<name>was_xcnt_space</name></decl>;</decl_stmt> <comment type="block">/* allocated size of xip */</comment>
		<decl_stmt><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>was_xip</name></decl>;</decl_stmt> <comment type="block">/* running xacts array, xidComparator-sorted */</comment>
	}</block>			<decl><name>was_running</name></decl>;</struct>

	<comment type="block">/*
	 * Array of transactions which could have catalog changes that committed
	 * between xmin and xmax.
	 */</comment>
	<struct>struct
	<block>{
		<comment type="block">/* number of committed transactions */</comment>
		<decl_stmt><decl><type><name>size_t</name></type>		<name>xcnt</name></decl>;</decl_stmt>

		<comment type="block">/* available space for committed transactions */</comment>
		<decl_stmt><decl><type><name>size_t</name></type>		<name>xcnt_space</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Until we reach a CONSISTENT state, we record commits of all
		 * transactions, not just the catalog changing ones. Record when that
		 * changes so we know we cannot export a snapshot safely anymore.
		 */</comment>
		<decl_stmt><decl><type><name>bool</name></type>		<name>includes_all_transactions</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Array of committed transactions that have modified the catalog.
		 *
		 * As this array is frequently modified we do *not* keep it in
		 * xidComparator order. Instead we sort the array when building &amp;
		 * distributing a snapshot.
		 *
		 * TODO: It's unclear whether that reasoning has much merit. Every
		 * time we add something here after becoming consistent will also
		 * require distributing a snapshot. Storing them sorted would
		 * potentially also make it easier to purge (but more complicated wrt
		 * wraparound?). Should be improved if sorting while building the
		 * snapshot shows up in profiles.
		 */</comment>
		<decl_stmt><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>xip</name></decl>;</decl_stmt>
	}</block>			<decl><name>committed</name></decl>;</struct>
}</block>;</struct>

<comment type="block">/*
 * Starting a transaction -- which we need to do while exporting a snapshot --
 * removes knowledge about the previously used resowner, so we save it here.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>ResourceOwner</name></type> <name>SavedResourceOwnerDuringExport</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>ExportInProgress</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* -&gt;committed manipulation */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SnapBuildPurgeCommittedTxn</name><parameter_list>(<parameter><decl><type><name>SnapBuild</name> <modifier>*</modifier></type><name>builder</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* snapshot building/manipulation/distribution functions */</comment>
<function_decl><type><specifier>static</specifier> <name>Snapshot</name></type> <name>SnapBuildBuildSnapshot</name><parameter_list>(<parameter><decl><type><name>SnapBuild</name> <modifier>*</modifier></type><name>builder</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SnapBuildFreeSnapshot</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>snap</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SnapBuildSnapIncRefcount</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>snap</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SnapBuildDistributeNewCatalogSnapshot</name><parameter_list>(<parameter><decl><type><name>SnapBuild</name> <modifier>*</modifier></type><name>builder</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* xlog reading helper functions for SnapBuildProcessRunningXacts */</comment>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>SnapBuildFindSnapshot</name><parameter_list>(<parameter><decl><type><name>SnapBuild</name> <modifier>*</modifier></type><name>builder</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>xl_running_xacts</name> <modifier>*</modifier></type><name>running</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SnapBuildWaitSnapshot</name><parameter_list>(<parameter><decl><type><name>xl_running_xacts</name> <modifier>*</modifier></type><name>running</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>cutoff</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* serialization functions */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SnapBuildSerialize</name><parameter_list>(<parameter><decl><type><name>SnapBuild</name> <modifier>*</modifier></type><name>builder</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>SnapBuildRestore</name><parameter_list>(<parameter><decl><type><name>SnapBuild</name> <modifier>*</modifier></type><name>builder</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Return TransactionId after which the next phase of initial snapshot
 * building will happen.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>TransactionId</name></type>
<name>SnapBuildNextPhaseAt</name><parameter_list>(<parameter><decl><type><name>SnapBuild</name> <modifier>*</modifier></type><name>builder</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * For backward compatibility reasons this has to be stored in the wrongly
	 * named field.  Will be fixed in next major version.
	 */</comment>
	<return>return <expr><name><name>builder</name><operator>-&gt;</operator><name>was_running</name><operator>.</operator><name>was_xmax</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Set TransactionId after which the next phase of initial snapshot building
 * will happen.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>SnapBuildStartNextPhaseAt</name><parameter_list>(<parameter><decl><type><name>SnapBuild</name> <modifier>*</modifier></type><name>builder</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>at</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * For backward compatibility reasons this has to be stored in the wrongly
	 * named field.  Will be fixed in next major version.
	 */</comment>
	<expr_stmt><expr><name><name>builder</name><operator>-&gt;</operator><name>was_running</name><operator>.</operator><name>was_xmax</name></name> <operator>=</operator> <name>at</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Allocate a new snapshot builder.
 *
 * xmin_horizon is the xid &gt;= which we can be sure no catalog rows have been
 * removed, start_lsn is the LSN &gt;= we want to replay commits.
 */</comment>
<function><type><name>SnapBuild</name> <modifier>*</modifier></type>
<name>AllocateSnapshotBuilder</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>reorder</name></decl></parameter>,
						<parameter><decl><type><name>TransactionId</name></type> <name>xmin_horizon</name></decl></parameter>,
						<parameter><decl><type><name>XLogRecPtr</name></type> <name>start_lsn</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>need_full_snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SnapBuild</name>  <modifier>*</modifier></type><name>builder</name></decl>;</decl_stmt>

	<comment type="block">/* allocate memory in own context, to have better accountability */</comment>
	<expr_stmt><expr><name>context</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
									<argument><expr><literal type="string">"snapshot builder context"</literal></expr></argument>,
									<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>builder</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SnapBuild</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>builder</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>SNAPBUILD_START</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>builder</name><operator>-&gt;</operator><name>context</name></name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>builder</name><operator>-&gt;</operator><name>reorder</name></name> <operator>=</operator> <name>reorder</name></expr>;</expr_stmt>
	<comment type="block">/* Other struct members initialized by zeroing via palloc0 above */</comment>

	<expr_stmt><expr><name><name>builder</name><operator>-&gt;</operator><name>committed</name><operator>.</operator><name>xcnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>builder</name><operator>-&gt;</operator><name>committed</name><operator>.</operator><name>xcnt_space</name></name> <operator>=</operator> <literal type="number">128</literal></expr>;</expr_stmt>	<comment type="block">/* arbitrary number */</comment>
	<expr_stmt><expr><name><name>builder</name><operator>-&gt;</operator><name>committed</name><operator>.</operator><name>xip</name></name> <operator>=</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>committed</name><operator>.</operator><name>xcnt_space</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>builder</name><operator>-&gt;</operator><name>committed</name><operator>.</operator><name>includes_all_transactions</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>builder</name><operator>-&gt;</operator><name>initial_xmin_horizon</name></name> <operator>=</operator> <name>xmin_horizon</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>builder</name><operator>-&gt;</operator><name>start_decoding_at</name></name> <operator>=</operator> <name>start_lsn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>builder</name><operator>-&gt;</operator><name>building_full_snapshot</name></name> <operator>=</operator> <name>need_full_snapshot</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>builder</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Free a snapshot builder.
 */</comment>
<function><type><name>void</name></type>
<name>FreeSnapshotBuilder</name><parameter_list>(<parameter><decl><type><name>SnapBuild</name> <modifier>*</modifier></type><name>builder</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>context</name> <init>= <expr><name><name>builder</name><operator>-&gt;</operator><name>context</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* free snapshot explicitly, that contains some error checking */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>builder</name><operator>-&gt;</operator><name>snapshot</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SnapBuildSnapDecRefcount</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>builder</name><operator>-&gt;</operator><name>snapshot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* other resources are deallocated via memory context reset */</comment>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Free an unreferenced snapshot that has previously been built by us.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SnapBuildFreeSnapshot</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>snap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* make sure we don't get passed an external snapshot */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>snap</name><operator>-&gt;</operator><name>snapshot_type</name></name> <operator>==</operator> <name>SNAPSHOT_HISTORIC_MVCC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* make sure nobody modified our snapshot */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>snap</name><operator>-&gt;</operator><name>curcid</name></name> <operator>==</operator> <name>FirstCommandId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>snap</name><operator>-&gt;</operator><name>suboverflowed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>snap</name><operator>-&gt;</operator><name>takenDuringRecovery</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>snap</name><operator>-&gt;</operator><name>regd_count</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* slightly more likely, so it's checked even without c-asserts */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>snap</name><operator>-&gt;</operator><name>copied</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot free a copied snapshot"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>snap</name><operator>-&gt;</operator><name>active_count</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot free an active snapshot"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>snap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * In which state of snapshot building are we?
 */</comment>
<function><type><name>SnapBuildState</name></type>
<name>SnapBuildCurrentState</name><parameter_list>(<parameter><decl><type><name>SnapBuild</name> <modifier>*</modifier></type><name>builder</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>builder</name><operator>-&gt;</operator><name>state</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Should the contents of transaction ending at 'ptr' be decoded?
 */</comment>
<function><type><name>bool</name></type>
<name>SnapBuildXactNeedsSkip</name><parameter_list>(<parameter><decl><type><name>SnapBuild</name> <modifier>*</modifier></type><name>builder</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>ptr</name> <operator>&lt;</operator> <name><name>builder</name><operator>-&gt;</operator><name>start_decoding_at</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Increase refcount of a snapshot.
 *
 * This is used when handing out a snapshot to some external resource or when
 * adding a Snapshot as builder-&gt;snapshot.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SnapBuildSnapIncRefcount</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>snap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>active_count</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Decrease refcount of a snapshot and free if the refcount reaches zero.
 *
 * Externally visible, so that external resources that have been handed an
 * IncRef'ed Snapshot can adjust its refcount easily.
 */</comment>
<function><type><name>void</name></type>
<name>SnapBuildSnapDecRefcount</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>snap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* make sure we don't get passed an external snapshot */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>snap</name><operator>-&gt;</operator><name>snapshot_type</name></name> <operator>==</operator> <name>SNAPSHOT_HISTORIC_MVCC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* make sure nobody modified our snapshot */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>snap</name><operator>-&gt;</operator><name>curcid</name></name> <operator>==</operator> <name>FirstCommandId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>snap</name><operator>-&gt;</operator><name>suboverflowed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>snap</name><operator>-&gt;</operator><name>takenDuringRecovery</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>snap</name><operator>-&gt;</operator><name>regd_count</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>snap</name><operator>-&gt;</operator><name>active_count</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* slightly more likely, so it's checked even without casserts */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>snap</name><operator>-&gt;</operator><name>copied</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot free a copied snapshot"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>active_count</name></name><operator>--</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>snap</name><operator>-&gt;</operator><name>active_count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SnapBuildFreeSnapshot</name><argument_list>(<argument><expr><name>snap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Build a new snapshot, based on currently committed catalog-modifying
 * transactions.
 *
 * In-progress transactions with catalog access are *not* allowed to modify
 * these snapshots; they have to copy them and fill in appropriate -&gt;curcid
 * and -&gt;subxip/subxcnt values.
 */</comment>
<function><type><specifier>static</specifier> <name>Snapshot</name></type>
<name>SnapBuildBuildSnapshot</name><parameter_list>(<parameter><decl><type><name>SnapBuild</name> <modifier>*</modifier></type><name>builder</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snapshot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>ssize</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>state</name></name> <operator>&gt;=</operator> <name>SNAPBUILD_FULL_SNAPSHOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ssize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SnapshotData</name></expr></argument>)</argument_list></sizeof>
		<operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>builder</name><operator>-&gt;</operator><name>committed</name><operator>.</operator><name>xcnt</name></name>
		<operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">1</literal></expr> <comment type="block">/* toplevel xid */</comment> ;</expr_stmt>

	<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>ssize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>snapshot_type</name></name> <operator>=</operator> <name>SNAPSHOT_HISTORIC_MVCC</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We misuse the original meaning of SnapshotData's xip and subxip fields
	 * to make the more fitting for our needs.
	 *
	 * In the 'xip' array we store transactions that have to be treated as
	 * committed. Since we will only ever look at tuples from transactions
	 * that have modified the catalog it's more efficient to store those few
	 * that exist between xmin and xmax (frequently there are none).
	 *
	 * Snapshots that are used in transactions that have modified the catalog
	 * also use the 'subxip' array to store their toplevel xid and all the
	 * subtransaction xids so we can recognize when we need to treat rows as
	 * visible that are not in xip but still need to be visible. Subxip only
	 * gets filled when the transaction is copied into the context of a
	 * catalog modifying transaction since we otherwise share a snapshot
	 * between transactions. As long as a txn hasn't modified the catalog it
	 * doesn't need to treat any uncommitted rows as visible, so there is no
	 * need for those xids.
	 *
	 * Both arrays are qsort'ed so that we can use bsearch() on them.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>xmax</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xmin</name></name> <operator>=</operator> <name><name>builder</name><operator>-&gt;</operator><name>xmin</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xmax</name></name> <operator>=</operator> <name><name>builder</name><operator>-&gt;</operator><name>xmax</name></name></expr>;</expr_stmt>

	<comment type="block">/* store all transactions to be treated as committed by this snapshot */</comment>
	<expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xip</name></name> <operator>=</operator>
		<operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>snapshot</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SnapshotData</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xcnt</name></name> <operator>=</operator> <name><name>builder</name><operator>-&gt;</operator><name>committed</name><operator>.</operator><name>xcnt</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xip</name></name></expr></argument>,
		   <argument><expr><name><name>builder</name><operator>-&gt;</operator><name>committed</name><operator>.</operator><name>xip</name></name></expr></argument>,
		   <argument><expr><name><name>builder</name><operator>-&gt;</operator><name>committed</name><operator>.</operator><name>xcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* sort so we can bsearch() */</comment>
	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xip</name></name></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xcnt</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>xidComparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initially, subxip is empty, i.e. it's a snapshot to be used by
	 * transactions that don't modify the catalog. Will be filled by
	 * ReorderBufferCopySnap() if necessary.
	 */</comment>
	<expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>subxcnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>subxip</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>suboverflowed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>takenDuringRecovery</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>copied</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>curcid</name></name> <operator>=</operator> <name>FirstCommandId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>active_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>regd_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<return>return <expr><name>snapshot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Build the initial slot snapshot and convert it to a normal snapshot that
 * is understood by HeapTupleSatisfiesMVCC.
 *
 * The snapshot will be usable directly in current transaction or exported
 * for loading in different transaction.
 */</comment>
<function><type><name>Snapshot</name></type>
<name>SnapBuildInitialSnapshot</name><parameter_list>(<parameter><decl><type><name>SnapBuild</name> <modifier>*</modifier></type><name>builder</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>newxip</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>newxcnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>FirstSnapshotSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>XactIsoLevel</name> <operator>==</operator> <name>XACT_REPEATABLE_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>builder</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>SNAPBUILD_CONSISTENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot build an initial slot snapshot before reaching a consistent state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>builder</name><operator>-&gt;</operator><name>committed</name><operator>.</operator><name>includes_all_transactions</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot build an initial slot snapshot, not all transactions are monitored anymore"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* so we don't overwrite the existing value */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot build an initial slot snapshot when MyPgXact-&gt;xmin already is valid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>snap</name> <operator>=</operator> <call><name>SnapBuildBuildSnapshot</name><argument_list>(<argument><expr><name>builder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We know that snap-&gt;xmin is alive, enforced by the logical xmin
	 * mechanism. Due to that we can do this without locks, we're only
	 * changing our own value.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>safeXid</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>safeXid</name> <operator>=</operator> <call><name>GetOldestSafeDecodingTransactionId</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdPrecedesOrEquals</name><argument_list>(<argument><expr><name>safeXid</name></expr></argument>, <argument><expr><name><name>snap</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>xmin</name></name> <operator>=</operator> <name><name>snap</name><operator>-&gt;</operator><name>xmin</name></name></expr>;</expr_stmt>

	<comment type="block">/* allocate in transaction context */</comment>
	<expr_stmt><expr><name>newxip</name> <operator>=</operator> <operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <call><name>GetMaxSnapshotXidCount</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * snapbuild.c builds transactions in an "inverted" manner, which means it
	 * stores committed transactions in -&gt;xip, not ones in progress. Build a
	 * classical snapshot by marking all non-committed transactions as
	 * in-progress. This can be expensive.
	 */</comment>
	<for>for <control>(<init><expr><name>xid</name> <operator>=</operator> <name><name>snap</name><operator>-&gt;</operator><name>xmin</name></name></expr>;</init> <condition><expr><call><name>NormalTransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>snap</name><operator>-&gt;</operator><name>xmax</name></name></expr></argument>)</argument_list></call></expr>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>test</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Check whether transaction committed using the decoding snapshot
		 * meaning of -&gt;xip.
		 */</comment>
		<expr_stmt><expr><name>test</name> <operator>=</operator> <call><name>bsearch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xid</name></expr></argument>, <argument><expr><name><name>snap</name><operator>-&gt;</operator><name>xip</name></name></expr></argument>, <argument><expr><name><name>snap</name><operator>-&gt;</operator><name>xcnt</name></name></expr></argument>,
					   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>xidComparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>test</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>newxcnt</name> <operator>&gt;=</operator> <call><name>GetMaxSnapshotXidCount</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"initial slot snapshot too large"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>newxip</name><index>[<expr><name>newxcnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>TransactionIdAdvance</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* adjust remaining snapshot fields as needed */</comment>
	<expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>snapshot_type</name></name> <operator>=</operator> <name>SNAPSHOT_MVCC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>xcnt</name></name> <operator>=</operator> <name>newxcnt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>xip</name></name> <operator>=</operator> <name>newxip</name></expr>;</expr_stmt>

	<return>return <expr><name>snap</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Export a snapshot so it can be set in another session with SET TRANSACTION
 * SNAPSHOT.
 *
 * For that we need to start a transaction in the current backend as the
 * importing side checks whether the source transaction is still open to make
 * sure the xmin horizon hasn't advanced since then.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>SnapBuildExportSnapshot</name><parameter_list>(<parameter><decl><type><name>SnapBuild</name> <modifier>*</modifier></type><name>builder</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>snapname</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsTransactionOrTransactionBlock</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot export a snapshot from within a transaction"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>SavedResourceOwnerDuringExport</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"can only export one snapshot at a time"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>SavedResourceOwnerDuringExport</name> <operator>=</operator> <name>CurrentResourceOwner</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ExportInProgress</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* There doesn't seem to a nice API to set these */</comment>
	<expr_stmt><expr><name>XactIsoLevel</name> <operator>=</operator> <name>XACT_REPEATABLE_READ</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>XactReadOnly</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>snap</name> <operator>=</operator> <call><name>SnapBuildInitialSnapshot</name><argument_list>(<argument><expr><name>builder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * now that we've built a plain snapshot, make it active and use the
	 * normal mechanisms for exporting it
	 */</comment>
	<expr_stmt><expr><name>snapname</name> <operator>=</operator> <call><name>ExportSnapshot</name><argument_list>(<argument><expr><name>snap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg_plural</name><argument_list>(<argument><expr><literal type="string">"exported logical decoding snapshot: \"%s\" with %u transaction ID"</literal></expr></argument>,
						   <argument><expr><literal type="string">"exported logical decoding snapshot: \"%s\" with %u transaction IDs"</literal></expr></argument>,
						   <argument><expr><name><name>snap</name><operator>-&gt;</operator><name>xcnt</name></name></expr></argument>,
						   <argument><expr><name>snapname</name></expr></argument>, <argument><expr><name><name>snap</name><operator>-&gt;</operator><name>xcnt</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>snapname</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Ensure there is a snapshot and if not build one for current transaction.
 */</comment>
<function><type><name>Snapshot</name></type>
<name>SnapBuildGetOrBuildSnapshot</name><parameter_list>(<parameter><decl><type><name>SnapBuild</name> <modifier>*</modifier></type><name>builder</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>SNAPBUILD_CONSISTENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* only build a new snapshot if we don't have a prebuilt one */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>builder</name><operator>-&gt;</operator><name>snapshot</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>builder</name><operator>-&gt;</operator><name>snapshot</name></name> <operator>=</operator> <call><name>SnapBuildBuildSnapshot</name><argument_list>(<argument><expr><name>builder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* increase refcount for the snapshot builder */</comment>
		<expr_stmt><expr><call><name>SnapBuildSnapIncRefcount</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>builder</name><operator>-&gt;</operator><name>snapshot</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Reset a previously SnapBuildExportSnapshot()'ed snapshot if there is
 * any. Aborts the previously started transaction and resets the resource
 * owner back to its original value.
 */</comment>
<function><type><name>void</name></type>
<name>SnapBuildClearExportedSnapshot</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResourceOwner</name></type> <name>tmpResOwner</name></decl>;</decl_stmt>

	<comment type="block">/* nothing exported, that is the usual case */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ExportInProgress</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"clearing exported snapshot in wrong transaction state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * AbortCurrentTransaction() takes care of resetting the snapshot state,
	 * so remember SavedResourceOwnerDuringExport.
	 */</comment>
	<expr_stmt><expr><name>tmpResOwner</name> <operator>=</operator> <name>SavedResourceOwnerDuringExport</name></expr>;</expr_stmt>

	<comment type="block">/* make sure nothing could have ever happened */</comment>
	<expr_stmt><expr><call><name>AbortCurrentTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>tmpResOwner</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Clear snapshot export state during transaction abort.
 */</comment>
<function><type><name>void</name></type>
<name>SnapBuildResetExportedSnapshotState</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>SavedResourceOwnerDuringExport</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ExportInProgress</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Handle the effects of a single heap change, appropriate to the current state
 * of the snapshot builder and returns whether changes made at (xid, lsn) can
 * be decoded.
 */</comment>
<function><type><name>bool</name></type>
<name>SnapBuildProcessChange</name><parameter_list>(<parameter><decl><type><name>SnapBuild</name> <modifier>*</modifier></type><name>builder</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We can't handle data in transactions if we haven't built a snapshot
	 * yet, so don't store them.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>builder</name><operator>-&gt;</operator><name>state</name></name> <operator>&lt;</operator> <name>SNAPBUILD_FULL_SNAPSHOT</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * No point in keeping track of changes in transactions that we don't have
	 * enough information about to decode. This means that they started before
	 * we got into the SNAPBUILD_FULL_SNAPSHOT state.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>builder</name><operator>-&gt;</operator><name>state</name></name> <operator>&lt;</operator> <name>SNAPBUILD_CONSISTENT</name> <operator>&amp;&amp;</operator>
		<call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><call><name>SnapBuildNextPhaseAt</name><argument_list>(<argument><expr><name>builder</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the reorderbuffer doesn't yet have a snapshot, add one now, it will
	 * be needed to decode the change we're currently processing.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ReorderBufferXidHasBaseSnapshot</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* only build a new snapshot if we don't have a prebuilt one */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>builder</name><operator>-&gt;</operator><name>snapshot</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>builder</name><operator>-&gt;</operator><name>snapshot</name></name> <operator>=</operator> <call><name>SnapBuildBuildSnapshot</name><argument_list>(<argument><expr><name>builder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* increase refcount for the snapshot builder */</comment>
			<expr_stmt><expr><call><name>SnapBuildSnapIncRefcount</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Increase refcount for the transaction we're handing the snapshot
		 * out to.
		 */</comment>
		<expr_stmt><expr><call><name>SnapBuildSnapIncRefcount</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReorderBufferSetBaseSnapshot</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>,
									 <argument><expr><name><name>builder</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Do CommandId/ComboCid handling after reading an xl_heap_new_cid record.
 * This implies that a transaction has done some form of write to system
 * catalogs.
 */</comment>
<function><type><name>void</name></type>
<name>SnapBuildProcessNewCid</name><parameter_list>(<parameter><decl><type><name>SnapBuild</name> <modifier>*</modifier></type><name>builder</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
					   <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>xl_heap_new_cid</name> <modifier>*</modifier></type><name>xlrec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CommandId</name></type>	<name>cid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * we only log new_cid's if a catalog tuple was modified, so mark the
	 * transaction as containing catalog modifications
	 */</comment>
	<expr_stmt><expr><call><name>ReorderBufferXidSetCatalogChanges</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReorderBufferAddNewTupleCids</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>top_xid</name></name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>,
								 <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>target_node</name></name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>target_tid</name></name></expr></argument>,
								 <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>cmin</name></name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>cmax</name></name></expr></argument>,
								 <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>combocid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* figure out new command id */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>cmin</name></name> <operator>!=</operator> <name>InvalidCommandId</name> <operator>&amp;&amp;</operator>
		<name><name>xlrec</name><operator>-&gt;</operator><name>cmax</name></name> <operator>!=</operator> <name>InvalidCommandId</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cid</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>cmin</name></name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>cmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>cmax</name></name> <operator>!=</operator> <name>InvalidCommandId</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cid</name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>cmax</name></name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>cmin</name></name> <operator>!=</operator> <name>InvalidCommandId</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cid</name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>cmin</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>cid</name> <operator>=</operator> <name>InvalidCommandId</name></expr>;</expr_stmt> <comment type="block">/* silence compiler */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"xl_heap_new_cid record without a valid CommandId"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>ReorderBufferAddNewCommandId</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>, <argument><expr><name>cid</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add a new Snapshot to all transactions we're decoding that currently are
 * in-progress so they can see new catalog contents made by the transaction
 * that just committed. This is necessary because those in-progress
 * transactions will use the new catalog's contents from here on (at the very
 * least everything they do needs to be compatible with newer catalog
 * contents).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SnapBuildDistributeNewCatalogSnapshot</name><parameter_list>(<parameter><decl><type><name>SnapBuild</name> <modifier>*</modifier></type><name>builder</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dlist_iter</name></type>	<name>txn_i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Iterate through all toplevel transactions. This can include
	 * subtransactions which we just don't yet know to be that, but that's
	 * fine, they will just get an unnecessary snapshot queued.
	 */</comment>
	<macro><name>dlist_foreach</name><argument_list>(<argument>txn_i</argument>, <argument>&amp;builder-&gt;reorder-&gt;toplevel_by_lsn</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>txn</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>ReorderBufferTXN</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>txn_i</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we don't have a base snapshot yet, there are no changes in this
		 * transaction which in turn implies we don't yet need a snapshot at
		 * all. We'll add a snapshot when the first change gets queued.
		 *
		 * NB: This works correctly even for subtransactions because
		 * ReorderBufferAssignChild() takes care to transfer the base snapshot
		 * to the top-level transaction, and while iterating the changequeue
		 * we'll get the change from the subtxn.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ReorderBufferXidHasBaseSnapshot</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>, <argument><expr><name><name>txn</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"adding a new snapshot to %u at %X/%X"</literal></expr></argument>,
			 <argument><expr><name><name>txn</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * increase the snapshot's refcount for the transaction we are handing
		 * it out to
		 */</comment>
		<expr_stmt><expr><call><name>SnapBuildSnapIncRefcount</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReorderBufferAddSnapshot</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>, <argument><expr><name><name>txn</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>,
								 <argument><expr><name><name>builder</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Keep track of a new catalog changing transaction that has committed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SnapBuildAddCommittedTxn</name><parameter_list>(<parameter><decl><type><name>SnapBuild</name> <modifier>*</modifier></type><name>builder</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>builder</name><operator>-&gt;</operator><name>committed</name><operator>.</operator><name>xcnt</name></name> <operator>==</operator> <name><name>builder</name><operator>-&gt;</operator><name>committed</name><operator>.</operator><name>xcnt_space</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>builder</name><operator>-&gt;</operator><name>committed</name><operator>.</operator><name>xcnt_space</name></name> <operator>=</operator> <name><name>builder</name><operator>-&gt;</operator><name>committed</name><operator>.</operator><name>xcnt_space</name></name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"increasing space for committed transactions to %u"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>builder</name><operator>-&gt;</operator><name>committed</name><operator>.</operator><name>xcnt_space</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>builder</name><operator>-&gt;</operator><name>committed</name><operator>.</operator><name>xip</name></name> <operator>=</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>committed</name><operator>.</operator><name>xip</name></name></expr></argument>,
										  <argument><expr><name><name>builder</name><operator>-&gt;</operator><name>committed</name><operator>.</operator><name>xcnt_space</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * TODO: It might make sense to keep the array sorted here instead of
	 * doing it every time we build a new snapshot. On the other hand this
	 * gets called repeatedly when a transaction with subtransactions commits.
	 */</comment>
	<expr_stmt><expr><name><name>builder</name><operator>-&gt;</operator><name>committed</name><operator>.</operator><name>xip</name><index>[<expr><name><name>builder</name><operator>-&gt;</operator><name>committed</name><operator>.</operator><name>xcnt</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Remove knowledge about transactions we treat as committed that are smaller
 * than -&gt;xmin. Those won't ever get checked via the -&gt;committed array but via
 * the clog machinery, so we don't need to waste memory on them.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SnapBuildPurgeCommittedTxn</name><parameter_list>(<parameter><decl><type><name>SnapBuild</name> <modifier>*</modifier></type><name>builder</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>off</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>workspace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>surviving_xids</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* not ready yet */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* TODO: Neater algorithm than just copying and iterating? */</comment>
	<expr_stmt><expr><name>workspace</name> <operator>=</operator>
		<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>context</name></name></expr></argument>,
						   <argument><expr><name><name>builder</name><operator>-&gt;</operator><name>committed</name><operator>.</operator><name>xcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* copy xids that still are interesting to workspace */</comment>
	<for>for <control>(<init><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>off</name> <operator>&lt;</operator> <name><name>builder</name><operator>-&gt;</operator><name>committed</name><operator>.</operator><name>xcnt</name></name></expr>;</condition> <incr><expr><name>off</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>NormalTransactionIdPrecedes</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>committed</name><operator>.</operator><name>xip</name><index>[<expr><name>off</name></expr>]</index></name></expr></argument>,
										<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<empty_stmt>;</empty_stmt></block_content></block></if>					<comment type="block">/* remove */</comment>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>workspace</name><index>[<expr><name>surviving_xids</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>builder</name><operator>-&gt;</operator><name>committed</name><operator>.</operator><name>xip</name><index>[<expr><name>off</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* copy workspace back to persistent state */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>committed</name><operator>.</operator><name>xip</name></name></expr></argument>, <argument><expr><name>workspace</name></expr></argument>,
		   <argument><expr><name>surviving_xids</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"purged committed transactions from %u to %u, xmin: %u, xmax: %u"</literal></expr></argument>,
		 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>builder</name><operator>-&gt;</operator><name>committed</name><operator>.</operator><name>xcnt</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>surviving_xids</name></expr></argument>,
		 <argument><expr><name><name>builder</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>, <argument><expr><name><name>builder</name><operator>-&gt;</operator><name>xmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>builder</name><operator>-&gt;</operator><name>committed</name><operator>.</operator><name>xcnt</name></name> <operator>=</operator> <name>surviving_xids</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>workspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Handle everything that needs to be done when a transaction commits
 */</comment>
<function><type><name>void</name></type>
<name>SnapBuildCommitTxn</name><parameter_list>(<parameter><decl><type><name>SnapBuild</name> <modifier>*</modifier></type><name>builder</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>nsubxacts</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>subxacts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nxact</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type>		<name>needs_snapshot</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needs_timetravel</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>sub_needs_timetravel</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xmax</name> <init>= <expr><name>xid</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Transactions preceding BUILDING_SNAPSHOT will neither be decoded, nor
	 * will they be part of a snapshot.  So we don't need to record anything.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>builder</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>SNAPBUILD_START</name> <operator>||</operator>
		<operator>(</operator><name><name>builder</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>SNAPBUILD_BUILDING_SNAPSHOT</name> <operator>&amp;&amp;</operator>
		 <call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><call><name>SnapBuildNextPhaseAt</name><argument_list>(<argument><expr><name>builder</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* ensure that only commits after this are getting replayed */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>builder</name><operator>-&gt;</operator><name>start_decoding_at</name></name> <operator>&lt;=</operator> <name>lsn</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>builder</name><operator>-&gt;</operator><name>start_decoding_at</name></name> <operator>=</operator> <name>lsn</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>builder</name><operator>-&gt;</operator><name>state</name></name> <operator>&lt;</operator> <name>SNAPBUILD_CONSISTENT</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* ensure that only commits after this are getting replayed */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>builder</name><operator>-&gt;</operator><name>start_decoding_at</name></name> <operator>&lt;=</operator> <name>lsn</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>builder</name><operator>-&gt;</operator><name>start_decoding_at</name></name> <operator>=</operator> <name>lsn</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If building an exportable snapshot, force xid to be tracked, even
		 * if the transaction didn't modify the catalog.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>builder</name><operator>-&gt;</operator><name>building_full_snapshot</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>needs_timetravel</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>nxact</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>nxact</name> <operator>&lt;</operator> <name>nsubxacts</name></expr>;</condition> <incr><expr><name>nxact</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>subxid</name> <init>= <expr><name><name>subxacts</name><index>[<expr><name>nxact</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Add subtransaction to base snapshot if catalog modifying, we don't
		 * distinguish to toplevel transactions there.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ReorderBufferXidHasCatalogChanges</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>, <argument><expr><name>subxid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>sub_needs_timetravel</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>needs_snapshot</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"found subtransaction %u:%u with catalog changes"</literal></expr></argument>,
				 <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>subxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>SnapBuildAddCommittedTxn</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name>subxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>NormalTransactionIdFollows</name><argument_list>(<argument><expr><name>subxid</name></expr></argument>, <argument><expr><name>xmax</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>xmax</name> <operator>=</operator> <name>subxid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>

		<comment type="block">/*
		 * If we're forcing timetravel we also need visibility information
		 * about subtransaction, so keep track of subtransaction's state, even
		 * if not catalog modifying.  Don't need to distribute a snapshot in
		 * that case.
		 */</comment>
		<if type="elseif">else if <condition>(<expr><name>needs_timetravel</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>SnapBuildAddCommittedTxn</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name>subxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>NormalTransactionIdFollows</name><argument_list>(<argument><expr><name>subxid</name></expr></argument>, <argument><expr><name>xmax</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>xmax</name> <operator>=</operator> <name>subxid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* if top-level modified catalog, it'll need a snapshot */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ReorderBufferXidHasCatalogChanges</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"found top level transaction %u, with catalog changes"</literal></expr></argument>,
			 <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>needs_snapshot</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>needs_timetravel</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SnapBuildAddCommittedTxn</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>sub_needs_timetravel</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* track toplevel txn as well, subxact alone isn't meaningful */</comment>
		<expr_stmt><expr><call><name>SnapBuildAddCommittedTxn</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>needs_timetravel</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"forced transaction %u to do timetravel"</literal></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SnapBuildAddCommittedTxn</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>needs_timetravel</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* record that we cannot export a general snapshot anymore */</comment>
		<expr_stmt><expr><name><name>builder</name><operator>-&gt;</operator><name>committed</name><operator>.</operator><name>includes_all_transactions</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>needs_snapshot</name> <operator>||</operator> <name>needs_timetravel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Adjust xmax of the snapshot builder, we only do that for committed,
	 * catalog modifying, transactions, everything else isn't interesting for
	 * us since we'll never look at the respective rows.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>needs_timetravel</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>xmax</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
		 <call><name>TransactionIdFollowsOrEquals</name><argument_list>(<argument><expr><name>xmax</name></expr></argument>, <argument><expr><name><name>builder</name><operator>-&gt;</operator><name>xmax</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>builder</name><operator>-&gt;</operator><name>xmax</name></name> <operator>=</operator> <name>xmax</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TransactionIdAdvance</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>xmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* if there's any reason to build a historic snapshot, do so now */</comment>
	<if_stmt><if>if <condition>(<expr><name>needs_snapshot</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we haven't built a complete snapshot yet there's no need to hand
		 * it out, it wouldn't (and couldn't) be used anyway.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>builder</name><operator>-&gt;</operator><name>state</name></name> <operator>&lt;</operator> <name>SNAPBUILD_FULL_SNAPSHOT</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Decrease the snapshot builder's refcount of the old snapshot, note
		 * that it still will be used if it has been handed out to the
		 * reorderbuffer earlier.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>builder</name><operator>-&gt;</operator><name>snapshot</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SnapBuildSnapDecRefcount</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>builder</name><operator>-&gt;</operator><name>snapshot</name></name> <operator>=</operator> <call><name>SnapBuildBuildSnapshot</name><argument_list>(<argument><expr><name>builder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* we might need to execute invalidations, add snapshot */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ReorderBufferXidHasBaseSnapshot</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>SnapBuildSnapIncRefcount</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReorderBufferSetBaseSnapshot</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>,
										 <argument><expr><name><name>builder</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* refcount of the snapshot builder for the new snapshot */</comment>
		<expr_stmt><expr><call><name>SnapBuildSnapIncRefcount</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* add a new catalog snapshot to all currently running transactions */</comment>
		<expr_stmt><expr><call><name>SnapBuildDistributeNewCatalogSnapshot</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/* -----------------------------------
 * Snapshot building functions dealing with xlog records
 * -----------------------------------
 */</comment>

<comment type="block">/*
 * Process a running xacts record, and use its information to first build a
 * historic snapshot and later to release resources that aren't needed
 * anymore.
 */</comment>
<function><type><name>void</name></type>
<name>SnapBuildProcessRunningXacts</name><parameter_list>(<parameter><decl><type><name>SnapBuild</name> <modifier>*</modifier></type><name>builder</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>xl_running_xacts</name> <modifier>*</modifier></type><name>running</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xmin</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If we're not consistent yet, inspect the record to see whether it
	 * allows to get closer to being consistent. If we are consistent, dump
	 * our snapshot so others or we, after a restart, can use it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>builder</name><operator>-&gt;</operator><name>state</name></name> <operator>&lt;</operator> <name>SNAPBUILD_CONSISTENT</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* returns false if there's no point in performing cleanup just yet */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SnapBuildFindSnapshot</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>, <argument><expr><name>running</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SnapBuildSerialize</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Update range of interesting xids based on the running xacts
	 * information. We don't increase -&gt;xmax using it, because once we are in
	 * a consistent state we can do that ourselves and much more efficiently
	 * so, because we only need to do it for catalog transactions since we
	 * only ever look at those.
	 *
	 * NB: We only increase xmax when a catalog modifying transaction commits
	 * (see SnapBuildCommitTxn).  Because of this, xmax can be lower than
	 * xmin, which looks odd but is correct and actually more efficient, since
	 * we hit fast paths in heapam_visibility.c.
	 */</comment>
	<expr_stmt><expr><name><name>builder</name><operator>-&gt;</operator><name>xmin</name></name> <operator>=</operator> <name><name>running</name><operator>-&gt;</operator><name>oldestRunningXid</name></name></expr>;</expr_stmt>

	<comment type="block">/* Remove transactions we don't need to keep track off anymore */</comment>
	<expr_stmt><expr><call><name>SnapBuildPurgeCommittedTxn</name><argument_list>(<argument><expr><name>builder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Advance the xmin limit for the current replication slot, to allow
	 * vacuum to clean up the tuples this slot has been protecting.
	 *
	 * The reorderbuffer might have an xmin among the currently running
	 * snapshots; use it if so.  If not, we need only consider the snapshots
	 * we'll produce later, which can't be less than the oldest running xid in
	 * the record we're reading now.
	 */</comment>
	<expr_stmt><expr><name>xmin</name> <operator>=</operator> <call><name>ReorderBufferGetOldestXmin</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>xmin</name> <operator>==</operator> <name>InvalidTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>xmin</name> <operator>=</operator> <name><name>running</name><operator>-&gt;</operator><name>oldestRunningXid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"xmin: %u, xmax: %u, oldest running: %u, oldest xmin: %u"</literal></expr></argument>,
		 <argument><expr><name><name>builder</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>, <argument><expr><name><name>builder</name><operator>-&gt;</operator><name>xmax</name></name></expr></argument>, <argument><expr><name><name>running</name><operator>-&gt;</operator><name>oldestRunningXid</name></name></expr></argument>, <argument><expr><name>xmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LogicalIncreaseXminForSlot</name><argument_list>(<argument><expr><name>lsn</name></expr></argument>, <argument><expr><name>xmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Also tell the slot where we can restart decoding from. We don't want to
	 * do that after every commit because changing that implies an fsync of
	 * the logical slot's state file, so we only do it every time we see a
	 * running xacts record.
	 *
	 * Do so by looking for the oldest in progress transaction (determined by
	 * the first LSN of any of its relevant records). Every transaction
	 * remembers the last location we stored the snapshot to disk before its
	 * beginning. That point is where we can restart from.
	 */</comment>

	<comment type="block">/*
	 * Can't know about a serialized snapshot's location if we're not
	 * consistent.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>builder</name><operator>-&gt;</operator><name>state</name></name> <operator>&lt;</operator> <name>SNAPBUILD_CONSISTENT</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>txn</name> <operator>=</operator> <call><name>ReorderBufferGetOldestTXN</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * oldest ongoing txn might have started when we didn't yet serialize
	 * anything because we hadn't reached a consistent state yet.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>txn</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>txn</name><operator>-&gt;</operator><name>restart_decoding_lsn</name></name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LogicalIncreaseRestartDecodingForSlot</name><argument_list>(<argument><expr><name>lsn</name></expr></argument>, <argument><expr><name><name>txn</name><operator>-&gt;</operator><name>restart_decoding_lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

	<comment type="block">/*
	 * No in-progress transaction, can reuse the last serialized snapshot if
	 * we have one.
	 */</comment>
	<if type="elseif">else if <condition>(<expr><name>txn</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			 <name><name>builder</name><operator>-&gt;</operator><name>reorder</name><operator>-&gt;</operator><name>current_restart_decoding_lsn</name></name> <operator>!=</operator> <name>InvalidXLogRecPtr</name> <operator>&amp;&amp;</operator>
			 <name><name>builder</name><operator>-&gt;</operator><name>last_serialized_snapshot</name></name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LogicalIncreaseRestartDecodingForSlot</name><argument_list>(<argument><expr><name>lsn</name></expr></argument>,
											  <argument><expr><name><name>builder</name><operator>-&gt;</operator><name>last_serialized_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Build the start of a snapshot that's capable of decoding the catalog.
 *
 * Helper function for SnapBuildProcessRunningXacts() while we're not yet
 * consistent.
 *
 * Returns true if there is a point in performing internal maintenance/cleanup
 * using the xl_running_xacts record.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>SnapBuildFindSnapshot</name><parameter_list>(<parameter><decl><type><name>SnapBuild</name> <modifier>*</modifier></type><name>builder</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>xl_running_xacts</name> <modifier>*</modifier></type><name>running</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* ---
	 * Build catalog decoding snapshot incrementally using information about
	 * the currently running transactions. There are several ways to do that:
	 *
	 * a) There were no running transactions when the xl_running_xacts record
	 *	  was inserted, jump to CONSISTENT immediately. We might find such a
	 *	  state while waiting on c)'s sub-states.
	 *
	 * b) This (in a previous run) or another decoding slot serialized a
	 *	  snapshot to disk that we can use.  Can't use this method for the
	 *	  initial snapshot when slot is being created and needs full snapshot
	 *	  for export or direct use, as that snapshot will only contain catalog
	 *	  modifying transactions.
	 *
	 * c) First incrementally build a snapshot for catalog tuples
	 *	  (BUILDING_SNAPSHOT), that requires all, already in-progress,
	 *	  transactions to finish.  Every transaction starting after that
	 *	  (FULL_SNAPSHOT state), has enough information to be decoded.  But
	 *	  for older running transactions no viable snapshot exists yet, so
	 *	  CONSISTENT will only be reached once all of those have finished.
	 * ---
	 */</comment>

	<comment type="block">/*
	 * xl_running_xact record is older than what we can use, we might not have
	 * all necessary catalog rows anymore.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>initial_xmin_horizon</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>NormalTransactionIdPrecedes</name><argument_list>(<argument><expr><name><name>running</name><operator>-&gt;</operator><name>oldestRunningXid</name></name></expr></argument>,
									<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>initial_xmin_horizon</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"skipping snapshot at %X/%X while building logical decoding snapshot, xmin horizon too low"</literal></expr></argument>,
								 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>lsn</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"initial xmin horizon of %u vs the snapshot's %u"</literal></expr></argument>,
									<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>initial_xmin_horizon</name></name></expr></argument>, <argument><expr><name><name>running</name><operator>-&gt;</operator><name>oldestRunningXid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>


		<expr_stmt><expr><call><name>SnapBuildWaitSnapshot</name><argument_list>(<argument><expr><name>running</name></expr></argument>, <argument><expr><name><name>builder</name><operator>-&gt;</operator><name>initial_xmin_horizon</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * a) No transaction were running, we can jump to consistent.
	 *
	 * This is not affected by races around xl_running_xacts, because we can
	 * miss transaction commits, but currently not transactions starting.
	 *
	 * NB: We might have already started to incrementally assemble a snapshot,
	 * so we need to be careful to deal with that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>running</name><operator>-&gt;</operator><name>oldestRunningXid</name></name> <operator>==</operator> <name><name>running</name><operator>-&gt;</operator><name>nextXid</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>builder</name><operator>-&gt;</operator><name>start_decoding_at</name></name> <operator>==</operator> <name>InvalidXLogRecPtr</name> <operator>||</operator>
			<name><name>builder</name><operator>-&gt;</operator><name>start_decoding_at</name></name> <operator>&lt;=</operator> <name>lsn</name></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/* can decode everything after this */</comment>
			<expr_stmt><expr><name><name>builder</name><operator>-&gt;</operator><name>start_decoding_at</name></name> <operator>=</operator> <name>lsn</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* As no transactions were running xmin/xmax can be trivially set. */</comment>
		<expr_stmt><expr><name><name>builder</name><operator>-&gt;</operator><name>xmin</name></name> <operator>=</operator> <name><name>running</name><operator>-&gt;</operator><name>nextXid</name></name></expr>;</expr_stmt>	<comment type="block">/* &lt; are finished */</comment>
		<expr_stmt><expr><name><name>builder</name><operator>-&gt;</operator><name>xmax</name></name> <operator>=</operator> <name><name>running</name><operator>-&gt;</operator><name>nextXid</name></name></expr>;</expr_stmt>	<comment type="block">/* &gt;= are running */</comment>

		<comment type="block">/* so we can safely use the faster comparisons */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>xmax</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>builder</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>SNAPBUILD_CONSISTENT</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SnapBuildStartNextPhaseAt</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name>InvalidTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"logical decoding found consistent point at %X/%X"</literal></expr></argument>,
						<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>lsn</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"There are no running transactions."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<comment type="block">/* b) valid on disk state and not building full snapshot */</comment>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>builder</name><operator>-&gt;</operator><name>building_full_snapshot</name></name> <operator>&amp;&amp;</operator>
			 <call><name>SnapBuildRestore</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* there won't be any state to cleanup */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>

	<comment type="block">/*
	 * c) transition from START to BUILDING_SNAPSHOT.
	 *
	 * In START state, and a xl_running_xacts record with running xacts is
	 * encountered.  In that case, switch to BUILDING_SNAPSHOT state, and
	 * record xl_running_xacts-&gt;nextXid.  Once all running xacts have finished
	 * (i.e. they're all &gt;= nextXid), we have a complete catalog snapshot.  It
	 * might look that we could use xl_running_xact's -&gt;xids information to
	 * get there quicker, but that is problematic because transactions marked
	 * as running, might already have inserted their commit record - it's
	 * infeasible to change that with locking.
	 */</comment>
	<if type="elseif">else if <condition>(<expr><name><name>builder</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>SNAPBUILD_START</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>builder</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>SNAPBUILD_BUILDING_SNAPSHOT</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SnapBuildStartNextPhaseAt</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name><name>running</name><operator>-&gt;</operator><name>nextXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Start with an xmin/xmax that's correct for future, when all the
		 * currently running transactions have finished. We'll update both
		 * while waiting for the pending transactions to finish.
		 */</comment>
		<expr_stmt><expr><name><name>builder</name><operator>-&gt;</operator><name>xmin</name></name> <operator>=</operator> <name><name>running</name><operator>-&gt;</operator><name>nextXid</name></name></expr>;</expr_stmt>	<comment type="block">/* &lt; are finished */</comment>
		<expr_stmt><expr><name><name>builder</name><operator>-&gt;</operator><name>xmax</name></name> <operator>=</operator> <name><name>running</name><operator>-&gt;</operator><name>nextXid</name></name></expr>;</expr_stmt>	<comment type="block">/* &gt;= are running */</comment>

		<comment type="block">/* so we can safely use the faster comparisons */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>xmax</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"logical decoding found initial starting point at %X/%X"</literal></expr></argument>,
						<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>lsn</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Waiting for transactions (approximately %d) older than %u to end."</literal></expr></argument>,
						   <argument><expr><name><name>running</name><operator>-&gt;</operator><name>xcnt</name></name></expr></argument>, <argument><expr><name><name>running</name><operator>-&gt;</operator><name>nextXid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SnapBuildWaitSnapshot</name><argument_list>(<argument><expr><name>running</name></expr></argument>, <argument><expr><name><name>running</name><operator>-&gt;</operator><name>nextXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>

	<comment type="block">/*
	 * c) transition from BUILDING_SNAPSHOT to FULL_SNAPSHOT.
	 *
	 * In BUILDING_SNAPSHOT state, and this xl_running_xacts' oldestRunningXid
	 * is &gt;= than nextXid from when we switched to BUILDING_SNAPSHOT.  This
	 * means all transactions starting afterwards have enough information to
	 * be decoded.  Switch to FULL_SNAPSHOT.
	 */</comment>
	<if type="elseif">else if <condition>(<expr><name><name>builder</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>SNAPBUILD_BUILDING_SNAPSHOT</name> <operator>&amp;&amp;</operator>
			 <call><name>TransactionIdPrecedesOrEquals</name><argument_list>(<argument><expr><call><name>SnapBuildNextPhaseAt</name><argument_list>(<argument><expr><name>builder</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name><name>running</name><operator>-&gt;</operator><name>oldestRunningXid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>builder</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>SNAPBUILD_FULL_SNAPSHOT</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SnapBuildStartNextPhaseAt</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name><name>running</name><operator>-&gt;</operator><name>nextXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"logical decoding found initial consistent point at %X/%X"</literal></expr></argument>,
						<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>lsn</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Waiting for transactions (approximately %d) older than %u to end."</literal></expr></argument>,
						   <argument><expr><name><name>running</name><operator>-&gt;</operator><name>xcnt</name></name></expr></argument>, <argument><expr><name><name>running</name><operator>-&gt;</operator><name>nextXid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SnapBuildWaitSnapshot</name><argument_list>(<argument><expr><name>running</name></expr></argument>, <argument><expr><name><name>running</name><operator>-&gt;</operator><name>nextXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>

	<comment type="block">/*
	 * c) transition from FULL_SNAPSHOT to CONSISTENT.
	 *
	 * In FULL_SNAPSHOT state (see d) ), and this xl_running_xacts'
	 * oldestRunningXid is &gt;= than nextXid from when we switched to
	 * FULL_SNAPSHOT.  This means all transactions that are currently in
	 * progress have a catalog snapshot, and all their changes have been
	 * collected.  Switch to CONSISTENT.
	 */</comment>
	<if type="elseif">else if <condition>(<expr><name><name>builder</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>SNAPBUILD_FULL_SNAPSHOT</name> <operator>&amp;&amp;</operator>
			 <call><name>TransactionIdPrecedesOrEquals</name><argument_list>(<argument><expr><call><name>SnapBuildNextPhaseAt</name><argument_list>(<argument><expr><name>builder</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name><name>running</name><operator>-&gt;</operator><name>oldestRunningXid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>builder</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>SNAPBUILD_CONSISTENT</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SnapBuildStartNextPhaseAt</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name>InvalidTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"logical decoding found consistent point at %X/%X"</literal></expr></argument>,
						<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>lsn</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"There are no old transactions anymore."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We already started to track running xacts and need to wait for all
	 * in-progress ones to finish. We fall through to the normal processing of
	 * records so incremental cleanup can be performed.
	 */</comment>
	<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<comment type="block">/* ---
 * Iterate through xids in record, wait for all older than the cutoff to
 * finish.  Then, if possible, log a new xl_running_xacts record.
 *
 * This isn't required for the correctness of decoding, but to:
 * a) allow isolationtester to notice that we're currently waiting for
 *	  something.
 * b) log a new xl_running_xacts record where it'd be helpful, without having
 *	  to write for bgwriter or checkpointer.
 * ---
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SnapBuildWaitSnapshot</name><parameter_list>(<parameter><decl><type><name>xl_running_xacts</name> <modifier>*</modifier></type><name>running</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>cutoff</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>off</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>off</name> <operator>&lt;</operator> <name><name>running</name><operator>-&gt;</operator><name>xcnt</name></name></expr>;</condition> <incr><expr><name>off</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name> <init>= <expr><name><name>running</name><operator>-&gt;</operator><name>xids</name><index>[<expr><name>off</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Upper layers should prevent that we ever need to wait on ourselves.
		 * Check anyway, since failing to do so would either result in an
		 * endless wait or an Assert() failure.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"waiting for ourselves"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdFollows</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>cutoff</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>XactLockTableWait</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>XLTW_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * All transactions we needed to finish finished - try to ensure there is
	 * another xl_running_xacts record in a timely manner, without having to
	 * write for bgwriter or checkpointer to log one.  During recovery we
	 * can't enforce that, so we'll have to wait.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LogStandbySnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* -----------------------------------
 * Snapshot serialization support
 * -----------------------------------
 */</comment>

<comment type="block">/*
 * We store current state of struct SnapBuild on disk in the following manner:
 *
 * struct SnapBuildOnDisk;
 * TransactionId * running.xcnt_space;
 * TransactionId * committed.xcnt; (*not xcnt_space*)
 *
 */</comment>
<typedef>typedef <type><struct>struct <name>SnapBuildOnDisk</name>
<block>{
	<comment type="block">/* first part of this struct needs to be version independent */</comment>

	<comment type="block">/* data not covered by checksum */</comment>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>magic</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_crc32c</name></type>	<name>checksum</name></decl>;</decl_stmt>

	<comment type="block">/* data covered by checksum */</comment>

	<comment type="block">/* version, in case we want to support pg_upgrade */</comment>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>version</name></decl>;</decl_stmt>
	<comment type="block">/* how large is the on disk data, excluding the constant sized part */</comment>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>length</name></decl>;</decl_stmt>

	<comment type="block">/* version dependent part */</comment>
	<decl_stmt><decl><type><name>SnapBuild</name></type>	<name>builder</name></decl>;</decl_stmt>

	<comment type="block">/* variable amount of TransactionIds follows */</comment>
}</block></struct></type> <name>SnapBuildOnDisk</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SnapBuildOnDiskConstantSize</name></cpp:macro> \
	<cpp:value>offsetof(SnapBuildOnDisk, builder)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SnapBuildOnDiskNotChecksummedSize</name></cpp:macro> \
	<cpp:value>offsetof(SnapBuildOnDisk, version)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SNAPBUILD_MAGIC</name></cpp:macro> <cpp:value>0x51A1E001</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SNAPBUILD_VERSION</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<comment type="block">/*
 * Store/Load a snapshot from disk, depending on the snapshot builder's state.
 *
 * Supposed to be used by external (i.e. not snapbuild.c) code that just read
 * a record that's a potential location for a serialized snapshot.
 */</comment>
<function><type><name>void</name></type>
<name>SnapBuildSerializationPoint</name><parameter_list>(<parameter><decl><type><name>SnapBuild</name> <modifier>*</modifier></type><name>builder</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>builder</name><operator>-&gt;</operator><name>state</name></name> <operator>&lt;</operator> <name>SNAPBUILD_CONSISTENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SnapBuildRestore</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SnapBuildSerialize</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Serialize the snapshot 'builder' at the location 'lsn' if it hasn't already
 * been done by another decoding process.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SnapBuildSerialize</name><parameter_list>(<parameter><decl><type><name>SnapBuild</name> <modifier>*</modifier></type><name>builder</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>needed_length</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SnapBuildOnDisk</name> <modifier>*</modifier></type><name>ondisk</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ondisk_c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>tmppath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>sz</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>lsn</name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>last_serialized_snapshot</name></name> <operator>==</operator> <name>InvalidXLogRecPtr</name> <operator>||</operator>
		   <name><name>builder</name><operator>-&gt;</operator><name>last_serialized_snapshot</name></name> <operator>&lt;=</operator> <name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * no point in serializing if we cannot continue to work immediately after
	 * restoring the snapshot
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>builder</name><operator>-&gt;</operator><name>state</name></name> <operator>&lt;</operator> <name>SNAPBUILD_CONSISTENT</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We identify snapshots by the LSN they are valid for. We don't need to
	 * include timelines in the name as each LSN maps to exactly one timeline
	 * unless the user used pg_resetwal or similar. If a user did so, there's
	 * no hope continuing to decode anyway.
	 */</comment>
	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"pg_logical/snapshots/%X-%X.snap"</literal></expr></argument>,
			<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * first check whether some other backend already has written the snapshot
	 * for this LSN. It's perfectly fine if there's none, so we accept ENOENT
	 * as a valid state. Everything else is an unexpected error.
	 */</comment>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>stat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not stat file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

	<if type="elseif">else if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * somebody else has already serialized to this point, don't overwrite
		 * but remember location, so we don't need to read old data again.
		 *
		 * To be sure it has been synced to disk after the rename() from the
		 * tempfile filename to the real filename, we just repeat the fsync.
		 * That ought to be cheap because in most scenarios it should already
		 * be safely on disk.
		 */</comment>
		<expr_stmt><expr><call><name>fsync_fname</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fsync_fname</name><argument_list>(<argument><expr><literal type="string">"pg_logical/snapshots"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>builder</name><operator>-&gt;</operator><name>last_serialized_snapshot</name></name> <operator>=</operator> <name>lsn</name></expr>;</expr_stmt>
		<goto>goto <name>out</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * there is an obvious race condition here between the time we stat(2) the
	 * file and us writing the file. But we rename the file into place
	 * atomically and all files created need to contain the same data anyway,
	 * so this is perfectly fine, although a bit of a resource waste. Locking
	 * seems like pointless complication.
	 */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"serializing snapshot to %s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* to make sure only we will write to this tempfile, include pid */</comment>
	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>tmppath</name></expr></argument>, <argument><expr><literal type="string">"pg_logical/snapshots/%X-%X.snap.%u.tmp"</literal></expr></argument>,
			<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>lsn</name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Unlink temporary file if it already exists, needs to have been before a
	 * crash/error since we won't enter this function twice from within a
	 * single decoding slot/backend and the temporary file contains the pid of
	 * the current process.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>tmppath</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>tmppath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>needed_length</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SnapBuildOnDisk</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
		<sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>builder</name><operator>-&gt;</operator><name>committed</name><operator>.</operator><name>xcnt</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>ondisk_c</name> <operator>=</operator> <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>needed_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ondisk</name> <operator>=</operator> <operator>(</operator><name>SnapBuildOnDisk</name> <operator>*</operator><operator>)</operator> <name>ondisk_c</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ondisk</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>SNAPBUILD_MAGIC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ondisk</name><operator>-&gt;</operator><name>version</name></name> <operator>=</operator> <name>SNAPBUILD_VERSION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ondisk</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <name>needed_length</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INIT_CRC32C</name><argument_list>(<argument><expr><name><name>ondisk</name><operator>-&gt;</operator><name>checksum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name><name>ondisk</name><operator>-&gt;</operator><name>checksum</name></name></expr></argument>,
				<argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>ondisk</name><operator>)</operator> <operator>+</operator> <name>SnapBuildOnDiskNotChecksummedSize</name></expr></argument>,
				<argument><expr><name>SnapBuildOnDiskConstantSize</name> <operator>-</operator> <name>SnapBuildOnDiskNotChecksummedSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ondisk_c</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SnapBuildOnDisk</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ondisk</name><operator>-&gt;</operator><name>builder</name></name></expr></argument>, <argument><expr><name>builder</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SnapBuild</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* NULL-ify memory-only data */</comment>
	<expr_stmt><expr><name><name>ondisk</name><operator>-&gt;</operator><name>builder</name><operator>.</operator><name>context</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ondisk</name><operator>-&gt;</operator><name>builder</name><operator>.</operator><name>snapshot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ondisk</name><operator>-&gt;</operator><name>builder</name><operator>.</operator><name>reorder</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ondisk</name><operator>-&gt;</operator><name>builder</name><operator>.</operator><name>committed</name><operator>.</operator><name>xip</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name><name>ondisk</name><operator>-&gt;</operator><name>checksum</name></name></expr></argument>,
				<argument><expr><operator>&amp;</operator><name><name>ondisk</name><operator>-&gt;</operator><name>builder</name></name></expr></argument>,
				<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SnapBuild</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* there shouldn't be any running xacts */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>was_running</name><operator>.</operator><name>was_xcnt</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* copy committed xacts */</comment>
	<expr_stmt><expr><name>sz</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>builder</name><operator>-&gt;</operator><name>committed</name><operator>.</operator><name>xcnt</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ondisk_c</name></expr></argument>, <argument><expr><name><name>builder</name><operator>-&gt;</operator><name>committed</name><operator>.</operator><name>xip</name></name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name><name>ondisk</name><operator>-&gt;</operator><name>checksum</name></name></expr></argument>, <argument><expr><name>ondisk_c</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ondisk_c</name> <operator>+=</operator> <name>sz</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FIN_CRC32C</name><argument_list>(<argument><expr><name><name>ondisk</name><operator>-&gt;</operator><name>checksum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we have valid data now, open tempfile and write it there */</comment>
	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>OpenTransientFile</name><argument_list>(<argument><expr><name>tmppath</name></expr></argument>,
						   <argument><expr><name>O_CREAT</name> <operator>|</operator> <name>O_EXCL</name> <operator>|</operator> <name>O_WRONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>tmppath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_SNAPBUILD_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>ondisk</name></expr></argument>, <argument><expr><name>needed_length</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>needed_length</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* if write didn't set errno, assume problem is no disk space */</comment>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <ternary><condition><expr><name>save_errno</name></expr> ?</condition><then> <expr><name>save_errno</name></expr> </then><else>: <expr><name>ENOSPC</name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>tmppath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * fsync the file before renaming so that even if we crash after this we
	 * have either a fully valid file or nothing.
	 *
	 * It's safe to just ERROR on fsync() here because we'll retry the whole
	 * operation including the writes.
	 *
	 * TODO: Do the fsync() via checkpoints/restartpoints, doing it here has
	 * some noticeable overhead since it's performed synchronously during
	 * decoding?
	 */</comment>
	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_SNAPBUILD_SYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pg_fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fsync file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>tmppath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not close file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>tmppath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>fsync_fname</name><argument_list>(<argument><expr><literal type="string">"pg_logical/snapshots"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We may overwrite the work from some other backend, but that's ok, our
	 * snapshot is valid as well, we'll just have done some superfluous work.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>rename</name><argument_list>(<argument><expr><name>tmppath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not rename file \"%s\" to \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>tmppath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* make sure we persist */</comment>
	<expr_stmt><expr><call><name>fsync_fname</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fsync_fname</name><argument_list>(<argument><expr><literal type="string">"pg_logical/snapshots"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now there's no way we can loose the dumped state anymore, remember this
	 * as a serialization point.
	 */</comment>
	<expr_stmt><expr><name><name>builder</name><operator>-&gt;</operator><name>last_serialized_snapshot</name></name> <operator>=</operator> <name>lsn</name></expr>;</expr_stmt>

<label><name>out</name>:</label>
	<expr_stmt><expr><call><name>ReorderBufferSetRestartPoint</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>,
								 <argument><expr><name><name>builder</name><operator>-&gt;</operator><name>last_serialized_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* be tidy */</comment>
	<if_stmt><if>if <condition>(<expr><name>ondisk</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>ondisk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Restore a snapshot into 'builder' if previously one has been stored at the
 * location indicated by 'lsn'. Returns true if successful, false otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>SnapBuildRestore</name><parameter_list>(<parameter><decl><type><name>SnapBuild</name> <modifier>*</modifier></type><name>builder</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SnapBuildOnDisk</name></type> <name>ondisk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>sz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>readBytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_crc32c</name></type>	<name>checksum</name></decl>;</decl_stmt>

	<comment type="block">/* no point in loading a snapshot if we're already there */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>builder</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>SNAPBUILD_CONSISTENT</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"pg_logical/snapshots/%X-%X.snap"</literal></expr></argument>,
			<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>OpenTransientFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* ----
	 * Make sure the snapshot had been stored safely to disk, that's normally
	 * cheap.
	 * Note that we do not need PANIC here, nobody will be able to use the
	 * slot without fsyncing, and saving it won't succeed without an fsync()
	 * either...
	 * ----
	 */</comment>
	<expr_stmt><expr><call><name>fsync_fname</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fsync_fname</name><argument_list>(<argument><expr><literal type="string">"pg_logical/snapshots"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<comment type="block">/* read statically sized portion of snapshot */</comment>
	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_SNAPBUILD_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>readBytes</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ondisk</name></expr></argument>, <argument><expr><name>SnapBuildOnDiskConstantSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>readBytes</name> <operator>!=</operator> <name>SnapBuildOnDiskConstantSize</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>readBytes</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read file \"%s\": read %d of %zu"</literal></expr></argument>,
							<argument><expr><name>path</name></expr></argument>, <argument><expr><name>readBytes</name></expr></argument>,
							<argument><expr><operator>(</operator><name>Size</name><operator>)</operator> <name>SnapBuildOnDiskConstantSize</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ondisk</name><operator>.</operator><name>magic</name></name> <operator>!=</operator> <name>SNAPBUILD_MAGIC</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"snapbuild state file \"%s\" has wrong magic number: %u instead of %u"</literal></expr></argument>,
						<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>ondisk</name><operator>.</operator><name>magic</name></name></expr></argument>, <argument><expr><name>SNAPBUILD_MAGIC</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ondisk</name><operator>.</operator><name>version</name></name> <operator>!=</operator> <name>SNAPBUILD_VERSION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"snapbuild state file \"%s\" has unsupported version: %u instead of %u"</literal></expr></argument>,
						<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>ondisk</name><operator>.</operator><name>version</name></name></expr></argument>, <argument><expr><name>SNAPBUILD_VERSION</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>INIT_CRC32C</name><argument_list>(<argument><expr><name>checksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>checksum</name></expr></argument>,
				<argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>ondisk</name><operator>)</operator> <operator>+</operator> <name>SnapBuildOnDiskNotChecksummedSize</name></expr></argument>,
				<argument><expr><name>SnapBuildOnDiskConstantSize</name> <operator>-</operator> <name>SnapBuildOnDiskNotChecksummedSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* read SnapBuild */</comment>
	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_SNAPBUILD_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>readBytes</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ondisk</name><operator>.</operator><name>builder</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SnapBuild</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>readBytes</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SnapBuild</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>readBytes</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read file \"%s\": read %d of %zu"</literal></expr></argument>,
							<argument><expr><name>path</name></expr></argument>, <argument><expr><name>readBytes</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SnapBuild</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>checksum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ondisk</name><operator>.</operator><name>builder</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SnapBuild</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* restore running xacts (dead, but kept for backward compat) */</comment>
	<expr_stmt><expr><name>sz</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>ondisk</name><operator>.</operator><name>builder</name><operator>.</operator><name>was_running</name><operator>.</operator><name>was_xcnt_space</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ondisk</name><operator>.</operator><name>builder</name><operator>.</operator><name>was_running</name><operator>.</operator><name>was_xip</name></name> <operator>=</operator>
		<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_SNAPBUILD_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>readBytes</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>ondisk</name><operator>.</operator><name>builder</name><operator>.</operator><name>was_running</name><operator>.</operator><name>was_xip</name></name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>readBytes</name> <operator>!=</operator> <name>sz</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>readBytes</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read file \"%s\": read %d of %zu"</literal></expr></argument>,
							<argument><expr><name>path</name></expr></argument>, <argument><expr><name>readBytes</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>checksum</name></expr></argument>, <argument><expr><name><name>ondisk</name><operator>.</operator><name>builder</name><operator>.</operator><name>was_running</name><operator>.</operator><name>was_xip</name></name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* restore committed xacts information */</comment>
	<expr_stmt><expr><name>sz</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>ondisk</name><operator>.</operator><name>builder</name><operator>.</operator><name>committed</name><operator>.</operator><name>xcnt</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ondisk</name><operator>.</operator><name>builder</name><operator>.</operator><name>committed</name><operator>.</operator><name>xip</name></name> <operator>=</operator> <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_SNAPBUILD_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>readBytes</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>ondisk</name><operator>.</operator><name>builder</name><operator>.</operator><name>committed</name><operator>.</operator><name>xip</name></name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>readBytes</name> <operator>!=</operator> <name>sz</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>readBytes</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read file \"%s\": read %d of %zu"</literal></expr></argument>,
							<argument><expr><name>path</name></expr></argument>, <argument><expr><name>readBytes</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>checksum</name></expr></argument>, <argument><expr><name><name>ondisk</name><operator>.</operator><name>builder</name><operator>.</operator><name>committed</name><operator>.</operator><name>xip</name></name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not close file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>FIN_CRC32C</name><argument_list>(<argument><expr><name>checksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* verify checksum of what we've read */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EQ_CRC32C</name><argument_list>(<argument><expr><name>checksum</name></expr></argument>, <argument><expr><name><name>ondisk</name><operator>.</operator><name>checksum</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"checksum mismatch for snapbuild state file \"%s\": is %u, should be %u"</literal></expr></argument>,
						<argument><expr><name>path</name></expr></argument>, <argument><expr><name>checksum</name></expr></argument>, <argument><expr><name><name>ondisk</name><operator>.</operator><name>checksum</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * ok, we now have a sensible snapshot here, figure out if it has more
	 * information than we have.
	 */</comment>

	<comment type="block">/*
	 * We are only interested in consistent snapshots for now, comparing
	 * whether one incomplete snapshot is more "advanced" seems to be
	 * unnecessarily complex.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ondisk</name><operator>.</operator><name>builder</name><operator>.</operator><name>state</name></name> <operator>&lt;</operator> <name>SNAPBUILD_CONSISTENT</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>snapshot_not_interesting</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Don't use a snapshot that requires an xmin that we cannot guarantee to
	 * be available.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name><name>ondisk</name><operator>.</operator><name>builder</name><operator>.</operator><name>xmin</name></name></expr></argument>, <argument><expr><name><name>builder</name><operator>-&gt;</operator><name>initial_xmin_horizon</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>snapshot_not_interesting</name>;</goto></block_content></block></if></if_stmt>


	<comment type="block">/* ok, we think the snapshot is sensible, copy over everything important */</comment>
	<expr_stmt><expr><name><name>builder</name><operator>-&gt;</operator><name>xmin</name></name> <operator>=</operator> <name><name>ondisk</name><operator>.</operator><name>builder</name><operator>.</operator><name>xmin</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>builder</name><operator>-&gt;</operator><name>xmax</name></name> <operator>=</operator> <name><name>ondisk</name><operator>.</operator><name>builder</name><operator>.</operator><name>xmax</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>builder</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name><name>ondisk</name><operator>.</operator><name>builder</name><operator>.</operator><name>state</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>builder</name><operator>-&gt;</operator><name>committed</name><operator>.</operator><name>xcnt</name></name> <operator>=</operator> <name><name>ondisk</name><operator>.</operator><name>builder</name><operator>.</operator><name>committed</name><operator>.</operator><name>xcnt</name></name></expr>;</expr_stmt>
	<comment type="block">/* We only allocated/stored xcnt, not xcnt_space xids ! */</comment>
	<comment type="block">/* don't overwrite preallocated xip, if we don't have anything here */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>builder</name><operator>-&gt;</operator><name>committed</name><operator>.</operator><name>xcnt</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>committed</name><operator>.</operator><name>xip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>builder</name><operator>-&gt;</operator><name>committed</name><operator>.</operator><name>xcnt_space</name></name> <operator>=</operator> <name><name>ondisk</name><operator>.</operator><name>builder</name><operator>.</operator><name>committed</name><operator>.</operator><name>xcnt</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>builder</name><operator>-&gt;</operator><name>committed</name><operator>.</operator><name>xip</name></name> <operator>=</operator> <name><name>ondisk</name><operator>.</operator><name>builder</name><operator>.</operator><name>committed</name><operator>.</operator><name>xip</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>ondisk</name><operator>.</operator><name>builder</name><operator>.</operator><name>committed</name><operator>.</operator><name>xip</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* our snapshot is not interesting anymore, build a new one */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>builder</name><operator>-&gt;</operator><name>snapshot</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SnapBuildSnapDecRefcount</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>builder</name><operator>-&gt;</operator><name>snapshot</name></name> <operator>=</operator> <call><name>SnapBuildBuildSnapshot</name><argument_list>(<argument><expr><name>builder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SnapBuildSnapIncRefcount</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReorderBufferSetRestartPoint</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>builder</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>SNAPBUILD_CONSISTENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"logical decoding found consistent point at %X/%X"</literal></expr></argument>,
					<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>lsn</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Logical decoding will begin using saved snapshot."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>

<label><name>snapshot_not_interesting</name>:</label>
	<if_stmt><if>if <condition>(<expr><name><name>ondisk</name><operator>.</operator><name>builder</name><operator>.</operator><name>committed</name><operator>.</operator><name>xip</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>ondisk</name><operator>.</operator><name>builder</name><operator>.</operator><name>committed</name><operator>.</operator><name>xip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Remove all serialized snapshots that are not required anymore because no
 * slot can need them. This doesn't actually have to run during a checkpoint,
 * but it's a convenient point to schedule this.
 *
 * NB: We run this during checkpoints even if logical decoding is disabled so
 * we cleanup old slots at some point after it got disabled.
 */</comment>
<function><type><name>void</name></type>
<name>CheckPointSnapBuild</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>cutoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>redo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>snap_dir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>snap_de</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name> <operator>+</operator> <literal type="number">21</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We start off with a minimum of the last redo pointer. No new
	 * replication slot will start before that, so that's a safe upper bound
	 * for removal.
	 */</comment>
	<expr_stmt><expr><name>redo</name> <operator>=</operator> <call><name>GetRedoRecPtr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* now check for the restart ptrs from existing slots */</comment>
	<expr_stmt><expr><name>cutoff</name> <operator>=</operator> <call><name>ReplicationSlotsComputeLogicalRestartLSN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* don't start earlier than the restart lsn */</comment>
	<if_stmt><if>if <condition>(<expr><name>redo</name> <operator>&lt;</operator> <name>cutoff</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cutoff</name> <operator>=</operator> <name>redo</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>snap_dir</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><literal type="string">"pg_logical/snapshots"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>snap_de</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>snap_dir</name></expr></argument>, <argument><expr><literal type="string">"pg_logical/snapshots"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>hi</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>lo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lsn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>snap_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>snap_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">".."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"pg_logical/snapshots/%s"</literal></expr></argument>, <argument><expr><name><name>snap_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>lstat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>statbuf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"only regular files expected: %s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * temporary filenames from SnapBuildSerialize() include the LSN and
		 * everything but are postfixed by .$pid.tmp. We can just remove them
		 * the same as other files because there can be none that are
		 * currently being written that are older than cutoff.
		 *
		 * We just log a message if a file doesn't fit the pattern, it's
		 * probably some editors lock/state file or similar...
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name><name>snap_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"%X-%X.snap"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>hi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lo</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not parse file name \"%s\""</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>lsn</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <name>hi</name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">32</literal> <operator>|</operator> <name>lo</name></expr>;</expr_stmt>

		<comment type="block">/* check whether we still need it */</comment>
		<if_stmt><if>if <condition>(<expr><name>lsn</name> <operator>&lt;</operator> <name>cutoff</name> <operator>||</operator> <name>cutoff</name> <operator>==</operator> <name>InvalidXLogRecPtr</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"removing snapbuild snapshot %s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * It's not particularly harmful, though strange, if we can't
			 * remove the file here. Don't prevent the checkpoint from
			 * completing, that'd be a cure worse than the disease.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove file \"%s\": %m"</literal></expr></argument>,
								<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>snap_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
