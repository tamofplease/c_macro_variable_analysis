<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/jit/llvm/llvmjit_deform.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * llvmjit_deform.c
 *	  Generate code for deforming a heap tuple.
 *
 * This gains performance benefits over unJITed deforming from compile-time
 * knowledge of the tuple descriptor. Fixed column widths, NOT NULLness, etc
 * can be taken advantage of.
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/jit/llvm/llvmjit_deform.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;llvm-c/Core.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tupdesc_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/tuptable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jit/llvmjit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jit/llvmjit_emit.h"</cpp:file></cpp:include>


<comment type="block">/*
 * Create a function that deforms a tuple of type desc up to natts columns.
 */</comment>
<function><type><name>LLVMValueRef</name></type>
<name>slot_compile_deform</name><parameter_list>(<parameter><decl><type><name>LLVMJitContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>desc</name></decl></parameter>,
					<parameter><decl><type><specifier>const</specifier> <name>TupleTableSlotOps</name> <modifier>*</modifier></type><name>ops</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>natts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>funcname</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>LLVMModuleRef</name></type> <name>mod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LLVMBuilderRef</name></type> <name>b</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>LLVMTypeRef</name></type> <name>deform_sig</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_deform_fn</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>LLVMBasicBlockRef</name></type> <name>b_entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LLVMBasicBlockRef</name></type> <name>b_adjust_unavail_cols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LLVMBasicBlockRef</name></type> <name>b_find_start</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>LLVMBasicBlockRef</name></type> <name>b_out</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LLVMBasicBlockRef</name></type> <name>b_dead</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LLVMBasicBlockRef</name> <modifier>*</modifier></type><name>attcheckattnoblocks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LLVMBasicBlockRef</name> <modifier>*</modifier></type><name>attstartblocks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LLVMBasicBlockRef</name> <modifier>*</modifier></type><name>attisnullblocks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LLVMBasicBlockRef</name> <modifier>*</modifier></type><name>attcheckalignblocks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LLVMBasicBlockRef</name> <modifier>*</modifier></type><name>attalignblocks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LLVMBasicBlockRef</name> <modifier>*</modifier></type><name>attstoreblocks</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_offp</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_tupdata_base</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_tts_values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_tts_nulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_slotoffp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_flagsp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_nvalidp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_nvalid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_maxatt</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_slot</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_tupleheaderp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_tuplep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_infomask1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_infomask2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_bits</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_hoff</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_hasnulls</name></decl>;</decl_stmt>

	<comment type="block">/* last column (0 indexed) guaranteed to exist */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>guaranteed_column_number</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* current known alignment */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>known_alignment</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* if true, known_alignment describes definite offset of column */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>attguaranteedalign</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name></decl>;</decl_stmt>

	<comment type="block">/* virtual tuples never need deforming, so don't generate code */</comment>
	<if_stmt><if>if <condition>(<expr><name>ops</name> <operator>==</operator> <operator>&amp;</operator><name>TTSOpsVirtual</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* decline to JIT for slot types we don't know to handle */</comment>
	<if_stmt><if>if <condition>(<expr><name>ops</name> <operator>!=</operator> <operator>&amp;</operator><name>TTSOpsHeapTuple</name> <operator>&amp;&amp;</operator> <name>ops</name> <operator>!=</operator> <operator>&amp;</operator><name>TTSOpsBufferHeapTuple</name> <operator>&amp;&amp;</operator>
		<name>ops</name> <operator>!=</operator> <operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>mod</name> <operator>=</operator> <call><name>llvm_mutable_module</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>funcname</name> <operator>=</operator> <call><name>llvm_expand_funcname</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"deform"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check which columns have to exist, so we don't have to check the row's
	 * natts unnecessarily.
	 */</comment>
	<for>for <control>(<init><expr><name>attnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attnum</name> <operator>&lt;</operator> <name><name>desc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If the column is declared NOT NULL then it must be present in every
		 * tuple, unless there's a "missing" entry that could provide a
		 * non-NULL value for it. That in turn guarantees that the NULL bitmap
		 * - if there are any NULLable columns - is at least long enough to
		 * cover columns up to attnum.
		 *
		 * Be paranoid and also check !attisdropped, even though the
		 * combination of attisdropped &amp;&amp; attnotnull combination shouldn't
		 * exist.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attnotnull</name></name> <operator>&amp;&amp;</operator>
			<operator>!</operator><name><name>att</name><operator>-&gt;</operator><name>atthasmissing</name></name> <operator>&amp;&amp;</operator>
			<operator>!</operator><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>guaranteed_column_number</name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Create the signature and function */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LLVMTypeRef</name></type> <name><name>param_types</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>param_types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>l_ptr</name><argument_list>(<argument><expr><name>StructTupleTableSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>deform_sig</name> <operator>=</operator> <call><name>LLVMFunctionType</name><argument_list>(<argument><expr><call><name>LLVMVoidType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>param_types</name></expr></argument>,
									  <argument><expr><call><name>lengthof</name><argument_list>(<argument><expr><name>param_types</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name>v_deform_fn</name> <operator>=</operator> <call><name>LLVMAddFunction</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>deform_sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LLVMSetLinkage</name><argument_list>(<argument><expr><name>v_deform_fn</name></expr></argument>, <argument><expr><name>LLVMInternalLinkage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LLVMSetParamAlignment</name><argument_list>(<argument><expr><call><name>LLVMGetParam</name><argument_list>(<argument><expr><name>v_deform_fn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MAXIMUM_ALIGNOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>llvm_copy_attributes</name><argument_list>(<argument><expr><name>AttributeTemplate</name></expr></argument>, <argument><expr><name>v_deform_fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>b_entry</name> <operator>=</operator>
		<call><name>LLVMAppendBasicBlock</name><argument_list>(<argument><expr><name>v_deform_fn</name></expr></argument>, <argument><expr><literal type="string">"entry"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>b_adjust_unavail_cols</name> <operator>=</operator>
		<call><name>LLVMAppendBasicBlock</name><argument_list>(<argument><expr><name>v_deform_fn</name></expr></argument>, <argument><expr><literal type="string">"adjust_unavail_cols"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>b_find_start</name> <operator>=</operator>
		<call><name>LLVMAppendBasicBlock</name><argument_list>(<argument><expr><name>v_deform_fn</name></expr></argument>, <argument><expr><literal type="string">"find_startblock"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>b_out</name> <operator>=</operator>
		<call><name>LLVMAppendBasicBlock</name><argument_list>(<argument><expr><name>v_deform_fn</name></expr></argument>, <argument><expr><literal type="string">"outblock"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>b_dead</name> <operator>=</operator>
		<call><name>LLVMAppendBasicBlock</name><argument_list>(<argument><expr><name>v_deform_fn</name></expr></argument>, <argument><expr><literal type="string">"deadblock"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>LLVMCreateBuilder</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>attcheckattnoblocks</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LLVMBasicBlockRef</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attstartblocks</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LLVMBasicBlockRef</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attisnullblocks</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LLVMBasicBlockRef</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attcheckalignblocks</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LLVMBasicBlockRef</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attalignblocks</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LLVMBasicBlockRef</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attstoreblocks</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LLVMBasicBlockRef</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>known_alignment</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LLVMPositionBuilderAtEnd</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>b_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* perform allocas first, llvm only converts those to registers */</comment>
	<expr_stmt><expr><name>v_offp</name> <operator>=</operator> <call><name>LLVMBuildAlloca</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>TypeSizeT</name></expr></argument>, <argument><expr><literal type="string">"v_offp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>v_slot</name> <operator>=</operator> <call><name>LLVMGetParam</name><argument_list>(<argument><expr><name>v_deform_fn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>v_tts_values</name> <operator>=</operator>
		<call><name>l_load_struct_gep</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_slot</name></expr></argument>, <argument><expr><name>FIELDNO_TUPLETABLESLOT_VALUES</name></expr></argument>,
						  <argument><expr><literal type="string">"tts_values"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>v_tts_nulls</name> <operator>=</operator>
		<call><name>l_load_struct_gep</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_slot</name></expr></argument>, <argument><expr><name>FIELDNO_TUPLETABLESLOT_ISNULL</name></expr></argument>,
						  <argument><expr><literal type="string">"tts_ISNULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>v_flagsp</name> <operator>=</operator> <call><name>LLVMBuildStructGEP</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_slot</name></expr></argument>, <argument><expr><name>FIELDNO_TUPLETABLESLOT_FLAGS</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>v_nvalidp</name> <operator>=</operator> <call><name>LLVMBuildStructGEP</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_slot</name></expr></argument>, <argument><expr><name>FIELDNO_TUPLETABLESLOT_NVALID</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ops</name> <operator>==</operator> <operator>&amp;</operator><name>TTSOpsHeapTuple</name> <operator>||</operator> <name>ops</name> <operator>==</operator> <operator>&amp;</operator><name>TTSOpsBufferHeapTuple</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_heapslot</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>v_heapslot</name> <operator>=</operator>
			<call><name>LLVMBuildBitCast</name><argument_list>(<argument><expr><name>b</name></expr></argument>,
							 <argument><expr><name>v_slot</name></expr></argument>,
							 <argument><expr><call><name>l_ptr</name><argument_list>(<argument><expr><name>StructHeapTupleTableSlot</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><literal type="string">"heapslot"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>v_slotoffp</name> <operator>=</operator> <call><name>LLVMBuildStructGEP</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_heapslot</name></expr></argument>, <argument><expr><name>FIELDNO_HEAPTUPLETABLESLOT_OFF</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>v_tupleheaderp</name> <operator>=</operator>
			<call><name>l_load_struct_gep</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_heapslot</name></expr></argument>, <argument><expr><name>FIELDNO_HEAPTUPLETABLESLOT_TUPLE</name></expr></argument>,
							  <argument><expr><literal type="string">"tupleheader"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>ops</name> <operator>==</operator> <operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_minimalslot</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>v_minimalslot</name> <operator>=</operator>
			<call><name>LLVMBuildBitCast</name><argument_list>(<argument><expr><name>b</name></expr></argument>,
							 <argument><expr><name>v_slot</name></expr></argument>,
							 <argument><expr><call><name>l_ptr</name><argument_list>(<argument><expr><name>StructMinimalTupleTableSlot</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><literal type="string">"minimalslot"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>v_slotoffp</name> <operator>=</operator> <call><name>LLVMBuildStructGEP</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_minimalslot</name></expr></argument>, <argument><expr><name>FIELDNO_MINIMALTUPLETABLESLOT_OFF</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>v_tupleheaderp</name> <operator>=</operator>
			<call><name>l_load_struct_gep</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_minimalslot</name></expr></argument>, <argument><expr><name>FIELDNO_MINIMALTUPLETABLESLOT_TUPLE</name></expr></argument>,
							  <argument><expr><literal type="string">"tupleheader"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* should've returned at the start of the function */</comment>
		<expr_stmt><expr><call><name>pg_unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>v_tuplep</name> <operator>=</operator>
		<call><name>l_load_struct_gep</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_tupleheaderp</name></expr></argument>, <argument><expr><name>FIELDNO_HEAPTUPLEDATA_DATA</name></expr></argument>,
						  <argument><expr><literal type="string">"tuple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>v_bits</name> <operator>=</operator>
		<call><name>LLVMBuildBitCast</name><argument_list>(<argument><expr><name>b</name></expr></argument>,
						 <argument><expr><call><name>LLVMBuildStructGEP</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_tuplep</name></expr></argument>,
											<argument><expr><name>FIELDNO_HEAPTUPLEHEADERDATA_BITS</name></expr></argument>,
											<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>l_ptr</name><argument_list>(<argument><expr><call><name>LLVMInt8Type</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><literal type="string">"t_bits"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>v_infomask1</name> <operator>=</operator>
		<call><name>l_load_struct_gep</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_tuplep</name></expr></argument>,
						  <argument><expr><name>FIELDNO_HEAPTUPLEHEADERDATA_INFOMASK</name></expr></argument>,
						  <argument><expr><literal type="string">"infomask1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>v_infomask2</name> <operator>=</operator>
		<call><name>l_load_struct_gep</name><argument_list>(<argument><expr><name>b</name></expr></argument>,
						  <argument><expr><name>v_tuplep</name></expr></argument>, <argument><expr><name>FIELDNO_HEAPTUPLEHEADERDATA_INFOMASK2</name></expr></argument>,
						  <argument><expr><literal type="string">"infomask2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* t_infomask &amp; HEAP_HASNULL */</comment>
	<expr_stmt><expr><name>v_hasnulls</name> <operator>=</operator>
		<call><name>LLVMBuildICmp</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>LLVMIntNE</name></expr></argument>,
					  <argument><expr><call><name>LLVMBuildAnd</name><argument_list>(<argument><expr><name>b</name></expr></argument>,
								   <argument><expr><call><name>l_int16_const</name><argument_list>(<argument><expr><name>HEAP_HASNULL</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>v_infomask1</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>l_int16_const</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><literal type="string">"hasnulls"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* t_infomask2 &amp; HEAP_NATTS_MASK */</comment>
	<expr_stmt><expr><name>v_maxatt</name> <operator>=</operator> <call><name>LLVMBuildAnd</name><argument_list>(<argument><expr><name>b</name></expr></argument>,
							<argument><expr><call><name>l_int16_const</name><argument_list>(<argument><expr><name>HEAP_NATTS_MASK</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>v_infomask2</name></expr></argument>,
							<argument><expr><literal type="string">"maxatt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Need to zext, as getelementptr otherwise treats hoff as a signed 8bit
	 * integer, which'd yield a negative offset for t_hoff &gt; 127.
	 */</comment>
	<expr_stmt><expr><name>v_hoff</name> <operator>=</operator>
		<call><name>LLVMBuildZExt</name><argument_list>(<argument><expr><name>b</name></expr></argument>,
					  <argument><expr><call><name>l_load_struct_gep</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_tuplep</name></expr></argument>,
										<argument><expr><name>FIELDNO_HEAPTUPLEHEADERDATA_HOFF</name></expr></argument>,
										<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>LLVMInt32Type</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t_hoff"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>v_tupdata_base</name> <operator>=</operator>
		<call><name>LLVMBuildGEP</name><argument_list>(<argument><expr><name>b</name></expr></argument>,
					 <argument><expr><call><name>LLVMBuildBitCast</name><argument_list>(<argument><expr><name>b</name></expr></argument>,
									  <argument><expr><name>v_tuplep</name></expr></argument>,
									  <argument><expr><call><name>l_ptr</name><argument_list>(<argument><expr><call><name>LLVMInt8Type</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name>v_hoff</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
					 <argument><expr><literal type="string">"v_tupdata_base"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Load tuple start offset from slot. Will be reset below in case there's
	 * no existing deformed columns in slot.
	 */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_off_start</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>v_off_start</name> <operator>=</operator> <call><name>LLVMBuildLoad</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_slotoffp</name></expr></argument>, <argument><expr><literal type="string">"v_slot_off"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>v_off_start</name> <operator>=</operator> <call><name>LLVMBuildZExt</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_off_start</name></expr></argument>, <argument><expr><name>TypeSizeT</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LLVMBuildStore</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_off_start</name></expr></argument>, <argument><expr><name>v_offp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* build the basic block for each attribute, need them as jump target */</comment>
	<for>for <control>(<init><expr><name>attnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attnum</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>attcheckattnoblocks</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator>
			<call><name>l_bb_append_v</name><argument_list>(<argument><expr><name>v_deform_fn</name></expr></argument>, <argument><expr><literal type="string">"block.attr.%d.attcheckattno"</literal></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>attstartblocks</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator>
			<call><name>l_bb_append_v</name><argument_list>(<argument><expr><name>v_deform_fn</name></expr></argument>, <argument><expr><literal type="string">"block.attr.%d.start"</literal></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>attisnullblocks</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator>
			<call><name>l_bb_append_v</name><argument_list>(<argument><expr><name>v_deform_fn</name></expr></argument>, <argument><expr><literal type="string">"block.attr.%d.attisnull"</literal></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>attcheckalignblocks</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator>
			<call><name>l_bb_append_v</name><argument_list>(<argument><expr><name>v_deform_fn</name></expr></argument>, <argument><expr><literal type="string">"block.attr.%d.attcheckalign"</literal></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>attalignblocks</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator>
			<call><name>l_bb_append_v</name><argument_list>(<argument><expr><name>v_deform_fn</name></expr></argument>, <argument><expr><literal type="string">"block.attr.%d.align"</literal></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>attstoreblocks</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator>
			<call><name>l_bb_append_v</name><argument_list>(<argument><expr><name>v_deform_fn</name></expr></argument>, <argument><expr><literal type="string">"block.attr.%d.store"</literal></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Check if it is guaranteed that all the desired attributes are available
	 * in the tuple (but still possibly NULL), by dint of either the last
	 * to-be-deformed column being NOT NULL, or subsequent ones not accessed
	 * here being NOT NULL.  If that's not guaranteed the tuple headers natt's
	 * has to be checked, and missing attributes potentially have to be
	 * fetched (using slot_getmissingattrs().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>natts</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;=</operator> <name>guaranteed_column_number</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* just skip through unnecessary blocks */</comment>
		<expr_stmt><expr><call><name>LLVMBuildBr</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>b_adjust_unavail_cols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LLVMPositionBuilderAtEnd</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>b_adjust_unavail_cols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LLVMBuildBr</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>b_find_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name><name>v_params</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

		<comment type="block">/* branch if not all columns available */</comment>
		<expr_stmt><expr><call><name>LLVMBuildCondBr</name><argument_list>(<argument><expr><name>b</name></expr></argument>,
						<argument><expr><call><name>LLVMBuildICmp</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>LLVMIntULT</name></expr></argument>,
									  <argument><expr><name>v_maxatt</name></expr></argument>,
									  <argument><expr><call><name>l_int16_const</name><argument_list>(<argument><expr><name>natts</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>b_adjust_unavail_cols</name></expr></argument>,
						<argument><expr><name>b_find_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* if not, memset tts_isnull of relevant cols to true */</comment>
		<expr_stmt><expr><call><name>LLVMPositionBuilderAtEnd</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>b_adjust_unavail_cols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>v_params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>v_slot</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>v_params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>LLVMBuildZExt</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_maxatt</name></expr></argument>, <argument><expr><call><name>LLVMInt32Type</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>v_params</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>l_int32_const</name><argument_list>(<argument><expr><name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LLVMBuildCall</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><call><name>llvm_pg_func</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="string">"slot_getmissingattrs"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>v_params</name></expr></argument>, <argument><expr><call><name>lengthof</name><argument_list>(<argument><expr><name>v_params</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LLVMBuildBr</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>b_find_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>LLVMPositionBuilderAtEnd</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>b_find_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>v_nvalid</name> <operator>=</operator> <call><name>LLVMBuildLoad</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_nvalidp</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build switch to go from nvalid to the right startblock.  Callers
	 * currently don't have the knowledge, but it'd be good for performance to
	 * avoid this check when it's known that the slot is empty (e.g. in scan
	 * nodes).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_switch</name> <init>= <expr><call><name>LLVMBuildSwitch</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_nvalid</name></expr></argument>,
												<argument><expr><name>b_dead</name></expr></argument>, <argument><expr><name>natts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>attnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attnum</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_attno</name> <init>= <expr><call><name>l_int16_const</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>LLVMAddCase</name><argument_list>(<argument><expr><name>v_switch</name></expr></argument>, <argument><expr><name>v_attno</name></expr></argument>, <argument><expr><name><name>attcheckattnoblocks</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* jump from entry block to first block */</comment>
		<expr_stmt><expr><call><name>LLVMBuildBr</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>attcheckattnoblocks</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>LLVMPositionBuilderAtEnd</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>b_dead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LLVMBuildUnreachable</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Iterate over each attribute that needs to be deformed, build code to
	 * deform it.
	 */</comment>
	<for>for <control>(<init><expr><name>attnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attnum</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_incby</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>alignto</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>l_attno</name> <init>= <expr><call><name>l_int16_const</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_attdatap</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_resultp</name></decl>;</decl_stmt>

		<comment type="block">/* build block checking whether we did all the necessary attributes */</comment>
		<expr_stmt><expr><call><name>LLVMPositionBuilderAtEnd</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>attcheckattnoblocks</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If this is the first attribute, slot-&gt;tts_nvalid was 0. Therefore
		 * also reset offset to 0, it may be from a previous execution.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LLVMBuildStore</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><call><name>l_sizet_const</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>v_offp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Build check whether column is available (i.e. whether the tuple has
		 * that many columns stored). We can avoid the branch if we know
		 * there's a subsequent NOT NULL column.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <name>guaranteed_column_number</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LLVMBuildBr</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>attstartblocks</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_islast</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>v_islast</name> <operator>=</operator> <call><name>LLVMBuildICmp</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>LLVMIntUGE</name></expr></argument>,
									 <argument><expr><name>l_attno</name></expr></argument>,
									 <argument><expr><name>v_maxatt</name></expr></argument>,
									 <argument><expr><literal type="string">"heap_natts"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LLVMBuildCondBr</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_islast</name></expr></argument>, <argument><expr><name>b_out</name></expr></argument>, <argument><expr><name><name>attstartblocks</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>LLVMPositionBuilderAtEnd</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>attstartblocks</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check for nulls if necessary. No need to take missing attributes
		 * into account, because if they're present the heaptuple's natts
		 * would have indicated that a slot_getmissingattrs() is needed.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>att</name><operator>-&gt;</operator><name>attnotnull</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>LLVMBasicBlockRef</name></type> <name>b_ifnotnull</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>LLVMBasicBlockRef</name></type> <name>b_ifnull</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>LLVMBasicBlockRef</name></type> <name>b_next</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_attisnull</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_nullbyteno</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_nullbytemask</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_nullbyte</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_nullbit</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>b_ifnotnull</name> <operator>=</operator> <name><name>attcheckalignblocks</name><index>[<expr><name>attnum</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>b_ifnull</name> <operator>=</operator> <name><name>attisnullblocks</name><index>[<expr><name>attnum</name></expr>]</index></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <name>natts</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>b_next</name> <operator>=</operator> <name>b_out</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>b_next</name> <operator>=</operator> <name><name>attcheckattnoblocks</name><index>[<expr><name>attnum</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name>v_nullbyteno</name> <operator>=</operator> <call><name>l_int32_const</name><argument_list>(<argument><expr><name>attnum</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v_nullbytemask</name> <operator>=</operator> <call><name>l_int8_const</name><argument_list>(<argument><expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><operator>(</operator><name>attnum</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x07</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v_nullbyte</name> <operator>=</operator> <call><name>l_load_gep1</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_bits</name></expr></argument>, <argument><expr><name>v_nullbyteno</name></expr></argument>, <argument><expr><literal type="string">"attnullbyte"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>v_nullbit</name> <operator>=</operator> <call><name>LLVMBuildICmp</name><argument_list>(<argument><expr><name>b</name></expr></argument>,
									  <argument><expr><name>LLVMIntEQ</name></expr></argument>,
									  <argument><expr><call><name>LLVMBuildAnd</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_nullbyte</name></expr></argument>, <argument><expr><name>v_nullbytemask</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>l_int8_const</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><literal type="string">"attisnull"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>v_attisnull</name> <operator>=</operator> <call><name>LLVMBuildAnd</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_hasnulls</name></expr></argument>, <argument><expr><name>v_nullbit</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>LLVMBuildCondBr</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_attisnull</name></expr></argument>, <argument><expr><name>b_ifnull</name></expr></argument>, <argument><expr><name>b_ifnotnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>LLVMPositionBuilderAtEnd</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>b_ifnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* store null-byte */</comment>
			<expr_stmt><expr><call><name>LLVMBuildStore</name><argument_list>(<argument><expr><name>b</name></expr></argument>,
						   <argument><expr><call><name>l_int8_const</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>LLVMBuildGEP</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_tts_nulls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>l_attno</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* store zero datum */</comment>
			<expr_stmt><expr><call><name>LLVMBuildStore</name><argument_list>(<argument><expr><name>b</name></expr></argument>,
						   <argument><expr><call><name>l_sizet_const</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>LLVMBuildGEP</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_tts_values</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>l_attno</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>LLVMBuildBr</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>b_next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>attguaranteedalign</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* nothing to do */</comment>
			<expr_stmt><expr><call><name>LLVMBuildBr</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>attcheckalignblocks</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LLVMPositionBuilderAtEnd</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>attisnullblocks</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LLVMBuildBr</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>attcheckalignblocks</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>LLVMPositionBuilderAtEnd</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>attcheckalignblocks</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* determine required alignment */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attalign</name></name> <operator>==</operator> <name>TYPALIGN_INT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>alignto</name> <operator>=</operator> <name>ALIGNOF_INT</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attalign</name></name> <operator>==</operator> <name>TYPALIGN_CHAR</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>alignto</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attalign</name></name> <operator>==</operator> <name>TYPALIGN_DOUBLE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>alignto</name> <operator>=</operator> <name>ALIGNOF_DOUBLE</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attalign</name></name> <operator>==</operator> <name>TYPALIGN_SHORT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>alignto</name> <operator>=</operator> <name>ALIGNOF_SHORT</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown alignment"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>alignto</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* ------
		 * Even if alignment is required, we can skip doing it if provably
		 * unnecessary:
		 * - first column is guaranteed to be aligned
		 * - columns following a NOT NULL fixed width datum have known
		 *   alignment, can skip alignment computation if that known alignment
		 *   is compatible with current column.
		 * ------
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>alignto</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>known_alignment</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>known_alignment</name> <operator>!=</operator> <call><name>TYPEALIGN</name><argument_list>(<argument><expr><name>alignto</name></expr></argument>, <argument><expr><name>known_alignment</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * When accessing a varlena field, we have to "peek" to see if we
			 * are looking at a pad byte or the first byte of a 1-byte-header
			 * datum.  A zero byte must be either a pad byte, or the first
			 * byte of a correctly aligned 4-byte length word; in either case,
			 * we can align safely.  A non-zero byte must be either a 1-byte
			 * length word, or the first byte of a correctly aligned 4-byte
			 * length word; in either case, we need not align.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_possible_padbyte</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_ispad</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_off</name></decl>;</decl_stmt>

				<comment type="block">/* don't know if short varlena or not */</comment>
				<expr_stmt><expr><name>attguaranteedalign</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

				<expr_stmt><expr><name>v_off</name> <operator>=</operator> <call><name>LLVMBuildLoad</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_offp</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>v_possible_padbyte</name> <operator>=</operator>
					<call><name>l_load_gep1</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_tupdata_base</name></expr></argument>, <argument><expr><name>v_off</name></expr></argument>, <argument><expr><literal type="string">"padbyte"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>v_ispad</name> <operator>=</operator>
					<call><name>LLVMBuildICmp</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>LLVMIntEQ</name></expr></argument>,
								  <argument><expr><name>v_possible_padbyte</name></expr></argument>, <argument><expr><call><name>l_int8_const</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><literal type="string">"ispadbyte"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>LLVMBuildCondBr</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_ispad</name></expr></argument>,
								<argument><expr><name><name>attalignblocks</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>,
								<argument><expr><name><name>attstoreblocks</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>LLVMBuildBr</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>attalignblocks</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>LLVMPositionBuilderAtEnd</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>attalignblocks</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* translation of alignment code (cf TYPEALIGN()) */</comment>
			<block>{<block_content>
				<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_off_aligned</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_off</name> <init>= <expr><call><name>LLVMBuildLoad</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_offp</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/* ((ALIGNVAL) - 1) */</comment>
				<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_alignval</name> <init>= <expr><call><name>l_sizet_const</name><argument_list>(<argument><expr><name>alignto</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/* ((uintptr_t) (LEN) + ((ALIGNVAL) - 1)) */</comment>
				<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_lh</name> <init>= <expr><call><name>LLVMBuildAdd</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_off</name></expr></argument>, <argument><expr><name>v_alignval</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/* ~((uintptr_t) ((ALIGNVAL) - 1)) */</comment>
				<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_rh</name> <init>= <expr><call><name>l_sizet_const</name><argument_list>(<argument><expr><operator>~</operator><operator>(</operator><name>alignto</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>v_off_aligned</name> <operator>=</operator> <call><name>LLVMBuildAnd</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_lh</name></expr></argument>, <argument><expr><name>v_rh</name></expr></argument>, <argument><expr><literal type="string">"aligned_offset"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>LLVMBuildStore</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_off_aligned</name></expr></argument>, <argument><expr><name>v_offp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>

			<comment type="block">/*
			 * As alignment either was unnecessary or has been performed, we
			 * now know the current alignment. This is only safe because this
			 * value isn't used for varlena and nullable columns.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>known_alignment</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>known_alignment</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>known_alignment</name> <operator>=</operator> <call><name>TYPEALIGN</name><argument_list>(<argument><expr><name>alignto</name></expr></argument>, <argument><expr><name>known_alignment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>LLVMBuildBr</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>attstoreblocks</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LLVMPositionBuilderAtEnd</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>attstoreblocks</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>LLVMPositionBuilderAtEnd</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>attcheckalignblocks</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LLVMBuildBr</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>attalignblocks</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LLVMPositionBuilderAtEnd</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>attalignblocks</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LLVMBuildBr</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>attstoreblocks</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>LLVMPositionBuilderAtEnd</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>attstoreblocks</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Store the current offset if known to be constant. That allows LLVM
		 * to generate better code. Without that LLVM can't figure out that
		 * the offset might be constant due to the jumps for previously
		 * decoded columns.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>attguaranteedalign</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>known_alignment</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LLVMBuildStore</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><call><name>l_sizet_const</name><argument_list>(<argument><expr><name>known_alignment</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>v_offp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* compute what following columns are aligned to */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* can't guarantee any alignment after variable length field */</comment>
			<expr_stmt><expr><name>known_alignment</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>attguaranteedalign</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attnotnull</name></name> <operator>&amp;&amp;</operator> <name>attguaranteedalign</name> <operator>&amp;&amp;</operator> <name>known_alignment</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If the offset to the column was previously known, a NOT NULL &amp;
			 * fixed-width column guarantees that alignment is just the
			 * previous alignment plus column width.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>known_alignment</name> <operator>+=</operator> <name><name>att</name><operator>-&gt;</operator><name>attlen</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attnotnull</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name> <operator>%</operator> <name>alignto</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * After a NOT NULL fixed-width column with a length that is a
			 * multiple of its alignment requirement, we know the following
			 * column is aligned to at least the current column's alignment.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>known_alignment</name> <operator>=</operator> <name>alignto</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>known_alignment</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>attguaranteedalign</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>known_alignment</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>attguaranteedalign</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>


		<comment type="block">/* compute address to load data from */</comment>
		<block>{<block_content>
			<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_off</name> <init>= <expr><call><name>LLVMBuildLoad</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_offp</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>v_attdatap</name> <operator>=</operator>
				<call><name>LLVMBuildGEP</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_tupdata_base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v_off</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/* compute address to store value at */</comment>
		<expr_stmt><expr><name>v_resultp</name> <operator>=</operator> <call><name>LLVMBuildGEP</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_tts_values</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>l_attno</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* store null-byte (false) */</comment>
		<expr_stmt><expr><call><name>LLVMBuildStore</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><call><name>l_int8_const</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><call><name>LLVMBuildGEP</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_tts_nulls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>l_attno</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Store datum. For byval: datums copy the value, extend to Datum's
		 * width, and store. For byref types: store pointer to data.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attbyval</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_tmp_loaddata</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>LLVMTypeRef</name></type> <name>vartypep</name> <init>=
			<expr><call><name>LLVMPointerType</name><argument_list>(<argument><expr><call><name>LLVMIntType</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name> <operator>*</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>v_tmp_loaddata</name> <operator>=</operator>
				<call><name>LLVMBuildPointerCast</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_attdatap</name></expr></argument>, <argument><expr><name>vartypep</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v_tmp_loaddata</name> <operator>=</operator> <call><name>LLVMBuildLoad</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_tmp_loaddata</name></expr></argument>, <argument><expr><literal type="string">"attr_byval"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v_tmp_loaddata</name> <operator>=</operator> <call><name>LLVMBuildZExt</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_tmp_loaddata</name></expr></argument>, <argument><expr><name>TypeSizeT</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>LLVMBuildStore</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_tmp_loaddata</name></expr></argument>, <argument><expr><name>v_resultp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_tmp_loaddata</name></decl>;</decl_stmt>

			<comment type="block">/* store pointer */</comment>
			<expr_stmt><expr><name>v_tmp_loaddata</name> <operator>=</operator>
				<call><name>LLVMBuildPtrToInt</name><argument_list>(<argument><expr><name>b</name></expr></argument>,
								  <argument><expr><name>v_attdatap</name></expr></argument>,
								  <argument><expr><name>TypeSizeT</name></expr></argument>,
								  <argument><expr><literal type="string">"attr_ptr"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LLVMBuildStore</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_tmp_loaddata</name></expr></argument>, <argument><expr><name>v_resultp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* increment data pointer */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>v_incby</name> <operator>=</operator> <call><name>l_sizet_const</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>v_incby</name> <operator>=</operator> <call><name>LLVMBuildCall</name><argument_list>(<argument><expr><name>b</name></expr></argument>,
									<argument><expr><call><name>llvm_pg_func</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="string">"varsize_any"</literal></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>v_attdatap</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
									<argument><expr><literal type="string">"varsize_any"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>l_callsite_ro</name><argument_list>(<argument><expr><name>v_incby</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>l_callsite_alwaysinline</name><argument_list>(<argument><expr><name>v_incby</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>v_incby</name> <operator>=</operator> <call><name>LLVMBuildCall</name><argument_list>(<argument><expr><name>b</name></expr></argument>,
									<argument><expr><call><name>llvm_pg_func</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="string">"strlen"</literal></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>v_attdatap</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"strlen"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>l_callsite_ro</name><argument_list>(<argument><expr><name>v_incby</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* add 1 for NUL byte */</comment>
			<expr_stmt><expr><name>v_incby</name> <operator>=</operator> <call><name>LLVMBuildAdd</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_incby</name></expr></argument>, <argument><expr><call><name>l_sizet_const</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>v_incby</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* silence compiler */</comment>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>attguaranteedalign</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>known_alignment</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LLVMBuildStore</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><call><name>l_sizet_const</name><argument_list>(<argument><expr><name>known_alignment</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>v_offp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_off</name> <init>= <expr><call><name>LLVMBuildLoad</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_offp</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>v_off</name> <operator>=</operator> <call><name>LLVMBuildAdd</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_off</name></expr></argument>, <argument><expr><name>v_incby</name></expr></argument>, <argument><expr><literal type="string">"increment_offset"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LLVMBuildStore</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_off</name></expr></argument>, <argument><expr><name>v_offp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * jump to next block, unless last possible column, or all desired
		 * (available) attributes have been fetched.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <name>natts</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* jump out */</comment>
			<expr_stmt><expr><call><name>LLVMBuildBr</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>b_out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>LLVMBuildBr</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>attcheckattnoblocks</name><index>[<expr><name>attnum</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>


	<comment type="block">/* build block that returns */</comment>
	<expr_stmt><expr><call><name>LLVMPositionBuilderAtEnd</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>b_out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<block>{<block_content>
		<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_off</name> <init>= <expr><call><name>LLVMBuildLoad</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_offp</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_flags</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>LLVMBuildStore</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><call><name>l_int16_const</name><argument_list>(<argument><expr><name>natts</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>v_nvalidp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>v_off</name> <operator>=</operator> <call><name>LLVMBuildTrunc</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_off</name></expr></argument>, <argument><expr><call><name>LLVMInt32Type</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LLVMBuildStore</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_off</name></expr></argument>, <argument><expr><name>v_slotoffp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>v_flags</name> <operator>=</operator> <call><name>LLVMBuildLoad</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_flagsp</name></expr></argument>, <argument><expr><literal type="string">"tts_flags"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>v_flags</name> <operator>=</operator> <call><name>LLVMBuildOr</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_flags</name></expr></argument>, <argument><expr><call><name>l_int16_const</name><argument_list>(<argument><expr><name>TTS_FLAG_SLOW</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LLVMBuildStore</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>v_flags</name></expr></argument>, <argument><expr><name>v_flagsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LLVMBuildRetVoid</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>LLVMDisposeBuilder</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>v_deform_fn</name></expr>;</return>
</block_content>}</block></function>
</unit>
