<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/parser/parse_cypher_expr.c"><comment type="block">/*
 * parse_cypher_expr.c
 *	  handle Cypher expressions in parser
 *
 * Copyright (c) 2017 by Bitnine Global, Inc.
 *
 * IDENTIFICATION
 *	  src/backend/parser/parse_cypher_expr.c
 *
 *
 * To store all types that Cypher supports in a single column, almost all
 * expressions expect jsonb values as their arguments and return a jsonb value.
 * Exceptions are comparison operators (=, &lt;&gt;, &lt;, &gt;, &lt;=, &gt;=) and boolean
 * operators (OR, AND, NOT). Comparison operators take jsonb values and return
 * a bool value. And boolean operators take bool values and return a bool
 * value. This is because they use the existing implementation to evaluate
 * themselves.
 * We use SQL NULL instead of 'null'::jsonb. This makes it easy to implement
 * "operations on NULL values return NULL".
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ag_const.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/analyze.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_clause.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_collate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_cypher_expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_func.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_oper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_target.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_cypher_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/jsonb.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformCypherExprRecurse</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformColumnRef</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ColumnRef</name> <modifier>*</modifier></type><name>cref</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformListCompColumnRef</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ColumnRef</name> <modifier>*</modifier></type><name>cref</name></decl></parameter>,
										<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>varname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>scanNSItemForVar</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl></parameter>,
							  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformFields</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>basenode</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fields</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>filterAccessArg</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>,
							 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>types</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformParamRef</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ParamRef</name> <modifier>*</modifier></type><name>pref</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformTypeCast</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>TypeCast</name> <modifier>*</modifier></type><name>tc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformCypherMapExpr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherMapExpr</name> <modifier>*</modifier></type><name>m</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformCypherListExpr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherListExpr</name> <modifier>*</modifier></type><name>cl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformCypherListComp</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherListComp</name> <modifier>*</modifier></type> <name>clc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformCaseExpr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CaseExpr</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformFuncCall</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>FuncCall</name> <modifier>*</modifier></type><name>fn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>preprocess_func_args</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>FuncCall</name> <modifier>*</modifier></type><name>fn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>FuncCandidateList</name></type> <name>func_get_best_candidate</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
												 <parameter><decl><type><name>FuncCall</name> <modifier>*</modifier></type><name>fn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>,
												 <parameter><decl><type><name>Oid</name></type> <name><name>argtypes</name><index>[<expr><name>FUNC_MAX_ARGS</name></expr>]</index></name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>func_match_argtypes_jsonb</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name><name>argtypes</name><index>[<expr><name>FUNC_MAX_ARGS</name></expr>]</index></name></decl></parameter>,
									 <parameter><decl><type><name>FuncCandidateList</name></type> <name>raw_candidates</name></decl></parameter>,
									 <parameter><decl><type><name>FuncCandidateList</name> <modifier>*</modifier></type><name>candidates</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>FuncCandidateList</name></type> <name>func_select_candidate_jsonb</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>,
													 <parameter><decl><type><name>Oid</name></type> <name><name>argtypes</name><index>[<expr><name>FUNC_MAX_ARGS</name></expr>]</index></name></decl></parameter>,
													 <parameter><decl><type><name>FuncCandidateList</name></type> <name>candidates</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>cypher_match_function</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>matchDepth</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>,
								 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>input_base_typeids</name></decl></parameter>,
								 <parameter><decl><type><name>TYPCATEGORY</name> <modifier>*</modifier></type><name>slot_category</name></decl></parameter>,
								 <parameter><decl><type><name>FuncCandidateList</name> <modifier>*</modifier></type><name>candidates</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>cypher_match_function_criteria</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>matchDepth</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>inputBaseType</name></decl></parameter>,
										   <parameter><decl><type><name>Oid</name></type> <name>currentType</name></decl></parameter>,
										   <parameter><decl><type><name>TYPCATEGORY</name></type> <name>slotCategory</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>func_get_best_args</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>,
								<parameter><decl><type><name>Oid</name></type> <name><name>argtypes</name><index>[<expr><name>FUNC_MAX_ARGS</name></expr>]</index></name></decl></parameter>,
								<parameter><decl><type><name>FuncCandidateList</name></type> <name>candidate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformCoalesceExpr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CoalesceExpr</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformIndirection</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>A_Indirection</name> <modifier>*</modifier></type><name>indir</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>makeArrayIndex</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>idx</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>exclusive</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>adjustListIndexType</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>idx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformAExprOp</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>A_Expr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformAExprIn</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>A_Expr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformBoolExpr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>BoolExpr</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>coerce_unknown_const</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>ityp</name></decl></parameter>,
								  <parameter><decl><type><name>Oid</name></type> <name>otyp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>stringToJsonb</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>coerce_to_jsonb</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
							 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_graph_type</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>coerce_all_to_jsonb</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>transformA_Star</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>build_cypher_cast_expr</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>otyp</name></decl></parameter>,
									<parameter><decl><type><name>CoercionContext</name></type> <name>cctx</name></decl></parameter>,
									<parameter><decl><type><name>CoercionForm</name></type> <name>cform</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>loc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>coerce_cypher_arg_to_boolean</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
										  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>constructName</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* GUC variable (allow/disallow null properties) */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>allow_null_properties</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<function><type><name>Node</name> <modifier>*</modifier></type>
<name>transformCypherExpr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>ParseExprKind</name></type> <name>exprKind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseExprKind</name></type> <name>sv_expr_kind</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>exprKind</name> <operator>!=</operator> <name>EXPR_KIND_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sv_expr_kind</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>exprKind</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformCypherExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>sv_expr_kind</name></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformCypherExprRecurse</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>expr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_ColumnRef</name></expr>:</case>
			<return>return <expr><call><name>transformColumnRef</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>ColumnRef</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_ParamRef</name></expr>:</case>
			<return>return <expr><call><name>transformParamRef</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>ParamRef</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_A_Const</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>A_Const</name>	   <modifier>*</modifier></type><name>a_con</name> <init>= <expr><operator>(</operator><name>A_Const</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Value</name>	   <modifier>*</modifier></type><name>value</name> <init>= <expr><operator>&amp;</operator><name><name>a_con</name><operator>-&gt;</operator><name>val</name></name></expr></init></decl>;</decl_stmt>

				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_const</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>a_con</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block>
		<case>case <expr><name>T_TypeCast</name></expr>:</case>
			<return>return <expr><call><name>transformTypeCast</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>TypeCast</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_CypherMapExpr</name></expr>:</case>
			<return>return <expr><call><name>transformCypherMapExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>CypherMapExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_CypherListExpr</name></expr>:</case>
			<return>return <expr><call><name>transformCypherListExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>CypherListExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_CypherListComp</name></expr>:</case>
			<return>return <expr><call><name>transformCypherListComp</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>CypherListComp</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_CaseExpr</name></expr>:</case>
			<return>return <expr><call><name>transformCaseExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>CaseExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_CaseTestExpr</name></expr>:</case>
			<return>return <expr><name>expr</name></expr>;</return>
		<case>case <expr><name>T_FuncCall</name></expr>:</case>
			<return>return <expr><call><name>transformFuncCall</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>FuncCall</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_CoalesceExpr</name></expr>:</case>
			<return>return <expr><call><name>transformCoalesceExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>CoalesceExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_SubLink</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SubLink</name>	   <modifier>*</modifier></type><name>sublink</name> <init>= <expr><operator>(</operator><name>SubLink</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>CypherGenericExpr</name> <modifier>*</modifier></type><name>cexpr</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>cexpr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CypherGenericExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>cexpr</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>cexpr</name></expr>;</expr_stmt>

				<return>return <expr><call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block>
		<case>case <expr><name>T_A_Indirection</name></expr>:</case>
			<return>return <expr><call><name>transformIndirection</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>A_Indirection</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_A_Expr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>A_Expr</name>	   <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>(</operator><name>A_Expr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

				<switch>switch <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>AEXPR_OP</name></expr>:</case>
						<return>return <expr><call><name>transformAExprOp</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</return>
					<case>case <expr><name>AEXPR_IN</name></expr>:</case>
						<return>return <expr><call><name>transformAExprIn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</return>
					<default>default:</default>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized A_Expr kind: %d"</literal></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<return>return <expr><name>NULL</name></expr>;</return>
				</block_content>}</block></switch>
			</block_content>}</block>
		<case>case <expr><name>T_NullTest</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>n</name> <init>= <expr><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>transformCypherExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
															 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>n</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>argisrow</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

				<return>return <expr><name>expr</name></expr>;</return>
			</block_content>}</block>
		<case>case <expr><name>T_BoolExpr</name></expr>:</case>
			<return>return <expr><call><name>transformBoolExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Because we have to check all the cases of variable references (Cypher
 * variables and variables in ancestor queries) for each level of ParseState,
 * logic and functions in the original transformColumnRef() are properly
 * modified, refactored, and then integrated into one.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformColumnRef</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ColumnRef</name> <modifier>*</modifier></type><name>cref</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nfields</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>location</name> <init>= <expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>field1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>field2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>field3</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>nspid1</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>field4</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>nspid2</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate_up</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nmatched</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * The iterator variable used in a list comprehension expression always
	 * hides other variables with the same name.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_lc_varname</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>transformListCompColumnRef</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>cref</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_lc_varname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>node</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>node</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_pre_columnref_hook</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <call>(<modifier>*</modifier><name><name>pstate</name><operator>-&gt;</operator><name>p_pre_columnref_hook</name></name>) <argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>node</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>node</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>field1</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nfields</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>field2</name> <operator>=</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>nfields</name> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>field3</name> <operator>=</operator> <call><name>lthird</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nspid1</name> <operator>=</operator> <call><name>LookupNamespaceNoError</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>field1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>nfields</name> <operator>&gt;=</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>field1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>field4</name> <operator>=</operator> <call><name>lfourth</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nspid2</name> <operator>=</operator> <call><name>LookupNamespaceNoError</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>field2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>pstate_up</name> <operator>=</operator> <name>pstate</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>pstate_up</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lni</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Find the Var at the current level of ParseState in a greedy fashion,
		 * i.e., match as many identifiers as possible. This means that, when
		 * a qualified name is given, resolving it as Var has higher priority
		 * than resolving it as property access.
		 *
		 * For example, when `x.y` is given, and if `x.y` can be resolved as
		 * &lt;Column x, Property y&gt; and &lt;RTE x, Column y&gt;, it will be resolved
		 * as the later.
		 *
		 * This is because, in the above case, there is no way to refer to
		 * &lt;Column y&gt; if it stops to resolve the name when &lt;Column x&gt; is found.
		 * However, by using `x['y']`, &lt;Property y&gt; is still accessible.
		 */</comment>

		<macro><name>foreach</name><argument_list>(<argument>lni</argument>, <argument>pstate_up-&gt;p_namespace</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lni</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_rte</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_lateral_only</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* If not inside LATERAL, ignore lateral-only items. */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pstate_up</name><operator>-&gt;</operator><name>p_lateral_active</name></name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * If the namespace item is currently disallowed as a LATERAL
				 * reference, skip the rest.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nsitem</name><operator>-&gt;</operator><name>p_lateral_ok</name></name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * If this RTE is accessible by unqualified names,
			 * examine `field1`.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_cols_visible</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>scanNSItemForVar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>field1</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>nmatched</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * If this RTE is inaccessible by qualified names,
			 * skip the rest.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nsitem</name><operator>-&gt;</operator><name>p_rel_visible</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* examine `field1.field2` */</comment>
			<if_stmt><if>if <condition>(<expr><name>field2</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>, <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>field1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>scanNSItemForVar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>field2</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>nmatched</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* examine `field1.field2.field3` */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>nspid1</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>relid2</name> <init>= <expr><call><name>get_relname_relid</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>field2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nspid1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid2</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name> <operator>&amp;&amp;</operator>
					<name><name>rte</name><operator>-&gt;</operator><name>relid</name></name> <operator>==</operator> <name>relid2</name> <operator>&amp;&amp;</operator>
					<name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>

					<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>scanNSItemForVar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>field3</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>nmatched</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* examine `field1.field2.field3.field4` */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>nspid2</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>relid3</name> <init>= <expr><call><name>get_relname_relid</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>field3</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nspid2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid3</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name> <operator>&amp;&amp;</operator>
					<name><name>rte</name><operator>-&gt;</operator><name>relid</name></name> <operator>==</operator> <name>relid3</name> <operator>&amp;&amp;</operator>
					<name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>scanNSItemForVar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>,
											<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>field4</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>nmatched</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>node</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>node</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>pstate_up</name> <operator>=</operator> <name><name>pstate_up</name><operator>-&gt;</operator><name>parentParseState</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_post_columnref_hook</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>hookresult</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>hookresult</name> <operator>=</operator> <call>(<modifier>*</modifier><name><name>pstate</name><operator>-&gt;</operator><name>p_post_columnref_hook</name></name>) <argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>cref</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>node</name> <operator>=</operator> <name>hookresult</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>nmatched</name> <operator>=</operator> <name>nfields</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>hookresult</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_AMBIGUOUS_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column reference \"%s\" is ambiguous"</literal></expr></argument>,
								   <argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"variable does not exist"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* use remaining fields of the given name as keys for property access */</comment>
	<if_stmt><if>if <condition>(<expr><name>nmatched</name> <operator>&lt;</operator> <name>nfields</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newfields</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newfields</name> <operator>=</operator> <call><name>list_copy_tail</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>, <argument><expr><name>nmatched</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><call><name>transformFields</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>newfields</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformListCompColumnRef</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ColumnRef</name> <modifier>*</modifier></type><name>cref</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>varname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>field1</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CypherListCompVar</name> <modifier>*</modifier></type><name>clcvar</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * For PROPERTY INDEX, removes the access "properties" in ColumnRef
	 * because it is granted with "properties" by default.
	 *
	 * i.e, properties-&gt;A =&gt; A
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>==</operator> <name>EXPR_KIND_INDEX_EXPRESSION</name> <operator>&amp;&amp;</operator>
		<call><name>list_length</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>field1</name> <operator>=</operator> <call><name>llast</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>varname</name></expr></argument>, <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>field1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>==</operator> <name>EXPR_KIND_INDEX_EXPRESSION</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>clcvar</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CypherListCompVar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>clcvar</name><operator>-&gt;</operator><name>varname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>clcvar</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newfields</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newfields</name> <operator>=</operator> <call><name>list_copy_tail</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><call><name>transformFields</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>clcvar</name></expr></argument>, <argument><expr><name>newfields</name></expr></argument>,
							   <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>clcvar</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>scanNSItemForVar</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>,
				 <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_rte</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attrno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name><modifier>*</modifier></type> <name>var</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>attrno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rte-&gt;eref-&gt;colnames</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colalias</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>attrno</name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>colalias</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>make_var</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>attrno</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>markVarForSelectPriv</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>var</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformFields</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>basenode</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fields</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>restype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Value</name>	   <modifier>*</modifier></type><name>field</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <name>basenode</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>restype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* record/composite type */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lf</argument>, <argument>fields</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/*
		 * Redirect access to the attributes of `vertex`/`edge` type to
		 * `properties` attribute of them by coercing them to `jsonb` later in
		 * this function.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>restype</name> <operator>==</operator> <name>VERTEXOID</name> <operator>||</operator> <name>restype</name> <operator>==</operator> <name>EDGEOID</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Prevent access to the attributes of `graphpath` type directly.
		 * Instead, users may call `nodes()` (or `vertices()`) and
		 * `relationships()` (or `edges()`) to get them.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>restype</name> <operator>==</operator> <name>GRAPHPATHOID</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>type_is_rowtype</name><argument_list>(<argument><expr><name>restype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>field</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ParseFuncOrColumn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"attribute \"%s\" not found in type %s"</literal></expr></argument>,
								   <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>restype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>restype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>lf</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>filterAccessArg</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>location</name></expr></argument>, <argument><expr><literal type="string">"map"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>for_each_cell</name><argument_list>(<argument>lf</argument>, <argument>fields</argument>, <argument>lf</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>elem</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>field</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>elem</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>DEFAULT_COLLATION_OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
								  <argument><expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><call><name>makeJsonbFuncAccessor</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>filterAccessArg</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>,
				<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>types</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>exprtype</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>exprtype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>VERTEXOID</name></expr>:</case>
		<case>case <expr><name>EDGEOID</name></expr>:</case>
			<return>return <expr><call><name>ParseFuncOrColumn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
									 <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>AG_ELEM_PROP_MAP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>JSONBOID</name></expr>:</case>
			<return>return <expr><name>expr</name></expr>;</return>

		<case>case <expr><name>JSONOID</name></expr>:</case>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>coerce_expr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>JSONOID</name></expr></argument>, <argument><expr><name>JSONBOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
							   <argument><expr><name>COERCION_EXPLICIT</name></expr></argument>, <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
							   <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>expr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>expr</name></expr>;</return>

		<default>default:</default>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is expected but %s"</literal></expr></argument>,
								   <argument><expr><name>types</name></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>exprtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformParamRef</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ParamRef</name> <modifier>*</modifier></type><name>pref</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_paramref_hook</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call>(<modifier>*</modifier><name><name>pstate</name><operator>-&gt;</operator><name>p_paramref_hook</name></name>) <argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>pref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_PARAMETER</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"there is no parameter $%d"</literal></expr></argument>, <argument><expr><name><name>pref</name><operator>-&gt;</operator><name>number</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>pref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformTypeCast</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>TypeCast</name> <modifier>*</modifier></type><name>tc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>otyp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>otypmod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ityp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>loc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>typenameTypeIdAndMod</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>tc</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>otyp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>otypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>transformCypherExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>tc</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ityp</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ityp</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>expr</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>loc</name> <operator>=</operator> <name><name>tc</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>loc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>loc</name> <operator>=</operator> <name><name>tc</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>coerce_expr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>ityp</name></expr></argument>, <argument><expr><name>otyp</name></expr></argument>, <argument><expr><name>otypmod</name></expr></argument>,
					   <argument><expr><name>COERCION_EXPLICIT</name></expr></argument>, <argument><expr><name>COERCE_EXPLICIT_CAST</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CANNOT_COERCE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot cast type %s to %s"</literal></expr></argument>,
							   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>ityp</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>otyp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_coercion_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformCypherMapExpr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherMapExpr</name> <modifier>*</modifier></type><name>m</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newkeyvals</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>le</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CypherMapExpr</name> <modifier>*</modifier></type><name>newm</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>keyvals</name></name></expr></argument>)</argument_list></call> <operator>%</operator> <literal type="number">2</literal> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>le</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>keyvals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>le</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>k</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>newv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>newk</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>le</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>keyvals</name></name></expr></argument>, <argument><expr><name>le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>le</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>keyvals</name></name></expr></argument>, <argument><expr><name>le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>newv</name> <operator>=</operator> <call><name>transformCypherExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>newv</name> <operator>=</operator> <call><name>coerce_to_jsonb</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>newv</name></expr></argument>, <argument><expr><literal type="string">"property value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>newk</name> <operator>=</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>DEFAULT_COLLATION_OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
						 <argument><expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>newkeyvals</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><call><name>lappend</name><argument_list>(<argument><expr><name>newkeyvals</name></expr></argument>, <argument><expr><name>newk</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>newv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><name>newm</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CypherMapExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newm</name><operator>-&gt;</operator><name>keyvals</name></name> <operator>=</operator> <name>newkeyvals</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newm</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newm</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformCypherListExpr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherListExpr</name> <modifier>*</modifier></type><name>cl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newelems</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>le</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CypherListExpr</name> <modifier>*</modifier></type><name>newcl</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>le</argument>, <argument>cl-&gt;elems</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>newe</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newe</name> <operator>=</operator> <call><name>transformCypherExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>newe</name> <operator>=</operator> <call><name>coerce_to_jsonb</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>newe</name></expr></argument>, <argument><expr><literal type="string">"list element"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>newelems</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newelems</name></expr></argument>, <argument><expr><name>newe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>newcl</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CypherListExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newcl</name><operator>-&gt;</operator><name>elems</name></name> <operator>=</operator> <name>newelems</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newcl</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>cl</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newcl</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformCypherListComp</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherListComp</name> <modifier>*</modifier></type><name>clc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>save_varname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>cond</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>elem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CypherListCompExpr</name> <modifier>*</modifier></type><name>clcexpr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>transformCypherExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>clc</name><operator>-&gt;</operator><name>list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>JSONBOID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>coerce_all_to_jsonb</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>save_varname</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_lc_varname</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_lc_varname</name></name> <operator>=</operator> <name><name>clc</name><operator>-&gt;</operator><name>varname</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cond</name> <operator>=</operator> <call><name>transformCypherWhere</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>clc</name><operator>-&gt;</operator><name>cond</name></name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>elem</name> <operator>=</operator> <call><name>transformCypherExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>clc</name><operator>-&gt;</operator><name>elem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_lc_varname</name></name> <operator>=</operator> <name>save_varname</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>elem</name> <operator>=</operator> <call><name>coerce_to_jsonb</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>, <argument><expr><literal type="string">"list comprehension result"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>clcexpr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CypherListCompExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>clcexpr</name><operator>-&gt;</operator><name>list</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>list</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>clcexpr</name><operator>-&gt;</operator><name>varname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>clc</name><operator>-&gt;</operator><name>varname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>clcexpr</name><operator>-&gt;</operator><name>cond</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>cond</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>clcexpr</name><operator>-&gt;</operator><name>elem</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>elem</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>clcexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>clc</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>clcexpr</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformCaseExpr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CaseExpr</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CaseTestExpr</name> <modifier>*</modifier></type><name>placeholder</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lw</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CaseWhen</name>   <modifier>*</modifier></type><name>w</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>results</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_jsonb</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>rdefresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>defresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>restype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CaseExpr</name>   <modifier>*</modifier></type><name>newc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>transformCypherExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>c</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>arg</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>placeholder</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>placeholder</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CaseTestExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>placeholder</name><operator>-&gt;</operator><name>typeId</name></name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>placeholder</name><operator>-&gt;</operator><name>typeMod</name></name> <operator>=</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>placeholder</name><operator>-&gt;</operator><name>collation</name></name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lw</argument>, <argument>c-&gt;args</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>rexpr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CaseWhen</name>   <modifier>*</modifier></type><name>neww</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>CaseWhen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>rexpr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>w</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>placeholder</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>rexpr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeSimpleA_Expr</name><argument_list>(<argument><expr><name>AEXPR_OP</name></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>,
											  <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>placeholder</name></expr></argument>, <argument><expr><name>rexpr</name></expr></argument>,
											  <argument><expr><name><name>w</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>transformCypherExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>coerce_cypher_arg_to_boolean</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><literal type="string">"CASE/WHEN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformCypherExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>w</name><operator>-&gt;</operator><name>result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>JSONBOID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>is_jsonb</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>neww</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CaseWhen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>neww</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>neww</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>result</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>neww</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>w</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>neww</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>results</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>results</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>rdefresult</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>c</name><operator>-&gt;</operator><name>defresult</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rdefresult</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>A_Const</name>	   <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>A_Const</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_Null</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>rdefresult</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>n</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>defresult</name> <operator>=</operator> <call><name>transformCypherExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rdefresult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><name>defresult</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>JSONBOID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>is_jsonb</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_jsonb</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>restype</name> <operator>=</operator> <name>JSONBOID</name></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lw</argument>, <argument>args</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>coerce_to_jsonb</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>w</name><operator>-&gt;</operator><name>result</name></name></expr></argument>,
												 <argument><expr><literal type="string">"CASE/WHEN value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><name>defresult</name> <operator>=</operator> <call><name>coerce_to_jsonb</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>defresult</name></expr></argument>, <argument><expr><literal type="string">"CASE/WHEN value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>results</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>defresult</name></expr></argument>, <argument><expr><name>results</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>restype</name> <operator>=</operator> <call><name>select_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>results</name></expr></argument>, <argument><expr><literal type="string">"CASE"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lw</argument>, <argument>args</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>coerce_to_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
													   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>w</name><operator>-&gt;</operator><name>result</name></name></expr></argument>,
													   <argument><expr><name>restype</name></expr></argument>, <argument><expr><literal type="string">"CASE/WHEN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><name>defresult</name> <operator>=</operator> <call><name>coerce_to_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>defresult</name></expr></argument>, <argument><expr><name>restype</name></expr></argument>,
										  <argument><expr><literal type="string">"CASE/WHEN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>newc</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CaseExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newc</name><operator>-&gt;</operator><name>casetype</name></name> <operator>=</operator> <name>restype</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newc</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newc</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>args</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newc</name><operator>-&gt;</operator><name>defresult</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>defresult</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newc</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformFuncCall</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>FuncCall</name> <modifier>*</modifier></type><name>fn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>last_srf</name> <init>= <expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>fn</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>funcname</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>funcname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>fn</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* todo: Later, the sin function will be defined as the basic function of PG. */</comment>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>, <argument><expr><literal type="string">"collect"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>fn</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"jsonb_agg"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>, <argument><expr><literal type="string">"stdev"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>fn</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"stddev_samp"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>, <argument><expr><literal type="string">"stdevp"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>fn</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"stddev_pop"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<comment type="block">/* translate log() into ln() for cypher queries */</comment>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>, <argument><expr><literal type="string">"log"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>fn</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"ln"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>preprocess_func_args</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>ParseFuncOrColumn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>fn</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>last_srf</name></expr></argument>, <argument><expr><name>fn</name></expr></argument>,
							 <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>fn</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Assume jsonb arguments are property values and coerce them to the actual
 * argument types of candidate functions.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>preprocess_func_args</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>FuncCall</name> <modifier>*</modifier></type><name>fn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isSubstr</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>named</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>la</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>argtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>argtypes</name><index>[<expr><name>FUNC_MAX_ARGS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncCandidateList</name></type> <name>candidate</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>fn</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>FUNC_MAX_ARGS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_ARGUMENTS</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot pass more than %d arguments to a function"</literal></expr></argument>,
							   <argument><expr><name>FUNC_MAX_ARGS</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>fn</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>fn</name><operator>-&gt;</operator><name>agg_filter</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>fn</name><operator>-&gt;</operator><name>agg_within_group</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* test if this is the substring function */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>llast</name><argument_list>(<argument><expr><name><name>fn</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"substring"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>isSubstr</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>nargs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>named</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>la</argument>, <argument>fn-&gt;args</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * If this is second argument of the substring function, adjust it
		 * by adding 1 to it because
		 *
		 * 1) Cypher substring uses 0-based index.
		 * 2) text version of substring uses 1-based index.
		 * 3) we will always use text version of substring function.
		 *
		 * NOTE: Remove this code when we define a rule for selecting a
		 *       function with given arguments.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>isSubstr</name> <operator>&amp;&amp;</operator> <name>nargs</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>A_Const</name>	   <modifier>*</modifier></type><name>aconst</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>A_Const</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* constant value 1 */</comment>
			<expr_stmt><expr><name><name>aconst</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_Integer</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>aconst</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>val</name><operator>.</operator><name>ival</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>aconst</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

			<comment type="block">/* replace the second argument with `second_arg + 1` */</comment>
			<expr_stmt><expr><name><name>la</name><operator>-&gt;</operator><name>ptr_value</name></name> <operator>=</operator> <call><name>makeSimpleA_Expr</name><argument_list>(<argument><expr><name>AEXPR_OP</name></expr></argument>, <argument><expr><literal type="string">"+"</literal></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>la</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>aconst</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>transformCypherExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>la</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>NamedArgExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>named</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>argtype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>argtype</name> <operator>==</operator> <name>VOIDOID</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>argtypes</name><index>[<expr><name>nargs</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* This function does not handle named arguments. */</comment>
	<if_stmt><if>if <condition>(<expr><name>named</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>args</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* column projection */</comment>
	<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
		<name><name>fn</name><operator>-&gt;</operator><name>agg_order</name></name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name><name>fn</name><operator>-&gt;</operator><name>agg_star</name></name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name><name>fn</name><operator>-&gt;</operator><name>agg_distinct</name></name> <operator>&amp;&amp;</operator>
		<name><name>fn</name><operator>-&gt;</operator><name>over</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name><name>fn</name><operator>-&gt;</operator><name>func_variadic</name></name> <operator>&amp;&amp;</operator>
		<call><name>list_length</name><argument_list>(<argument><expr><name><name>fn</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>argtype</name> <operator>=</operator> <name><name>argtypes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>argtype</name> <operator>==</operator> <name>RECORDOID</name> <operator>||</operator> <call><name>ISCOMPLEX</name><argument_list>(<argument><expr><name>argtype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>args</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>candidate</name> <operator>=</operator> <call><name>func_get_best_candidate</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>fn</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>candidate</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function %s does not exist"</literal></expr></argument>,
							   <argument><expr><call><name>func_signature_string</name><argument_list>(<argument><expr><name><name>fn</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
													 <argument><expr><name>argtypes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"No function matches the given name and argument types. "</literal>
								<literal type="string">"You might need to add explicit type casts."</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>fn</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>func_get_best_args</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>FuncCandidateList</name></type>
<name>func_get_best_candidate</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>FuncCall</name> <modifier>*</modifier></type><name>fn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>,
						<parameter><decl><type><name>Oid</name></type> <name><name>argtypes</name><index>[<expr><name>FUNC_MAX_ARGS</name></expr>]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncCandidateList</name></type> <name>raw_candidates</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncCandidateList</name></type> <name>best_candidate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncCandidateList</name></type> <name>current_candidates</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncCandidateList</name></type> <name>previous_candidate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ncandidates</name></decl>;</decl_stmt>

	<comment type="block">/* get all candidates */</comment>
	<expr_stmt><expr><name>raw_candidates</name> <operator>=</operator> <call><name>FuncnameGetCandidates</name><argument_list>(<argument><expr><name><name>fn</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
										   <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Added to remove jsonb version of substring (jsonb_substr*) from the list
	 * of candidates if the function is substring.
	 *
	 * NOTE: Remove this code when we define a rule for selecting a function
	 *       with given arguments.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>llast</name><argument_list>(<argument><expr><name><name>fn</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"substring"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>best_candidate</name> <operator>=</operator> <name>raw_candidates</name></expr><operator>,</operator> <expr><name>previous_candidate</name> <operator>=</operator> <name>NULL</name></expr>;</init>
			 <condition><expr><name>best_candidate</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
			 <incr><expr><name>best_candidate</name> <operator>=</operator> <name><name>best_candidate</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/* if this is a jsonb substring function OID */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>best_candidate</name><operator>-&gt;</operator><name>oid</name></name> <operator>==</operator> <literal type="number">7235</literal> <operator>||</operator> <name><name>best_candidate</name><operator>-&gt;</operator><name>oid</name></name> <operator>==</operator> <literal type="number">7236</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* we are at the head of the list */</comment>
				<if_stmt><if>if <condition>(<expr><name>best_candidate</name> <operator>==</operator> <name>raw_candidates</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>raw_candidates</name> <operator>=</operator> <name><name>best_candidate</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>previous_candidate</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>best_candidate</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>previous_candidate</name> <operator>=</operator> <name>best_candidate</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* find exact match */</comment>
	<for>for <control>(<init><expr><name>best_candidate</name> <operator>=</operator> <name>raw_candidates</name></expr>;</init>
		 <condition><expr><name>best_candidate</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
		 <incr><expr><name>best_candidate</name> <operator>=</operator> <name><name>best_candidate</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>argtypes</name></expr></argument>, <argument><expr><name><name>best_candidate</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>nargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>best_candidate</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>best_candidate</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ncandidates</name> <operator>=</operator> <call><name>func_match_argtypes_jsonb</name><argument_list>(<argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>, <argument><expr><name>raw_candidates</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>current_candidates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ncandidates</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>best_candidate</name> <operator>=</operator> <name>current_candidates</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>ncandidates</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>best_candidate</name> <operator>=</operator> <call><name>func_select_candidate_jsonb</name><argument_list>(<argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>,
													 <argument><expr><name>current_candidates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>best_candidate</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_AMBIGUOUS_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function %s is not unique"</literal></expr></argument>,
								   <argument><expr><call><name>func_signature_string</name><argument_list>(<argument><expr><name><name>fn</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
														 <argument><expr><name>argtypes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Could not choose a best candidate function. "</literal>
									<literal type="string">"You might need to add explicit type casts."</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>fn</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>best_candidate</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>func_match_argtypes_jsonb</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name><name>argtypes</name><index>[<expr><name>FUNC_MAX_ARGS</name></expr>]</index></name></decl></parameter>,
						  <parameter><decl><type><name>FuncCandidateList</name></type> <name>raw_candidates</name></decl></parameter>,
						  <parameter><decl><type><name>FuncCandidateList</name> <modifier>*</modifier></type><name>candidates</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncCandidateList</name></type> <name>current_candidate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncCandidateList</name></type> <name>next_candidate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ncandidates</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>candidates</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>current_candidate</name> <operator>=</operator> <name>raw_candidates</name></expr>;</init>
		 <condition><expr><name>current_candidate</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
		 <incr><expr><name>current_candidate</name> <operator>=</operator> <name>next_candidate</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>next_candidate</name> <operator>=</operator> <name><name>current_candidate</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/* jsonb can be coerced to any type by calling coerce_expr() */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>JSONBOID</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* any type can be coerced to jsonb */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>current_candidate</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>JSONBOID</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>can_coerce_type</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>current_candidate</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
								<argument><expr><name>COERCION_IMPLICIT</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<break>break;</break>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>current_candidate</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <operator>*</operator><name>candidates</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>candidates</name> <operator>=</operator> <name>current_candidate</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ncandidates</name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>current_candidate</name><operator>-&gt;</operator><name>oid</name></name> <operator>==</operator> <name>F_ARRAY_HEAD</name> <operator>||</operator>
			<name><name>current_candidate</name><operator>-&gt;</operator><name>oid</name></name> <operator>==</operator> <name>F_ARRAY_LAST</name> <operator>||</operator>
			<name><name>current_candidate</name><operator>-&gt;</operator><name>oid</name></name> <operator>==</operator> <name>F_ARRAY_TAIL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>ncandidates</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* see func_select_candidate() */</comment>
<function><type><name>FuncCandidateList</name></type>
<name>func_select_candidate_jsonb</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name><name>argtypes</name><index>[<expr><name>FUNC_MAX_ARGS</name></expr>]</index></name></decl></parameter>,
							<parameter><decl><type><name>FuncCandidateList</name></type> <name>candidates</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nunknowns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>input_base_typeids</name><index>[<expr><name>FUNC_MAX_ARGS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>matchDepth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ncandidates</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncCandidateList</name></type> <name>current_candidate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncCandidateList</name></type> <name>last_candidate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>current_typeids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TYPCATEGORY</name></type> <name><name>slot_category</name><index>[<expr><name>FUNC_MAX_ARGS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>resolved_unknowns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>slot_has_preferred_type</name><index>[<expr><name>FUNC_MAX_ARGS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TYPCATEGORY</name></type>	<name>current_category</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>current_is_preferred</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncCandidateList</name></type> <name>first_candidate</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>nunknowns</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>UNKNOWNOID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>input_base_typeids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>getBaseType</name><argument_list>(<argument><expr><name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>input_base_typeids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>UNKNOWNOID</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>nunknowns</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>slot_category</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>TypeCategory</name><argument_list>(<argument><expr><name><name>input_base_typeids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* find our candidates */</comment>
	<for>for <control>(<init><expr><name>matchDepth</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>matchDepth</name> <operator>&lt;=</operator> <literal type="number">6</literal></expr>;</condition> <incr><expr><name>matchDepth</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>ncandidates</name> <operator>=</operator> <call><name>cypher_match_function</name><argument_list>(<argument><expr><name>matchDepth</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>,
											<argument><expr><name>input_base_typeids</name></expr></argument>, <argument><expr><name>slot_category</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>candidates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ncandidates</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>candidates</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>nunknowns</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>resolved_unknowns</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>have_conflict</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>input_base_typeids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>UNKNOWNOID</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>resolved_unknowns</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>slot_category</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>TYPCATEGORY_INVALID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slot_has_preferred_type</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>have_conflict</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>current_candidate</name> <operator>=</operator> <name>candidates</name></expr>;</init>
			 <condition><expr><name>current_candidate</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
			 <incr><expr><name>current_candidate</name> <operator>=</operator> <name><name>current_candidate</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>current_typeids</name> <operator>=</operator> <name><name>current_candidate</name><operator>-&gt;</operator><name>args</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>get_type_category_preferred</name><argument_list>(<argument><expr><name><name>current_typeids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>current_category</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>current_is_preferred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>slot_category</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>TYPCATEGORY_INVALID</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>slot_category</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>current_category</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>slot_has_preferred_type</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>current_is_preferred</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>current_category</name> <operator>==</operator> <name><name>slot_category</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>slot_has_preferred_type</name><index>[<expr><name>i</name></expr>]</index></name> <operator>|=</operator> <name>current_is_preferred</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>current_category</name> <operator>==</operator> <name>TYPCATEGORY_STRING</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>slot_category</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>current_category</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>slot_has_preferred_type</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>current_is_preferred</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>have_conflict</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>have_conflict</name> <operator>&amp;&amp;</operator> <name><name>slot_category</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>TYPCATEGORY_STRING</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>resolved_unknowns</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>resolved_unknowns</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>last_candidate</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>first_candidate</name> <operator>=</operator> <name>candidates</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ncandidates</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>current_candidate</name> <operator>=</operator> <name>candidates</name></expr>;</init>
			 <condition><expr><name>current_candidate</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
			 <incr><expr><name>current_candidate</name> <operator>=</operator> <name><name>current_candidate</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>keepit</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>current_typeids</name> <operator>=</operator> <name><name>current_candidate</name><operator>-&gt;</operator><name>args</name></name></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>input_base_typeids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>UNKNOWNOID</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>get_type_category_preferred</name><argument_list>(<argument><expr><name><name>current_typeids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>current_category</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>current_is_preferred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>current_category</name> <operator>!=</operator> <name><name>slot_category</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>keepit</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>slot_has_preferred_type</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>current_is_preferred</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>keepit</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if <condition>(<expr><name>keepit</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>last_candidate</name> <operator>=</operator> <name>current_candidate</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>ncandidates</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>last_candidate</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>first_candidate</name> <operator>=</operator> <name><name>current_candidate</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>last_candidate</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>current_candidate</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>last_candidate</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>candidates</name> <operator>=</operator> <name>first_candidate</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>last_candidate</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>ncandidates</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>candidates</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>nunknowns</name> <operator>&lt;</operator> <name>nargs</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>known_type</name> <init>= <expr><name>UNKNOWNOID</name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>input_base_typeids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>known_type</name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>known_type</name> <operator>=</operator> <name><name>input_base_typeids</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>known_type</name> <operator>!=</operator> <name><name>input_base_typeids</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>known_type</name> <operator>=</operator> <name>UNKNOWNOID</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>known_type</name> <operator>!=</operator> <name>UNKNOWNOID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>last_candidate</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ncandidates</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>current_candidate</name> <operator>=</operator> <name>candidates</name></expr>;</init>
				 <condition><expr><name>current_candidate</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
				 <incr><expr><name>current_candidate</name> <operator>=</operator> <name><name>current_candidate</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>current_typeids</name> <operator>=</operator> <name><name>current_candidate</name><operator>-&gt;</operator><name>args</name></name></expr>;</expr_stmt>

				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>known_type</name> <operator>==</operator> <name>JSONBOID</name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>current_typeids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>JSONBOID</name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>can_coerce_type</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>known_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>current_typeids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
										<argument><expr><name>COERCION_IMPLICIT</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>

					<break>break;</break>
				</block_content>}</block></for>
				<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>++</operator><name>ncandidates</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>last_candidate</name> <operator>=</operator> <name>current_candidate</name></expr>;</expr_stmt>
			</block_content>}</block></for>

			<if_stmt><if>if <condition>(<expr><name>ncandidates</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>last_candidate</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<return>return <expr><name>last_candidate</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Function to run the criteria match against the candidate list.
 * The candidates list IS MODIFIED by this function (filtered down).
 * The function returns the number of candidates found.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>cypher_match_function</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>matchDepth</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>input_base_typeids</name></decl></parameter>,
					  <parameter><decl><type><name>TYPCATEGORY</name> <modifier>*</modifier></type><name>slot_category</name></decl></parameter>, <parameter><decl><type><name>FuncCandidateList</name> <modifier>*</modifier></type><name>candidates</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ncandidates</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bestmatch</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncCandidateList</name></type> <name>current_candidate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncCandidateList</name></type> <name>last_candidate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* loop through candidate list by following the next pointer */</comment>
	<for>for <control>(<init><expr><name>current_candidate</name> <operator>=</operator> <operator>*</operator><name>candidates</name></expr>;</init>
		 <condition><expr><name>current_candidate</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
		 <incr><expr><name>current_candidate</name> <operator>=</operator> <name><name>current_candidate</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>current_typeids</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nmatches</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>current_typeids</name> <operator>=</operator> <name><name>current_candidate</name><operator>-&gt;</operator><name>args</name></name></expr>;</expr_stmt>
		<comment type="block">/* loop through the arguments and check for matches */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>input_base_typeids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>cypher_match_function_criteria</name><argument_list>(<argument><expr><name>matchDepth</name></expr></argument>,
											   <argument><expr><name><name>input_base_typeids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
											   <argument><expr><name><name>current_typeids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
											   <argument><expr><name><name>slot_category</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>nmatches</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>nmatches</name> <operator>&gt;</operator> <name>bestmatch</name> <operator>||</operator> <name>last_candidate</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>candidates</name> <operator>=</operator> <name>current_candidate</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>last_candidate</name> <operator>=</operator> <name>current_candidate</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ncandidates</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>bestmatch</name> <operator>=</operator> <name>nmatches</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>nmatches</name> <operator>==</operator> <name>bestmatch</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>last_candidate</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>current_candidate</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>last_candidate</name> <operator>=</operator> <name>current_candidate</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ncandidates</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* make sure that the end of the list is terminated */</comment>
	<if_stmt><if>if <condition>(<expr><name>last_candidate</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>last_candidate</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>ncandidates</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Function to match a specific criteria, given a specific number of
 * conditions to match. It will return true if a match is found, false
 * otherwise. The larger the include value is, the more conditions it will
 * test for. The conditions higher up in function have more weight than
 * those lower.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>cypher_match_function_criteria</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>matchDepth</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>inputBaseType</name></decl></parameter>,
							   <parameter><decl><type><name>Oid</name></type> <name>currentType</name></decl></parameter>, <parameter><decl><type><name>TYPCATEGORY</name></type> <name>slotCategory</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* if the match depth is out of range, which shouldn't happen, fail */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>matchDepth</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1</literal> <operator>||</operator> <name>matchDepth</name></expr></argument> &gt;</argument_list></name> <literal type="number">6</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid matchDepth value [%d] for cypher_match_function_criteria"</literal></expr></argument>,
			 <argument><expr><name>matchDepth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* elog ERROR aborts, it will never get here */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* check for exact match */</comment>
	<if_stmt><if>if <condition>(<expr><name>currentType</name> <operator>==</operator> <name>inputBaseType</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* check for preferred match */</comment>
	<if_stmt><if>if <condition>(<expr><name>matchDepth</name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
		<call><name>IsPreferredType</name><argument_list>(<argument><expr><name>slotCategory</name></expr></argument>, <argument><expr><name>currentType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * we prioritized NUMERICOID over TEXTOID and BOOLOID due to ambiguity
	 * in matching aggregate functions for jsonb types.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>matchDepth</name> <operator>&gt;=</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>inputBaseType</name> <operator>==</operator> <name>JSONBOID</name> <operator>&amp;&amp;</operator> <name>currentType</name> <operator>==</operator> <name>NUMERICOID</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * we prioritize BOOLOID, TEXOID, and JSONBOID over the rest as JSONB
	 * has those types as primitive types
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>matchDepth</name> <operator>&gt;=</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>inputBaseType</name> <operator>==</operator> <name>JSONBOID</name> <operator>&amp;&amp;</operator>
		  <operator>(</operator><name>currentType</name> <operator>==</operator> <name>BOOLOID</name> <operator>||</operator> <name>currentType</name> <operator>==</operator> <name>TEXTOID</name><operator>)</operator><operator>)</operator> <operator>||</operator>
		 <name>currentType</name> <operator>==</operator> <name>JSONBOID</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * the following types are also number in JSON but they have lower priority
	 * than above types because jsonb stores number using numeric type
	 * internally and this means that we need to type-cast numeric type to
	 * those types.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>matchDepth</name> <operator>&gt;=</operator> <literal type="number">5</literal> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>inputBaseType</name> <operator>==</operator> <name>JSONBOID</name> <operator>&amp;&amp;</operator>
		 <operator>(</operator><name>currentType</name> <operator>==</operator> <name>INT2OID</name> <operator>||</operator> <name>currentType</name> <operator>==</operator> <name>INT4OID</name> <operator>||</operator>
		  <name>currentType</name> <operator>==</operator> <name>INT8OID</name> <operator>||</operator> <name>currentType</name> <operator>==</operator> <name>FLOAT4OID</name> <operator>||</operator>
		  <name>currentType</name> <operator>==</operator> <name>FLOAT8OID</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* we can type-cast jsonb type to any type through CypherTypeCast */</comment>
	<if_stmt><if>if <condition>(<expr><name>matchDepth</name> <operator>&gt;=</operator> <literal type="number">6</literal> <operator>&amp;&amp;</operator>
		<name>inputBaseType</name> <operator>==</operator> <name>JSONBOID</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* none found */</comment>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>func_get_best_args</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name><name>argtypes</name><index>[<expr><name>FUNC_MAX_ARGS</name></expr>]</index></name></decl></parameter>,
				   <parameter><decl><type><name>FuncCandidateList</name></type> <name>candidate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>la</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newargs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>la</argument>, <argument>args</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>la</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>JSONBOID</name> <operator>||</operator> <name><name>candidate</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>JSONBOID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>coerce_expr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>candidate</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
							  <argument><expr><name>COERCION_ASSIGNMENT</name></expr></argument>, <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>newargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>newargs</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformCoalesceExpr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CoalesceExpr</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>la</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>newarg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newargs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_jsonb</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>coalescetype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newcoercedargs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CoalesceExpr</name> <modifier>*</modifier></type><name>newc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>la</argument>, <argument>c-&gt;args</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>la</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>newarg</name> <operator>=</operator> <call><name>transformCypherExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><name>newarg</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>JSONBOID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>is_jsonb</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>newargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>, <argument><expr><name>newarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>is_jsonb</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>coalescetype</name> <operator>=</operator> <name>JSONBOID</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>coalescetype</name> <operator>=</operator> <call><name>select_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>newargs</name></expr></argument>, <argument><expr><literal type="string">"COALESCE"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>la</argument>, <argument>newargs</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>la</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>is_jsonb</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>newarg</name> <operator>=</operator> <call><name>coerce_to_jsonb</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"COALESCE value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>newarg</name> <operator>=</operator> <call><name>coerce_to_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>coalescetype</name></expr></argument>,
										   <argument><expr><literal type="string">"COALESCE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>newcoercedargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newcoercedargs</name></expr></argument>, <argument><expr><name>newarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>newc</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CoalesceExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newc</name><operator>-&gt;</operator><name>coalescetype</name></name> <operator>=</operator> <name>coalescetype</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newc</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>newcoercedargs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newc</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformIndirection</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>A_Indirection</name> <modifier>*</modifier></type><name>indir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>last_srf</name> <init>= <expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>restype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>location</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>li</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>transformCypherExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>indir</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>restype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>location</name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* record/composite or array type */</comment>
	<macro><name>foreach</name><argument_list>(<argument>li</argument>, <argument>indir-&gt;indirection</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>i</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>restype</name> <operator>==</operator> <name>VERTEXOID</name> <operator>||</operator> <name>restype</name> <operator>==</operator> <name>EDGEOID</name> <operator>||</operator>
				<name>restype</name> <operator>==</operator> <name>GRAPHPATHOID</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>type_is_rowtype</name><argument_list>(<argument><expr><name>restype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ParseFuncOrColumn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name>last_srf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" not found in data type %s"</literal></expr></argument>,
									   <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>restype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>A_Indices</name>		<modifier>*</modifier></type><name>ind</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name>			<modifier>*</modifier></type><name>lidx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name>			<modifier>*</modifier></type><name>uidx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>				<name>arrtype</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type>			<name>arrtypmod</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>				<name>elemtype</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>SubscriptingRef</name>	<modifier>*</modifier></type><name>aref</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>A_Indices</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>type_is_array_domain</name><argument_list>(<argument><expr><name>restype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>ind</name> <operator>=</operator> <operator>(</operator><name>A_Indices</name> <operator>*</operator><operator>)</operator> <name>i</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>ind</name><operator>-&gt;</operator><name>is_slice</name></name> <operator>&amp;&amp;</operator> <name><name>ind</name><operator>-&gt;</operator><name>lidx</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>lidx</name> <operator>=</operator> <call><name>makeArrayIndex</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>ind</name><operator>-&gt;</operator><name>lidx</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>ind</name><operator>-&gt;</operator><name>uidx</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>uidx</name> <operator>=</operator> <call><name>makeArrayIndex</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>ind</name><operator>-&gt;</operator><name>uidx</name></name></expr></argument>, <argument><expr><name><name>ind</name><operator>-&gt;</operator><name>is_slice</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>arrtype</name> <operator>=</operator> <name>restype</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>arrtypmod</name> <operator>=</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>elemtype</name> <operator>=</operator> <call><name>transformContainerType</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arrtype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arrtypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>aref</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SubscriptingRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>aref</name><operator>-&gt;</operator><name>refcontainertype</name></name> <operator>=</operator> <name>arrtype</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>aref</name><operator>-&gt;</operator><name>refelemtype</name></name> <operator>=</operator> <name>elemtype</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>aref</name><operator>-&gt;</operator><name>reftypmod</name></name> <operator>=</operator> <name>arrtypmod</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>aref</name><operator>-&gt;</operator><name>refupperindexpr</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>uidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>aref</name><operator>-&gt;</operator><name>reflowerindexpr</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>ind</name><operator>-&gt;</operator><name>is_slice</name></name></expr> ?</condition><then> <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>lidx</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NIL</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>aref</name><operator>-&gt;</operator><name>refexpr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>res</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>aref</name><operator>-&gt;</operator><name>refassgnexpr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>res</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>aref</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>restype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>li</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>filterAccessArg</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>location</name></expr></argument>, <argument><expr><literal type="string">"map or list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsJsonbAccessor</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>getAccessorArguments</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<macro><name>for_each_cell</name><argument_list>(<argument>li</argument>, <argument>indir-&gt;indirection</argument>, <argument>li</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>i</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>elem</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>elem</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>DEFAULT_COLLATION_OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
									  <argument><expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>A_Indices</name>  <modifier>*</modifier></type><name>ind</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>CypherIndices</name> <modifier>*</modifier></type><name>cind</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>lidx</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>uidx</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>A_Indices</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>ind</name> <operator>=</operator> <operator>(</operator><name>A_Indices</name> <operator>*</operator><operator>)</operator> <name>i</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * ExecEvalCypherAccess() will handle lidx and uidx properly
			 * based on their types.
			 */</comment>

			<expr_stmt><expr><name>lidx</name> <operator>=</operator> <call><name>transformCypherExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>ind</name><operator>-&gt;</operator><name>lidx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>lidx</name> <operator>=</operator> <call><name>adjustListIndexType</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>lidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>uidx</name> <operator>=</operator> <call><name>transformCypherExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>ind</name><operator>-&gt;</operator><name>uidx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>uidx</name> <operator>=</operator> <call><name>adjustListIndexType</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>uidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>cind</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CypherIndices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cind</name><operator>-&gt;</operator><name>is_slice</name></name> <operator>=</operator> <name><name>ind</name><operator>-&gt;</operator><name>is_slice</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cind</name><operator>-&gt;</operator><name>lidx</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>lidx</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cind</name><operator>-&gt;</operator><name>uidx</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>uidx</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>elem</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>cind</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><call><name>makeJsonbFuncAccessor</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>makeArrayIndex</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>idx</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>exclusive</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>last_srf</name> <init>= <expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>idxexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>one</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>idx</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>idxexpr</name> <operator>=</operator> <call><name>transformCypherExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>coerce_expr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>idxexpr</name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>idxexpr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
						 <argument><expr><name>COERCION_ASSIGNMENT</name></expr></argument>, <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"array subscript must have type integer"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>idxexpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>exclusive</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>one</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>,
							 <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_op</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"+"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>result</name></expr></argument>, <argument><expr><name>one</name></expr></argument>, <argument><expr><name>last_srf</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>adjustListIndexType</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>idx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TEXTOID</name></expr>:</case>
		<case>case <expr><name>BOOLOID</name></expr>:</case>
		<case>case <expr><name>JSONBOID</name></expr>:</case>
			<return>return <expr><name>idx</name></expr>;</return>
		<default>default:</default>
			<return>return <expr><call><name>coerce_to_jsonb</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><literal type="string">"list index"</literal></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformAExprOp</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>A_Expr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>last_srf</name> <init>= <expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>transformCypherExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>lexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>transformCypherExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>rexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>AEXPR_OP</name> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>opname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>ltype</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>rtype</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>opname</name></expr></argument>, <argument><expr><literal type="string">"`+`"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>opname</name></expr></argument>, <argument><expr><literal type="string">"`-`"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>opname</name></expr></argument>, <argument><expr><literal type="string">"`*`"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>opname</name></expr></argument>, <argument><expr><literal type="string">"`/`"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>opname</name></expr></argument>, <argument><expr><literal type="string">"`%`"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>opname</name></expr></argument>, <argument><expr><literal type="string">"`^`"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>coerce_to_jsonb</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><literal type="string">"jsonb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>coerce_to_jsonb</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="string">"jsonb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_op</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>last_srf</name></expr></argument>,
									<argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>opname</name></expr></argument>, <argument><expr><literal type="string">"+"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>opname</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>opname</name></expr></argument>, <argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>opname</name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>opname</name></expr></argument>, <argument><expr><literal type="string">"%"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>opname</name></expr></argument>, <argument><expr><literal type="string">"^"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>ltype</name> <operator>==</operator> <name>JSONBOID</name> <operator>||</operator> <name>rtype</name> <operator>==</operator> <name>JSONBOID</name> <operator>||</operator>
				<operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>LookupOperName</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>ltype</name></expr></argument>, <argument><expr><name>rtype</name></expr></argument>,
										   <argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>newopname</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>coerce_to_jsonb</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><literal type="string">"jsonb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>coerce_to_jsonb</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="string">"jsonb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>newopname</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"`%s`"</literal></expr></argument>, <argument><expr><name>opname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>newopname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_op</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>last_srf</name></expr></argument>,
										<argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>opname</name></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				 <call><name>strcmp</name><argument_list>(<argument><expr><name>opname</name></expr></argument>, <argument><expr><literal type="string">"&lt;&gt;"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				 <call><name>strcmp</name><argument_list>(<argument><expr><name>opname</name></expr></argument>, <argument><expr><literal type="string">"&lt;"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				 <call><name>strcmp</name><argument_list>(<argument><expr><name>opname</name></expr></argument>, <argument><expr><literal type="string">"&gt;"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				 <call><name>strcmp</name><argument_list>(<argument><expr><name>opname</name></expr></argument>, <argument><expr><literal type="string">"&lt;="</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				 <call><name>strcmp</name><argument_list>(<argument><expr><name>opname</name></expr></argument>, <argument><expr><literal type="string">"&gt;="</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>ltype</name> <operator>!=</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator> <name>rtype</name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>rtype</name> <operator>=</operator> <name>ltype</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>ltype</name> <operator>==</operator> <name>UNKNOWNOID</name> <operator>&amp;&amp;</operator> <name>rtype</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ltype</name> <operator>=</operator> <name>rtype</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>ltype</name> <operator>==</operator> <name>GRAPHIDOID</name> <operator>||</operator> <name>rtype</name> <operator>==</operator> <name>GRAPHIDOID</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_op</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>last_srf</name></expr></argument>,
										<argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>ltype</name> <operator>==</operator> <name>JSONBOID</name> <operator>||</operator> <name>rtype</name> <operator>==</operator> <name>JSONBOID</name> <operator>||</operator>
				<operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>LookupOperName</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>ltype</name></expr></argument>, <argument><expr><name>rtype</name></expr></argument>,
										   <argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>coerce_to_jsonb</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><literal type="string">"jsonb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>coerce_to_jsonb</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="string">"jsonb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_op</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>last_srf</name></expr></argument>,
										<argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_op</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>last_srf</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformAExprIn</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>A_Expr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>lexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>rexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rexprs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rvars</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rnonvars</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>lexpr</name> <operator>=</operator> <call><name>transformCypherExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>lexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lexpr</name> <operator>=</operator> <call><name>coerce_to_jsonb</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>lexpr</name></expr></argument>, <argument><expr><literal type="string">"jsonb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rexpr</name> <operator>=</operator> <call><name>transformCypherExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>rexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rexprs</name> <operator>=</operator> <name>rvars</name> <operator>=</operator> <name>rnonvars</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>rexpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_CypherListExpr</name></expr>:</case>
			<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>((CypherListExpr *) rexpr)-&gt;elems</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>elem</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>rexprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rexprs</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><name>elem</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>rvars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rvars</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>rnonvars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rnonvars</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CypherAccessExpr</name></expr>:</case>
		<case>case <expr><name>T_Var</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_op</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"@&gt;"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>rexpr</name></expr></argument>, <argument><expr><name>lexpr</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>,
									  <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"CypherList is expected but %s"</literal></expr></argument>,
								   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>rexpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>rexpr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * ScalarArrayOpExpr is only going to be useful if there's more than one
	 * non-Var righthand item.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>rnonvars</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>allexprs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>scalar_type</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>array_type</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Try to select a common type for the array elements.  Note that
		 * since the LHS' type is first in the list, it will be preferred when
		 * there is doubt (eg, when all the RHS items are unknown literals).
		 *
		 * Note: use list_concat here not lcons, to avoid damaging rnonvars.
		 */</comment>
		<expr_stmt><expr><name>allexprs</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>lexpr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rnonvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>scalar_type</name> <operator>=</operator> <call><name>select_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>allexprs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Do we have an array type to use?  Aside from the case where there
		 * isn't one, we don't risk using ScalarArrayOpExpr when the common
		 * type is RECORD, because the RowExpr comparison logic below can cope
		 * with some cases of non-identical row types.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>scalar_type</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>scalar_type</name> <operator>!=</operator> <name>RECORDOID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>array_type</name> <operator>=</operator> <call><name>get_array_type</name><argument_list>(<argument><expr><name>scalar_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>array_type</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>array_type</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * OK: coerce all the right-hand non-Var inputs to the common type
			 * and build an ArrayExpr for them.
			 */</comment>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>aexprs</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ArrayExpr</name>  <modifier>*</modifier></type><name>newa</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>aexprs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>rnonvars</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>rexpr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>rexpr</name> <operator>=</operator> <call><name>coerce_to_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rexpr</name></expr></argument>, <argument><expr><name>scalar_type</name></expr></argument>, <argument><expr><literal type="string">"IN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>aexprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>aexprs</name></expr></argument>, <argument><expr><name>rexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<expr_stmt><expr><name>newa</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ArrayExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newa</name><operator>-&gt;</operator><name>array_typeid</name></name> <operator>=</operator> <name>array_type</name></expr>;</expr_stmt>
			<comment type="block">/* array_collid will be set by parse_collate.c */</comment>
			<expr_stmt><expr><name><name>newa</name><operator>-&gt;</operator><name>element_typeid</name></name> <operator>=</operator> <name>scalar_type</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newa</name><operator>-&gt;</operator><name>elements</name></name> <operator>=</operator> <name>aexprs</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newa</name><operator>-&gt;</operator><name>multidims</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newa</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_scalar_array_op</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>lexpr</name></expr></argument>,
												   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newa</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Consider only the Vars (if any) in the loop below */</comment>
			<expr_stmt><expr><name>rexprs</name> <operator>=</operator> <name>rvars</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Must do it the hard way, ie, with a boolean expression tree.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>rexprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>rexpr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>cmp</name></decl>;</decl_stmt>

		<comment type="block">/* Ordinary scalar operator */</comment>
		<expr_stmt><expr><name>cmp</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_op</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>lexpr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rexpr</name></expr></argument>,
							   <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>coerce_to_boolean</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>cmp</name></expr></argument>, <argument><expr><literal type="string">"IN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>cmp</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>OR_EXPR</name></expr></argument>, <argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>cmp</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformBoolExpr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>BoolExpr</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>opname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>la</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>boolop</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>AND_EXPR</name></expr>:</case>
			<expr_stmt><expr><name>opname</name> <operator>=</operator> <literal type="string">"AND"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OR_EXPR</name></expr>:</case>
			<expr_stmt><expr><name>opname</name> <operator>=</operator> <literal type="string">"OR"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>NOT_EXPR</name></expr>:</case>
			<expr_stmt><expr><name>opname</name> <operator>=</operator> <literal type="string">"NOT"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized boolop: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>b</name><operator>-&gt;</operator><name>boolop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></switch>

	<macro><name>foreach</name><argument_list>(<argument>la</argument>, <argument>b-&gt;args</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>la</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>transformCypherExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>coerce_cypher_arg_to_boolean</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>opname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolExpr</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>boolop</name></name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to build a CypherTypeCast node.
 *
 * Note: expr is expected to be non NULL.
 *
 * Note: coercion context and type category were added for runtime
 * type casting.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>build_cypher_cast_expr</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>otyp</name></decl></parameter>, <parameter><decl><type><name>CoercionContext</name></type> <name>cctx</name></decl></parameter>,
					   <parameter><decl><type><name>CoercionForm</name></type> <name>cform</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>loc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CypherTypeCast</name> <modifier>*</modifier></type><name>tc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>obtyp</name></decl>;</decl_stmt>

	<comment type="block">/* validate input */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>expr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>obtyp</name> <operator>=</operator> <call><name>getBaseType</name><argument_list>(<argument><expr><name>otyp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tc</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CypherTypeCast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tc</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>obtyp</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tc</name><operator>-&gt;</operator><name>cctx</name></name> <operator>=</operator> <name>cctx</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tc</name><operator>-&gt;</operator><name>cform</name></name> <operator>=</operator> <name>cform</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tc</name><operator>-&gt;</operator><name>typcategory</name></name> <operator>=</operator> <call><name>TypeCategory</name><argument_list>(<argument><expr><name>obtyp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tc</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tc</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>loc</name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>tc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Node</name> <modifier>*</modifier></type>
<name>coerce_expr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>ityp</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>otyp</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>otypmod</name></decl></parameter>,
			<parameter><decl><type><name>CoercionContext</name></type> <name>cctx</name></decl></parameter>, <parameter><decl><type><name>CoercionForm</name></type> <name>cform</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>loc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>

	<comment type="block">/* return expr if it is already coerced or null */</comment>
	<if_stmt><if>if <condition>(<expr><name>ityp</name> <operator>==</operator> <name>otyp</name> <operator>||</operator> <name>expr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>expr</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>coerce_unknown_const</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>ityp</name></expr></argument>, <argument><expr><name>otyp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>node</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Process JSONBOID input and output types here EXCLUDING:
	 * JSONOID    -&gt; JSONBOID
	 * JSONBOID   -&gt; JSONOID
	 * VERTEXOID  -&gt; JSONBOID
	 * EDGEOID    -&gt; JSONBOID
	 * UNKNOWNOID -&gt; JSONBOID
	 * JSONBOID   -&gt; ANY*OID  ANYOID &amp; (IsPolymorphicType)
	 * We need to let postgres process these.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ityp</name> <operator>!=</operator> <name>JSONOID</name> <operator>&amp;&amp;</operator> <name>otyp</name> <operator>!=</operator> <name>JSONOID</name> <operator>&amp;&amp;</operator>
		<name>ityp</name> <operator>!=</operator> <name>VERTEXOID</name> <operator>&amp;&amp;</operator> <name>ityp</name> <operator>!=</operator> <name>EDGEOID</name> <operator>&amp;&amp;</operator>
		<name>ityp</name> <operator>!=</operator> <name>UNKNOWNOID</name> <operator>&amp;&amp;</operator>
		<name>otyp</name> <operator>!=</operator> <name>ANYOID</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>IsPolymorphicType</name><argument_list>(<argument><expr><name>otyp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>ityp</name> <operator>==</operator> <name>JSONBOID</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>get_element_type</name><argument_list>(<argument><expr><name>otyp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
				<name>otyp</name> <operator>==</operator> <name>RECORDARRAYOID</name> <operator>||</operator>
				<call><name>type_is_rowtype</name><argument_list>(<argument><expr><name>otyp</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot cast type jsonb to %s"</literal></expr></argument>,
									   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>otyp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Cast our JSONBOID types here, exec phase will do the rest.
			 * Note: The output of a jsonb string is double quoted (not a
			 * proper format for strings). We defer this to the execution
			 * phase of the cypher type cast.
			 */</comment>

			<return>return <expr><call><name>build_cypher_cast_expr</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>otyp</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>cform</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Catch cypher to_jsonb casts here */</comment>
		<if_stmt><if>if <condition>(<expr><name>otyp</name> <operator>==</operator> <name>JSONBOID</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeFuncExpr</name><argument_list>(<argument><expr><name>F_CYPHER_TO_JSONB</name></expr></argument>, <argument><expr><name>JSONBOID</name></expr></argument>,
										 <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
										 <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>COERCE_EXPLICIT_CALL</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * UNKNOWNOID parameters will be handled by p_coerce_param_hook
	 * Note: We need coerce_to_target_type done last to make sure that
	 * cypher JSONBOID casts happen before any postgres JSONBOID casts.
	 * In the event any get added to postgres in the future.
	 */</comment>
	<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>ityp</name></expr></argument>, <argument><expr><name>otyp</name></expr></argument>, <argument><expr><name>otypmod</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>,
								 <argument><expr><name>cform</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>coerce_unknown_const</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>ityp</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>otyp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>con</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>coll</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>newcon</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>con</name> <operator>=</operator> <operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* This case will be handled later. NULL can be coerced to any type. */</comment>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ityp</name> <operator>!=</operator> <name>UNKNOWNOID</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Other types will be handled later by calling coerce_type(). */</comment>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>otyp</name> <operator>==</operator> <name>JSONBOID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>stringToJsonb</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>coll</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>otyp</name> <operator>==</operator> <name>TEXTOID</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>j</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>jv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>stringToJsonb</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>j</name> <operator>=</operator> <call><name>DatumGetJsonbP</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>JB_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>jv</name> <operator>=</operator> <call><name>getIthJsonbValueFromContainer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>j</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>jv</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>jbvString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>jv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>jv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>coll</name> <operator>=</operator> <name>DEFAULT_COLLATION_OID</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Other types will be handled later by calling coerce_type().
		 * UNKNOWNOID can be coerced to any type using the input function of
		 * the target type.
		 */</comment>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>newcon</name> <operator>=</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>otyp</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>coll</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>datum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newcon</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>stringToJsonb</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>si</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>escape</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseCallbackState</name></type> <name>pcbstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>d</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>c</name> <operator>=</operator> <name>s</name></expr>;</init> <condition><expr><operator>*</operator><name>c</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>escape</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>, <argument><expr><operator>*</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>escape</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<switch>switch <condition>(<expr><operator>*</operator><name>c</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><literal type="char">'\\'</literal></expr>:</case>
					<comment type="block">/* any character coming next will be escaped */</comment>
					<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>escape</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'"'</literal></expr>:</case>
					<comment type="block">/* Escape `"`. `"` and `\"` are the same as `\"`. */</comment>
					<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>, <argument><expr><literal type="string">"\\\""</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>, <argument><expr><operator>*</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>setup_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>jsonb_in</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>si</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>cancel_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>d</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>coerce_to_jsonb</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>type</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>is_graph_type</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"graph object cannot be %s"</literal></expr></argument>, <argument><expr><name>targetname</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>coerce_all_to_jsonb</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_graph_type</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>type</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>GRAPHIDARRAYOID</name></expr>:</case>
		<case>case <expr><name>GRAPHIDOID</name></expr>:</case>
		<case>case <expr><name>VERTEXARRAYOID</name></expr>:</case>
		<case>case <expr><name>VERTEXOID</name></expr>:</case>
		<case>case <expr><name>EDGEARRAYOID</name></expr>:</case>
		<case>case <expr><name>EDGEOID</name></expr>:</case>
		<case>case <expr><name>GRAPHPATHARRAYOID</name></expr>:</case>
		<case>case <expr><name>GRAPHPATHOID</name></expr>:</case>
			<return>return <expr><name>true</name></expr>;</return>

		<default>default:</default>
			<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>coerce_all_to_jsonb</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>type</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TypeCategory</name><argument_list>(<argument><expr><call><name>getBaseType</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>TYPCATEGORY_STRING</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeFuncExpr</name><argument_list>(<argument><expr><name>F_CYPHER_TO_JSONB</name></expr></argument>, <argument><expr><name>JSONBOID</name></expr></argument>,
									 <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
									 <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>COERCE_EXPLICIT_CALL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>coerce_expr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>JSONBOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
					   <argument><expr><name>COERCION_EXPLICIT</name></expr></argument>, <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
					   <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>expr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>expr</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Node</name> <modifier>*</modifier></type>
<name>transformCypherMapForSet</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>pathelems</name></decl></parameter>,
						 <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>varname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParseExprKind</name></type> <name>sv_expr_kind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>aelem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>apath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>elem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>elemtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>resname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>le</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>textlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>sv_expr_kind</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>EXPR_KIND_UPDATE_SOURCE</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>transformCypherExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>sv_expr_kind</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsJsonbAccessor</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>getAccessorArguments</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aelem</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>apath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>aelem</name> <operator>=</operator> <name>expr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>apath</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* examine what aelem is */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>aelem</name></expr></argument>, <argument><expr><name>FieldSelect</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>elem</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>FieldSelect</name> <operator>*</operator><operator>)</operator> <name>aelem</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>elem</name> <operator>=</operator> <name>aelem</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>elemtype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>elemtype</name> <operator>!=</operator> <name>VERTEXOID</name> <operator>&amp;&amp;</operator> <name>elemtype</name> <operator>!=</operator> <name>EDGEOID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"vertex or edge is expected but %s"</literal></expr></argument>,
							   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>elemtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>aelem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>elem</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>elem</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>GetRTEByRangeTablePosn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>resname</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* FIXME: This is because of the way eager is implemented. */</comment>
	<if_stmt><if>if <condition>(<expr><name>resname</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Only direct variable reference is supported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>aelem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>apath</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>pathelems</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>varname</name> <operator>=</operator> <name>resname</name></expr>;</expr_stmt>
		<return>return <expr><name>elem</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>le</argument>, <argument>apath</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TEXTOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>textlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>textlist</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>CypherIndices</name> <modifier>*</modifier></type><name>cind</name> <init>= <expr><operator>(</operator><name>CypherIndices</name> <operator>*</operator><operator>)</operator> <name>e</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>CypherIndices</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>cind</name><operator>-&gt;</operator><name>is_slice</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"list slicing on LHS of SET is invalid"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>cind</name><operator>-&gt;</operator><name>uidx</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
									  <argument><expr><name>COERCION_ASSIGNMENT</name></expr></argument>, <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
									  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>t</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"path element must be text"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
												   <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>cind</name><operator>-&gt;</operator><name>uidx</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>textlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>textlist</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><operator>*</operator><name>pathelems</name> <operator>=</operator> <name>textlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>varname</name> <operator>=</operator> <name>resname</name></expr>;</expr_stmt>
	<return>return <expr><name>elem</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * coerce_cypher_arg_to_boolean()
 *      Coerce an argument of a construct that requires boolean input
 *      (AND, OR, NOT, etc).  Also check that input is not a set.
 *
 * Returns the possibly-transformed node tree.
 *
 * As with coerce_type, pstate may be NULL if no special unknown-Param
 * processing is wanted.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>coerce_cypher_arg_to_boolean</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
							 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>constructName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>inputTypeId</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>inputTypeId</name> <operator>!=</operator> <name>BOOLOID</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>		<modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newnode</name> <operator>=</operator> <call><name>coerce_expr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>inputTypeId</name></expr></argument>, <argument><expr><name>BOOLOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
							  <argument><expr><name>COERCION_ASSIGNMENT</name></expr></argument>, <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>newnode</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
							<comment type="block">/* translator: first %s is name of a SQL construct, eg WHERE */</comment>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument of %s must be type %s, not type %s"</literal></expr></argument>,
								   <argument><expr><name>constructName</name></expr></argument>, <argument><expr><literal type="string">"boolean"</literal></expr></argument>,
								   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>inputTypeId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <name>newnode</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>expression_returns_set</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						<comment type="block">/* translator: %s is name of a SQL construct, eg WHERE */</comment>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument of %s must not return a set"</literal></expr></argument>,
							   <argument><expr><name>constructName</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * clause functions
 */</comment>

<function><type><name>Node</name> <modifier>*</modifier></type>
<name>transformCypherWhere</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>, <parameter><decl><type><name>ParseExprKind</name></type> <name>exprKind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>qual</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>clause</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>transformCypherExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>, <argument><expr><name>exprKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>coerce_cypher_arg_to_boolean</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>, <argument><expr><literal type="string">"WHERE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>qual</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Node</name> <modifier>*</modifier></type>
<name>transformCypherLimit</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>,
					 <parameter><decl><type><name>ParseExprKind</name></type> <name>exprKind</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>constructName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>qual</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>clause</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>transformCypherExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>, <argument><expr><name>exprKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>coerce_to_specific_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>, <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><name>constructName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* LIMIT can't refer to any variables of the current query */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument of %s must not contain variables"</literal></expr></argument>,
							   <argument><expr><name>constructName</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>locate_var_of_level</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>qual</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>List</name> <modifier>*</modifier></type>
<name>transformCypherOrderBy</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sortitems</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ParseExprKind</name></type> <name>exprKind</name> <init>= <expr><name>EXPR_KIND_ORDER_BY</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sortgroups</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lsi</name></decl>;</decl_stmt>

	<comment type="block">/* See findTargetlistEntrySQL99() */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lsi</argument>, <argument>sortitems</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortBy</name>	   <modifier>*</modifier></type><name>sortby</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lsi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>transformCypherExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>sortby</name><operator>-&gt;</operator><name>node</name></name></expr></argument>, <argument><expr><name>exprKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lt</argument>, <argument>*targetlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>texpr</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>texpr</name> <operator>=</operator> <call><name>strip_implicit_coercions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tmp</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>texpr</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>te</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>te</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>transformTargetEntry</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>sortby</name><operator>-&gt;</operator><name>node</name></name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>exprKind</name></expr></argument>,
									  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><operator>*</operator><name>targetlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>targetlist</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>sortgroups</name> <operator>=</operator> <call><name>addTargetToSortList</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>te</name></expr></argument>, <argument><expr><name>sortgroups</name></expr></argument>, <argument><expr><operator>*</operator><name>targetlist</name></expr></argument>,
										 <argument><expr><name>sortby</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>sortgroups</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * item list functions
 */</comment>

<function><type><name>List</name> <modifier>*</modifier></type>
<name>transformItemList</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>items</name></decl></parameter>, <parameter><decl><type><name>ParseExprKind</name></type> <name>exprKind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>targets</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>li</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>li</argument>, <argument>items</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ColumnRef</name>  <modifier>*</modifier></type><name>cref</name> <init>= <expr><operator>(</operator><name>ColumnRef</name> <operator>*</operator><operator>)</operator> <name><name>item</name><operator>-&gt;</operator><name>val</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* item is a bare `*` */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
				<call><name>IsA</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>A_Star</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>targets</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>targets</name></expr></argument>,
									  <argument><expr><call><name>transformA_Star</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>transformCypherExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>exprKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>colname</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><call><name>FigureColname</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>,
							 <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>,
							 <argument><expr><name>colname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>targets</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>targets</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>targets</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>resolveItemList</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>items</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>li</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>li</argument>, <argument>items</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>restype</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>restype</name> <operator>==</operator> <name>BOOLOID</name> <operator>||</operator>
			<call><name>is_graph_type</name><argument_list>(<argument><expr><name>restype</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>type_is_array</name><argument_list>(<argument><expr><name>restype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>coerce_all_to_jsonb</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><name>List</name> <modifier>*</modifier></type>
<name>transformCypherExprList</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprlist</name></decl></parameter>,
						<parameter><decl><type><name>ParseExprKind</name></type> <name>exprKind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>le</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>le</argument>, <argument>exprlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
						 <argument><expr><call><name>transformCypherExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>exprKind</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>transformA_Star</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>targets</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>visible</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lni</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lni</argument>, <argument>pstate-&gt;p_namespace</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lni</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* ignore RTEs that are inaccessible by unqualified names */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nsitem</name><operator>-&gt;</operator><name>p_cols_visible</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>visible</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/* should not have any lateral-only items when parsing items */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>nsitem</name><operator>-&gt;</operator><name>p_lateral_only</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>targets</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>targets</name></expr></argument>,
							  <argument><expr><call><name>expandNSItemAttrs</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
												<argument><expr><name>nsitem</name></expr></argument>,
												<argument><expr><literal type="number">0</literal></expr></argument>,
												<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>visible</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"RETURN * with no accessible variables is invalid"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>targets</name></expr>;</return>
</block_content>}</block></function>
</unit>
